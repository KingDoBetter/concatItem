{"version":3,"sources":["webpack:///./static/echarts.js","webpack:///./src/components/login.vue?7111","webpack:///./src/components/login.vue","webpack:///src/components/login.vue","webpack:///src/components/index.vue","webpack:///./src/components/index.vue?2116","webpack:///./src/components/index.vue","webpack:///src/components/loginChild/log.vue","webpack:///./src/components/loginChild/log.vue?ca34","webpack:///./src/components/loginChild/log.vue","webpack:///src/components/loginChild/reg.vue","webpack:///./src/components/loginChild/reg.vue?c6ad","webpack:///./src/components/loginChild/reg.vue","webpack:///src/components/common/swiper.vue","webpack:///./src/components/common/swiper.vue?432f","webpack:///./src/components/common/swiper.vue","webpack:///src/components/children/home.vue","webpack:///./src/components/children/home.vue?50d2","webpack:///./src/components/children/home.vue","webpack:///src/components/children/makePic.vue","webpack:///./src/components/children/makePic.vue?5355","webpack:///./src/components/children/makePic.vue","webpack:///src/components/children/echarts.vue","webpack:///./src/components/children/echarts.vue?6323","webpack:///./src/components/children/echarts.vue","webpack:///src/components/children/richScan.vue","webpack:///./src/components/children/richScan.vue?34b7","webpack:///./src/components/children/richScan.vue","webpack:///src/components/errPage.vue","webpack:///./src/components/errPage.vue?3b98","webpack:///./src/components/errPage.vue","webpack:///./src/router/index.js","webpack:///src/App.vue","webpack:///./src/App.vue?c9ce","webpack:///./src/App.vue","webpack:///./src/main.js","webpack:///./static/Detector.js","webpack:///./src/assets/images/bg_content.png"],"names":["global","exports","dev","window","__DEV__","idStart","guid","env$1","navigator","browser","os","node","canvasSupported","svgSupported","ua","firefox","match","ie","edge","weChat","test","version","document","createElement","getContext","SVGRect","touchEventsSupported","pointerEventsSupported","detect","userAgent","BUILTIN_OBJECT","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","[object Canvas]","TYPED_ARRAY","[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]","objToString","Object","prototype","toString","arrayProto","Array","nativeForEach","forEach","nativeFilter","filter","nativeSlice","slice","nativeMap","map","nativeReduce","reduce","methods","$override","name","fn","clone","source","result","typeStr","call","i","len","length","Ctor","constructor","from","isPrimitive","isDom","key","hasOwnProperty","merge","target","overwrite","isObject","targetProp","sourceProp","isArray","isBuiltInObject","mergeAll","targetAndSources","extend","defaults","overlay","_ctx","createCanvas","indexOf","array","value","inherits","clazz","baseClazz","clazzPrototype","F","prop","superClass","mixin","isArrayLike","data","each$1","obj","cb","context","push","memo","bind","func","args","arguments","apply","concat","curry","this","isFunction","isString","type","nodeType","ownerDocument","eqNaN","retrieve","values","retrieve2","value0","value1","retrieve3","value2","Function","normalizeCssArray","val","assert","condition","message","Error","primitiveKey","setAsPrimitive","HashMap","set","createHashMap","noop","get","each","prefixedKey","removeKey","zrUtil","freeze","find","ArrayCtor","Float32Array","create","x","y","out","copy","v","clone$1","a","b","add","v1","v2","scaleAndAdd","sub","Math","sqrt","lenSquare","lengthSquare","scale","s","normalize","d","distance","dist","distanceSquare","distSquare","lerp","t","applyTransform","m","min","max","vector","mul","div","dot","negate","Draggable","on","_dragStart","_drag","_dragEnd","param","e","topTarget","draggingTarget","draggable","_draggingTarget","dragging","_x","offsetX","_y","offsetY","dispatchToElement","event","dx","dy","drift","dropTarget","findHover","lastDropTarget","_dropTarget","arrySlice","Eventful","_$handlers","one","handler","_h","h","ctx","isSilent","off","newList","l","trigger","argLen","splice","triggerWithContext","SILENT","EmptyProxy","dispose","handlerNames","Handler","storage","painter","proxy","painterRoot","_hovered","_lastTouchMoment","_lastX","_lastY","isHover","displayable","rectHover","el","clipPath","contain","silent","parent","mousemove","zrX","zrY","lastHovered","lastHoveredTarget","__zr","hovered","hoveredTarget","setCursor","cursor","mouseout","innerDom","element","toElement","relatedTarget","parentNode","resize","dispatch","eventName","eventArgs","setCursorStyle","cursorStyle","targetInfo","eventHandler","eventPacket","eveType","cancelBubble","gestureEvent","pinchX","pinchY","pinchScale","wheelDelta","zrDelta","zrByTouch","which","makeEventPacket","eachOtherLayer","layer","exclude","list","getDisplayList","hoverCheckResult","ignore","_downEl","_downPoint","_upEl","ArrayCtor$1","create$1","identity","copy$1","mul$1","m1","m2","out0","out1","out2","out3","out4","out5","translate","rotate","rad","aa","ac","atx","ab","ad","aty","st","sin","ct","cos","scale$1","vx","vy","invert","det","matrix","mIdentity","EPSILON","isNotAroundZero","Transformable","opts","position","rotation","origin","transformableProto","transform","needLocalTransform","updateTransform","parentHasTransform","getLocalTransform","invTransform","setTransform","dpr","restoreTransform","tmpTransform","decomposeTransform","sx","sy","scale$$1","atan2","getGlobalScale","transformCoordToLocal","transformCoordToGlobal","easing","linear","k","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","PI","sinusoidalOut","sinusoidalInOut","exponentialIn","pow","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","p","asin","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","Clip","options","_target","_life","life","_delay","delay","_initialized","loop","gap","onframe","ondestroy","onrestart","_pausedTime","_paused","step","globalTime","deltaTime","_startTime","percent","easing$$1","easingFunc","schedule","fire","restart","_needsRemove","remainder","eventType","arg","pause","resume","LinkedList","head","tail","_len","linkedListProto","insert","entry","Entry","insertEntry","next","prev","remove","clear","LRU","maxSize","_list","_map","_maxSize","_lastRemovedEntry","LRUProto","put","removed","leastUsedEntry","kCSSColorTable","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","clampCssByte","round","clampCssFloat","f","parseCssInt","str","charAt","parseFloat","parseInt","parseCssFloat","cssHueToRgb","lerpNumber","setRgba","r","g","copyRgba","colorCache","lastRemovedArr","putToCache","colorStr","rgbaArr","parse","cached","iv","replace","toLowerCase","substr","op","ep","fname","params","split","alpha","pop","hsla2rgba","hsla","rgba","lift","color","level","colorArr","stringify","toHex","fastLerp","normalizedValue","colors","leftIndex","floor","rightIndex","ceil","leftColor","rightColor","dv","fastMapToColor","lerp$1","fullOutput","mapToColor","modifyHSL","H","S","R","G","B","vMin","vMax","delta","L","deltaR","deltaG","deltaB","rgba2hsla","modifyAlpha","arrColor","arraySlice","defaultGetter","defaultSetter","interpolateNumber","p0","p1","interpolateString","interpolateArray","arrDim","len2","j","fillArr","arr0","arr1","arr0Len","arr1Len","isNaN","isArraySame","catmullRomInterpolateArray","p2","p3","t2","t3","catmullRomInterpolate","v0","cloneValue","ret","rgba2String","join","createTrackClip","animator","oneTrackDone","keyframes","propName","forceAnimate","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","isValueArray","isValueColor","isValueString","lastValue","getArrayDim","sort","time","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","w","lastFrame","lastFramePercent","clip","_loop","frame","range","Animator","_tracks","_clipCount","_doneList","_onframeList","_clipList","when","props","tracks","during","callback","isPaused","_doneCallback","doneList","start","lastClip","self","clipCount","animation","addClip","oldOnFrame","stop","forwardToLast","clipList","removeClip","done","getClips","devicePixelRatio","log","zrLog","Animatable","animators","animate","path","animatingShape","zr","pathSplitted","dirty","addAnimator","id","stopAnimation","animateTo","_animateToShallow","count","objShallow","propertyCount","attr","Element","beforeUpdate","afterUpdate","update","traverse","attrKV","hide","refresh","show","setClipPath","addSelfToZr","removeClipPath","__clipTarget","removeSelfFromZr","removeAnimator","lt","rb","lb","rt","v2ApplyTransform","mathMin","mathMax","BoundingRect","width","height","union","other","maxX","maxY","calculateTransform","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","plain","rect","Group","_children","__storage","__dirty","isGroup","children","childAt","idx","childOfName","childCount","child","_doAdd","addBefore","nextSibling","addToStorage","addChildrenToStorage","delFromStorage","delChildrenFromStorage","removeAll","eachChild","getBoundingRect","includeChildren","tmpRect","tmpMat","invisible","childRect","DEFAULT_MIN_MERGE","DEFAULT_MIN_GALLOPING","makeAscendingRun","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","mid","pivot","left","right","n","gallopLeft","hint","lastOffset","maxOffset","offset","tmp","gallopRight","TimSort","runStart","runLength","minGallop","stackSize","mergeAt","start1","length1","start2","length2","cursor1","cursor2","dest","count1","count2","exit","_minGallop","mergeLow","customCursor","customDest","mergeHigh","mergeRuns","forceMergeRuns","pushRun","_runStart","_runLength","remaining","ts","minRun","minRunLength","force","shapeCompareFunc","zlevel","z","z2","Storage","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","roots","displayList","_updateAndAddDisplayable","clipPaths","userSetClipPath","currentClipPath","parentClipPath","__clipPaths","addRoot","delRoot","root","_renderList","displayableSortFunc","STYLE_COMMON_PROPS","Style","host","extendFrom","createLinearGradient","x2","y2","createRadialGradient","fill","stroke","opacity","lineDash","lineDashOffset","shadowBlur","shadowOffsetX","shadowOffsetY","lineWidth","strokeNoScale","text","font","textFont","fontStyle","fontWeight","fontSize","fontFamily","textTag","textFill","textStroke","textWidth","textHeight","textStrokeWidth","textLineHeight","textPosition","textRect","textOffset","textAlign","textVerticalAlign","textDistance","textShadowColor","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textBoxShadowColor","textBoxShadowBlur","textBoxShadowOffsetX","textBoxShadowOffsetY","transformText","textRotation","textOrigin","textBackgroundColor","textBorderColor","textBorderWidth","textBorderRadius","textPadding","rich","truncate","blend","prevEl","prevStyle","style","firstDraw","styleName","fillStyle","strokeStyle","globalAlpha","globalCompositeOperation","hasStroke","getLineScale","hasFill","otherStyle","newStyle","getGradient","canvasGradient","colorStops","addColorStop","styleProto","Pattern","image","repeat","returnFalse","createDom","newDom","getWidth","getHeight","newDomStyle","top","setAttribute","getCanvasPattern","createPattern","Layer","dom","domStyle","onselectstart","domBack","ctxBack","config","clearColor","motionBlur","lastFrameAlpha","elCount","initContext","__currentValues","createBackBuffer","clearAll","clearColorGradientOrPattern","haveMotionBLur","drawImage","clearRect","__canvasGradient","save","fillRect","restore","requestAnimationFrame","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","setTimeout","globalImageCache","findExistImage","newImageOrSrc","cachedImgObj","createOrUpdateImage","hostEl","cbPayload","__zrImageSrc","pendingWrap","isImageReady","pending","Image","onload","imageOnLoad","__cachedImgObj","src","textWidthCache","textWidthCacheCounter","TEXT_CACHE_MAX","STYLE_REG","DEFAULT_FONT","methods$1","textLines","measureText","contentBlock","parseRichText","outerWidth","outerHeight","adjustTextX","adjustTextY","getRichTextRect","parsePlainText","lineHeight","getPlainTextRect","adjustTextPositionOnRect","halfHeight","truncateText","containerWidth","ellipsis","prepareTruncateOptions","truncateSingleLine","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","subLength","estimateLength","charCode","charCodeAt","getLineHeight","padding","lines","truncOuterHeight","truncOuterWidth","lastIndex","exec","matchedIndex","index","pushTokens","substring","contentHeight","pendingList","stlPadding","truncateWidth","truncateHeight","line","tokens","tokenStyle","token","tokenHeight","tokenWidth","tokenWidthNotSpecified","percentWidth","bgImg","paddingW","remianTruncWidth","block","isEmptyStr","strs","isLineHolder","tokensLen","makeFont","buildPath","shape","r1","r2","r3","r4","total","moveTo","lineTo","quadraticCurveTo","VALID_TEXT_ALIGN","center","VALID_TEXT_VERTICAL_ALIGN","bottom","middle","normalizeTextStyle","normalizeStyle","textBaseline","renderText","__textCotentBlock","boxPos","getBoxPosition","baseX","baseY","applyTextRotation","boxX","boxY","xLeft","lineTop","xRight","needDrawBackground","drawBackground","tokenCount","usedWidth","lineXLeft","lineXRight","placeToken","drawRichText","renderRichText","setCtx","textX","textY","needDrawBg","getTextXForPadding","getStroke","getFill","strokeText","fillText","renderPlainText","isPlainBg","beginPath","closePath","onBgImageLoaded","blockHeiht","parsePercent","res","maxValue","lastIndexOf","needDrawText","tmpRect$1","RectText","Displayable","_rect","ZImage","drawRectText","culling","progressive","beforeBrush","afterBrush","brush","rectContain","coord","animateStyle","setStyle","useStyle","_image","aspect","sWidth","sHeight","parseInt10","preProcessLayer","__unusedCount","postProcessLayer","viewRect","Painter","singleCanvas","nodeName","toUpperCase","_opts","_singleCanvas","rootStyle","innerHTML","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","_domRoot","_getSize","domRoot","cssText","createRoot","appendChild","_progressiveLayers","_hoverlayer","_hoverElements","getType","isSingleCanvas","getViewportRoot","getViewportRootOffset","viewportRoot","offsetLeft","offsetTop","paintAll","_paintList","__builtin__","refreshHover","_startProgessive","addHover","hoverStyle","__hoverMir","elMirror","__from","removeHover","hoverElements","clearHover","hoverLayer","getLayer","scope","originalEl","_doPaintEl","_furtherProgressive","_progressiveToken","Date","_progress","_doPaintList","_clearProgressive","_updateLayerStatus","eachBuiltinLayer","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","flushProgressiveLayer","elZLevel","elFrame","__frame","MAX_PROGRESSIVE_LAYER_NUMBER","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","isDisplayableCulled","prevClipLayer","prevClipPaths","isClipPathChanged","prevElClipPaths","doClip","insertLayer","layersMap","prevLayer","isLayerValid","virtual","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","configLayer","layerConfig","delLayer","removeChild","display","clearLayer","getRenderedCanvas","imageLayer","pixelRatio","backgroundColor","findAndDrawOtherLayer","smaller","larger","intermediateLayer","Infinity","renderToCanvas","whIdx","wh","cwh","plt","prb","stl","defaultView","getComputedStyle","pathToImage","canvas","shadowBlurSize","leftMargin","rightMargin","topMargin","bottomMargin","pathTransform","imgShape","isDomLevel2","addEventListener","MOUSE_EVENT_REG","clientToLocal","calculate","defaultGetZrXY","layerX","layerY","box","getBoundingClientRect","clientX","clientY","normalizeEvent","touch","targetTouches","changedTouches","detail","button","undefined","attachEvent","removeEventListener","detachEvent","preventDefault","stopPropagation","returnValue","notLeftMouse","Animation","stage","_clips","_running","_time","_pauseStart","clips","_update","getTime","deferredEvents","deferredClips","_startLoop","GestureMgr","_track","dist$1","pointPair","recognize","_doTrack","_recognize","touches","trackItem","points","pos","recognizers","gestureInfo","pinch","track","pinchEnd","pinchPre","isFinite","pinchCenter","mouseHandlerNames","touchHandlerNames","pointerEventNames","pointerdown","pointerup","pointermove","pointerout","pointerHandlerNames","nm","eventNameFix","processGesture","gestureMgr","_gestureMgr","setTouchTimer","instance","_touching","clearTimeout","_touchTimer","domHandlers","touchstart","mousedown","touchmove","touchend","mouseup","click","isPointerFromTouch","pointerType","HandlerDomProxy","mountHandlers","_handlers","makeMouseHandler","handlerDomProxyProto","useVML","painterCtors","instances$1","version$1","init$1","ZRender","registerPainter","rendererType","renderer","vml","handerProxy","flush","_needsRefresh","oldDelFromStorage","oldAddToStorage","getId","zLevel","refreshImmediately","_needsRefreshHover","refreshHoverImmediately","clearAnimation","zrender","init","getInstance","RADIAN_EPSILON","linearMap","domain","clamp","subDomain","subRange","parsePercent$1","all","NaN","precision","returnStr","toFixed","asc","arr","getPrecision","getPrecisionSafe","eIndex","dotIndex","getPixelPrecision","dataExtent","pixelExtent","LN10","dataQuantity","sizeQuantity","abs","getPercentWithPrecision","valueList","sum","acc","digits","votesPerQuota","targetSeats","seats","votes","currentSum","Number","NEGATIVE_INFINITY","maxId","MAX_SAFE_INTEGER","remRadian","radian","pi2","isRadianAroundZero","TIME_REG","parseDate","hour","UTC","quantity","quantityExponent","nice","exponent","exp10","reformIntervals","littleThan","lg","interval","close","curr","currClose","isNumeric","number","addCommas","toCamelCase","upperCaseFirst","group1","normalizeCssArray$1","encodeHTML","String","TPL_VAR_ALIAS","wrapVar","varName","seriesIdx","formatTpl","tpl","paramsList","encode","seriesLen","$vars","alias","formatTplSimple","getTooltipMarker","extraCssText","s2d","formatTime","isUTC","date","utc","M","capitalFirst","truncateText$1","getTextRect","format","TYPE_DELIMITER","IS_CONTAINER","MEMBER_PRIFIX","set$1","parseClassType$1","componentType","main","enableClassExtend","RootClass","mandatoryMethods","$constructor","proto","method","console","warn","ExtendedClass","superCall","superApply","methodName","enableClassManagement","entity","registerClass","Clazz","checkClassType","container","makeContainer","getClass","componentMainType","subType","throwWhenNotFound","getClassesByMainType","o","hasClass","getAllClassMainTypes","types","hasSubTypes","parseClassType","registerWhenExtend","originalExtend","makeStyleMapper","properties","model","excludes","includes","getShallow","getLineStyle","lineStyleMixin","getLineDash","lineType","dotSize","dashSize","getAreaStyle","areaStyleMixin","mathPow","mathSqrt$2","EPSILON$1","EPSILON_NUMERIC","THREE_SQRT","ONE_THIRD","_v0","_v1","_v2","isAroundZero","isNotAroundZero$1","cubicAt","onet","cubicDerivativeAt","cubicExtrema","extrema","c","t1","disc","discSqrt","cubicSubdivide","p01","p12","p23","p012","p123","p0123","quadraticAt","quadraticDerivativeAt","quadraticExtremum","divider","quadraticSubdivide","mathMin$3","mathMax$3","mathSin$2","mathCos$2","PI2","end","extremity","fromPoints","min$$1","max$$1","fromLine","x0","y0","x1","y1","xDim","yDim","fromCubic","x3","y3","cubicExtrema$$1","cubicAt$$1","fromQuadratic","quadraticExtremum$$1","quadraticAt$$1","tx","ty","fromArc","rx","ry","startAngle","endAngle","anticlockwise","vec2Min","vec2Max","diff","angle","CMD","C","Q","A","Z","min$1","max$1","min2","max2","mathMin$2","mathMax$2","mathCos$1","mathSin$1","mathSqrt$1","mathAbs","hasTypedArray","PathProxy","notSaveData","_saveData","containStroke$1","_l","_a","containStroke$2","d1","d2","_t","cubicProjectPoint","containStroke$3","quadraticProjectPoint","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","setScale","addData","exceedUnit","_needsDash","_dashedLineTo","bezierCurveTo","_dashedBezierTo","_dashedQuadraticTo","arc","cx","cy","arcTo","radius","toStatic","setLineDash","lineDashSum","setLineDashOffset","setData","len$$1","appendPath","appendSize","appendPathData","cmd","_expandData","_prevCmd","newData","dash","dashSum","dist$$1","nDash","bezierLen","tmpLen","MAX_VALUE","xi","yi","rebuildPath","ux","uy","theta","dTheta","psi","fs","scaleX","scaleY","PI2$3","normalizeRadian","PI2$2","containStroke$4","windingLine","dir","CMD$1","PI2$1","EPSILON$2","windingCubic","nRoots","K","Y1","Y2","T","acos","ASqrt","cubicRootAt","y0_","y1_","nExtrema","unit","windingQuadratic","quadraticRootAt","y_","windingArc","x_","containPath","isStroke","pathProxyForDraw","Path","__dirtyPath","strokeContainThreshold","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","_fillGradient","_strokeGradient","ctxLineDash","shapeCfg","inBundle","createPathProxy","needsUpdateRect","rectWithStroke","_rectWithStroke","lineScale","localPos","pathData","containStroke","dirtyPath","animateShape","setShape","defaults$$1","Sub","defaultShape","thisShape","CMD$2","mathSqrt$3","mathAtan2","transformPath","nPoint","cc","mathSqrt","mathSin","mathCos","vMag","vRatio","u","vAngle","processArc","fa","psiDeg","xp","yp","lambda","cxp","cyp","createPathOptions","pathProxy","cs","RegExp","prevCmd","cpx","cpy","shift","ctlPtx","ctlPty","createPathProxyFromString","Text","shadowColor","Circle","shadowTemp","fixClipWithShadow","orignalBrush","modified","Sector","r0","clockwise","unitX","unitY","Ring","interpolate","smoothSpline","isLoop","distance$$1","segs","w2","w3","smoothBezier","smooth","constraint","prevPoint","nextPoint","cps","point","d0","cp0","cp1","buildPath$1","controlPoints","smoothConstraint","cp2","Polygon","Polyline","Rect","Line","pointAt","someVectorAt","isTangent","cpx2","cpy2","cpx1","cpy1","BezierCurve","tangentAt","Arc","CompoundPath","paths","_updatePathDirty","Gradient","LinearGradient","globalCoord","RadialGradient","round$1","mathMax$1","mathMin$1","EMPTY_OBJ","extendShape","makePath","layout","createFromString","boundingRect","centerGraphic","resizePath","makeImage","imageUrl","img","mergePath","pathEls","pathList","pathEl","pathBundle","subPixelOptimizeLine","subPixelOptimize","subPixelOptimizeRect","originX","originY","originWidth","originHeight","positiveOrNegative","doubledPosition","hasFillOrStroke","fillOrStroke","liftColor","cacheElementStl","__hoverStlDirty","__hoverStl","normalStyle","__normalStl","doSingleEnterHover","__isHover","useHoverLayer","insideRollbackOpt","insideRollback","rollbackInsideStyle","applyInsideStyle","insideOriginalTextPosition","autoColor","doSingleLeaveHover","normalStl","doEnterHover","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__hoverSilentOnTouch","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","setHoverStyle","opt","hoverSilentOnTouch","setLabelStyle","emphasisStyle","normalModel","emphasisModel","normalSpecified","emphasisSpecified","labelFetcher","labelDataIndex","labelDimIndex","showNormal","showEmphasis","baseText","getFormattedLabel","defaultText","normalStyleText","emphasisStyleText","setTextStyle","textStyle","textStyleModel","specifiedTextStyle","isEmphasis","setTextStyleCommon","isRectText","labelRotate","richResult","ecModel","globalTextStyle","option","richItemNames","richItemNameMap","parentModel","getRichItemNames","richTextStyle","getModel","setTokenTextStyle","forceRich","isBlock","getAutoColor","originalTextPosition","disableBox","useInsideStyle","getFont","gTextStyleModel","animateOrSetProps","isUpdate","animatableModel","dataIndex","isAnimationEnabled","postfix","duration","animationEasing","animationDelay","getAnimationDelayParams","updateProps","initProps","getTransform","ancestor","mat","applyTransform$1","invert$$1","transformDirection","direction","hBase","vBase","vertex","groupTransition","g1","g2","elMap","elMap1","anid","oldEl","newProp","getAnimatableProps","clipPointsByRect","createIcon","iconStr","graphic","extendPath","extendFromString","setText","labelModel","defaultColor","clipRectByRect","targetRect","PATH_COLOR","textStyleMixin","getTextColor","getItemStyle","itemStyleMixin","getBorderLineDash","mixin$1","Model","doGet","pathArr","getParent","getParentMethod","mergeOption","ignoreParent","parsePath","thisParentModel","isEmpty","restoreData","setReadOnly","customizeGetParent","each$3","isObject$2","normalizeToArray","defaultEmphasis","subOpts","emphasisOpt","emphasis","normalOpt","normal","subOptName","TEXT_STYLE_OPTIONS","getDataItemValue","dataItem","isDataItemOption","converDataValue","dimInfo","dimType","dataFormatMixin","getDataParams","dataType","getData","rawValue","getRawValue","rawDataIndex","getRawIndex","getName","itemOpt","getRawDataItem","getItemVisual","mainType","componentSubType","seriesType","seriesIndex","seriesId","seriesName","marker","status","dimIndex","labelProp","itemModel","getItemModel","formatter","formatTooltip","mappingToExists","exists","newCptOptions","exist","cptOption","isIdInner","makeIdAndName","mapResult","idMap","item","existCpt","keyInfo","idNum","queryDataIndex","payload","dataIndexInside","indexOfRawIndex","indexOfName","makeGetter","hostObj","parseFinder","finder","defaultMainType","has","parsedKey","queryType","includeMainTypes","queryParam","models","queryComponents","otherDimToDataDim","otherDim","dataDim","dimensions","dimName","dimItem","getDimensionInfo","otherDims","base","DELIMITER","getUID","random","each$4","LOCATION_PARAMS","HV_NAMES","boxLayout","orient","group","maxWidth","maxHeight","currentLineMaxSize","nextX","nextY","nextChild","nextChildRect","moveX","newline","moveY","getLayoutRect","positionInfo","containerRect","margin","containerHeight","verticalMargin","horizontalMargin","positionElement","hv","boundingMode","elPos","mergeLayoutParam","targetOption","newOption","ignoreSize","hResult","merge$$1","vResult","names","hvIdx","newParams","newValueCount","merged","mergedValueCount","hasProp","hasValue","getLayoutParams","copyLayoutParams","subTypeDefaulters","arrayPush","ComponentModel","componentIndex","defaultOption","dependentModels","uid","layoutMode","extraOpt","mergeDefaultAndTheme","inputPositionParams","getTheme","getDefaultOption","optionUpdated","newCptOption","isInit","optList","Class","getReferringComponents","registerSubTypeDefaulter","defaulter","determineSubType","componentTypeMain","dependencyGetter","createDependencyGraphItem","graph","predecessor","successor","topologicalTravel","targetNameList","fullNameList","noEntryList","thisItem","availableDeps","originalDeps","dep","getAvailableDependencies","entryCount","dependentName","thatItem","makeDepndencyGraph","stack","targetNameSet","currComponentType","currVertex","isInTargetNameSet","removeEdgeAndAdd","removeEdge","succComponentType","enableTopologicalTravel","deps","dependencies","getBoxLayoutParams","platform","globalDefault","blendMode","animationDuration","animationDurationUpdate","animationEasingUpdate","animationThreshold","progressiveThreshold","hoverLayerThreshold","useUTC","colorPaletteMixin","clearColorPalette","getColorFromPalette","colorIdx","colorNameMap","colorPalette","each$2","filter$1","map$1","isArray$1","indexOf$1","isObject$1","OPTION_INNER_KEY","GlobalModel","theme","optionManager","_theme","_optionManager","setOption","optionPreprocessorFuncs","resetOption","optionChanged","baseOption","mountOption","_componentsMap","series","_seriesIndices","themeItem","timelineOption","getTimelineOption","mediaOptions","getMediaOption","_api","mediaOption","componentsMap","newCptTypes","componentOption","newCptOptionList","existComponent","getComponentsByTypes","resultItem","componentModel","ComponentModelClass","createSeriesIndices","getOption","getComponent","cpts","isIdArray","cpt","isNameArray","filterBySubType","findComponents","q","indexAttr","idAttr","nameAttr","query","queryCond","eachComponent","components","component","queryResult","getSeriesByName","oneSeries","getSeriesByIndex","getSeriesByType","getSeries","eachSeries","assertSeriesInitialized","rawSeriesIndex","eachRawSeries","eachSeriesByType","eachRawSeriesByType","isSeriesFiltered","seriesModel","getCurrentSeriesIndices","filterSeries","filteredSeries","componentTypes","seriesModels","echartsAPIList","coordinateSystemCreators","CoordinateSystemManager","_coordinateSystems","api","coordinateSystems","creater","coordSys","getCoordinateSystems","register","coordinateSystemCreator","each$5","clone$2","map$2","merge$1","QUERY_REG","OptionManager","_timelineOptions","_mediaList","_mediaDefault","_currentMediaIndices","_optionBackup","_newBaseOption","applyMediaQuery","ecWidth","ecHeight","realMap","aspectratio","applicatable","matched","operator","realAttr","real","expect","rawOption","oldOption","oldOptionBackup","newParsedOption","isNew","mediaDefault","timelineOptions","mediaList","timelineOpt","timeline","media","singleMedia","preProcess","newCptOpt","oldCptOpt","isRecreate","optionBackup","timelineModel","getCurrentIndex","indices1","indices2","indices","each$6","isObject$3","POSSIBLE_STYLES","compatItemStyle","itemStyleOpt","itemStyle","normalItemStyleOpt","emphasisItemStyleOpt","compatTextStyle","labelOptSingle","compatLabelTextStyle","labelOpt","toArr","toObj","compatStyle","isTheme","seriesOpt","label","upperLabel","edgeLabel","markPoint","markLine","markArea","mpData","mlData","processSeries","axes","axisName","axisOpt","axisPointer","parallel","parallelOpt","parallelAxisDefault","calendar","calendarOpt","radar","radarOpt","geo","geoOpt","regions","regionObj","tooltip","compatLayoutProperties","LAYOUT_PROPERTIES","COMPATITABLE_COMPONENTS","COMPATITABLE_SERIES","backwardCompat","clockWise","pointerColor","get$1","set$2","dataRange","visualMap","componentName","SeriesModel","coordinateSystem","legendDataProvider","visualColorAccessPath","getInitialData","themeSubType","fillDataTextStyle","newSeriesOption","cloneShallow","getLinkedData","getRawData","coordDimToDataDim","coordDim","coordDimIndex","dataDimToCoordDim","getDimension","getBaseAxis","multipleSeries","formattedValue","vertially","tooltipName","tooltipDims","setEachItem","dimIdx","valStr","formatArrayValue","colorEl","animationEnabled","getAxisTooltipData","getTooltipPosition","Component","render","componentProto","Chart","updateView","updateLayout","updateVisual","highlight","toggleHighlight","downplay","chartProto","elSetState","state","dataIdx","getItemGraphicEl","eachItemGraphicEl","ORIGIN_METHOD","RATE","THROTTLE_TYPE","throttle","debounce","currCall","debounceNextCall","lastCall","lastExec","timer","thisDelay","thisDebounce","debounceDelay","createOrUpdate","fnAttr","rate","throttleType","originFn","lastThrottleType","PI$1","PRIORITY_PROCESSOR_FILTER","PRIORITY_VISUAL_LAYOUT","PRIORITY_VISUAL_CHART","PRIORITY","PROCESSOR","FILTER","STATISTIC","VISUAL","LAYOUT","GLOBAL","CHART","COMPONENT","BRUSH","IN_MAIN_PROCESS","OPTION_UPDATED","ACTION_REG","createRegisterEventWithLowercaseName","MessageCenter","ECharts","themeStorage","_dom","defaultRenderer","__ECHARTS__DEFAULT__RENDERER__","ecInstance","coordSysMgr","_zr","prioritySortFunc","prio","_throttledZrFlush","_chartsViews","_chartsMap","_componentsViews","_coordSysMgr","chartInstance","getComponentByElement","modelInfo","__ecComponentInfo","_model","_messageCenter","_initEvents","_pendingActions","visualFuncs","dataProcessorFuncs","_onframe","echartsProto","doConvertPixel","coordSysList","updateMethods","prepareAndUpdate","flushPendingActions","triggerUpdatedEvent","getDom","getZr","notMerge","lazyUpdate","setTheme","getDevicePixelRatio","getSvgDataUrl","pathToSvg","getDataURL","excludeComponents","excludesComponentViews","view","__viewId","url","toDataURL","getConnectedDataURL","groupId","connectedGroups","canvasList","instances","chart","targetCanvas","convertToPixel","convertFromPixel","containPixel","containPoint","getVisual","visualType","getViewOfComponentModel","getViewOfSeriesModel","process","stackedDataMap","previousStack","stackedOn","doVisualEncoding","componentView","__model","updateZ","__alive","chartView","updateProgressiveAndBlend","updateHoverLayerStatus","background","postUpdateFuncs","clearAllVisual","invokeUpdateMethod","visual","isLayout","prepareView","updateDirectly","ecIns","callView","doDispatchAction","payloadType","escapeConnect","actionWrap","actions","actionInfo","cptType","updateMethod","payloads","batched","batch","eventObj","eventObjBatch","isHighDown","batchItem","action","pendingActions","isComponent","viewList","viewMap","viewId","classType","__id","excludesLayout","_loadingFX","showLoading","cfg","hideLoading","loadingEffects","makeActionFromEvent","eventActionMap","dispatchAction","MOUSE_EVENT_NAMES","frameDrawNum","needProgressive","eveName","dataModel","eventData","actionType","isDisposed","_disposed","idBase","groupIdBase","DOM_ATTRIBUTE_KEY","mapDataStores","disConnect","disconnect","getInstanceByDom","getAttribute","registerPreprocessor","preprocessorFunc","registerProcessor","priority","processorFunc","registerAction","registerCoordinateSystem","CoordinateSystem$$1","registerLayout","layoutFunc","registerVisual","visualFunc","registerLoading","loadingFx","extendComponentModel","extendComponentView","extendSeriesModel","extendChartView","getMap","mapName","colorAccessPath","setVisual","setItemVisual","textColor","maskColor","mask","lineCap","labelRect","defaultKeyGetter","DataDiffer","oldArr","newArr","oldKeyGetter","newKeyGetter","_old","_new","_oldKeyGetter","_newKeyGetter","initIndexMap","keyArr","keyGetterName","dataDiffer","existence","_add","_remove","execute","newDataIndexMap","oldDataKeyArr","newDataKeyArr","unshift","isObject$4","globalObj","dataCtors","float","Float64Array","int","Int32Array","ordinal","TRANSFERABLE_PROPERTIES","transferProperties","__wrappedMethods","DefaultDataProvider","dataArray","_array","pure","getItem","List","hostModel","dimensionInfos","dimensionNames","dimensionName","dimensionInfo","stackable","_dimensionInfos","_storage","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_rawData","_extent","listProto","normalizeDimensions","cloneListForMapAndSample","original","excludeDimensions","allDimensions","originalStorage","dim","dimStore","hasItemOption","initData","nameList","dimValueGetter","isDataArray","nameDimIdx","dimensionInfoMap","size","idList","nameRepeatCount","itemName","DataCtor","stackedValue","getValues","getDataExtent","filter$$1","dimData","dimExtent","getSum","rawIndex","indicesOfNearest","maxDistance","nearestIndices","minDist","minDiff","rawIdx","dims","dimSize","filterSelf","newIndices","keep","mapArray","tmpRetValue","retValue","downSample","dimension","sampleValue","sampleIndex","targetStorage","originalIndices","frameValues","frameIndices","frameSize","otherList","otherIdList","setLayout","getLayout","getItemLayout","setItemLayout","clearItemLayouts","itemVisual","setItemDataAndSeriesIndex","setItemGraphicEl","dimensionInfoList","wrapMethod","injectFunction","originalMethod","TRANSFERABLE_METHODS","CHANGABLE_METHODS","each$7","isString$1","defaults$1","OTHER_DIMS","completeDimensions","sysDims","dimsDef","encodeDef","dataDimNameMap","coordDimNameMap","dimCount","retrieveValue","sysDimItem","sysDimItemDimsDef","dimDefItem","userDimName","dataDims","resultDimIdx","applyDim","availDimIdx","sysDimIndex","sysDimItemOtherDims","extra","extraPrefix","genName","extraFromZero","isExtraCoord","guessOrdinal","map$$1","fromZero","createListFromArray","coordSysName","creator","creators","registeredCoordSys","completeDimOpt","axesInfo","getDimensionsInfo","categoryIndex","categoryAxisModel","categoryDim","categoryAxesModels","categories","getCategories","dataLen","createNameList","sampleItem","firstDataNotNull","ifNeedCompleteOrdinalData","isStackable","axisType","getDimTypeByAxis","cartesian2d","axesModels","xAxisModel","yAxisModel","xAxisType","yAxisType","isXAxisCateogry","isYAxisCategory","singleAxis","singleAxisModel","singleAxisType","isCategory","single","polar","polarModel","angleAxisModel","findAxisModel","radiusAxisModel","radiusAxisType","angleAxisType","isAngleAxisCateogry","isRadiusAxisCateogry","Scale","setting","_setting","_interval","getSetting","extent","unionExtent","unionExtentFromData","getExtent","setExtent","thisExtent","getTicksLabels","labels","ticks","getTicks","getLabel","isBlank","_isBlank","setBlank","scaleProto","OrdinalScale","_data","rank","niceTicks","niceExtent","roundNumber$1","getIntervalPrecision","niceTickExtent","fixExtent","roundNumber","IntervalScale","_intervalPrecision","getInterval","setInterval","_niceExtent","intervalPrecision","tick","intervalScaleGetTicks","splitNumber","minInterval","maxInterval","span","reverse","intervalScaleNiceTicks","expandSize","fixMax","fixMin","intervalScaleProto","mathCeil","mathFloor","TimeScale","stepLvl","_stepLvl","ONE_HOUR","getFullYear","getMonth","getDate","approxTickNum","approxInterval","scaleLevelsLen","scaleLevels","bisect","timezoneOffset","getTimezoneOffset","ONE_SECOND","ONE_MINUTE","ONE_DAY","scaleProto$1","intervalScaleProto$1","getPrecisionSafe$1","roundingErrorFix","mathFloor$1","mathCeil$1","mathPow$1","mathLog","LogScale","_originalScale","originalScale","originalExtent","powVal","__fixMin","fixRoundingError","__fixMax","originalVal","getScaleExtent","axisDataLen","boundaryGap","scaleType","getMin","getMax","getNeedCrossZero","niceScaleExtent","createScaleByModel","getAxisLabelInterval","tickCoords","axisRotate","textSpaceTakenRect","autoLabelInterval","accumulatedLabelInterval","tickCoord","getFormattedLabels","axis","labelFormatter","getAxisRawValue","axisModelCommonMixin","rangeStart","rangeEnd","getCoordSysModel","setRange","resetRange","Triangle","Diamond","Pin","tanX","tanY","cpLen","cpLen2","Arrow","symbolShapeMakers","roundRect","square","circle","diamond","pin","arrow","triangle","symbolBuildProxies","SymbolClz","symbolType","proxySymbol","symbolPathSetColor","innerColor","symbolStyle","symbolShape","__isEmptyBrush","createSymbol","keepAspect","symbolPath","setColor","helper","createList","createScale","axisModel","mixinAxisModelCommonMethods","Model$$1","linearMap$1","fixExtentWithBands","nTick","normalizedExtent","Axis","inverse","onBand","_labelInterval","containData","dataToCoord","coordToData","pointToData","getTicksCoords","alignWithLabel","bands","getBands","coords","getLabelsCoords","getBandWidth","axisExtent","isHorizontal","getRotate","getLabelInterval","labelInterval","EPSILON$3","isAroundEqual$1","contain$1","Region","geometries","cp","decodePolygon","coordinate","encodeOffsets","encodeScale","prevX","prevY","MAX_NUMBER","exterior","loopGeo","interiors","transformTo","parseGeoJson","geoJson","json","UTF8Encoding","UTF8Scale","features","geometry","coordinates","c2","polygon","decode","featureObj","region","ecUtil","findLabelValueDim","valueDim","labelDims","getScale","symbolSize","SymbolClz$1","seriesScope","updateData","legendHoverLink","hoverAnimation","clipOverflow","lineStyle","smoothMonotone","symbol","symbolRotate","showSymbol","showAllSymbol","connectNulls","sampling","symbolProto","driftSymbol","_createSymbol","_symbolType","stopSymbolAnimation","toLastFrame","getSymbolPath","setZ","setDraggable","getSymbolSize","_updateCommon","fadeIn","_seriesModel","normalStyleAccessPath","emphasisStyleAccessPath","normalLabelAccessPath","emphasisLabelAccessPath","SymbolDraw","symbolCtor","_symbolCtor","hoverItemStyle","symbolOffset","hoverLabelModel","elStyle","symbolInnerColor","useNameLabel","onEmphasis","ratio","onNormal","fadeOut","keepLabel","symbolDrawProto","symbolNeedsDraw","isIgnore","sign$1","getStackedOnPoint","stackedOnSameSign","baseAxis","valueAxis","getOtherAxis","valueStart","onZero","baseDataOffset","stackedData","dataToPoint","oldData","SymbolCtor","newIdx","symbolEl","oldIdx","enableAnimation","scaleAndAdd$1","v2Copy","isPointNull","drawSegment","segLen","allLen","smoothMin","smoothMax","prevIdx","nextIdx","nextP","ratioNextSeg","prevP","lenPrevSeg","lenNextSeg","getBoundingBox","ptMin","ptMax","pt","Polyline$1","Polygon$1","stackedOnPoints","stackedOnSmooth","bbox","stackedOnBBox","isPointsSame","points1","points2","getSmooth","getAxisExtentWithGap","getGlobalExtent","halfBandWidth","sign","createClipShape","hasAnimation","angleAxis","getAngleAxis","radiusExtent","getRadiusAxis","angleExtent","RADIAN","createPolarClipShape","cartesian","xExtent","getAxis","yExtent","createGridClipShape","turnPointsIntoStep","stepTurnAt","baseIndex","stepPoints","nextPt","stepPt","stepPt2","lineGroup","symbolDraw","_symbolDraw","_lineGroup","lineStyleModel","areaStyleModel","isCoordSysPolar","prevCoordSys","_coordSys","polyline","_polyline","_polygon","isAreaChart","getStackedOnPoints","isSymbolIgnore","_getSymbolIgnoreFunc","__temp","_step","_newPolygon","_stackedOnPoints","_points","_updateAnimation","_newPolyline","visualColor","visualMetaList","visualMeta","stops","toGlobalCoord","stopLen","outerColors","minCoord","maxCoord","coordSpan","gradient","getVisualGradient","lineJoin","categoryAxis","getAxesByScale","isLabelIgnored","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","diffResult","idx1","diffData","currPoints","nextPoints","currStackedPoints","nextStackedPoints","sortedIndices","rawIndices","diffItem","pointAdded","currentPt","sortedCurrPoints","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","current","stackedOnCurrent","stackedOnNext","lineAnimationDiff","__points","updatedDataInfo","diffStatus","ptIdx","visualSymbol","defaultSymbolType","legendSymbol","itemSymbolType","itemSymbolSize","layoutPoints","coordDims","samplers","average","nearest","indexSampler","dimAxisMapper","_axes","Cartesian","_dimList","Cartesian2D","getAxes","addAxis","_dataCoordConvert","input","dimList","output","axisX","axisY","toLocalCoord","xAxis","yAxis","Axis2D","coordExtent","grid","nameLocation","nameRotate","nameTruncate","nameTextStyle","nameGap","triggerEvent","axisLine","onZeroAxisIndex","axisTick","inside","axisLabel","showMinLabel","showMaxLabel","splitLine","splitArea","areaStyle","axisDefault","timeAxis","logAxis","logBase","AXIS_TYPES","axisModelCreator","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","AxisModel","gridIndex","gridId","getAxisType","axisDim","extraOption","containLabel","borderWidth","borderColor","each$8","ifAxisCrossZero$1","niceScaleExtent$1","isAxisUsedInTheGrid","gridModel","Grid","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","gridProto","fixAxisOnZero","axesMap","otherAxisDim","otherAxis","canNotOnZeroToAxis","axisPointerEnabled","getRect","_updateScale","ignoreContainLabel","gridRect","axesList","adjustAxes","coordBase","axisExtentSum","updateAxisTransfrom","labelUnionRect","rotateRadians","boundingBox","beforeWidth","beforeHeight","afterWidth","afterHeight","axisLabelModel","labelCount","unrotatedSingleRect","singleRect","getLabelUnionRect","axisIndex","axesMapOnDim","getCartesian","xAxisIndex","yAxisIndex","coordList","getCartesians","_findConvertTarget","coordsList","axisPositionUsed","axesCount","createAxisCreator","axisPosition","isCartesian2D","findAxesModels","getTooltipAxes","baseAxes","otherAxes","axesTypes","grids","PI$2","makeAxisEventDataBase","AxisBuilder","labelOffset","nameDirection","tickDirection","labelDirection","dumbGroup","_transform","_dumbGroup","hasBuilder","builders","getGroup","pt1","pt2","arrows","arrowSize","symbolWidth","symbolHeight","axisTickLabel","tickEls","axisBuilder","tickModel","tickLen","tickInterval","getInterval$1","ticksCoords","ticksCnt","ifIgnoreOnTick$1","tickEl","buildAxisTick","labelEls","firstLabel","nextLabel","lastLabel","prevLabel","firstTick","nextTick","lastTick","prevTick","ignoreEl","isTwoLabelOverlapped","fixMinMaxLabelShow","axisLabelShow","labelMargin","labelRotation","labelLayout","innerTextLayout","categoryData","tickVal","itemLabelModel","labelStr","textEl","targetType","buildAxisLabel","axisNameAvailableWidth","gapSignal","isNameLocationCenter","nameRotation","textRotate","rotationDiff","onLeft","endTextLayout","truncateOpt","nameTruncateMaxWidth","truncatedText","tooltipOpt","formatterParams","__fullText","__truncatedText","content","axisRotation","firstRect","nextRect","mRotationBack","ifIgnoreOnTick","rawTick","each$9","curry$1","collect","seriesInvolved","coordSysAxesInfo","coordSysMap","globalTooltipModel","globalAxisPointerModel","linksOption","linkGroups","coordSysKey","makeKey","axesInfoInCoordSys","coordSysModel","baseTooltipModel","saveTooltipAxisInfo","triggerAxis","cross","tooltipAxes","fromTooltip","triggerTooltip","axisPointerModel","axisPointerShow","isHandleTrigger","snap","tooltipAxisPointerModel","volatileOption","field","labelOption","crossStyle","makeAxisPointerModel","involveSeries","axisInfo","useHandle","groupIndex","linkOption","checkPropInLink","getLinkGroupIndex","linkGroup","mapper","collectAxesInfo","seriesTooltipTrigger","seriesTooltipShow","seriesDataCount","collectSeriesInfo","linkPropValue","axisPropValue","getAxisInfo","AxisView","_axisPointer","axisPointerClass","fixValue","updateAxisPointer","disposeAxisPointer","axisView","forceRender","getAxisPointerClass","getAxisPointerModel","axisPointerClazz","rawAxisPosition","rectBound","axisOffset","posBound","onZeroCoord","labelInside","registerAxisPointerClass","axisBuilderAttrs","selfBuilderAttrs","CartesianAxisView","oldAxisGroup","_axisGroup","layout$$1","_splitLine","splitLineModel","lineColors","lineInterval","lineCount","colorIndex","_splitArea","splitAreaModel","areaColors","areaInterval","sampler","STACK_PREFIX","getSeriesStackId","getAxisKey","doCalBarWidthAndOffset","seriesInfoList","columnsMap","seriesInfo","axisKey","bandWidth","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","stacks","stackId","barWidth","barMaxWidth","barGap","barCategoryGap","barGapPercent","autoWidth","column","lastColumn","widthSum","barLayoutGrid","barWidthAndOffset","lastStackCoords","lastStackCoordsOrigin","columnLayoutInfo","columnOffset","columnWidth","barMinHeight","valueAxisStart","lastCoord","lastCoordOrigin","getLayoutOnAxis","widthAndOffsets","offsetCenter","BaseBarSeries","getMarkerPosition","barMinAngle","setLabel","labelPositionOutside","fixPosition","brushSelector","getBarItemStyle","barItemStyle","BAR_BORDER_WIDTH_QUERY","coordinateSystemType","_render","isHorizontalOrRadial","animationModel","elementCreator","updateStyle","newIndex","oldIndex","removeRect","removeSector","rectShape","animateProperty","animateTarget","isRadial","sector","sectorShape","fixedLineWidth","rawLayout","getLineWidth","signX","signY","isPolar","itemStyleModel","selectableMixin","updateSelectedMap","targetList","_targetList","_selectTargetMap","targetMap","select","selected","unSelect","toggleSelected","isSelected","PieSeries","_defaultLabelLine","labelLine","labelLineNormalOpt","labelLineEmphasisOpt","minAngle","selectedOffset","hoverOffset","avoidLabelOverlap","percentPrecision","stillShowZeroSum","animationType","updateDataSelected","toggleItemSelected","midAngle","PiePiece","hoverIgnore","normalIgnore","piePieceProto","firstCreate","_updateLabel","labelText","linePoints","labelHoverModel","labelLineModel","labelLineHoverModel","verticalAlign","sectorGroup","_sectorGroup","isFirstRender","onSectorClick","selectedMode","piePiece","_createClipPath","itemLayout","createDataSelectAction","actionInfos","dataColor","paletteScope","dataAll","idxMap","filteredIdx","singleDataColor","adjustSingleSide","viewWidth","viewHeight","shiftDown","shiftUp","changeX","isDownList","lastDeltaX","deltaY","deltaX","lastY","upList","downList","labelLayoutList","hasLabelRotate","labelPosition","labelLineLen","labelLineLen2","isLabelInside","leftList","rightList","avoidOverlap","PI2$4","dataFilter","legendModels","validDataCount","unitRadian","roseType","restAngle","valueSumLargerThanMinAngle","currentAngle","large","largeThreshold","LargeSymbolPath","sizes","symbolProxy","symbolProxyShape","findDataIndex","LargeSymbolDraw","_symbolEl","largeSymbolProto","IndicatorAxis","Radar","radarModel","_indicatorAxes","getIndicatorModels","indicatorModel","indicatorAxis","_normalSymbolDraw","_largeSymbolDraw","largeSymbolDraw","normalSymbolDraw","getIndicatorAxes","indicatorIndex","coordToPoint","closestAxis","minRadianDiff","closestAxisIdx","coodToData","viewSize","indicatorAxes","radarSeries","increaseInterval","rawExtent","fixedMin","fixedMax","halfSplitNumber","radarList","valueAxisDefault","defaultsShow","showName","nameFormatter","indicatorModels","indicatorOpt","iNameTextStyle","indName","indicator","axisBuilderAttrs$1","_buildAxes","_buildSplitLineAndArea","showSplitLine","showSplitArea","splitLineColors","splitAreaColors","splitLines","splitAreas","ticksRadius","getColorIndex","realSplitNumber","axesTicksPoints","prevPoints","error","areaOrLine","areaOrLineColorList","RadarSeries","radarIndex","createSymbol$$1","normalizeSymbolSize","updateSymbols","oldPoints","newPoints","symbolGroup","__dimIdx","getInitialPoints","itemGroup","hoverAreaStyleModel","polygonIgnore","hoverPolygonIgnore","itemHoverStyle","pointsConverter","polarOptArr","polarNotRadar","polarOpt","polarIndex","v2ApplyTransform$1","TransformDummy","View","zoomLimit","_roamTransform","_viewTransform","_center","_zoom","doConvert$1","setBoundingRect","setViewRect","_viewRect","viewTransform","_updateTransform","setCenter","centerCoord","_updateCenterAndZoom","setZoom","zoom","getDefaultCenter","rawRect","getCenter","getZoom","getRoamTransform","viewTransformMatrix","roamTransform","defaultCenter","getViewRect","getViewRectAfterRoam","geoCoord","points$1","i$1","coordsOffsetMap","","","","","","geoCoordMap","Russia","United States","United States of America","points$2","geoFixFuncs","coordFix","Geo","specialAreas","nameMap","_nameCoordMap","loadGeoJson","doConvert","geoModel","resizeGeo","boundingCoords","leftTop","rightBottom","boxLayoutOption","aspectScale","useCenterAndSize","setGeoCoords","addGeoCoord","containCoord","regionsMap","regionName","specialArea","_regionsMap","fixFunc","getRegion","getRegionByCoord","getGeoCoord","regionRect","mapNotExistsError","geoCreator","geoList","mapData","geoIndex","mapModelGroupBySeries","getHostGeoModel","mapType","getMapType","mapSeries","nameMapList","singleMapSeries","getFilledRegions","originRegionArr","regionsArr","dataNameMap","MapSeries","needsDrawMap","seriesGroup","_fillOption","getRegionModel","seriesNames","otherIndex","originalData","showLegendSymbol","dataRangeHoverLink","scaleLimit","areaColor","ATTR","isTaken","resourceKey","getStore","RoamController","pointerChecker","_opt","bind$$1","mousedownHandler","mousemoveHandler","mouseupHandler","mousewheelHandler","mousewheel","pinchHandler","setPointerChecker","enable","controlType","disable","zoomOnMouseWheel","moveOnMouseMove","preventDefaultMouseMove","isDragging","_dragging","isPinching","_pinching","checkKeyBinding","oldX","oldY","zoomDelta","zoomX","zoomY","roamController","updateViewOnPan","controllerHost","updateViewOnZoom","newZoom","zoomMin","zoomMax","zoomScale","IRRELEVANT_EXCLUDES","onIrrelevantElement","targetCoordSysModel","getFixedItemStyle","updateMapSelected","mapOrGeoModel","otherRegionEl","__regions","MapDraw","updateGroup","_controller","_controllerHost","_updateGroup","_mouseDownFlag","updateCenterAndZoom","previousZoom","fixX","fixY","draw","fromView","isGeo","groupNewProp","itemStyleAccessPath","hoverItemStyleAccessPath","labelAccessPath","hoverLabelAccessPath","regionGroup","compoundPath","regionModel","hoverItemStyleModel","showLabel","hoverShowLabel","isDataNaN","_updateController","mapDraw","updateMapSelectHandler","controller","makeActionBase","mouseX","mouseY","mapModel","_mapDraw","_renderSymbols","fullData","mainSeries","fullIndex","polygonGroups","normalText","emphasisText","__mapOriginalZ2","processedMapType","mapSymbolOffsets","subMapSeries","colorList","seriesGroups","hostGeoModel","seriesList","datas","statisticType","mapKey","mapLocation","each$10","DATAS","MAIN_DATA","linkList","mainData","datasAttr","linkAll","transferInjection","cloneShallowInjection","changeInjection","linkSingle","struct","structAttr","TreeNode","hostTree","depth","viewChildren","Tree","levelOptions","leavesOption","_nodes","levelModels","levelDefine","leavesModel","firstWalk","separation","isExpand","siblings","subtreeW","hierNode","change","prelim","modifier","executeShifts","midPoint","defaultAncestor","subtreeV","nodeOutRight","nodeInRight","nodeOutLeft","nodeInLeft","sumOutRight","sumInRight","sumOutLeft","sumInLeft","nextRight","nextLeft","moveSubtree","nextAncestor","thread","apportion","secondWalk","nodeX","defaultSeparation","radialCoordinate","radialCoor","wl","wr","node1","node2","symbolNeedsDraw$1","getTreeNodeStyle","updateNode","tree","getNodeByDataIndex","virtualRoot","sourceSymbolEl","sourceLayout","sourceOldLayout","rawX","__radialOldRawX","rawY","__radialOldRawY","targetLayout","__radialRawX","__radialRawY","isLeft","realRoot","rootLayout","__edge","getEdgeShape","removeNode","radialCoor1","radialCoor2","curvature","radialCoor3","radialCoor4","eachBefore","nodes","isRemoved","eachNode","order","suppressVisitSub","updateDepthAndHeight","getNodeById","contains","getAncestors","includeSelf","ancestors","getValue","levelModel","getLevelModel","getLeavesModel","getNodeByName","clearLayouts","createTree","dataRoot","treeOptions","levels","leaves","listData","dimMax","buildHierarchy","dataNode","addChild","layoutInfo","treeOption","treeDepth","expandTreeDepth","expandAndCollapse","initialTreeDepth","collapsed","curveness","_oldTree","_mainGroup","commonLayout","separation$$1","init$2","eachAfter","kx","ky","coorX","coorY","finalCoor","retrieveTargetInfo","targetNode","targetNodeId","getPathToRoot","aboveViewRoot","viewRoot","wrapTreePathInfo","treePathInfo","nodeDataIndex","_viewRoot","clipWindow","squareRatio","leafDepth","drillDownIcon","zoomToNodeRatio","roam","nodeClick","breadcrumb","emptyItemWidth","colorAlpha","colorSaturation","gapWidth","borderColorSaturation","visualDimension","visualMin","visualMax","colorMappingBy","visibleMin","childrenVisibleMin","completeTreeValue","childValue","thisValue","hasColorDefine","globalColorList","modelColor","level0","setDefault","resetViewRoot","setLayoutInfo","mapIdToIndex","idIndexMap","_idIndexMap","_idIndexMapCount","getViewRoot","ARRAY_LENGTH","Breadcrumb","containerGroup","makeItemPoints","itemWidth","itemHeight","packEventData","itemNode","selfType","nodeData","onSelect","thisGroup","normalStyleModel","layoutParam","totalWidth","renderList","_prepare","_renderContent","TEXT_PADDING","lastX","availableSize","onclick","bind$1","Group$2","Rect$1","each$11","PATH_LABEL_NOAMAL","PATH_LABEL_EMPHASIS","PATH_UPPERLABEL_NORMAL","PATH_UPPERLABEL_EMPHASIS","Z_BASE","Z_BG","Z_CONTENT","getItemStyleEmphasis","getItemStyleNormal","renderNode","thisStorage","oldStorage","reRoot","lastsForAnimation","willInvisibleEls","thisNode","oldNode","parentGroup","thisLayout","isInView","thisWidth","thisHeight","thisInvisible","thisRawIndex","oldRawIndex","thisViewChildren","upperHeight","isParent","itemStyleNormalModel","itemStyleEmphasisModel","giveGraphic","__tmNodeWidth","__tmNodeHeight","isAboveViewRoot","bg","useUpperLabel","visualBorderColor","emphasisBorderColor","upperLabelWidth","prepareText","renderBackground","renderContent","__tmWillVisible","upperLabelRect","nodeModel","isLeafRoot","iconChar","normalLabelModel","emphasisLabelModel","isShow","storageName","lasts","old","prepareAnimationWhenHasOld","zInLevel","zb","calculateZ","__tmDepth","__tmStorageName","lastCfg","parentOldX","parentOldY","parentOldBg","fadein","prepareAnimationWhenNoOld","_containerGroup","nodeGroup","_breadcrumb","_state","rootNodeGroup","_giveContainerGroup","renderResult","_doRender","renderFinally","_doAnimation","_resetController","_renderBreadcrumb","thisTree","oldTree","doRenderNode","dualTravel","oldViewChildren","sameTree","processNode","getKey","willDeleteEls","store","delEls","__tmWillDelete","clearStorage","els","doneCallback","elExistsMap","animationWrap","targetX","targetY","last","_onPan","_onZoom","_clearController","rootRect","findTarget","_rootToNode","_zoomToNode","link","linkTarget","open","bgEl","noop$1","actionTypes","i$2","originViewRoot","each$12","isObject$5","CATEGORY_DEFAULT_VISUAL_INDEX","VisualMapping","mappingMethod","thisOption","_normalizeData","normalizers","visualHandler","visualHandlers","applyVisual","getColorMapper","_doMap","normalizeVisualRange","pieceList","hasSpecialVisual","piece","originIndex","preprocessForPiecewise","categoryMap","cate","visualArr","setVisualToOption","preprocessForSpecifiedCategory","mapValueToVisual","normalized","getNormalizer","makeApplyVisual","isNormalized","doMapCategory","returnRGBArray","parsedVisual","category","piecewise","getSpecifiedVisual","fixed","doMapFixed","colorHue","makePartialColorVisualHandler","colorLightness","makeDoMap","symbolCfg","doMapToArray","applyValue","sourceExtent","findPieceIndex","pieceIndex","listVisualTypes","visualTypes","addVisualHandler","isValidType","eachVisual","mapVisual","isPrimary","newVisual","newVal","retrieveVisuals","hasVisual","prepareVisualTypes","type1","type2","dependsOn","visualType1","visualType2","findClosestWhenOutside","possibleI","pieceValue","updatePossible","newAbs","isArray$2","ITEM_STYLE_NORMAL","calculateColor","visuals","getValueVisualDefine","getRangeVisual","mathMax$4","mathMin$4","retrieveValue$1","each$13","PATH_BORDER_WIDTH","PATH_GAP_WIDTH","PATH_UPPER_LABEL_SHOW","PATH_UPPER_LABEL_HEIGHT","worst","row","rowFixedLength","area","areaMax","areaMin","squareArea","halfGapWidth","idx0WhenH","idx1WhenH","xy","rowOtherLength","rowLen","nodeLayout","wh1","remain","modWH","wh0","getUpperLabelHeight","generateNodeKey","seriesItemStyleModel","travelTree","designatedVisual","levelItemStyles","viewRootAncestors","thisNodeColor","nodeItemStyleModel","levelItemStyle","visualName","buildVisuals","calculateBorderColor","mapping","rangeVisual","__drColorMappingBy","buildVisualMapping","childVisual","childVisuals","mappingType","mapVisual$1","seriesOption","viewAbovePath","rootSize","currNode","defaultSize","viewArea","currNodeValue","estimateRootSize","viewRootLayout","squarify","hideChildren","upperLabelHeight","layoutOffset","layoutOffsetUpper","totalArea","orderBy","overLeafDepth","sort$1","info","statistic","orderedChildren","deletePoint","filterByThreshold","initChildren","best","score","treeRoot","defaultPosition","targetCenter","calculateRootPosition","prunning","clipRect","nodeInViewAbovePath","childClipRect","Graph","directed","_directed","edges","_nodesMap","_edgesMap","edgeData","graphProto","Node","inEdges","outEdges","hostGraph","Edge","n1","n2","isDirected","addNode","nodesMap","getNodeByIndex","addEdge","edgesMap","getEdgeByIndex","getEdge","eachEdge","breadthFirstTraverse","startNode","edgeType","__visited","queue","currentNode","otherNode","degree","inDegree","outDegree","createGraphDataProxyMixin","hostName","dataName","getGraphicEl","createGraphFromNodeEdge","beforeLink","linkNameList","validEdges","linkCount","coordSysCtor","GraphSeries","_categoriesData","links","_updateCategoriesData","categoriesModels","_categoriesModels","categoryIdx","categoryModel","edgeLabelModel","fakeSeriesModel","edgeGetParent","getGraph","getEdgeData","getCategoriesData","sourceName","targetName","html","categoriesData","focusNodeAdjacency","circular","rotateLabel","initLayout","repulsion","gravity","edgeLength","layoutAnimation","edgeSymbol","edgeSymbolSize","nodeScaleRatio","straightLineProto","bezierCurveProto","isLine","LinePath","SYMBOL_CATEGORIES","makeSymbolTypeKey","symbolCategory","createSymbol$1","lineData","setLinePoints","targetShape","Line$1","_createLine","lineProto","isPointNaN","lineNeedsDraw","pts","LineDraw","ctor","_ctor","symbolFrom","symbolTo","invScale","fromPos","toPos","tangent","__position","halfPercent","__verticalAlign","__textAlign","createLine","_updateCommonStl","hoverLineStyle","visualOpacity","defaultLabelColor","rawVal","labelStyle","linePath","lineDrawProto","oldLineData","_lineData","LineCtor","v3","quadraticAt$1","v2DistSquare","mathAbs$1","intersectCurveCircle","curvePoints","radiusSquare","nextDiff","adjustEdge","tmp0","quadraticSubdivide$$1","pts2","fromSymbol","toSymbol","__original","originalPoints","nodeOpacityPath","lineOpacityPath","getItemOpacity","opacityPath","fadeOutItem","opacityRatio","fadeInItem","lineDraw","_lineDraw","_firstRender","_nodeScaleRatio","_getNodeGlobalScale","_updateNodeAndLinkScale","_layoutTimeout","forceLayout","_startForceLayoutIteration","warmUp","_layouting","setFixed","setUnfixed","__focusNodeAdjacency","__unfocusNodeAdjacency","edgeDataIndex","circularRotateLabel","adjacentEdge","unfocusNodeAdjacency","stopped","nodeScale","groupScale","groupZoom","normalize$1","simpleLayout$1","simpleLayoutEdge","circularLayout$1","unitAngle","x12","y12","scaleAndAdd$2","graphSeries","categoryNames","categoryNameIdxMap","colorQuery","opacityQuery","preservedPoints","forceModel","nodeDataExtent","edgeDataExtent","rep","forceInstance","pp","friction","v12","nLen","repFact","forceLayout$1","oldStep","coordSysType","getViewRect$1","bbWidth","bbHeight","viewCoordSys","dataOpt","pointer","title","PointerPath","formatLabel","PI2$5","FunnelSeries","posInfo","parsePosition","_renderMain","angleRangeSpan","prevEndAngle","axisLineWidth","getColor","_renderTicks","_renderPointer","_renderTitle","_renderDetail","minVal","maxVal","subSplitNumber","splitLineLen","subStep","splitLineStyle","tickLineStyle","tickLine","valueExtent","pointerModel","titleModel","detailModel","minSize","funnelAlign","FunnelPiece","funnelPieceProto","opacityAccessPath","funnelPiece","getViewRect$2","valueArr","isAscending","getSortedIndices","sizeExtent","getLinePoints","offY","labelLayout$1","ParallelAxis","sliderMove","handleEnds","handleIndex","minSpan","maxSpan","restrict$1","extentSpan","originalDistSign","getSpanSign","extentMinSpan","realExtent","currDistSign","each$14","mathMin$5","mathMax$5","mathFloor$2","mathCeil$2","round$2","PI$3","Parallel","parallelModel","_axesLayout","_init","restrict","parallelAxisIndex","_updateAxesFromSeries","_makeLayoutInfo","axisBase","layoutBase","pixelDimIndex","pAxis","pLayout","axisLength","layoutLength","_layoutAxes","winSize","layoutExtent","axisCount","axisExpandWidth","axisExpandCount","axisExpandable","axisExpandWindow","axisCollapseWidth","winInnerIndices","axisExpandWindow0Pos","positionTable","horizontal","vertical","rotationTable","axisCoordToPoint","eachActiveState","hasActiveSet","hasAxisBrushed","activeState","lenj","getActiveState","getAxisLayout","getSlidedAxisExpandWindow","behavior","pointCoord","triggerArea","useJump","AxisModel$2","activeIntervals","getAreaSelectStyle","setActiveIntervals","intervals","areaSelectStyle","realtime","axisExpandCenter","axisExpandRate","axisExpandDebounce","axisExpandSlideTriggerArea","axisExpandTriggerOn","_initDimensions","parallelIndex","setAxisExpand","parallelAxis","parallelAxisModel","curry$2","each$15","map$3","mathMin$6","mathMax$6","mathPow$2","COVER_Z","UNSELECT_THRESHOLD","MIN_RESIZE_LINE_WIDTH","MUTEX_RESOURCE_KEY","DIRECTION_MAP","CURSOR_MAP","ne","sw","nw","se","DEFAULT_BRUSH_OPT","brushStyle","transformable","brushMode","removeOnClick","baseUID","BrushController","_brushType","_brushOption","_panels","_covers","_creatingCover","_creatingPanel","_enableGlobalPan","_mounted","_uid","mouseHandlers","createCover","brushOption","cover","coverRenderers","brushType","__brushOption","updateZ$1","endCreating","creatingCover","coverRenderer","getCoverRenderer","updateCoverShape","updateCoverAfterCreation","updateCommon","getPanelByPoint","localCursorPoint","panel","panels","pn","isTargetByCursor","getPanelByCover","panelId","clearCovers","covers","originalLength","areas","isEnd","getTrackEnds","createBaseRectCover","doDrift","edgeNames","makeStyle","ondragend","updateBaseRect","localRange","handleSize","xa","ya","x2a","y2a","widtha","heighta","updateRectShape","mainEl","globalDir","getGlobalDirection","localDirection","getTransform$1","xmin","ymin","xmax","ymax","clipByPanel","formatRectRange","driftRect","toRectRange","fromRectRange","rectRange","localDelta","toLocalDelta","namePart","ind","driftPolygon","localD","localZero","rawE","mainShapeContain","updateCoverByMouse","eventParams","thisBrushOption","shouldShowCover","determineBrushType","getCreatingRange","defaultBrushType","enableBrush","userKey","release","take","doEnableBrush","setPanels","panelOpts","mount","enableGlobalPan","eachCover","updateCovers","brushOptionList","tmpIdPrefix","oldCovers","newCovers","addOrUpdate","newBrushOption","unmount","handleDragEnd","currPanel","resetCursor","lineX","getLineRenderer","lineY","localTrack","ends","xyIndex","otherExtent","getLinearBrushOtherExtent","makeRectPanelClipPath","normalizeRect","localPoints","makeLinearBrushOtherExtent","specifiedXYIndex","brushWidth","makeRectIsTargetByCursor","targetModel","elementList","AxisView$2","_brushController","_onBrush","fromAxisAreaSelect","areaWidth","builderOpt","_refreshBrushController","getCoverInfoList","extentLen","coverInfoList","coverInfo","parallelAxisId","handlers","_throttledDispatchExpand","_dispatchExpand","checkTrigger","_mouseDownPoint","mouseDownPoint","triggerOn","convertDimNameToNumber","hasParallelSeries","createParallelIfNeeded","axisOption","parallelOption","mergeAxisOptionFromParallel","parallelAxisIndices","rawData","modelDims","dataDimsInfo","maxDimNum","numberDim","firstItem","generateDataDims","modelDimsIndex","axisData","translateCategoryValue","getRawIndicesByActiveState","theActiveState","inactiveOpacity","activeOpacity","_dataGroup","_renderForNormal","dataGroup","newDataIndex","createLinePoints","addEl","oldDataIndex","seriesStyleModel","updateElCommon","rectEl","createGridClipShape$1","opacityAccessPath$1","globalColors","opacityMap","active","inactive","itemOpacity","SankeySeries","rawDataOpt","nodeWidth","nodeGap","layoutIterations","SankeyShape","halfExtent","nest","keysFunction","sortKeysFunction","sortKeys","entries","entriesMap","mapObject","sortKeyFunction","keyFunction","valuesByKey","keyValue","curve","n1Layout","n2Layout","edgeLayout","createGridClipShape$2","resolveCollisions","nodesByBreadth","ascendingDepth","nodeY","relaxRightToLeft","weightedTarget","getEdgeValue","center$1","relaxLeftToRight","weightedSource","ascendingTargetDepth","ascendingSourceDepth","ascending","getViewRect$3","computeNodeValues","iterations","remainNodes","nextNode","moveSinksRight","scaleNodeBreadths","computeNodeBreadths","kyArray","ky0","nodeDy","edgeDy","initializeNodeDepth","computeNodeDepths","computeEdgeDepths","layoutSankey","minValue","mapValueToColor","customColor","WhiskerPath","WhiskerBox","styleUpdater","bodyIndex","whiskerIndex","_createContent","whiskerBoxProto","transInit","initBaseline","makeWhiskerEndsShape","whiskerEnds","WhiskerBoxDraw","constDim","chartLayout","bodyEnds","whiskerBoxDrawProto","seriesModelMixin","_baseAxisDim","addOrdinal","baseAxisDimIndex","baseAxisDim","defaultValueDimensions","viewMixin","whiskerBoxDraw","_whiskerBoxDraw","getStyleUpdater","boxWidth","updateStyle$1","normalStyleAccessPath$1","emphasisStyleAccessPath$1","normalItemStyleModel","whiskerEl","bodyEl","borderColorQuery","each$16","defaulColor","groupResult","axisList","groupSeriesByAxis","groupItem","seriesCount","boxWidthList","boxOffsetList","boundList","maxDataCount","boxWidthBound","availableWidth","boxGap","calculateBase","cDim","halfWidth","variableDim","vDims","axisDimVal","median","getPoint","end1","end5","layEndLine","addBodyEnd","point1","point2","endCenter","layoutSingleSeries","color0","borderColor0","barMinWidth","animationUpdate","getShadowDim","selectors","brushRect","updateStyle$2","normalStyleAccessPath$2","emphasisStyleAccessPath$2","positiveBorderColorQuery","negativeBorderColorQuery","positiveColorQuery","negativeColorQuery","retrieve2$1","seriesItem","candleWidth","calculateCandleWidth","pmin","pmax","openVal","closeVal","lowestVal","highestVal","ocLow","ocHigh","ocLowPoint","ocHighPoint","lowestPoint","subPixelOptimizePoint","effectType","showEffectOn","rippleEffect","period","updateRipplePath","rippleGroup","effectCfg","ripplePath","EffectSymbol","effectSymbolProto","preprocessOption","fromName","toName","stopEffectAnimation","startEffectAnimation","effectOffset","rippleScale","updateEffectAnimation","oldEffectCfg","_effectCfg","DIFFICULT_PROPS","normalizeSymbolSize$1","effectSymbolDraw","LinesSeries","effect","constantSpeed","trailLength","EffectLine","_updateEffectSymbol","effectLineProto","Polyline$2","_createPolyline","effectModel","_updateEffectAnimation","delayExpr","isDelayFunc","updateAnimationPoints","getLineLength","_period","__t","updateSymbolPosition","__p1","__cp1","__p2","quadraticDerivativeAt$$1","polylineProto","EffectPolyline","_lastFrame","_lastFramePercent","effectPolylineProto","accLenArr","_offsets","_length","offsets","LargeLineShape","isPolyline","seg","LargeLineDraw","_lineEl","largeLineProto","lineEl","hasEffect","isLarge","_hasEffet","_isPolyline","_isLarge","isSvg","_lastZlevel","notInIndividual","otherSeriesModel","normalize$2","JSON","blurSize","pointSize","maxOpacity","minOpacity","Heatmap","_gradientPixels","colorFunc","isInRange","_getBrush","gradientInRange","_getGradient","gradientOutOfRange","imageData","getImageData","pixels","pixelLen","diffOpacity","gradientOffset","putImageData","brushCanvas","_brushCanvas","gradientPixels","pixelsSingleState","Uint8ClampedArray","visualMapOfThisSeries","eachTargetSeries","targetSeries","_renderOnCartesianAndCalendar","isGeoCoordSys","_renderOnGeo","dataToRect","contentShape","visualMapModel","inRangeVisuals","targetVisuals","inRange","outOfRangeVisuals","outOfRange","hmLayer","_hmLayer","lng","lat","dataSpan","getIsInContinuousRange","getIsInPiecewiseRange","getPieceList","PictorialBarSeries","symbolPosition","symbolMargin","symbolRepeat","symbolRepeatDirection","symbolClip","symbolBoundingData","symbolPatternSize","BAR_BORDER_WIDTH_QUERY$1","LAYOUT_ATTRS","posDesc","pathForLineWidth","coordSysRect","ecSize","coordSysExtent","symbolMeta","getSymbolMeta","bar","createBar","updateCommon$1","pictorialShapeStr","getShapeStr","__pictorialShapeStr","__pictorialBundle","bundlePosition","createOrUpdateRepeatSymbols","createOrUpdateSingleSymbol","createOrUpdateBarRect","createOrUpdateClip","updateBar","__pictorialSymbolMeta","removeBar","boundingLength","zeroPx","pxSignIdx","symbolBoundingExtent","convertToCoordOnAxis","repeatCutLength","pxSign","prepareBarLength","categorySize","symbolScale","prepareSymbolSize","valueLineWidth","prepareLineWidth","unitLength","pathLen","absBoundingLength","hasEndGap","uLenWithMargin","endFix","repeatSpecified","repeatTimes","toIntTimes","mDiff","sizeFix","pathPosition","barRectShape","clipShape","prepareLayoutInfo","createPath","bundle","eachPath","__pictorialAnimationIndex","__pictorialRepeatTimes","updateAttr","makeTarget","updateHoverAnimation","onMouseOver","onMouseOut","mainPath","__pictorialMainPath","barRect","__pictorialBarRect","__pictorialClipPath","pathes","immediateAttrs","animationAttrs","barRectHoverStyle","times","roundedTimes","SingleAxis","Single","_axis","layout$1","positionMap","_adjustAxis","_updateAxisTransform","extentSum","singles","getInterval$2","ifIgnoreOnTick$2","axisBuilderAttrs$2","SingleAxisView","selfBuilderAttr","AxisModel$4","findPointFromSeries","each$17","curry$3","get$2","processOnAxis","newValue","updaters","dontSnap","outputFinder","payloadInfo","snapToValue","payloadBatch","seriesNestestValue","dataIndices","nestestValue","buildPayloadsBySeries","showPointer","showTooltip","showValueMap","dataByCoordSys","coordSysItem","coordSysId","coordSysIndex","coordSysMainType","dataByAxis","axisId","valueLabelOpt","seriesDataIndices","makeMapperParam","illegalPoint","shadowStyle","handle","icon","get$3","each$18","records","initialized","useHandler","dis","pendings","showTip","hideTip","makeDispatchAction","record","actuallyPayload","showLen","hideLen","dispatchTooltipFinally","doEnter","onLeave","initGlobalListeners","currTrigger","unregister","AxisPointerView","get$4","clone$3","bind$2","BaseAxisPointer","updateProps$1","moveAnimation","propsEqual","lastProps","newProps","equals","lastProp","updateLabelShowHide","labelEl","getHandleTransProps","trans","updateMandatoryProps","buildElStyle","axisPointerType","styleModel","buildLabelElOption","elOption","labelPos","getValueLabel","paddings","align","confineInContainer","bgColor","seriesData","idxItem","dataParams","getTransformedPosition","buildCartesianSingleLabelElOption","textLayout","makeLineShape","xDimIndex","makeRectShape","makeSectorShape","_group","_lastGraphicKey","_handle","_lastValue","_lastStatus","_payloadInfo","_axisModel","_axisPointerModel","makeElOption","graphicKey","_moveAnimation","determineAnimation","doUpdateProps","updatePointerEl","updateLabelEl","createPointerEl","createLabelEl","_renderHandle","isCategoryAxis","useSnap","pointerOption","pointerEl","updateProps$$1","updateHandleTransform","handleModel","onmousemove","onmousedown","_onHandleDragMove","_onHandleDragEnd","_moveHandleToValue","getHandleTransform","_doDispatchAxisPointer","cursorPoint","tooltipOption","doClear","buildLabel","CartesianAxisPointer","pixelValue","pointerShapeBuilder","currPosition","cursorOtherValue","getAxisDimIndex","shadow","isIllegalPoint","inputAxesInfo","shouldHide","coordSysContainsPoint","inputAxisInfo","findInputAxisInfo","linkTriggers","tarAxisInfo","tarKey","srcAxisInfo","srcKey","srcValItem","outputAxesInfo","valItem","updateModelActually","dispatchTooltipActually","lastHighlights","newHighlights","toHighlight","toDownplay","dispatchHighDownActually","XY","WH","SingleAxisPointer","getPointDimIndex","pointerShapeBuilder$1","ThemeRiverSeries","fixData","rawDataLength","layData","dataList","layerNum","largestLayer","timeValue","keyIndex","filterData","getLayerSeries","lenCount","indexArr","layerSeries","comparer","index1","index2","nearestIdx","pointNum","theValue","htmlName","htmlValue","singleAxisIndex","keyGetter","newLayersGroups","oldLayersGroups","points0","layerGroup","createGridClipShape$3","_layersSeries","themeRiverLayout$1","baseY0","layerPoints","singleLayer","sums","temp","computeBaseline","baseLine","layerIndex","dataToCoordSize","dataSize","halfSize","dataToCoordSize$1","dataToCoordSize$2","dataToCoordSize$3","ITEM_STYLE_NORMAL_PATH","ITEM_STYLE_EMPHASIS_PATH","LABEL_NORMAL","LABEL_EMPHASIS","GROUP_DIFF_PREFIX","prepareCustoms","radiusAxis","dataToRadius","dataToAngle","rangeInfo","getRangeInfo","cellWidth","getCellWidth","cellHeight","getCellHeight","weeks","dayCount","allDay","prepareStyleTransition","targetStyle","elOptionStyle","oldElStyle","createOrUpdate$1","doCreateOrUpdate","elOptionType","__customGraphicType","__customPathData","__customImagePath","__customText","graphicType","Clz","createEl","targetProps","targetOpacity","styleEmphasis","updateEl","oldChildren","newChildren","diffChildrenByName","processAddUpdate","processRemove","childOption","customSeries","renderItem","prepareResult","currDataIndexInside","currItemModel","currLabelNormalModel","currLabelEmphasisModel","currLabelValueDim","currVisualColor","userAPI","updateCache","barLayout","currentSeriesIndices","userParams","dataInsideLength","dataDimIndex","wrapEncodeDef","currDirty","makeRenderItem","graphicOption","elements","GraphicModel","parentId","_elOptionsToUpdate","existList","flattenedList","_flatten","mappingResult","elOptionsToUpdate","newElOption","existElOption","newElParentOption","parentOption","setKeyInfoToNewElOption","newElOptCopy","$action","newType","mergeNewElOptionToExist","existItem","isSetLoc","setLayoutInfoToExist","optionList","useElOptionsToUpdate","createEl$1","targetElParent","__ecGraphicId","removeEl","existEl","existElParent","isSet","_elMap","_lastGraphicModel","graphicModel","_clear","_updateElements","_relocate","rootGroup","elOptionCleaned","getCleanedElOption","__ecGraphicWidth","__ecGraphicHeight","elOptions","parentEl","bounding","LegendModel","_updateData","legendData","hasSelected","availableNames","_availableNames","borderRadius","itemGap","inactiveColor","legendSelectActionHandler","selectedMap","isToggleSelect","legendModel","isItemSelected","makeBackground","curry$4","each$19","Group$3","LegendView","newlineDisabled","_contentGroup","_backgroundEl","getContentGroup","resetInner","itemAlign","renderInner","viewportSize","mainRect","layoutInner","layoutRect","contentGroup","legendDrawnMap","selectMode","legendSymbolType","_createItem","dispatchSelectAction","dispatchHighlightAction","dispatchDownplayAction","itemIcon","tooltipModel","legendGlobalTooltipModel","hitRect","legendIndex","__legendDataIndex","contentRect","ScrollableLegendModel","setScrollDataIndex","scrollDataIndex","pageButtonItemGap","pageButtonGap","pageButtonPosition","pageFormatter","pageIcons","pageIconColor","pageIconInactiveColor","pageIconSize","pageTextStyle","mergeAndNormalizeLayoutParams","getOrient","raw","Group$4","WH$1","XY$1","ScrollableLegendView","_currentIndex","_controllerGroup","_showController","__rectSize","me","controllerGroup","createPageButton","pageTextStyleModel","iconIdx","pageDataIndexName","_pageGo","orientIdx","hw","yx","controllerRect","showController","contentPos","containerPos","controllerPos","pageInfo","_getPageInfo","pageIndex","contentPosition","_updatePageInfoView","to","legendId","canJump","pageText","pageCount","pagePrevDataIndex","pageNextDataIndex","targetItemGroup","currDataIndex","containerRectSize","itemRect","itemLoc","startIdx","winRect","getItemRect","startRect","showContent","alwaysShowContent","displayMode","confine","showDelay","hideDelay","transitionDuration","enterable","each$21","toCamelCase$1","vendors","assembleCssText","transitionText","vendorPrefix","borderName","camelCase","assembleFont","TooltipContent","_container","_show","_hideTimeout","onmouseenter","_enterable","_inContent","onmouseleave","hideLater","_hideDelay","currentStyle","setContent","setEnterable","getSize","clientWidth","clientHeight","viewportRootOffset","bind$3","each$20","parsePercent$2","proxyRect","buildTooltipModel","modelCascade","resultModel","makeDispatchAction$1","getOuterSize","paddingLeft","paddingRight","borderLeftWidth","borderRightWidth","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","isCenterAlign","getSeriesStackId$1","getAxisKey$1","RadiusAxis","AngleAxis","tooltipContent","_tooltipContent","_tooltipModel","_ecModel","_lastDataByCoordSys","_alwaysShowContent","_initGlobalListener","_keepShow","_tryShow","_hide","_refreshUpdateTimeout","manuallyShowTip","_ticket","_manuallyAxisShowTip","pointInfo","manuallyHideTip","_showAxisTooltip","_showSeriesItemTooltip","_showComponentItemTooltip","_showOrMove","_showTimout","singleDefaultHTML","singleParamsList","singleTooltipModel","itemCoordSys","axisValue","seriesDefaultHTML","valueLabel","axisValueLabel","firstLine","positionExpr","_updateContentNotChangedOnAxis","_updatePosition","_showTooltipContent","tooltipTrigger","defaultHtml","asyncTicket","subTooltipModel","cbTicket","contentSize","vAlign","domWidth","domHeight","rectWidth","rectHeight","calcTooltipPosition","gapH","gapV","refixTooltipPosition","confineTooltipPosition","lastCoordSys","contentNotChanged","lastItemCoordSys","indexCoordSys","lastDataByAxis","thisDataByAxis","lastItem","indexAxis","lastIndices","lastIdxItem","newIdxItem","radiusToData","angleToData","Polar","_radiusAxis","_angleAxis","pointToCoord","maxAngle","PolarAxisModel","polarId","polarAxisDefaultExtendedOption","getAxisType$3","updatePolarScale","setAxis","foundAxisModel","polarCreator","polarList","resizePolar","elementList$1","getAxisLineShape","rExtent","getRadiusIdx","ticksAngles","_axisLine","_axisTick","tickAngle","_axisLabel","labelsAngles","labelTextAlign","labelTextVerticalAlign","prevAngle","axisBuilderAttrs$3","selfBuilderAttrs$1","axisAngle","layoutAxis","prevRadius","PolarAxisPointer","coordValue","pointerShapeBuilder$2","getLabelPosition","makeAction","barSeries","calRadialBar","valueMax","valueMin","stackCoord","_optionModelMap","optionModelMap","regionOpt","DEFAULT_TOOLBOX_BTNS","each$22","hasKeys","createVisualMappings","stateList","supplementVisualOption","visualMappings","Creater","mappings","__hidden","visualData","mappingOption","__alphaForOpacity","replaceVisualOption","keys","getValueState","visualTypesMap","eachItem","valueOrIndex","rawDataItem","valueState","selector","getLineSelectors","lineIntersectPolygon","inLineRange","layoutRange","lx","ly","l2x","l2y","lineIntersect","a1x","a1y","a2x","a2y","b1x","b1y","b2x","b2y","determinant","namenda","miu","v4","each$23","indexOf$2","curry$5","COORD_CONVERTS","INCLUDE_FINDER_MAIN_TYPES","BrushTargetManager","targetInfoList","_targetInfoList","foundCpts","parseFinder$1","targetInfoBuilders","builder","include","formatMinMax","minMax","setOutputRanges","matchOutputRanges","coordRange","coordRanges","coordConvert","__rangeOffset","diffProcessor","xyMinMax","findTargetInfo","coordSyses","setInputRanges","xyMinMaxCurr","xyMinMaxOrigin","sizeCurr","sizeOrigin","scales","rangeOffset","makePanelOpts","getDefaultBrushType","getPanelRect","controlSeries","areaPanelId","targetInfoMatchers","xAxisModels","yAxisModels","gridModels","gridModelMap","xAxesHas","yAxesHas","cartesians","panelRectBuilder","xAxisDeclared","yAxisDeclared","geoModels","axisConvert","rangeOrCoordRange","xminymin","xmaxymax","axisNameIndex","axisDiffProcessor","refer","STATE_LIST","DISPATCH_METHOD","DISPATCH_FLAG","PRIORITY_BRUSH","doDispatch","brushSelected","checkInRange","selectorsByBrushType","rangeInfoList","getSelectorsByBrushType","sels","selectorsByElementType","bSelector","sel","brushModel","setBrushOption","brushTargetManager","throttleDelay","brushIndex","thisBrushSelected","brushId","brushName","brushLink","linkedSeriesMap","selectedDataIndexForLink","rangeInfoBySeries","hasBrushExists","selFn","elType","bindSelector","boundingRectBuilders","linkOthers","brushed","stepAParallel","seriesIndices","brushModelNotControll","stepAOthers","seriesBrushSelected","getBoundingRectFromMinMax","rg","DEFAULT_OUT_OF_BRUSH_COLOR","toolbox","coordInfoList","inBrush","outOfBrush","setAreas","generateBrushOption","updateController","$from","modelId","register$1","get$5","lang","dataView","dataZoom","back","magicType","tiled","saveAsImage","brushLang","Brush","_brushMode","proto$1","featureModel","isBrushed","setIconStatus","getIcons","availableIcons","icons","command","brushComponents","brushComponentSpecifiedBtns","brushOpt","tbs","feature","toolboxFeature","toolboxBrush","brushTypes","flag","Calendar","calendarModel","doConvert$2","_rangeInfo","_sw","_sh","_orient","getFirstDayOfWeek","_firstDayOfWeek","getDateInfo","day","getDay","formatedDate","getNextNDay","setDate","_lineWidth","_getRangeInfo","_initRangeOption","whNames","cellSize","layoutParams","cellNumbers","cellSizeSpecified","whGlobal","calendarRect","dayInfo","week","nthWeek","pointToDate","tl","tr","br","bl","nthX","nthY","_getDateByWeeksAndDay","firstDay","setMonth","reversed","startDateNum","endDateNum","fweek","lweek","nthDay","calendarList","calendarSeries","CalendarModel","dayLabel","monthLabel","yearLabel","mergeAndNormalizeLayoutParams$1","sizeCalculable","MONTH_TEXT","EN","CN","WEEK_TEXT","_tlpoints","_blpoints","_firstDayOfMonth","_firstDayPoints","rangeData","_renderDayRect","_renderLines","_renderYearText","_renderMonthText","_renderWeekText","itemRectStyleModel","sh","addPoints","_getLinePointsOfOneWeek","_drawSplitline","_getEdgesPoints","rs","poyline","tmpD","_formatterLabel","_yearTextPositionControl","aligns","xc","yc","posPoints","yearText","_monthTextPositionControl","isCenter","termPoints","firstDayPoints","yyyy","yy","MM","monthText","_weekTextPositionControl","isStart","firstDayOfWeek","weekText","subtext","subtarget","subtextStyle","subtextStyleModel","subText","subTextEl","sublink","groupRect","layoutOption","alignStyle","COORDS","attrs","capitalNames","capitalAttrs","eachAxisDim$1","nameObj","capital","createLinkedNodesFinder","forEachNode","forEachEdgeType","edgeIdGetter","sourceNode","existsLink","absorb","processSingleNode","isNodeAbsorded","hasLink","edgeId","isLinked","each$25","asc$1","AxisProxy","dataZoomModel","_dimName","_axisIndex","_valueWindow","_percentWindow","_dataExtent","_minMaxSpan","_dataZoomModel","setAxisModel","axisProxy","isRestore","getAxisModel","percentWindow","valueWindow","useOrigin","hostedBy","getDataValueWindow","getDataPercentWindow","getTargetSeriesModels","coordType","getOtherAxisModel","coordSysIndexName","foundOtherAxisModel","otherAxisModel","getMinMaxSpan","calculateDataWindow","rangePropMode","getRangePropMode","percentExtent","boundValue","boundPercent","reset","seriesExtent","fixExtentByAxis","calculateDataExtent","dataWindow","minMaxSpan","valueSpan","setMinMaxSpan","filterMode","leftOut","rightOut","thisHasValue","thisLeftOut","thisRightOut","isInWindow","each$24","eachAxisDim","DataZoomModel","startValue","endValue","minValueSpan","maxValueSpan","rangeMode","_dataIntervalByAxis","_dataInfo","_axisProxies","_autoThrottle","_rangePropMode","retrieveRaw","doInit","_setDefaultThrottle","updateRangeUse","_resetTarget","_giveAxisProxies","axisProxies","eachTargetAxis","dimNames","__dzAxisProxy","autoMode","_judgeAutoMode","axisIndexName","_autoSetAxisIndex","_autoSetOrient","hasIndexSpecified","autoAxisIndex","axisIndices","axisModels","_isSeriesHasAllAxesTypeOf","is","seriesAxisIndex","globalOption","getFirstTargetAxisModel","firstAxisModel","getAxisProxy","setRawRange","ignoreUpdateRangeUsg","getPercentRange","findRepresentativeAxisProxy","getValueRange","axisDimName","rangeModeInOption","percentSpecified","valueSpecified","DataZoomView","getTargetCoordInfo","coordSysLists","coordModel","coordIndex","Rect$2","dataBackground","fillerColor","handleIcon","handleStyle","labelPrecision","showDetail","showDataShadow","zoomLock","linearMap$2","asc$2","bind$4","each$26","HORIZONTAL","LABEL_GAP","SHOW_DATA_SHADOW_SERIES_TYPE","SliderZoomView","_displayables","_range","_handleEnds","_size","_handleWidth","_handleHeight","_location","_dataShadowInfo","_buildView","_updateView","_resetLocation","_resetInterval","barGroup","_renderBackground","_renderDataShadow","_positionGroup","coordRect","_findCoordRect","location","targetAxisModel","otherAxisInverse","_getViewExtent","_onClickPanelClick","_prepareDataShadowInfo","otherDataExtent","otherOffset","lastIsEmpty","otherShadowExtent","thisShadowExtent","areaPoints","thisCoord","stride","otherCoord","thisAxis","thisDim","displaybles","handles","handleLabels","filler","getCursor","_onDragMove","ondragstart","_showDataInfo","_onDragEnd","onmouseover","onmouseout","bRect","handleColor","viewExtent","_updateInterval","viewExtend","nonRealtime","handleInterval","handleHeight","_updateDataInfo","labelTexts","dataInterval","_formatLabel","orderedHandleEnds","barTransform","textPoint","valueStr","showOrHide","_dispatchZoomAction","localPoint","dataZoomId","disabled","curry$6","ATTR$1","register$2","dataZoomInfo","giveStore","theDataZoomId","theCoordId","coordId","dataZoomInfos","allCoordIds","cleanStore","newRecord","onPan","onZoom","createController","dispatchAction$1","typePriority","controllerParams","true","move","false","oneType","roamControllerOpt","containsPoint","throttleRate","generateCoordId","newX","newY","wrapAndDispatch","panGetRange","zoomGetRange","getRange","bind$5","InsideZoomView","shouldRecordRange","coordInfo","dataZoomOption","directionInfo","getDirectionInfo","percentDelta","signal","pixel","pixelLength","percentPoint","pixelStart","oldPoint","newPoint","resetSingleAxis","filterSingleAxis","percentRange","valueRange","linkedNodesFinder","effectedModels","each$27","preprocessor$2","has$1","pieces","splitList","getColorVisual","resultVisual","calculable","getDataDimension","processSingleVisualMap","isTargetSeries","getVisualMeta","prepareVisualMeta","visualDefault","defaultOption$3","mapVisual$2","isArray$3","each$28","asc$3","linearMap$3","DEFAULT_COLOR","VisualMapModel","replacableOptionKeys","dataBound","contentColor","textGap","controllerVisuals","itemSize","resetItemSize","completeVisualOption","resetVisual","getTargetSeriesIndices","optionSeriesIndex","formatValueText","edgeSymbols","isMinMax","textValue","resetExtent","optDim","completeSingle","defa","stateExist","stateAbsent","optExist","optAbsent","symbolExists","symbolSizeExists","setSelected","DEFAULT_BAR_BOUND","ContinuousModel","hoverLink","hoverLinkDataSize","hoverLinkOnHandle","_resetRange","auto","getSelected","findTargetDataIndices","oVals","getColorStopValues","iVals","setStop","iIdx","oIdx","iLen","oLen","first","stopsLen","stopValues","VisualMapView","autoPositionValues","doRender","getControllerVisual","targetValue","visualCluster","forceState","visualObj","visualMapping","convertOpacityToAlpha","positionGroup","getItemAlign","modelOption","realIndex","paramsSet","reals","fakeValue","layoutInput","rParam","convertDataIndex","linearMap$4","each$29","mathMin$7","mathMax$7","HOVER_LINK_SIZE","HOVER_LINK_OUT","ContinuousView","_shapes","_dataInterval","_useHandle","_hoverLinkDataIndices","_hovering","_renderBar","dataRangeText","_renderEndsText","_enableHoverLinkToSeries","_enableHoverLinkFromSeries","endsIndex","_applyTransform","targetGroup","shapes","_createBarGroup","createPolygon","getCursor$1","_dragHandle","textSize","handleThumbs","handleLabelPoints","_createHandle","_createIndicator","onDrift","onDragEnd","handleThumb","createHandlePoints","handleLabel","handleLabelPoint","indicatorLabel","indicatorLabelPoint","visualMapId","_clearHoverLinkToSeries","useHoverLinkOnHandle","_doHoverLinkToSeries","forSketch","outOfRangeHandleEnds","inRangeHandleEnds","visualInRange","_createBarVisual","visualOutOfRange","barColor","barPoints","_updateHandle","_makeColorGradient","symbolSizes","_createBarPoints","handlesColor","currValue","_showIndicator","cursorValue","rangeSymbol","halfHoverLinkSize","isRange","extentMax","createIndicatorPoints","_hoverLinkFromSeriesMouseOver","_hideIndicator","_clearHoverLinkFromSeries","cursorPos","hoverOnBar","getHalfHoverLinkSize","hoverRange","oldBatch","newBatch","resultBatches","batchA","batchB","mapA","mapB","makeMap","mapToArray","sourceBatch","otherMap","otherDataIndices","isData","compressBatches","_dispatchHighDown","PiecewiseModel","minOpen","maxOpen","itemSymbol","_pieceList","mode","_mode","_determineMode","resetMethods","_resetSelected","visualTypesInPieces","getSelectedMapKey","hasSel","getRepresentValue","representValue","pieceInterval","splitStep","normalizeReverse","pieceListItem","closeList","infinityList","useMinMax","_getItemAlign","viewData","_getViewData","endsText","viewPieceList","_onItemClick","_enableHoverLink","indexInModelPieceList","_createItemSymbol","visualState","onHoverLink","shapeParam","newKey","addCommas$1","encodeHTML$1","fillLabel","MarkerModel","createdBySelf","hostSeries","__hostSeries","newOpt","modelPropName","markerOpt","markerModel","indexOf$3","markerTypeCalculatorWithExtent","mlType","otherDataDim","targetDataDim","otherCoordIndex","targetCoordIndex","coordArr","numCalculate","valueAxisDim","getPrecision$1","curry$7","markerTypeCalculator","dataTransform","hasXAndY","getAxisInfo$1","baseDataDim","valueDataDim","valueIndex","dataFilter$1","hasXOrY","MarkerView","markerGroupMap","__keep","markerModelKey","renderSeries","updateMarkerLayout","xPx","yPx","markPointModel","mpModel","symbolDrawMap","coordDimsInfos","createList$1","markLineTransform","mlModel","mlFrom","mlTo","isInifinity","ifMarkLineHasOnlyDim","fromCoord","toCoord","otherDimIndex","markLineFilter","updateSingleMarkerEndLayout","isFrom","markLineModel","fromData","toData","__to","lineDrawMap","optData","dimValueGetter$$1","createList$2","updateDataVisualAndLayout","lineColor","fromSymbolSize","toSymbolSize","markAreaTransform","maModel","retrieve$$1","ltCoord","rbCoord","isInifinity$1","ifMarkLineHasOnlyDim$1","markAreaFilter","getSingleMarkerEndPoint","dimPermutations","markAreaModel","areaData","areaGroupMap","polygonGroup","createList$3","__data","transferItem","itemStyleEmphasis","labelNormal","excludeLabelAttr","has$2","currentIndex","setCurrentIndex","isIndexMax","setPlayState","playState","TimelineModel","controlPosition","autoPlay","rewind","playInterval","_names","_initData","getPlayState","dataArr","idxArr","newItem","checkpointStyle","controlStyle","showPlayBtn","showPrevBtn","showNextBtn","playIcon","stopIcon","nextIcon","prevIcon","TimelineView","TimelineAxis","_autoLabelInterval","bind$6","each$30","PI$4","giveSymbol","onUpdate","onCreate","pointerMoveTo","noAnimation","_timer","_currentPointer","_labelGroup","mainGroup","_createGroup","labelGroup","_createAxis","_renderAxisLabel","_position","_doPlayStop","_clearTimer","labelPosOpt","getViewRect$4","playPosition","prevBtnPosition","nextBtnPosition","labelAlignMap","labelBaselineMap","rotationMap","mainLength","controlModel","controlSize","showControl","controlGap","sizePlusGap","labelAlign","labelBaseline","rotateOriginX","rotateOriginY","viewBound","getBound","mainBound","labelBound","mainPosition","labelsPosition","mainBoundIdx","toBound","setOrigin","boundIdx","_customizeScale","newGroup","_renderAxisLine","_renderAxisTick","hoverStyleModel","symbolOpt","_changeTimeline","_renderControl","makeBtn","iconPath","willRotate","btn","objPath","makeIcon","_handlePlayClick","_renderCurrentPointer","_handlePointerDrag","_handlePointerDragend","nextState","_pointerChangeTimeline","mousePos","_toAxisCoord","targetDataIndex","_findNearestTick","axisCoord","nextIndex","ec2Types","compatibleEC2","ToolboxModel","featureOpt","featureName","Feature","showTitle","iconStyle","toolboxModel","featureOpts","_features","featureNames","_featureNames","processFeature","boxLayoutParams","layout$2","titleText","__title","needPutOnTop","topOffset","oldName","isUserFeatureName","unusable","iconStyleModel","titles","iconPaths","iconName","createIconPaths","iconStatus","saveAsImageLang","SaveAsImage","$a","download","href","MouseEvent","msSaveOrOpenBlob","bstr","atob","u8arr","Uint8Array","blob","Blob","lang$$1","write","evt","bubbles","cancelable","dispatchEvent","magicTypeLang","MagicType","proto$3","seriesOptGenreator","radioTypes","radio","newSeriesOpt","currentType","dataViewLang","BLOCK_SPLITER","ITEM_SPLITER","getContentFromModel","tables","seriesGroupByCategoryAxis","otherSeries","meta","groupSeries","headers","columns","items","vals","assembleOtherSeries","trim","itemSplitRegex","parseContents","blockMetaList","isTSVFormat","tsv","tsvLines","header","parseTSVContents","blockMeta","hasName","parseListContents","DataView","readOnly","optionToContent","contentToOption","textareaColor","textareaBorderColor","buttonColor","buttonTextColor","viewMain","textarea","htmlOrDom","buttonContainer","buttonStyle","closeButton","refreshButton","keyCode","selectionStart","selectionEnd","newSeriesOptList","tryMergeDataOption","each$32","ATTR$2","giveStore$1","dataZoomLang","each$31","DATA_ZOOM_ID_BASE","DataZoom","_isZoomActive","proto$4","zoomActive","dataZoomSelectActive","retrieveAxisSetting","updateZoomBtnStatus","updateBackBtnStatus","handlers$1","nextActive","snapshot","setBatch","newSnapshot","found","dzModel","findDataZoom","dataZoomOpts","toolboxOpt","dataZoomOpt","addForAxis","axisIndicesName","givenAxisIndices","forEachComponent","$fromToolbox","restoreLang","Restore","clear$1","doCreateNode","urn","win","vmlInited","doc","createNode","tagName","namespaces","zrvml","CMD$3","round$3","abs$1","mathMax$8","Z2","initRootElStyle","coordsize","coordorigin","rgb2Str","append","getZIndex","parsePercent$3","setColorAndOpacity","updateFillAndStroke","vmlEl","zrEl","isFill","getElementsByTagName","gradientType","focus","expansion","cs1","cs2","length$$1","colorAndAlphaList","colorAndAlpha","color1","color2","opacity1","opacity2","focusposition","updateFillNode","dashstyle","updateStrokeNode","points$3","brushVML","vmlRoot","_vmlEl","needTransform","strokeEl","weight","cmdStr","dataLength","pathDataToString","zIndex","removeRectText","onRemove","onAdd","appendRectText","ow","oh","_imageSrc","_imageWidth","_imageHeight","imageRuntimeStyle","runtimeStyle","oldRuntimeWidth","oldRuntimeHeight","dw","dh","hasCrop","vmlElStyle","hasRotation","transformFilter","imageTransformPrefix","imageEl","_imageEl","cropEl","_cropEl","imageELStyle","tmpImage","overflow","cropElStyle","filterStr","textMeasureEl","fontStyleCache","fontStyleCacheCount","fontEl","$override$1","doc$$1","body","ex","createTextNode","offsetWidth","tmpRect$2","fromTextEl","fontString","variant","fontVariant","family","getFontStyle","textPathEl","skewEl","createNode$$1","textVmlEl","_textVmlEl","textpathok","textVmlElStyle","string","i$3","proto$6","parseInt10$1","VMLPainter","styleSheets","createStyleSheet","addRule","initVML","vmlViewport","_vmlRoot","_vmlViewport","_firstPaint","__alreadyNotVisible","_getWidth","_getHeight","vmlViewportStyle","svgURI","createElementNS","CMD$4","arrayJoin","NONE","mathRound","mathSin$3","mathCos$3","PI$5","PI2$6","EPSILON$4","round4","isAroundZero$1","svgEl","bindStyle","isText","pathHasFill","pathHasStroke","miterLimit","svgPath","__svgEl","pathStr","nData","dThetaPositive","isCircle","pathDataToString$1","svgTextDrawRectText","svgImage","HTMLImageElement","__imageSrc","setAttributeNS","attrXLink","svgText","tmpRect$3","textSvgEl","__textSvgEl","getVerticalAlignForSvg","newPos","nTextLines","textAnchor","__text","__textFont","tspanList","__tspanList","tspan","Diff","buildValues","componentPos","componentLen","oldPos","added","newLen","oldLen","editLength","maxEditLength","bestPath","extractCommon","execEditLength","diagonalPath","basePath","addPath","removePath","canAdd","canRemove","pushComponent","commonCount","tokenize","arrayDiff","Definable","svgRoot","tagNames","markLabel","_svgRoot","_tagNames","_markLabel","nextId","GradientManager","ClippathManager","parseInt10$2","checkParentAvailable","insertAfter","prevSibling","prepend","remove$1","getTextSvgElement","getSvgElement","getDefs","isForceCreating","defs","addDom","removeDom","getDoms","doms","tags","markAllUnused","that","markUsed","removeUnused","getSvgProxy","addWithoutUpdate","svgElement","updateDom","clipPathEl","svgProxy","cloneNode","_textDom","SVGPainter","gradientManager","clipPathManager","viewport","_viewport","_visibleList","visibleList","listLen","newVisibleList","prevSvgElement","textSvgElement","_getDefs","viewportStyle","outerHTML","unescape","existInstance","STATUS_KEY","updateConnectedChartsStatus","charts","otherCharts","otherChart","enableConnect","connect","getInstanceById","registerTheme","registerPostUpdate","postUpdateFunc","getCoordinateSystemDimensions","coordSysCreator","setCanvasCreator","registerMap","dataTool","util","env","factory","components_login","$createElement","_c","_self","before-enter","bEnter","enter","after-enter","aEnter","enter-cancelled","enterCanc","staticRenderFns","src_components_login","__webpack_require__","normalizeComponent","mounted","transition","watch","directives","inserted","ssrContext","userName","localStorage","created","selectortype_template_index_0_src_components","_vm","staticStyle","max-width","z-index","slot","_v","staticClass","update:selected","$event","tag","src_components","components_normalizeComponent","inpVal","goToReg","inpValue","setItem","$router","mint_ui_common","$refs","def","loginChild_log","rawName","expression","ref","required","maxlength","domProps","blur","keyup","_k","composing","alt","components_loginChild_log","log_normalizeComponent","reg","bgUrl","bg_content_default","_this","goIndex","loginChild_reg","_s","components_loginChild_reg","reg_normalizeComponent","swiper","lunboList","countHeight","myType","$el","swPic","swHeight","swWidth","$emit","getLunbo","axios","then","msg","listArray","common_swiper","indicator-position","diyType","components_common_swiper","swiper_normalizeComponent","home","fullscreenLoading","newsList","swHeights","$store","getters","showType","isLoading","swTall","cardUseList","card","orderNumber","openFullScreen","stringify_default","v-swiper","swHei","$root","setTypeFn","onSearch","onCancel","setTop","onRefresh","$toast","addObj","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","get_iterator_default","err","return","getNews","loading","$loading","lock","spinner","oldVal","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_ref","_ref2","slicedToArray_default","children_home","setType","show-action","search","cancel","$$v","text-align","class","components_children_home","home_normalizeComponent","makePic","activeName","payTitleData","payValData","payNumData","sellTitleData","sellValData","sellNumData","cusTitleData","cusValData","cusNumData","fundTitleData","fundValData","fundNumData","memberTitleData","memberValData","giveTitleData","giveValData","useTitleData","useValData","titleArray","colorStyle","optionPay","legend","optionSell","optionCus","optionFund","optionMember","optionGive","optionUse","echarts_default","echPay","echSell","echCus","echFund","echMember","echGiveIntegral","echUseIntegral","arrObj","oldValue","children_makePic","margin-bottom","accordion","background-color","components_children_makePic","makePic_normalizeComponent","children_echarts","minWidth","echartContent","components_children_echarts","src_components_children_echarts","echarts_normalizeComponent","richScan","qrcodeFn","qrcode_default","colorDark","colorLight","children_richScan","_m","components_children_richScan","richScan_normalizeComponent","errPage","timeCount","setTime","clearInterval","destroyed","components_errPage","src_components_errPage","errPage_normalizeComponent","Vue","use","Router","router","routes","redirect","login","echarts","linkActiveClass","App","$route.path","canBox","getElementById","selectortype_template_index_0_src_App","src_App","App_normalizeComponent","Vuex","MintUI","ElementUI","Search","PullRefresh","Row","Col","productionTip","baseURL","Store","mutations","changeType","parmsObj","template","Detector","CanvasRenderingContext2D","webgl","workers","Worker","fileapi","File","FileReader","FileList","getWebGLErrorMessage","domElement","addGetWebGLMessage","parameters","innerText","ss","camera","scene","mesh","material","start_time","now","innerWidth","innerHeight","onWindowResize","reload","backgroundImage","THREE","PerspectiveCamera","Scene","Geometry","texture","ImageUtils","loadTexture","magFilter","LinearMipMapLinearFilter","minFilter","fog","Fog","ShaderMaterial","uniforms","fogColor","fogNear","near","fogFar","far","vertexShader","textContent","fragmentShader","depthWrite","depthTest","plane","Mesh","PlaneGeometry","GeometryUtils","WebGLRenderer","antialias","setSize","module"],"mappings":"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","file":"static/js/app.90e72061a1c6f779d74a.js","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.echarts = {})));\n}(this, (function (exports) { 'use strict';\n\n// (1) The code `if (__DEV__) ...` can be removed by build tool.\n// (2) If intend to use `__DEV__`, this module should be imported. Use a global\n// variable `__DEV__` may cause that miss the declaration (see #6535), or the\n// declaration is behind of the using position (for example in `Model.extent`,\n// And tools like rollup can not analysis the dependency if not import).\n\nvar dev;\n\n// In browser\nif (typeof window !== 'undefined') {\n    dev = window.__DEV__;\n}\n// In node\nelse if (typeof global !== 'undefined') {\n    dev = global.__DEV__;\n}\n\nif (typeof dev === 'undefined') {\n    dev = true;\n}\n\nvar __DEV__ = dev;\n\n/**\n * zrender: id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\nvar idStart = 0x0907;\n\nvar guid = function () {\n    return idStart++;\n};\n\n/**\n * echarts\n *\n * @desc echartsCanvasJavascript\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\nvar env = {};\n\nif (typeof navigator === 'undefined') {\n    // In node\n    env = {\n        browser: {},\n        os: {},\n        node: true,\n        // Assume canvas is supported\n        canvasSupported: true,\n        svgSupported: true\n    };\n}\nelse {\n    env = detect(navigator.userAgent);\n}\n\nvar env$1 = env;\n\n// Zepto.js\n// (c) 2010-2013 Thomas Fuchs\n// Zepto.js may be freely distributed under the MIT license.\n\nfunction detect(ua) {\n    var os = {};\n    var browser = {};\n    // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n    // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n    // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n    // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n    // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n    // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n    // var touchpad = webos && ua.match(/TouchPad/);\n    // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n    // var silk = ua.match(/Silk\\/([\\d._]+)/);\n    // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n    // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n    // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n    // var playbook = ua.match(/PlayBook/);\n    // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n    var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n    // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n    // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n    var ie = ua.match(/MSIE\\s([\\d.]+)/)\n        // IE 11 Trident/7.0; rv:11.0\n        || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n    var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n    var weChat = (/micromessenger/i).test(ua);\n\n    // Todo: clean this up with a better OS/browser seperation:\n    // - discern (more) between multiple browsers on android\n    // - decide if kindle fire in silk mode is android or not\n    // - Firefox on Android doesn't specify the Android version\n    // - possibly devide in os, device and browser hashes\n\n    // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n    // if (android) os.android = true, os.version = android[2];\n    // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n    // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n    // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n    // if (webos) os.webos = true, os.version = webos[2];\n    // if (touchpad) os.touchpad = true;\n    // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n    // if (bb10) os.bb10 = true, os.version = bb10[2];\n    // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n    // if (playbook) browser.playbook = true;\n    // if (kindle) os.kindle = true, os.version = kindle[1];\n    // if (silk) browser.silk = true, browser.version = silk[1];\n    // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n    // if (chrome) browser.chrome = true, browser.version = chrome[1];\n    if (firefox) {\n        browser.firefox = true;\n        browser.version = firefox[1];\n    }\n    // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n    // if (webview) browser.webview = true;\n\n    if (ie) {\n        browser.ie = true;\n        browser.version = ie[1];\n    }\n\n    if (edge) {\n        browser.edge = true;\n        browser.version = edge[1];\n    }\n\n    // It is difficult to detect WeChat in Win Phone precisely, because ua can\n    // not be set on win phone. So we do not consider Win Phone.\n    if (weChat) {\n        browser.weChat = true;\n    }\n\n    // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n    //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n    // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n    //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n    //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n    return {\n        browser: browser,\n        os: os,\n        node: false,\n        // canvas\n        // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n        canvasSupported: !!document.createElement('canvas').getContext,\n        svgSupported: typeof SVGRect !== 'undefined',\n        // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n        // works on most browsers\n        // IE10/11 does not support touch event, and MS Edge supports them but not by\n        // default, so we dont check navigator.maxTouchPoints for them here.\n        touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n        // <http://caniuse.com/#search=pointer%20event>.\n        pointerEventsSupported: 'onpointerdown' in window\n            // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n            // events currently. So we dont use that on other browsers unless tested sufficiently.\n            // Although IE 10 supports pointer event, it use old style and is different from the\n            // standard. So we exclude that. (IE 10 is hardly used on touch device)\n            && (browser.edge || (browser.ie && browser.version >= 11))\n    };\n}\n\n/**\n * @module zrender/core/util\n */\n\n// mergeDate\nvar BUILTIN_OBJECT = {\n    '[object Function]': 1,\n    '[object RegExp]': 1,\n    '[object Date]': 1,\n    '[object Error]': 1,\n    '[object CanvasGradient]': 1,\n    '[object CanvasPattern]': 1,\n    // For node-canvas\n    '[object Image]': 1,\n    '[object Canvas]': 1\n};\n\nvar TYPED_ARRAY = {\n    '[object Int8Array]': 1,\n    '[object Uint8Array]': 1,\n    '[object Uint8ClampedArray]': 1,\n    '[object Int16Array]': 1,\n    '[object Uint16Array]': 1,\n    '[object Int32Array]': 1,\n    '[object Uint32Array]': 1,\n    '[object Float32Array]': 1,\n    '[object Float64Array]': 1\n};\n\nvar objToString = Object.prototype.toString;\n\nvar arrayProto = Array.prototype;\nvar nativeForEach = arrayProto.forEach;\nvar nativeFilter = arrayProto.filter;\nvar nativeSlice = arrayProto.slice;\nvar nativeMap = arrayProto.map;\nvar nativeReduce = arrayProto.reduce;\n\n// Avoid assign to an exported variable, for transforming to cjs.\nvar methods = {};\n\nfunction $override(name, fn) {\n    methods[name] = fn;\n}\n\n/**\n * Those data types can be cloned:\n *     Plain object, Array, TypedArray, number, string, null, undefined.\n * Those data types will be assgined using the orginal data:\n *     BUILTIN_OBJECT\n * Instance of user defined class will be cloned to a plain object, without\n * properties in prototype.\n * Other data types is not supported (not sure what will happen).\n *\n * Caution: do not support clone Date, for performance consideration.\n * (There might be a large number of date in `series.data`).\n * So date should not be modified in and out of echarts.\n *\n * @param {*} source\n * @return {*} new\n */\nfunction clone(source) {\n    if (source == null || typeof source != 'object') {\n        return source;\n    }\n\n    var result = source;\n    var typeStr = objToString.call(source);\n\n    if (typeStr === '[object Array]') {\n        result = [];\n        for (var i = 0, len = source.length; i < len; i++) {\n            result[i] = clone(source[i]);\n        }\n    }\n    else if (TYPED_ARRAY[typeStr]) {\n        var Ctor = source.constructor;\n        if (source.constructor.from) {\n            result = Ctor.from(source);\n        }\n        else {\n            result = new Ctor(source.length);\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n    }\n    else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n        result = {};\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                result[key] = clone(source[key]);\n            }\n        }\n    }\n\n    return result;\n}\n\n/**\n * @memberOf module:zrender/core/util\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overwrite=false]\n */\nfunction merge(target, source, overwrite) {\n    // We should escapse that source is string\n    // and enter for ... in ...\n    if (!isObject(source) || !isObject(target)) {\n        return overwrite ? clone(source) : target;\n    }\n\n    for (var key in source) {\n        if (source.hasOwnProperty(key)) {\n            var targetProp = target[key];\n            var sourceProp = source[key];\n\n            if (isObject(sourceProp)\n                && isObject(targetProp)\n                && !isArray(sourceProp)\n                && !isArray(targetProp)\n                && !isDom(sourceProp)\n                && !isDom(targetProp)\n                && !isBuiltInObject(sourceProp)\n                && !isBuiltInObject(targetProp)\n                && !isPrimitive(sourceProp)\n                && !isPrimitive(targetProp)\n            ) {\n                // merge\n                merge(targetProp, sourceProp, overwrite);\n            }\n            else if (overwrite || !(key in target)) {\n                // overwritetrue\n                // NOTE target[key] \n                target[key] = clone(source[key], true);\n            }\n        }\n    }\n\n    return target;\n}\n\n/**\n * @param {Array} targetAndSources The first item is target, and the rests are source.\n * @param {boolean} [overwrite=false]\n * @return {*} target\n */\nfunction mergeAll(targetAndSources, overwrite) {\n    var result = targetAndSources[0];\n    for (var i = 1, len = targetAndSources.length; i < len; i++) {\n        result = merge(result, targetAndSources[i], overwrite);\n    }\n    return result;\n}\n\n/**\n * @param {*} target\n * @param {*} source\n * @memberOf module:zrender/core/util\n */\nfunction extend(target, source) {\n    for (var key in source) {\n        if (source.hasOwnProperty(key)) {\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n\n/**\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overlay=false]\n * @memberOf module:zrender/core/util\n */\nfunction defaults(target, source, overlay) {\n    for (var key in source) {\n        if (source.hasOwnProperty(key)\n            && (overlay ? source[key] != null : target[key] == null)\n        ) {\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\n\nvar createCanvas = function () {\n    return methods.createCanvas();\n};\n\nmethods.createCanvas = function () {\n    return document.createElement('canvas');\n};\n\n// FIXME\nvar _ctx;\n\nfunction getContext() {\n    if (!_ctx) {\n        // Use util.createCanvas instead of createCanvas\n        // because createCanvas may be overwritten in different environment\n        _ctx = createCanvas().getContext('2d');\n    }\n    return _ctx;\n}\n\n/**\n * index\n * @memberOf module:zrender/core/util\n */\nfunction indexOf(array, value) {\n    if (array) {\n        if (array.indexOf) {\n            return array.indexOf(value);\n        }\n        for (var i = 0, len = array.length; i < len; i++) {\n            if (array[i] === value) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n\n/**\n * \n *\n * @memberOf module:zrender/core/util\n * @param {Function} clazz \n * @param {Function} baseClazz \n */\nfunction inherits(clazz, baseClazz) {\n    var clazzPrototype = clazz.prototype;\n    function F() {}\n    F.prototype = baseClazz.prototype;\n    clazz.prototype = new F();\n\n    for (var prop in clazzPrototype) {\n        clazz.prototype[prop] = clazzPrototype[prop];\n    }\n    clazz.prototype.constructor = clazz;\n    clazz.superClass = baseClazz;\n}\n\n/**\n * @memberOf module:zrender/core/util\n * @param {Object|Function} target\n * @param {Object|Function} sorce\n * @param {boolean} overlay\n */\nfunction mixin(target, source, overlay) {\n    target = 'prototype' in target ? target.prototype : target;\n    source = 'prototype' in source ? source.prototype : source;\n\n    defaults(target, source, overlay);\n}\n\n/**\n * Consider typed array.\n * @param {Array|TypedArray} data\n */\nfunction isArrayLike(data) {\n    if (! data) {\n        return;\n    }\n    if (typeof data == 'string') {\n        return false;\n    }\n    return typeof data.length == 'number';\n}\n\n/**\n * \n * @memberOf module:zrender/core/util\n * @param {Object|Array} obj\n * @param {Function} cb\n * @param {*} [context]\n */\nfunction each$1(obj, cb, context) {\n    if (!(obj && cb)) {\n        return;\n    }\n    if (obj.forEach && obj.forEach === nativeForEach) {\n        obj.forEach(cb, context);\n    }\n    else if (obj.length === +obj.length) {\n        for (var i = 0, len = obj.length; i < len; i++) {\n            cb.call(context, obj[i], i, obj);\n        }\n    }\n    else {\n        for (var key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                cb.call(context, obj[key], key, obj);\n            }\n        }\n    }\n}\n\n/**\n * \n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\nfunction map(obj, cb, context) {\n    if (!(obj && cb)) {\n        return;\n    }\n    if (obj.map && obj.map === nativeMap) {\n        return obj.map(cb, context);\n    }\n    else {\n        var result = [];\n        for (var i = 0, len = obj.length; i < len; i++) {\n            result.push(cb.call(context, obj[i], i, obj));\n        }\n        return result;\n    }\n}\n\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {Object} [memo]\n * @param {*} [context]\n * @return {Array}\n */\nfunction reduce(obj, cb, memo, context) {\n    if (!(obj && cb)) {\n        return;\n    }\n    if (obj.reduce && obj.reduce === nativeReduce) {\n        return obj.reduce(cb, memo, context);\n    }\n    else {\n        for (var i = 0, len = obj.length; i < len; i++) {\n            memo = cb.call(context, memo, obj[i], i, obj);\n        }\n        return memo;\n    }\n}\n\n/**\n * \n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\nfunction filter(obj, cb, context) {\n    if (!(obj && cb)) {\n        return;\n    }\n    if (obj.filter && obj.filter === nativeFilter) {\n        return obj.filter(cb, context);\n    }\n    else {\n        var result = [];\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                result.push(obj[i]);\n            }\n        }\n        return result;\n    }\n}\n\n/**\n * \n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {*}\n */\nfunction find(obj, cb, context) {\n    if (!(obj && cb)) {\n        return;\n    }\n    for (var i = 0, len = obj.length; i < len; i++) {\n        if (cb.call(context, obj[i], i, obj)) {\n            return obj[i];\n        }\n    }\n}\n\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @param {*} context\n * @return {Function}\n */\nfunction bind(func, context) {\n    var args = nativeSlice.call(arguments, 2);\n    return function () {\n        return func.apply(context, args.concat(nativeSlice.call(arguments)));\n    };\n}\n\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @return {Function}\n */\nfunction curry(func) {\n    var args = nativeSlice.call(arguments, 1);\n    return function () {\n        return func.apply(this, args.concat(nativeSlice.call(arguments)));\n    };\n}\n\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\nfunction isArray(value) {\n    return objToString.call(value) === '[object Array]';\n}\n\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\n\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\nfunction isString(value) {\n    return objToString.call(value) === '[object String]';\n}\n\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\nfunction isObject(value) {\n    // Avoid a V8 JIT bug in Chrome 19-20.\n    // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n    var type = typeof value;\n    return type === 'function' || (!!value && type == 'object');\n}\n\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\nfunction isBuiltInObject(value) {\n    return !!BUILTIN_OBJECT[objToString.call(value)];\n}\n\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\nfunction isDom(value) {\n    return typeof value === 'object'\n        && typeof value.nodeType === 'number'\n        && typeof value.ownerDocument === 'object';\n}\n\n/**\n * Whether is exactly NaN. Notice isNaN('a') returns true.\n * @param {*} value\n * @return {boolean}\n */\nfunction eqNaN(value) {\n    return value !== value;\n}\n\n/**\n * If value1 is not null, then return value1, otherwise judget rest of values.\n * Low performance.\n * @memberOf module:zrender/core/util\n * @return {*} Final value\n */\nfunction retrieve(values) {\n    for (var i = 0, len = arguments.length; i < len; i++) {\n        if (arguments[i] != null) {\n            return arguments[i];\n        }\n    }\n}\n\nfunction retrieve2(value0, value1) {\n    return value0 != null\n        ? value0\n        : value1;\n}\n\nfunction retrieve3(value0, value1, value2) {\n    return value0 != null\n        ? value0\n        : value1 != null\n        ? value1\n        : value2;\n}\n\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} arr\n * @param {number} startIndex\n * @param {number} endIndex\n * @return {Array}\n */\nfunction slice() {\n    return Function.call.apply(nativeSlice, arguments);\n}\n\n/**\n * Normalize css liked array configuration\n * e.g.\n *  3 => [3, 3, 3, 3]\n *  [4, 2] => [4, 2, 4, 2]\n *  [4, 3, 2] => [4, 3, 2, 3]\n * @param {number|Array.<number>} val\n * @return {Array.<number>}\n */\nfunction normalizeCssArray(val) {\n    if (typeof (val) === 'number') {\n        return [val, val, val, val];\n    }\n    var len = val.length;\n    if (len === 2) {\n        // vertical | horizontal\n        return [val[0], val[1], val[0], val[1]];\n    }\n    else if (len === 3) {\n        // top | horizontal | bottom\n        return [val[0], val[1], val[2], val[1]];\n    }\n    return val;\n}\n\n/**\n * @memberOf module:zrender/core/util\n * @param {boolean} condition\n * @param {string} message\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message);\n    }\n}\n\nvar primitiveKey = '__ec_primitive__';\n/**\n * Set an object as primitive to be ignored traversing children in clone or merge\n */\nfunction setAsPrimitive(obj) {\n    obj[primitiveKey] = true;\n}\n\nfunction isPrimitive(obj) {\n    return obj[primitiveKey];\n}\n\n/**\n * @constructor\n * @param {Object} obj Only apply `ownProperty`.\n */\nfunction HashMap(obj) {\n    obj && each$1(obj, function (value, key) {\n        this.set(key, value);\n    }, this);\n}\n\n// Add prefix to avoid conflict with Object.prototype.\nvar HASH_MAP_PREFIX = '_ec_';\nvar HASH_MAP_PREFIX_LENGTH = 4;\n\nHashMap.prototype = {\n    constructor: HashMap,\n    // Do not provide `has` method to avoid defining what is `has`.\n    // (We usually treat `null` and `undefined` as the same, different\n    // from ES6 Map).\n    get: function (key) {\n        return this[HASH_MAP_PREFIX + key];\n    },\n    set: function (key, value) {\n        this[HASH_MAP_PREFIX + key] = value;\n        // Comparing with invocation chaining, `return value` is more commonly\n        // used in this case: `var someVal = map.set('a', genVal());`\n        return value;\n    },\n    // Although util.each can be performed on this hashMap directly, user\n    // should not use the exposed keys, who are prefixed.\n    each: function (cb, context) {\n        context !== void 0 && (cb = bind(cb, context));\n        for (var prefixedKey in this) {\n            this.hasOwnProperty(prefixedKey)\n                && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n        }\n    },\n    // Do not use this method if performance sensitive.\n    removeKey: function (key) {\n        delete this[HASH_MAP_PREFIX + key];\n    }\n};\n\nfunction createHashMap(obj) {\n    return new HashMap(obj);\n}\n\nfunction noop() {}\n\n\nvar zrUtil = (Object.freeze || Object)({\n\t$override: $override,\n\tclone: clone,\n\tmerge: merge,\n\tmergeAll: mergeAll,\n\textend: extend,\n\tdefaults: defaults,\n\tcreateCanvas: createCanvas,\n\tgetContext: getContext,\n\tindexOf: indexOf,\n\tinherits: inherits,\n\tmixin: mixin,\n\tisArrayLike: isArrayLike,\n\teach: each$1,\n\tmap: map,\n\treduce: reduce,\n\tfilter: filter,\n\tfind: find,\n\tbind: bind,\n\tcurry: curry,\n\tisArray: isArray,\n\tisFunction: isFunction,\n\tisString: isString,\n\tisObject: isObject,\n\tisBuiltInObject: isBuiltInObject,\n\tisDom: isDom,\n\teqNaN: eqNaN,\n\tretrieve: retrieve,\n\tretrieve2: retrieve2,\n\tretrieve3: retrieve3,\n\tslice: slice,\n\tnormalizeCssArray: normalizeCssArray,\n\tassert: assert,\n\tsetAsPrimitive: setAsPrimitive,\n\tisPrimitive: isPrimitive,\n\tcreateHashMap: createHashMap,\n\tnoop: noop\n});\n\nvar ArrayCtor = typeof Float32Array === 'undefined'\n    ? Array\n    : Float32Array;\n\n/**\n * \n * @param {number} [x=0]\n * @param {number} [y=0]\n * @return {Vector2}\n */\nfunction create(x, y) {\n    var out = new ArrayCtor(2);\n    if (x == null) {\n        x = 0;\n    }\n    if (y == null) {\n        y = 0;\n    }\n    out[0] = x;\n    out[1] = y;\n    return out;\n}\n\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n * @return {Vector2}\n */\nfunction copy(out, v) {\n    out[0] = v[0];\n    out[1] = v[1];\n    return out;\n}\n\n/**\n * \n * @param {Vector2} v\n * @return {Vector2}\n */\nfunction clone$1(v) {\n    var out = new ArrayCtor(2);\n    out[0] = v[0];\n    out[1] = v[1];\n    return out;\n}\n\n/**\n * \n * @param {Vector2} out\n * @param {number} a\n * @param {number} b\n * @return {Vector2} \n */\nfunction set(out, a, b) {\n    out[0] = a;\n    out[1] = b;\n    return out;\n}\n\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\nfunction add(out, v1, v2) {\n    out[0] = v1[0] + v2[0];\n    out[1] = v1[1] + v2[1];\n    return out;\n}\n\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @param {number} a\n */\nfunction scaleAndAdd(out, v1, v2, a) {\n    out[0] = v1[0] + v2[0] * a;\n    out[1] = v1[1] + v2[1] * a;\n    return out;\n}\n\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\nfunction sub(out, v1, v2) {\n    out[0] = v1[0] - v2[0];\n    out[1] = v1[1] - v2[1];\n    return out;\n}\n\n/**\n * \n * @param {Vector2} v\n * @return {number}\n */\nfunction len(v) {\n    return Math.sqrt(lenSquare(v));\n}\nvar length = len; // jshint ignore:line\n\n/**\n * \n * @param {Vector2} v\n * @return {number}\n */\nfunction lenSquare(v) {\n    return v[0] * v[0] + v[1] * v[1];\n}\nvar lengthSquare = lenSquare;\n\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\nfunction mul(out, v1, v2) {\n    out[0] = v1[0] * v2[0];\n    out[1] = v1[1] * v2[1];\n    return out;\n}\n\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\nfunction div(out, v1, v2) {\n    out[0] = v1[0] / v2[0];\n    out[1] = v1[1] / v2[1];\n    return out;\n}\n\n/**\n * \n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\nfunction dot(v1, v2) {\n    return v1[0] * v2[0] + v1[1] * v2[1];\n}\n\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n * @param {number} s\n */\nfunction scale(out, v, s) {\n    out[0] = v[0] * s;\n    out[1] = v[1] * s;\n    return out;\n}\n\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n */\nfunction normalize(out, v) {\n    var d = len(v);\n    if (d === 0) {\n        out[0] = 0;\n        out[1] = 0;\n    }\n    else {\n        out[0] = v[0] / d;\n        out[1] = v[1] / d;\n    }\n    return out;\n}\n\n/**\n * \n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\nfunction distance(v1, v2) {\n    return Math.sqrt(\n        (v1[0] - v2[0]) * (v1[0] - v2[0])\n        + (v1[1] - v2[1]) * (v1[1] - v2[1])\n    );\n}\nvar dist = distance;\n\n/**\n * \n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\nfunction distanceSquare(v1, v2) {\n    return (v1[0] - v2[0]) * (v1[0] - v2[0])\n        + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n}\nvar distSquare = distanceSquare;\n\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n */\nfunction negate(out, v) {\n    out[0] = -v[0];\n    out[1] = -v[1];\n    return out;\n}\n\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @param {number} t\n */\nfunction lerp(out, v1, v2, t) {\n    out[0] = v1[0] + t * (v2[0] - v1[0]);\n    out[1] = v1[1] + t * (v2[1] - v1[1]);\n    return out;\n}\n\n/**\n * \n * @param {Vector2} out\n * @param {Vector2} v\n * @param {Vector2} m\n */\nfunction applyTransform(out, v, m) {\n    var x = v[0];\n    var y = v[1];\n    out[0] = m[0] * x + m[2] * y + m[4];\n    out[1] = m[1] * x + m[3] * y + m[5];\n    return out;\n}\n\n/**\n * \n * @param  {Vector2} out\n * @param  {Vector2} v1\n * @param  {Vector2} v2\n */\nfunction min(out, v1, v2) {\n    out[0] = Math.min(v1[0], v2[0]);\n    out[1] = Math.min(v1[1], v2[1]);\n    return out;\n}\n\n/**\n * \n * @param  {Vector2} out\n * @param  {Vector2} v1\n * @param  {Vector2} v2\n */\nfunction max(out, v1, v2) {\n    out[0] = Math.max(v1[0], v2[0]);\n    out[1] = Math.max(v1[1], v2[1]);\n    return out;\n}\n\n\nvar vector = (Object.freeze || Object)({\n\tcreate: create,\n\tcopy: copy,\n\tclone: clone$1,\n\tset: set,\n\tadd: add,\n\tscaleAndAdd: scaleAndAdd,\n\tsub: sub,\n\tlen: len,\n\tlength: length,\n\tlenSquare: lenSquare,\n\tlengthSquare: lengthSquare,\n\tmul: mul,\n\tdiv: div,\n\tdot: dot,\n\tscale: scale,\n\tnormalize: normalize,\n\tdistance: distance,\n\tdist: dist,\n\tdistanceSquare: distanceSquare,\n\tdistSquare: distSquare,\n\tnegate: negate,\n\tlerp: lerp,\n\tapplyTransform: applyTransform,\n\tmin: min,\n\tmax: max\n});\n\n// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\nfunction Draggable() {\n\n    this.on('mousedown', this._dragStart, this);\n    this.on('mousemove', this._drag, this);\n    this.on('mouseup', this._dragEnd, this);\n    this.on('globalout', this._dragEnd, this);\n    // this._dropTarget = null;\n    // this._draggingTarget = null;\n\n    // this._x = 0;\n    // this._y = 0;\n}\n\nDraggable.prototype = {\n\n    constructor: Draggable,\n\n    _dragStart: function (e) {\n        var draggingTarget = e.target;\n        if (draggingTarget && draggingTarget.draggable) {\n            this._draggingTarget = draggingTarget;\n            draggingTarget.dragging = true;\n            this._x = e.offsetX;\n            this._y = e.offsetY;\n\n            this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n        }\n    },\n\n    _drag: function (e) {\n        var draggingTarget = this._draggingTarget;\n        if (draggingTarget) {\n\n            var x = e.offsetX;\n            var y = e.offsetY;\n\n            var dx = x - this._x;\n            var dy = y - this._y;\n            this._x = x;\n            this._y = y;\n\n            draggingTarget.drift(dx, dy, e);\n            this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n\n            var dropTarget = this.findHover(x, y, draggingTarget).target;\n            var lastDropTarget = this._dropTarget;\n            this._dropTarget = dropTarget;\n\n            if (draggingTarget !== dropTarget) {\n                if (lastDropTarget && dropTarget !== lastDropTarget) {\n                    this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n                }\n                if (dropTarget && dropTarget !== lastDropTarget) {\n                    this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n                }\n            }\n        }\n    },\n\n    _dragEnd: function (e) {\n        var draggingTarget = this._draggingTarget;\n\n        if (draggingTarget) {\n            draggingTarget.dragging = false;\n        }\n\n        this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\n        if (this._dropTarget) {\n            this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n        }\n\n        this._draggingTarget = null;\n        this._dropTarget = null;\n    }\n\n};\n\nfunction param(target, e) {\n    return {target: target, topTarget: e && e.topTarget};\n}\n\n/**\n * \n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\nvar arrySlice = Array.prototype.slice;\n\n/**\n * \n * @alias module:zrender/mixin/Eventful\n * @constructor\n */\nvar Eventful = function () {\n    this._$handlers = {};\n};\n\nEventful.prototype = {\n\n    constructor: Eventful,\n\n    /**\n     * trigger\n     *\n     * @param {string} event \n     * @param {Function} handler \n     * @param {Object} context\n     */\n    one: function (event, handler, context) {\n        var _h = this._$handlers;\n\n        if (!handler || !event) {\n            return this;\n        }\n\n        if (!_h[event]) {\n            _h[event] = [];\n        }\n\n        for (var i = 0; i < _h[event].length; i++) {\n            if (_h[event][i].h === handler) {\n                return this;\n            }\n        }\n\n        _h[event].push({\n            h: handler,\n            one: true,\n            ctx: context || this\n        });\n\n        return this;\n    },\n\n    /**\n     * \n     * @param {string} event \n     * @param {Function} handler \n     * @param {Object} [context]\n     */\n    on: function (event, handler, context) {\n        var _h = this._$handlers;\n\n        if (!handler || !event) {\n            return this;\n        }\n\n        if (!_h[event]) {\n            _h[event] = [];\n        }\n\n        for (var i = 0; i < _h[event].length; i++) {\n            if (_h[event][i].h === handler) {\n                return this;\n            }\n        }\n\n        _h[event].push({\n            h: handler,\n            one: false,\n            ctx: context || this\n        });\n\n        return this;\n    },\n\n    /**\n     * \n     * @param  {string}  event\n     * @return {boolean}\n     */\n    isSilent: function (event) {\n        var _h = this._$handlers;\n        return _h[event] && _h[event].length;\n    },\n\n    /**\n     * \n     * @param {string} event \n     * @param {Function} [handler] \n     */\n    off: function (event, handler) {\n        var _h = this._$handlers;\n\n        if (!event) {\n            this._$handlers = {};\n            return this;\n        }\n\n        if (handler) {\n            if (_h[event]) {\n                var newList = [];\n                for (var i = 0, l = _h[event].length; i < l; i++) {\n                    if (_h[event][i]['h'] != handler) {\n                        newList.push(_h[event][i]);\n                    }\n                }\n                _h[event] = newList;\n            }\n\n            if (_h[event] && _h[event].length === 0) {\n                delete _h[event];\n            }\n        }\n        else {\n            delete _h[event];\n        }\n\n        return this;\n    },\n\n    /**\n     * \n     *\n     * @param {string} type \n     */\n    trigger: function (type) {\n        if (this._$handlers[type]) {\n            var args = arguments;\n            var argLen = args.length;\n\n            if (argLen > 3) {\n                args = arrySlice.call(args, 1);\n            }\n\n            var _h = this._$handlers[type];\n            var len = _h.length;\n            for (var i = 0; i < len;) {\n                // Optimize advise from backbone\n                switch (argLen) {\n                    case 1:\n                        _h[i]['h'].call(_h[i]['ctx']);\n                        break;\n                    case 2:\n                        _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                        break;\n                    case 3:\n                        _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                        break;\n                    default:\n                        // have more than 2 given arguments\n                        _h[i]['h'].apply(_h[i]['ctx'], args);\n                        break;\n                }\n\n                if (_h[i]['one']) {\n                    _h.splice(i, 1);\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * context, context\n     * @param {string} type \n     */\n    triggerWithContext: function (type) {\n        if (this._$handlers[type]) {\n            var args = arguments;\n            var argLen = args.length;\n\n            if (argLen > 4) {\n                args = arrySlice.call(args, 1, args.length - 1);\n            }\n            var ctx = args[args.length - 1];\n\n            var _h = this._$handlers[type];\n            var len = _h.length;\n            for (var i = 0; i < len;) {\n                // Optimize advise from backbone\n                switch (argLen) {\n                    case 1:\n                        _h[i]['h'].call(ctx);\n                        break;\n                    case 2:\n                        _h[i]['h'].call(ctx, args[1]);\n                        break;\n                    case 3:\n                        _h[i]['h'].call(ctx, args[1], args[2]);\n                        break;\n                    default:\n                        // have more than 2 given arguments\n                        _h[i]['h'].apply(ctx, args);\n                        break;\n                }\n\n                if (_h[i]['one']) {\n                    _h.splice(i, 1);\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n        }\n\n        return this;\n    }\n};\n\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\nvar SILENT = 'silent';\n\nfunction makeEventPacket(eveType, targetInfo, event) {\n    return {\n        type: eveType,\n        event: event,\n        // target can only be an element that is not silent.\n        target: targetInfo.target,\n        // topTarget can be a silent element.\n        topTarget: targetInfo.topTarget,\n        cancelBubble: false,\n        offsetX: event.zrX,\n        offsetY: event.zrY,\n        gestureEvent: event.gestureEvent,\n        pinchX: event.pinchX,\n        pinchY: event.pinchY,\n        pinchScale: event.pinchScale,\n        wheelDelta: event.zrDelta,\n        zrByTouch: event.zrByTouch,\n        which: event.which\n    };\n}\n\nfunction EmptyProxy () {}\nEmptyProxy.prototype.dispose = function () {};\n\nvar handlerNames = [\n    'click', 'dblclick', 'mousewheel', 'mouseout',\n    'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n];\n/**\n * @alias module:zrender/Handler\n * @constructor\n * @extends module:zrender/mixin/Eventful\n * @param {module:zrender/Storage} storage Storage instance.\n * @param {module:zrender/Painter} painter Painter instance.\n * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n */\nvar Handler = function(storage, painter, proxy, painterRoot) {\n    Eventful.call(this);\n\n    this.storage = storage;\n\n    this.painter = painter;\n\n    this.painterRoot = painterRoot;\n\n    proxy = proxy || new EmptyProxy();\n\n    /**\n     * Proxy of event. can be Dom, WebGLSurface, etc.\n     */\n    this.proxy = proxy;\n\n    // Attach handler\n    proxy.handler = this;\n\n    /**\n     * {target, topTarget, x, y}\n     * @private\n     * @type {Object}\n     */\n    this._hovered = {};\n\n    /**\n     * @private\n     * @type {Date}\n     */\n    this._lastTouchMoment;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this._lastX;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this._lastY;\n\n\n    Draggable.call(this);\n\n    each$1(handlerNames, function (name) {\n        proxy.on && proxy.on(name, this[name], this);\n    }, this);\n};\n\nHandler.prototype = {\n\n    constructor: Handler,\n\n    mousemove: function (event) {\n        var x = event.zrX;\n        var y = event.zrY;\n\n        var lastHovered = this._hovered;\n        var lastHoveredTarget = lastHovered.target;\n\n        // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n        // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n        // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n        // See #6198.\n        if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n            lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n            lastHoveredTarget = lastHovered.target;\n        }\n\n        var hovered = this._hovered = this.findHover(x, y);\n        var hoveredTarget = hovered.target;\n\n        var proxy = this.proxy;\n        proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default');\n\n        // Mouse out on previous hovered element\n        if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n            this.dispatchToElement(lastHovered, 'mouseout', event);\n        }\n\n        // Mouse moving on one element\n        this.dispatchToElement(hovered, 'mousemove', event);\n\n        // Mouse over on a new element\n        if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n            this.dispatchToElement(hovered, 'mouseover', event);\n        }\n    },\n\n    mouseout: function (event) {\n        this.dispatchToElement(this._hovered, 'mouseout', event);\n\n        // There might be some doms created by upper layer application\n        // at the same level of painter.getViewportRoot() (e.g., tooltip\n        // dom created by echarts), where 'globalout' event should not\n        // be triggered when mouse enters these doms. (But 'mouseout'\n        // should be triggered at the original hovered element as usual).\n        var element = event.toElement || event.relatedTarget;\n        var innerDom;\n        do {\n            element = element && element.parentNode;\n        }\n        while (element && element.nodeType != 9 && !(\n            innerDom = element === this.painterRoot\n        ));\n\n        !innerDom && this.trigger('globalout', {event: event});\n    },\n\n    /**\n     * Resize\n     */\n    resize: function (event) {\n        this._hovered = {};\n    },\n\n    /**\n     * Dispatch event\n     * @param {string} eventName\n     * @param {event=} eventArgs\n     */\n    dispatch: function (eventName, eventArgs) {\n        var handler = this[eventName];\n        handler && handler.call(this, eventArgs);\n    },\n\n    /**\n     * Dispose\n     */\n    dispose: function () {\n\n        this.proxy.dispose();\n\n        this.storage =\n        this.proxy =\n        this.painter = null;\n    },\n\n    /**\n     * cursor style\n     * @param {string} [cursorStyle='default']  crosshair\n     */\n    setCursorStyle: function (cursorStyle) {\n        var proxy = this.proxy;\n        proxy.setCursor && proxy.setCursor(cursorStyle);\n    },\n\n    /**\n     * \n     *\n     * @private\n     * @param {Object} targetInfo {target, topTarget} \n     * @param {string} eventName \n     * @param {Object} event \n     */\n    dispatchToElement: function (targetInfo, eventName, event) {\n        targetInfo = targetInfo || {};\n        var el = targetInfo.target;\n        if (el && el.silent) {\n            return;\n        }\n        var eventHandler = 'on' + eventName;\n        var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n        while (el) {\n            el[eventHandler]\n                && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n            el.trigger(eventName, eventPacket);\n\n            el = el.parent;\n\n            if (eventPacket.cancelBubble) {\n                break;\n            }\n        }\n\n        if (!eventPacket.cancelBubble) {\n            //  zrender \n            this.trigger(eventName, eventPacket);\n            // \n            //  click  dispose painter \n            this.painter && this.painter.eachOtherLayer(function (layer) {\n                if (typeof(layer[eventHandler]) == 'function') {\n                    layer[eventHandler].call(layer, eventPacket);\n                }\n                if (layer.trigger) {\n                    layer.trigger(eventName, eventPacket);\n                }\n            });\n        }\n    },\n\n    /**\n     * @private\n     * @param {number} x\n     * @param {number} y\n     * @param {module:zrender/graphic/Displayable} exclude\n     * @return {model:zrender/Element}\n     * @method\n     */\n    findHover: function(x, y, exclude) {\n        var list = this.storage.getDisplayList();\n        var out = {x: x, y: y};\n\n        for (var i = list.length - 1; i >= 0 ; i--) {\n            var hoverCheckResult;\n            if (list[i] !== exclude\n                // getDisplayList may include ignored item in VML mode\n                && !list[i].ignore\n                && (hoverCheckResult = isHover(list[i], x, y))\n            ) {\n                !out.topTarget && (out.topTarget = list[i]);\n                if (hoverCheckResult !== SILENT) {\n                    out.target = list[i];\n                    break;\n                }\n            }\n        }\n\n        return out;\n    }\n};\n\n// Common handlers\neach$1(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n    Handler.prototype[name] = function (event) {\n        // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n        var hovered = this.findHover(event.zrX, event.zrY);\n        var hoveredTarget = hovered.target;\n\n        if (name === 'mousedown') {\n            this._downEl = hoveredTarget;\n            this._downPoint = [event.zrX, event.zrY];\n            // In case click triggered before mouseup\n            this._upEl = hoveredTarget;\n        }\n        else if (name === 'mosueup') {\n            this._upEl = hoveredTarget;\n        }\n        else if (name === 'click') {\n            if (this._downEl !== this._upEl\n                // Original click event is triggered on the whole canvas element,\n                // including the case that `mousedown` - `mousemove` - `mouseup`,\n                // which should be filtered, otherwise it will bring trouble to\n                // pan and zoom.\n                || !this._downPoint\n                // Arbitrary value\n                || dist(this._downPoint, [event.zrX, event.zrY]) > 4\n            ) {\n                return;\n            }\n            this._downPoint = null;\n        }\n\n        this.dispatchToElement(hovered, name, event);\n    };\n});\n\nfunction isHover(displayable, x, y) {\n    if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n        var el = displayable;\n        var isSilent;\n        while (el) {\n            // If clipped by ancestor.\n            // FIXME: If clipPath has neither stroke nor fill,\n            // el.clipPath.contain(x, y) will always return false.\n            if (el.clipPath && !el.clipPath.contain(x, y))  {\n                return false;\n            }\n            if (el.silent) {\n                isSilent = true;\n            }\n            el = el.parent;\n        }\n        return isSilent ? SILENT : true;\n    }\n\n    return false;\n}\n\nmixin(Handler, Eventful);\nmixin(Handler, Draggable);\n\n/**\n * 3x2\n * @exports zrender/tool/matrix\n */\n\nvar ArrayCtor$1 = typeof Float32Array === 'undefined'\n    ? Array\n   : Float32Array;\n\n/**\n * \n * @return {Float32Array|Array.<number>}\n */\nfunction create$1() {\n    var out = new ArrayCtor$1(6);\n    identity(out);\n\n    return out;\n}\n\n/**\n * \n * @param {Float32Array|Array.<number>} out\n */\nfunction identity(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    out[4] = 0;\n    out[5] = 0;\n    return out;\n}\n\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} m\n */\nfunction copy$1(out, m) {\n    out[0] = m[0];\n    out[1] = m[1];\n    out[2] = m[2];\n    out[3] = m[3];\n    out[4] = m[4];\n    out[5] = m[5];\n    return out;\n}\n\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} m1\n * @param {Float32Array|Array.<number>} m2\n */\nfunction mul$1(out, m1, m2) {\n    // Consider matrix.mul(m, m2, m);\n    // where out is the same as m2.\n    // So use temp variable to escape error.\n    var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n    var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n    var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n    var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n    var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n    var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n    out[0] = out0;\n    out[1] = out1;\n    out[2] = out2;\n    out[3] = out3;\n    out[4] = out4;\n    out[5] = out5;\n    return out;\n}\n\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {Float32Array|Array.<number>} v\n */\nfunction translate(out, a, v) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4] + v[0];\n    out[5] = a[5] + v[1];\n    return out;\n}\n\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {number} rad\n */\nfunction rotate(out, a, rad) {\n    var aa = a[0];\n    var ac = a[2];\n    var atx = a[4];\n    var ab = a[1];\n    var ad = a[3];\n    var aty = a[5];\n    var st = Math.sin(rad);\n    var ct = Math.cos(rad);\n\n    out[0] = aa * ct + ab * st;\n    out[1] = -aa * st + ab * ct;\n    out[2] = ac * ct + ad * st;\n    out[3] = -ac * st + ct * ad;\n    out[4] = ct * atx + st * aty;\n    out[5] = ct * aty - st * atx;\n    return out;\n}\n\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {Float32Array|Array.<number>} v\n */\nfunction scale$1(out, a, v) {\n    var vx = v[0];\n    var vy = v[1];\n    out[0] = a[0] * vx;\n    out[1] = a[1] * vy;\n    out[2] = a[2] * vx;\n    out[3] = a[3] * vy;\n    out[4] = a[4] * vx;\n    out[5] = a[5] * vy;\n    return out;\n}\n\n/**\n * \n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n */\nfunction invert(out, a) {\n\n    var aa = a[0];\n    var ac = a[2];\n    var atx = a[4];\n    var ab = a[1];\n    var ad = a[3];\n    var aty = a[5];\n\n    var det = aa * ad - ab * ac;\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = ad * det;\n    out[1] = -ab * det;\n    out[2] = -ac * det;\n    out[3] = aa * det;\n    out[4] = (ac * aty - ad * atx) * det;\n    out[5] = (ab * atx - aa * aty) * det;\n    return out;\n}\n\n\nvar matrix = (Object.freeze || Object)({\n\tcreate: create$1,\n\tidentity: identity,\n\tcopy: copy$1,\n\tmul: mul$1,\n\ttranslate: translate,\n\trotate: rotate,\n\tscale: scale$1,\n\tinvert: invert\n});\n\n/**\n * \n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\nvar mIdentity = identity;\n\nvar EPSILON = 5e-5;\n\nfunction isNotAroundZero(val) {\n    return val > EPSILON || val < -EPSILON;\n}\n\n/**\n * @alias module:zrender/mixin/Transformable\n * @constructor\n */\nvar Transformable = function (opts) {\n    opts = opts || {};\n    // If there are no given position, rotation, scale\n    if (!opts.position) {\n        /**\n         * \n         * @type {Array.<number>}\n         * @default [0, 0]\n         */\n        this.position = [0, 0];\n    }\n    if (opts.rotation == null) {\n        /**\n         * \n         * @type {Array.<number>}\n         * @default 0\n         */\n        this.rotation = 0;\n    }\n    if (!opts.scale) {\n        /**\n         * \n         * @type {Array.<number>}\n         * @default [1, 1]\n         */\n        this.scale = [1, 1];\n    }\n    /**\n     * \n     * @type {Array.<number>}\n     * @default null\n     */\n    this.origin = this.origin || null;\n};\n\nvar transformableProto = Transformable.prototype;\ntransformableProto.transform = null;\n\n/**\n * \n * , position, rotation, scaletransformtransform\n */\ntransformableProto.needLocalTransform = function () {\n    return isNotAroundZero(this.rotation)\n        || isNotAroundZero(this.position[0])\n        || isNotAroundZero(this.position[1])\n        || isNotAroundZero(this.scale[0] - 1)\n        || isNotAroundZero(this.scale[1] - 1);\n};\n\ntransformableProto.updateTransform = function () {\n    var parent = this.parent;\n    var parentHasTransform = parent && parent.transform;\n    var needLocalTransform = this.needLocalTransform();\n\n    var m = this.transform;\n    if (!(needLocalTransform || parentHasTransform)) {\n        m && mIdentity(m);\n        return;\n    }\n\n    m = m || create$1();\n\n    if (needLocalTransform) {\n        this.getLocalTransform(m);\n    }\n    else {\n        mIdentity(m);\n    }\n\n    // \n    if (parentHasTransform) {\n        if (needLocalTransform) {\n            mul$1(m, parent.transform, m);\n        }\n        else {\n            copy$1(m, parent.transform);\n        }\n    }\n    // \n    this.transform = m;\n\n    this.invTransform = this.invTransform || create$1();\n    invert(this.invTransform, m);\n};\n\ntransformableProto.getLocalTransform = function (m) {\n    return Transformable.getLocalTransform(this, m);\n};\n\n/**\n * transformcontext\n * @param {CanvasRenderingContext2D} ctx\n */\ntransformableProto.setTransform = function (ctx) {\n    var m = this.transform;\n    var dpr = ctx.dpr || 1;\n    if (m) {\n        ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n    }\n    else {\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    }\n};\n\ntransformableProto.restoreTransform = function (ctx) {\n    var dpr = ctx.dpr || 1;\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n};\n\nvar tmpTransform = [];\n\n/**\n * `transform``position`, `rotation`, `scale`\n */\ntransformableProto.decomposeTransform = function () {\n    if (!this.transform) {\n        return;\n    }\n    var parent = this.parent;\n    var m = this.transform;\n    if (parent && parent.transform) {\n        // Get local transform and decompose them to position, scale, rotation\n        mul$1(tmpTransform, parent.invTransform, m);\n        m = tmpTransform;\n    }\n    var sx = m[0] * m[0] + m[1] * m[1];\n    var sy = m[2] * m[2] + m[3] * m[3];\n    var position = this.position;\n    var scale$$1 = this.scale;\n    if (isNotAroundZero(sx - 1)) {\n        sx = Math.sqrt(sx);\n    }\n    if (isNotAroundZero(sy - 1)) {\n        sy = Math.sqrt(sy);\n    }\n    if (m[0] < 0) {\n        sx = -sx;\n    }\n    if (m[3] < 0) {\n        sy = -sy;\n    }\n    position[0] = m[4];\n    position[1] = m[5];\n    scale$$1[0] = sx;\n    scale$$1[1] = sy;\n    this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n};\n\n/**\n * Get global scale\n * @return {Array.<number>}\n */\ntransformableProto.getGlobalScale = function () {\n    var m = this.transform;\n    if (!m) {\n        return [1, 1];\n    }\n    var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n    var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n    if (m[0] < 0) {\n        sx = -sx;\n    }\n    if (m[3] < 0) {\n        sy = -sy;\n    }\n    return [sx, sy];\n};\n/**\n *  shape \n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\ntransformableProto.transformCoordToLocal = function (x, y) {\n    var v2 = [x, y];\n    var invTransform = this.invTransform;\n    if (invTransform) {\n        applyTransform(v2, v2, invTransform);\n    }\n    return v2;\n};\n\n/**\n * \n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\ntransformableProto.transformCoordToGlobal = function (x, y) {\n    var v2 = [x, y];\n    var transform = this.transform;\n    if (transform) {\n        applyTransform(v2, v2, transform);\n    }\n    return v2;\n};\n\n/**\n * @static\n * @param {Object} target\n * @param {Array.<number>} target.origin\n * @param {number} target.rotation\n * @param {Array.<number>} target.position\n * @param {Array.<number>} [m]\n */\nTransformable.getLocalTransform = function (target, m) {\n    m = m || [];\n    mIdentity(m);\n\n    var origin = target.origin;\n    var scale$$1 = target.scale || [1, 1];\n    var rotation = target.rotation || 0;\n    var position = target.position || [0, 0];\n\n    if (origin) {\n        // Translate to origin\n        m[4] -= origin[0];\n        m[5] -= origin[1];\n    }\n    scale$1(m, m, scale$$1);\n    if (rotation) {\n        rotate(m, m, rotation);\n    }\n    if (origin) {\n        // Translate back from origin\n        m[4] += origin[0];\n        m[5] += origin[1];\n    }\n\n    m[4] += position[0];\n    m[5] += position[1];\n\n    return m;\n};\n\n/**\n *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\nvar easing = {\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    linear: function (k) {\n        return k;\n    },\n\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    quadraticIn: function (k) {\n        return k * k;\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    quadraticOut: function (k) {\n        return k * (2 - k);\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    quadraticInOut: function (k) {\n        if ((k *= 2) < 1) {\n            return 0.5 * k * k;\n        }\n        return -0.5 * (--k * (k - 2) - 1);\n    },\n\n    // t^3\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    cubicIn: function (k) {\n        return k * k * k;\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    cubicOut: function (k) {\n        return --k * k * k + 1;\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    cubicInOut: function (k) {\n        if ((k *= 2) < 1) {\n            return 0.5 * k * k * k;\n        }\n        return 0.5 * ((k -= 2) * k * k + 2);\n    },\n\n    // t^4\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    quarticIn: function (k) {\n        return k * k * k * k;\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    quarticOut: function (k) {\n        return 1 - (--k * k * k * k);\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    quarticInOut: function (k) {\n        if ((k *= 2) < 1) {\n            return 0.5 * k * k * k * k;\n        }\n        return -0.5 * ((k -= 2) * k * k * k - 2);\n    },\n\n    // t^5\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    quinticIn: function (k) {\n        return k * k * k * k * k;\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    quinticOut: function (k) {\n        return --k * k * k * k * k + 1;\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    quinticInOut: function (k) {\n        if ((k *= 2) < 1) {\n            return 0.5 * k * k * k * k * k;\n        }\n        return 0.5 * ((k -= 2) * k * k * k * k + 2);\n    },\n\n    // sin(t)\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    sinusoidalIn: function (k) {\n        return 1 - Math.cos(k * Math.PI / 2);\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    sinusoidalOut: function (k) {\n        return Math.sin(k * Math.PI / 2);\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    sinusoidalInOut: function (k) {\n        return 0.5 * (1 - Math.cos(Math.PI * k));\n    },\n\n    // 2^t\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    exponentialIn: function (k) {\n        return k === 0 ? 0 : Math.pow(1024, k - 1);\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    exponentialOut: function (k) {\n        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    exponentialInOut: function (k) {\n        if (k === 0) {\n            return 0;\n        }\n        if (k === 1) {\n            return 1;\n        }\n        if ((k *= 2) < 1) {\n            return 0.5 * Math.pow(1024, k - 1);\n        }\n        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n    },\n\n    // sqrt(1-t^2)\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    circularIn: function (k) {\n        return 1 - Math.sqrt(1 - k * k);\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    circularOut: function (k) {\n        return Math.sqrt(1 - (--k * k));\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    circularInOut: function (k) {\n        if ((k *= 2) < 1) {\n            return -0.5 * (Math.sqrt(1 - k * k) - 1);\n        }\n        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n    },\n\n    // \n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    elasticIn: function (k) {\n        var s;\n        var a = 0.1;\n        var p = 0.4;\n        if (k === 0) {\n            return 0;\n        }\n        if (k === 1) {\n            return 1;\n        }\n        if (!a || a < 1) {\n            a = 1; s = p / 4;\n        }\n        else {\n            s = p * Math.asin(1 / a) / (2 * Math.PI);\n        }\n        return -(a * Math.pow(2, 10 * (k -= 1)) *\n                    Math.sin((k - s) * (2 * Math.PI) / p));\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    elasticOut: function (k) {\n        var s;\n        var a = 0.1;\n        var p = 0.4;\n        if (k === 0) {\n            return 0;\n        }\n        if (k === 1) {\n            return 1;\n        }\n        if (!a || a < 1) {\n            a = 1; s = p / 4;\n        }\n        else {\n            s = p * Math.asin(1 / a) / (2 * Math.PI);\n        }\n        return (a * Math.pow(2, -10 * k) *\n                Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    elasticInOut: function (k) {\n        var s;\n        var a = 0.1;\n        var p = 0.4;\n        if (k === 0) {\n            return 0;\n        }\n        if (k === 1) {\n            return 1;\n        }\n        if (!a || a < 1) {\n            a = 1; s = p / 4;\n        }\n        else {\n            s = p * Math.asin(1 / a) / (2 * Math.PI);\n        }\n        if ((k *= 2) < 1) {\n            return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                * Math.sin((k - s) * (2 * Math.PI) / p));\n        }\n        return a * Math.pow(2, -10 * (k -= 1))\n                * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n    },\n\n    // \n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    backIn: function (k) {\n        var s = 1.70158;\n        return k * k * ((s + 1) * k - s);\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    backOut: function (k) {\n        var s = 1.70158;\n        return --k * k * ((s + 1) * k + s) + 1;\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    backInOut: function (k) {\n        var s = 1.70158 * 1.525;\n        if ((k *= 2) < 1) {\n            return 0.5 * (k * k * ((s + 1) * k - s));\n        }\n        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n    },\n\n    // \n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    bounceIn: function (k) {\n        return 1 - easing.bounceOut(1 - k);\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    bounceOut: function (k) {\n        if (k < (1 / 2.75)) {\n            return 7.5625 * k * k;\n        }\n        else if (k < (2 / 2.75)) {\n            return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n        }\n        else if (k < (2.5 / 2.75)) {\n            return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n        }\n        else {\n            return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n        }\n    },\n    /**\n    * @param {number} k\n    * @return {number}\n    */\n    bounceInOut: function (k) {\n        if (k < 0.5) {\n            return easing.bounceIn(k * 2) * 0.5;\n        }\n        return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n    }\n};\n\n/**\n * \n * @config target onframe\n * @config life(1000) \n * @config delay(0) \n * @config loop(true)\n * @config gap(0) \n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\nfunction Clip(options) {\n\n    this._target = options.target;\n\n    // \n    this._life = options.life || 1000;\n    // \n    this._delay = options.delay || 0;\n    // \n    // this._startTime = new Date().getTime() + this._delay;// \n    this._initialized = false;\n\n    // \n    this.loop = options.loop == null ? false : options.loop;\n\n    this.gap = options.gap || 0;\n\n    this.easing = options.easing || 'Linear';\n\n    this.onframe = options.onframe;\n    this.ondestroy = options.ondestroy;\n    this.onrestart = options.onrestart;\n\n    this._pausedTime = 0;\n    this._paused = false;\n}\n\nClip.prototype = {\n\n    constructor: Clip,\n\n    step: function (globalTime, deltaTime) {\n        // Set startTime on first step, or _startTime may has milleseconds different between clips\n        // PENDING\n        if (!this._initialized) {\n            this._startTime = globalTime + this._delay;\n            this._initialized = true;\n        }\n\n        if (this._paused) {\n            this._pausedTime += deltaTime;\n            return;\n        }\n\n        var percent = (globalTime - this._startTime - this._pausedTime) / this._life;\n\n        // \n        if (percent < 0) {\n            return;\n        }\n\n        percent = Math.min(percent, 1);\n\n        var easing$$1 = this.easing;\n        var easingFunc = typeof easing$$1 == 'string' ? easing[easing$$1] : easing$$1;\n        var schedule = typeof easingFunc === 'function'\n            ? easingFunc(percent)\n            : percent;\n\n        this.fire('frame', schedule);\n\n        // \n        if (percent == 1) {\n            if (this.loop) {\n                this.restart (globalTime);\n                // \n                //  stage.update \n                return 'restart';\n            }\n\n            // \n            // Animation.update\n            this._needsRemove = true;\n            return 'destroy';\n        }\n\n        return null;\n    },\n\n    restart: function (globalTime) {\n        var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n        this._startTime = globalTime - remainder + this.gap;\n        this._pausedTime = 0;\n\n        this._needsRemove = false;\n    },\n\n    fire: function (eventType, arg) {\n        eventType = 'on' + eventType;\n        if (this[eventType]) {\n            this[eventType](this._target, arg);\n        }\n    },\n\n    pause: function () {\n        this._paused = true;\n    },\n\n    resume: function () {\n        this._paused = false;\n    }\n};\n\n// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n/**\n * Simple double linked list. Compared with array, it has O(1) remove operation.\n * @constructor\n */\nvar LinkedList = function () {\n\n    /**\n     * @type {module:zrender/core/LRU~Entry}\n     */\n    this.head = null;\n\n    /**\n     * @type {module:zrender/core/LRU~Entry}\n     */\n    this.tail = null;\n\n    this._len = 0;\n};\n\nvar linkedListProto = LinkedList.prototype;\n/**\n * Insert a new value at the tail\n * @param  {} val\n * @return {module:zrender/core/LRU~Entry}\n */\nlinkedListProto.insert = function (val) {\n    var entry = new Entry(val);\n    this.insertEntry(entry);\n    return entry;\n};\n\n/**\n * Insert an entry at the tail\n * @param  {module:zrender/core/LRU~Entry} entry\n */\nlinkedListProto.insertEntry = function (entry) {\n    if (!this.head) {\n        this.head = this.tail = entry;\n    }\n    else {\n        this.tail.next = entry;\n        entry.prev = this.tail;\n        entry.next = null;\n        this.tail = entry;\n    }\n    this._len++;\n};\n\n/**\n * Remove entry.\n * @param  {module:zrender/core/LRU~Entry} entry\n */\nlinkedListProto.remove = function (entry) {\n    var prev = entry.prev;\n    var next = entry.next;\n    if (prev) {\n        prev.next = next;\n    }\n    else {\n        // Is head\n        this.head = next;\n    }\n    if (next) {\n        next.prev = prev;\n    }\n    else {\n        // Is tail\n        this.tail = prev;\n    }\n    entry.next = entry.prev = null;\n    this._len--;\n};\n\n/**\n * @return {number}\n */\nlinkedListProto.len = function () {\n    return this._len;\n};\n\n/**\n * Clear list\n */\nlinkedListProto.clear = function () {\n    this.head = this.tail = null;\n    this._len = 0;\n};\n\n/**\n * @constructor\n * @param {} val\n */\nvar Entry = function (val) {\n    /**\n     * @type {}\n     */\n    this.value = val;\n\n    /**\n     * @type {module:zrender/core/LRU~Entry}\n     */\n    this.next;\n\n    /**\n     * @type {module:zrender/core/LRU~Entry}\n     */\n    this.prev;\n};\n\n/**\n * LRU Cache\n * @constructor\n * @alias module:zrender/core/LRU\n */\nvar LRU = function (maxSize) {\n\n    this._list = new LinkedList();\n\n    this._map = {};\n\n    this._maxSize = maxSize || 10;\n\n    this._lastRemovedEntry = null;\n};\n\nvar LRUProto = LRU.prototype;\n\n/**\n * @param  {string} key\n * @param  {} value\n * @return {} Removed value\n */\nLRUProto.put = function (key, value) {\n    var list = this._list;\n    var map = this._map;\n    var removed = null;\n    if (map[key] == null) {\n        var len = list.len();\n        // Reuse last removed entry\n        var entry = this._lastRemovedEntry;\n\n        if (len >= this._maxSize && len > 0) {\n            // Remove the least recently used\n            var leastUsedEntry = list.head;\n            list.remove(leastUsedEntry);\n            delete map[leastUsedEntry.key];\n\n            removed = leastUsedEntry.value;\n            this._lastRemovedEntry = leastUsedEntry;\n        }\n\n        if (entry) {\n            entry.value = value;\n        }\n        else {\n            entry = new Entry(value);\n        }\n        entry.key = key;\n        list.insertEntry(entry);\n        map[key] = entry;\n    }\n\n    return removed;\n};\n\n/**\n * @param  {string} key\n * @return {}\n */\nLRUProto.get = function (key) {\n    var entry = this._map[key];\n    var list = this._list;\n    if (entry != null) {\n        // Put the latest used entry in the tail\n        if (entry !== list.tail) {\n            list.remove(entry);\n            list.insertEntry(entry);\n        }\n\n        return entry.value;\n    }\n};\n\n/**\n * Clear the cache\n */\nLRUProto.clear = function () {\n    this._list.clear();\n    this._map = {};\n};\n\nvar kCSSColorTable = {\n    'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n    'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n    'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n    'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n    'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n    'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n    'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n    'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n    'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n    'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n    'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n    'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n    'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n    'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n    'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n    'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n    'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n    'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n    'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n    'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n    'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n    'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n    'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n    'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n    'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n    'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n    'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n    'gray': [128,128,128,1], 'green': [0,128,0,1],\n    'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n    'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n    'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n    'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n    'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n    'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n    'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n    'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n    'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n    'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n    'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n    'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n    'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n    'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n    'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n    'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n    'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n    'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n    'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n    'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n    'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n    'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n    'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n    'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n    'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n    'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n    'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n    'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n    'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n    'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n    'pink': [255,192,203,1], 'plum': [221,160,221,1],\n    'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n    'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n    'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n    'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n    'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n    'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n    'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n    'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n    'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n    'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n    'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n    'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n    'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n    'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n    'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n};\n\nfunction clampCssByte(i) {  // Clamp to integer 0 .. 255.\n    i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n    return i < 0 ? 0 : i > 255 ? 255 : i;\n}\n\nfunction clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n    i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n    return i < 0 ? 0 : i > 360 ? 360 : i;\n}\n\nfunction clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n    return f < 0 ? 0 : f > 1 ? 1 : f;\n}\n\nfunction parseCssInt(str) {  // int or percentage.\n    if (str.length && str.charAt(str.length - 1) === '%') {\n        return clampCssByte(parseFloat(str) / 100 * 255);\n    }\n    return clampCssByte(parseInt(str, 10));\n}\n\nfunction parseCssFloat(str) {  // float or percentage.\n    if (str.length && str.charAt(str.length - 1) === '%') {\n        return clampCssFloat(parseFloat(str) / 100);\n    }\n    return clampCssFloat(parseFloat(str));\n}\n\nfunction cssHueToRgb(m1, m2, h) {\n    if (h < 0) {\n        h += 1;\n    }\n    else if (h > 1) {\n        h -= 1;\n    }\n\n    if (h * 6 < 1) {\n        return m1 + (m2 - m1) * h * 6;\n    }\n    if (h * 2 < 1) {\n        return m2;\n    }\n    if (h * 3 < 2) {\n        return m1 + (m2 - m1) * (2/3 - h) * 6;\n    }\n    return m1;\n}\n\nfunction lerpNumber(a, b, p) {\n    return a + (b - a) * p;\n}\n\nfunction setRgba(out, r, g, b, a) {\n    out[0] = r; out[1] = g; out[2] = b; out[3] = a;\n    return out;\n}\nfunction copyRgba(out, a) {\n    out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];\n    return out;\n}\n\nvar colorCache = new LRU(20);\nvar lastRemovedArr = null;\n\nfunction putToCache(colorStr, rgbaArr) {\n    // Reuse removed array\n    if (lastRemovedArr) {\n        copyRgba(lastRemovedArr, rgbaArr);\n    }\n    lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));\n}\n\n/**\n * @param {string} colorStr\n * @param {Array.<number>} out\n * @return {Array.<number>}\n * @memberOf module:zrender/util/color\n */\nfunction parse(colorStr, rgbaArr) {\n    if (!colorStr) {\n        return;\n    }\n    rgbaArr = rgbaArr || [];\n\n    var cached = colorCache.get(colorStr);\n    if (cached) {\n        return copyRgba(rgbaArr, cached);\n    }\n\n    // colorStr may be not string\n    colorStr = colorStr + '';\n    // Remove all whitespace, not compliant, but should just be more accepting.\n    var str = colorStr.replace(/ /g, '').toLowerCase();\n\n    // Color keywords (and transparent) lookup.\n    if (str in kCSSColorTable) {\n        copyRgba(rgbaArr, kCSSColorTable[str]);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n    }\n\n    // #abc and #abc123 syntax.\n    if (str.charAt(0) === '#') {\n        if (str.length === 4) {\n            var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n            if (!(iv >= 0 && iv <= 0xfff)) {\n                setRgba(rgbaArr, 0, 0, 0, 1);\n                return;  // Covers NaN.\n            }\n            setRgba(rgbaArr,\n                ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                (iv & 0xf) | ((iv & 0xf) << 4),\n                1\n            );\n            putToCache(colorStr, rgbaArr);\n            return rgbaArr;\n        }\n        else if (str.length === 7) {\n            var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n            if (!(iv >= 0 && iv <= 0xffffff)) {\n                setRgba(rgbaArr, 0, 0, 0, 1);\n                return;  // Covers NaN.\n            }\n            setRgba(rgbaArr,\n                (iv & 0xff0000) >> 16,\n                (iv & 0xff00) >> 8,\n                iv & 0xff,\n                1\n            );\n            putToCache(colorStr, rgbaArr);\n            return rgbaArr;\n        }\n\n        return;\n    }\n    var op = str.indexOf('('), ep = str.indexOf(')');\n    if (op !== -1 && ep + 1 === str.length) {\n        var fname = str.substr(0, op);\n        var params = str.substr(op + 1, ep - (op + 1)).split(',');\n        var alpha = 1;  // To allow case fallthrough.\n        switch (fname) {\n            case 'rgba':\n                if (params.length !== 4) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;\n                }\n                alpha = parseCssFloat(params.pop()); // jshint ignore:line\n            // Fall through.\n            case 'rgb':\n                if (params.length !== 3) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;\n                }\n                setRgba(rgbaArr,\n                    parseCssInt(params[0]),\n                    parseCssInt(params[1]),\n                    parseCssInt(params[2]),\n                    alpha\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            case 'hsla':\n                if (params.length !== 4) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;\n                }\n                params[3] = parseCssFloat(params[3]);\n                hsla2rgba(params, rgbaArr);\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            case 'hsl':\n                if (params.length !== 3) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;\n                }\n                hsla2rgba(params, rgbaArr);\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            default:\n                return;\n        }\n    }\n\n    setRgba(rgbaArr, 0, 0, 0, 1);\n    return;\n}\n\n/**\n * @param {Array.<number>} hsla\n * @param {Array.<number>} rgba\n * @return {Array.<number>} rgba\n */\nfunction hsla2rgba(hsla, rgba) {\n    var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n    // NOTE(deanm): According to the CSS spec s/l should only be\n    // percentages, but we don't bother and let float or percentage.\n    var s = parseCssFloat(hsla[1]);\n    var l = parseCssFloat(hsla[2]);\n    var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n    var m1 = l * 2 - m2;\n\n    rgba = rgba || [];\n    setRgba(rgba,\n        clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n        clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n        clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255),\n        1\n    );\n\n    if (hsla.length === 4) {\n        rgba[3] = hsla[3];\n    }\n\n    return rgba;\n}\n\n/**\n * @param {Array.<number>} rgba\n * @return {Array.<number>} hsla\n */\nfunction rgba2hsla(rgba) {\n    if (!rgba) {\n        return;\n    }\n\n    // RGB from 0 to 255\n    var R = rgba[0] / 255;\n    var G = rgba[1] / 255;\n    var B = rgba[2] / 255;\n\n    var vMin = Math.min(R, G, B); // Min. value of RGB\n    var vMax = Math.max(R, G, B); // Max. value of RGB\n    var delta = vMax - vMin; // Delta RGB value\n\n    var L = (vMax + vMin) / 2;\n    var H;\n    var S;\n    // HSL results from 0 to 1\n    if (delta === 0) {\n        H = 0;\n        S = 0;\n    }\n    else {\n        if (L < 0.5) {\n            S = delta / (vMax + vMin);\n        }\n        else {\n            S = delta / (2 - vMax - vMin);\n        }\n\n        var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n        var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n        var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n        if (R === vMax) {\n            H = deltaB - deltaG;\n        }\n        else if (G === vMax) {\n            H = (1 / 3) + deltaR - deltaB;\n        }\n        else if (B === vMax) {\n            H = (2 / 3) + deltaG - deltaR;\n        }\n\n        if (H < 0) {\n            H += 1;\n        }\n\n        if (H > 1) {\n            H -= 1;\n        }\n    }\n\n    var hsla = [H * 360, S, L];\n\n    if (rgba[3] != null) {\n        hsla.push(rgba[3]);\n    }\n\n    return hsla;\n}\n\n/**\n * @param {string} color\n * @param {number} level\n * @return {string}\n * @memberOf module:zrender/util/color\n */\nfunction lift(color, level) {\n    var colorArr = parse(color);\n    if (colorArr) {\n        for (var i = 0; i < 3; i++) {\n            if (level < 0) {\n                colorArr[i] = colorArr[i] * (1 - level) | 0;\n            }\n            else {\n                colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n            }\n        }\n        return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n    }\n}\n\n/**\n * @param {string} color\n * @return {string}\n * @memberOf module:zrender/util/color\n */\nfunction toHex(color) {\n    var colorArr = parse(color);\n    if (colorArr) {\n        return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n    }\n}\n\n/**\n * Map value to color. Faster than lerp methods because color is represented by rgba array.\n * @param {number} normalizedValue A float between 0 and 1.\n * @param {Array.<Array.<number>>} colors List of rgba color array\n * @param {Array.<number>} [out] Mapped gba color array\n * @return {Array.<number>} will be null/undefined if input illegal.\n */\nfunction fastLerp(normalizedValue, colors, out) {\n    if (!(colors && colors.length)\n        || !(normalizedValue >= 0 && normalizedValue <= 1)\n    ) {\n        return;\n    }\n\n    out = out || [];\n\n    var value = normalizedValue * (colors.length - 1);\n    var leftIndex = Math.floor(value);\n    var rightIndex = Math.ceil(value);\n    var leftColor = colors[leftIndex];\n    var rightColor = colors[rightIndex];\n    var dv = value - leftIndex;\n    out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n    out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n    out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n    out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n\n    return out;\n}\n\n/**\n * @deprecated\n */\nvar fastMapToColor = fastLerp;\n\n/**\n * @param {number} normalizedValue A float between 0 and 1.\n * @param {Array.<string>} colors Color list.\n * @param {boolean=} fullOutput Default false.\n * @return {(string|Object)} Result color. If fullOutput,\n *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n * @memberOf module:zrender/util/color\n */\nfunction lerp$1(normalizedValue, colors, fullOutput) {\n    if (!(colors && colors.length)\n        || !(normalizedValue >= 0 && normalizedValue <= 1)\n    ) {\n        return;\n    }\n\n    var value = normalizedValue * (colors.length - 1);\n    var leftIndex = Math.floor(value);\n    var rightIndex = Math.ceil(value);\n    var leftColor = parse(colors[leftIndex]);\n    var rightColor = parse(colors[rightIndex]);\n    var dv = value - leftIndex;\n\n    var color = stringify(\n        [\n            clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),\n            clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),\n            clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),\n            clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))\n        ],\n        'rgba'\n    );\n\n    return fullOutput\n        ? {\n            color: color,\n            leftIndex: leftIndex,\n            rightIndex: rightIndex,\n            value: value\n        }\n        : color;\n}\n\n/**\n * @deprecated\n */\nvar mapToColor = lerp$1;\n\n/**\n * @param {string} color\n * @param {number=} h 0 ~ 360, ignore when null.\n * @param {number=} s 0 ~ 1, ignore when null.\n * @param {number=} l 0 ~ 1, ignore when null.\n * @return {string} Color string in rgba format.\n * @memberOf module:zrender/util/color\n */\nfunction modifyHSL(color, h, s, l) {\n    color = parse(color);\n\n    if (color) {\n        color = rgba2hsla(color);\n        h != null && (color[0] = clampCssAngle(h));\n        s != null && (color[1] = parseCssFloat(s));\n        l != null && (color[2] = parseCssFloat(l));\n\n        return stringify(hsla2rgba(color), 'rgba');\n    }\n}\n\n/**\n * @param {string} color\n * @param {number=} alpha 0 ~ 1\n * @return {string} Color string in rgba format.\n * @memberOf module:zrender/util/color\n */\nfunction modifyAlpha(color, alpha) {\n    color = parse(color);\n\n    if (color && alpha != null) {\n        color[3] = clampCssFloat(alpha);\n        return stringify(color, 'rgba');\n    }\n}\n\n/**\n * @param {Array.<number>} arrColor like [12,33,44,0.4]\n * @param {string} type 'rgba', 'hsva', ...\n * @return {string} Result color. (If input illegal, return undefined).\n */\nfunction stringify(arrColor, type) {\n    if (!arrColor || !arrColor.length) {\n        return;\n    }\n    var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n    if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n        colorStr += ',' + arrColor[3];\n    }\n    return type + '(' + colorStr + ')';\n}\n\n\nvar color = (Object.freeze || Object)({\n\tparse: parse,\n\tlift: lift,\n\ttoHex: toHex,\n\tfastLerp: fastLerp,\n\tfastMapToColor: fastMapToColor,\n\tlerp: lerp$1,\n\tmapToColor: mapToColor,\n\tmodifyHSL: modifyHSL,\n\tmodifyAlpha: modifyAlpha,\n\tstringify: stringify\n});\n\n/**\n * @module echarts/animation/Animator\n */\n\nvar arraySlice = Array.prototype.slice;\n\nfunction defaultGetter(target, key) {\n    return target[key];\n}\n\nfunction defaultSetter(target, key, value) {\n    target[key] = value;\n}\n\n/**\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} percent\n * @return {number}\n */\nfunction interpolateNumber(p0, p1, percent) {\n    return (p1 - p0) * percent + p0;\n}\n\n/**\n * @param  {string} p0\n * @param  {string} p1\n * @param  {number} percent\n * @return {string}\n */\nfunction interpolateString(p0, p1, percent) {\n    return percent > 0.5 ? p1 : p0;\n}\n\n/**\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {number} percent\n * @param  {Array} out\n * @param  {number} arrDim\n */\nfunction interpolateArray(p0, p1, percent, out, arrDim) {\n    var len = p0.length;\n    if (arrDim == 1) {\n        for (var i = 0; i < len; i++) {\n            out[i] = interpolateNumber(p0[i], p1[i], percent);\n        }\n    }\n    else {\n        var len2 = len && p0[0].length;\n        for (var i = 0; i < len; i++) {\n            for (var j = 0; j < len2; j++) {\n                out[i][j] = interpolateNumber(\n                    p0[i][j], p1[i][j], percent\n                );\n            }\n        }\n    }\n}\n\n// arr0 is source array, arr1 is target array.\n// Do some preprocess to avoid error happened when interpolating from arr0 to arr1\nfunction fillArr(arr0, arr1, arrDim) {\n    var arr0Len = arr0.length;\n    var arr1Len = arr1.length;\n    if (arr0Len !== arr1Len) {\n        // FIXME Not work for TypedArray\n        var isPreviousLarger = arr0Len > arr1Len;\n        if (isPreviousLarger) {\n            // Cut the previous\n            arr0.length = arr1Len;\n        }\n        else {\n            // Fill the previous\n            for (var i = arr0Len; i < arr1Len; i++) {\n                arr0.push(\n                    arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                );\n            }\n        }\n    }\n    // Handling NaN value\n    var len2 = arr0[0] && arr0[0].length;\n    for (var i = 0; i < arr0.length; i++) {\n        if (arrDim === 1) {\n            if (isNaN(arr0[i])) {\n                arr0[i] = arr1[i];\n            }\n        }\n        else {\n            for (var j = 0; j < len2; j++) {\n                if (isNaN(arr0[i][j])) {\n                    arr0[i][j] = arr1[i][j];\n                }\n            }\n        }\n    }\n}\n\n/**\n * @param  {Array} arr0\n * @param  {Array} arr1\n * @param  {number} arrDim\n * @return {boolean}\n */\nfunction isArraySame(arr0, arr1, arrDim) {\n    if (arr0 === arr1) {\n        return true;\n    }\n    var len = arr0.length;\n    if (len !== arr1.length) {\n        return false;\n    }\n    if (arrDim === 1) {\n        for (var i = 0; i < len; i++) {\n            if (arr0[i] !== arr1[i]) {\n                return false;\n            }\n        }\n    }\n    else {\n        var len2 = arr0[0].length;\n        for (var i = 0; i < len; i++) {\n            for (var j = 0; j < len2; j++) {\n                if (arr0[i][j] !== arr1[i][j]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n/**\n * Catmull Rom interpolate array\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {Array} p2\n * @param  {Array} p3\n * @param  {number} t\n * @param  {number} t2\n * @param  {number} t3\n * @param  {Array} out\n * @param  {number} arrDim\n */\nfunction catmullRomInterpolateArray(\n    p0, p1, p2, p3, t, t2, t3, out, arrDim\n) {\n    var len = p0.length;\n    if (arrDim == 1) {\n        for (var i = 0; i < len; i++) {\n            out[i] = catmullRomInterpolate(\n                p0[i], p1[i], p2[i], p3[i], t, t2, t3\n            );\n        }\n    }\n    else {\n        var len2 = p0[0].length;\n        for (var i = 0; i < len; i++) {\n            for (var j = 0; j < len2; j++) {\n                out[i][j] = catmullRomInterpolate(\n                    p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                    t, t2, t3\n                );\n            }\n        }\n    }\n}\n\n/**\n * Catmull Rom interpolate number\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @param  {number} t2\n * @param  {number} t3\n * @return {number}\n */\nfunction catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n    var v0 = (p2 - p0) * 0.5;\n    var v1 = (p3 - p1) * 0.5;\n    return (2 * (p1 - p2) + v0 + v1) * t3\n            + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n            + v0 * t + p1;\n}\n\nfunction cloneValue(value) {\n    if (isArrayLike(value)) {\n        var len = value.length;\n        if (isArrayLike(value[0])) {\n            var ret = [];\n            for (var i = 0; i < len; i++) {\n                ret.push(arraySlice.call(value[i]));\n            }\n            return ret;\n        }\n\n        return arraySlice.call(value);\n    }\n\n    return value;\n}\n\nfunction rgba2String(rgba) {\n    rgba[0] = Math.floor(rgba[0]);\n    rgba[1] = Math.floor(rgba[1]);\n    rgba[2] = Math.floor(rgba[2]);\n\n    return 'rgba(' + rgba.join(',') + ')';\n}\n\nfunction getArrayDim(keyframes) {\n    var lastValue = keyframes[keyframes.length - 1].value;\n    return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n}\n\nfunction createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {\n    var getter = animator._getter;\n    var setter = animator._setter;\n    var useSpline = easing === 'spline';\n\n    var trackLen = keyframes.length;\n    if (!trackLen) {\n        return;\n    }\n    // Guess data type\n    var firstVal = keyframes[0].value;\n    var isValueArray = isArrayLike(firstVal);\n    var isValueColor = false;\n    var isValueString = false;\n\n    // For vertices morphing\n    var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n\n    var trackMaxTime;\n    // Sort keyframe as ascending\n    keyframes.sort(function(a, b) {\n        return a.time - b.time;\n    });\n\n    trackMaxTime = keyframes[trackLen - 1].time;\n    // Percents of each keyframe\n    var kfPercents = [];\n    // Value of each keyframe\n    var kfValues = [];\n    var prevValue = keyframes[0].value;\n    var isAllValueEqual = true;\n    for (var i = 0; i < trackLen; i++) {\n        kfPercents.push(keyframes[i].time / trackMaxTime);\n        // Assume value is a color when it is a string\n        var value = keyframes[i].value;\n\n        // Check if value is equal, deep check if value is array\n        if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n            || (!isValueArray && value === prevValue))) {\n            isAllValueEqual = false;\n        }\n        prevValue = value;\n\n        // Try converting a string to a color array\n        if (typeof value == 'string') {\n            var colorArray = parse(value);\n            if (colorArray) {\n                value = colorArray;\n                isValueColor = true;\n            }\n            else {\n                isValueString = true;\n            }\n        }\n        kfValues.push(value);\n    }\n    if (!forceAnimate && isAllValueEqual) {\n        return;\n    }\n\n    var lastValue = kfValues[trackLen - 1];\n    // Polyfill array and NaN value\n    for (var i = 0; i < trackLen - 1; i++) {\n        if (isValueArray) {\n            fillArr(kfValues[i], lastValue, arrDim);\n        }\n        else {\n            if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                kfValues[i] = lastValue;\n            }\n        }\n    }\n    isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n    // Cache the key of last frame to speed up when\n    // animation playback is sequency\n    var lastFrame = 0;\n    var lastFramePercent = 0;\n    var start;\n    var w;\n    var p0;\n    var p1;\n    var p2;\n    var p3;\n\n    if (isValueColor) {\n        var rgba = [0, 0, 0, 0];\n    }\n\n    var onframe = function (target, percent) {\n        // Find the range keyframes\n        // kf1-----kf2---------current--------kf3\n        // find kf2 and kf3 and do interpolation\n        var frame;\n        // In the easing function like elasticOut, percent may less than 0\n        if (percent < 0) {\n            frame = 0;\n        }\n        else if (percent < lastFramePercent) {\n            // Start from next key\n            // PENDING start from lastFrame ?\n            start = Math.min(lastFrame + 1, trackLen - 1);\n            for (frame = start; frame >= 0; frame--) {\n                if (kfPercents[frame] <= percent) {\n                    break;\n                }\n            }\n            // PENDING really need to do this ?\n            frame = Math.min(frame, trackLen - 2);\n        }\n        else {\n            for (frame = lastFrame; frame < trackLen; frame++) {\n                if (kfPercents[frame] > percent) {\n                    break;\n                }\n            }\n            frame = Math.min(frame - 1, trackLen - 2);\n        }\n        lastFrame = frame;\n        lastFramePercent = percent;\n\n        var range = (kfPercents[frame + 1] - kfPercents[frame]);\n        if (range === 0) {\n            return;\n        }\n        else {\n            w = (percent - kfPercents[frame]) / range;\n        }\n        if (useSpline) {\n            p1 = kfValues[frame];\n            p0 = kfValues[frame === 0 ? frame : frame - 1];\n            p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n            p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n            if (isValueArray) {\n                catmullRomInterpolateArray(\n                    p0, p1, p2, p3, w, w * w, w * w * w,\n                    getter(target, propName),\n                    arrDim\n                );\n            }\n            else {\n                var value;\n                if (isValueColor) {\n                    value = catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        rgba, 1\n                    );\n                    value = rgba2String(rgba);\n                }\n                else if (isValueString) {\n                    // String is step(0.5)\n                    return interpolateString(p1, p2, w);\n                }\n                else {\n                    value = catmullRomInterpolate(\n                        p0, p1, p2, p3, w, w * w, w * w * w\n                    );\n                }\n                setter(\n                    target,\n                    propName,\n                    value\n                );\n            }\n        }\n        else {\n            if (isValueArray) {\n                interpolateArray(\n                    kfValues[frame], kfValues[frame + 1], w,\n                    getter(target, propName),\n                    arrDim\n                );\n            }\n            else {\n                var value;\n                if (isValueColor) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        rgba, 1\n                    );\n                    value = rgba2String(rgba);\n                }\n                else if (isValueString) {\n                    // String is step(0.5)\n                    return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                }\n                else {\n                    value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                }\n                setter(\n                    target,\n                    propName,\n                    value\n                );\n            }\n        }\n    };\n\n    var clip = new Clip({\n        target: animator._target,\n        life: trackMaxTime,\n        loop: animator._loop,\n        delay: animator._delay,\n        onframe: onframe,\n        ondestroy: oneTrackDone\n    });\n\n    if (easing && easing !== 'spline') {\n        clip.easing = easing;\n    }\n\n    return clip;\n}\n\n/**\n * @alias module:zrender/animation/Animator\n * @constructor\n * @param {Object} target\n * @param {boolean} loop\n * @param {Function} getter\n * @param {Function} setter\n */\nvar Animator = function(target, loop, getter, setter) {\n    this._tracks = {};\n    this._target = target;\n\n    this._loop = loop || false;\n\n    this._getter = getter || defaultGetter;\n    this._setter = setter || defaultSetter;\n\n    this._clipCount = 0;\n\n    this._delay = 0;\n\n    this._doneList = [];\n\n    this._onframeList = [];\n\n    this._clipList = [];\n};\n\nAnimator.prototype = {\n    /**\n     * \n     * @param  {number} time ms\n     * @param  {Object} props key-value\n     * @return {module:zrender/animation/Animator}\n     */\n    when: function(time /* ms */, props) {\n        var tracks = this._tracks;\n        for (var propName in props) {\n            if (!props.hasOwnProperty(propName)) {\n                continue;\n            }\n\n            if (!tracks[propName]) {\n                tracks[propName] = [];\n                // Invalid value\n                var value = this._getter(this._target, propName);\n                if (value == null) {\n                    // zrLog('Invalid property ' + propName);\n                    continue;\n                }\n                // If time is 0\n                //  Then props is given initialize value\n                // Else\n                //  Initialize value from current prop value\n                if (time !== 0) {\n                    tracks[propName].push({\n                        time: 0,\n                        value: cloneValue(value)\n                    });\n                }\n            }\n            tracks[propName].push({\n                time: time,\n                value: props[propName]\n            });\n        }\n        return this;\n    },\n    /**\n     * \n     * @param  {Function} callback\n     * @return {module:zrender/animation/Animator}\n     */\n    during: function (callback) {\n        this._onframeList.push(callback);\n        return this;\n    },\n\n    pause: function () {\n        for (var i = 0; i < this._clipList.length; i++) {\n            this._clipList[i].pause();\n        }\n        this._paused = true;\n    },\n\n    resume: function () {\n        for (var i = 0; i < this._clipList.length; i++) {\n            this._clipList[i].resume();\n        }\n        this._paused = false;\n    },\n\n    isPaused: function () {\n        return !!this._paused;\n    },\n\n    _doneCallback: function () {\n        // Clear all tracks\n        this._tracks = {};\n        // Clear all clips\n        this._clipList.length = 0;\n\n        var doneList = this._doneList;\n        var len = doneList.length;\n        for (var i = 0; i < len; i++) {\n            doneList[i].call(this);\n        }\n    },\n    /**\n     * \n     * @param  {string|Function} [easing]\n     *         {@link module:zrender/animation/easing}\n     * @param  {boolean} forceAnimate\n     * @return {module:zrender/animation/Animator}\n     */\n    start: function (easing, forceAnimate) {\n\n        var self = this;\n        var clipCount = 0;\n\n        var oneTrackDone = function() {\n            clipCount--;\n            if (!clipCount) {\n                self._doneCallback();\n            }\n        };\n\n        var lastClip;\n        for (var propName in this._tracks) {\n            if (!this._tracks.hasOwnProperty(propName)) {\n                continue;\n            }\n            var clip = createTrackClip(\n                this, easing, oneTrackDone,\n                this._tracks[propName], propName, forceAnimate\n            );\n            if (clip) {\n                this._clipList.push(clip);\n                clipCount++;\n\n                // If start after added to animation\n                if (this.animation) {\n                    this.animation.addClip(clip);\n                }\n\n                lastClip = clip;\n            }\n        }\n\n        // Add during callback on the last clip\n        if (lastClip) {\n            var oldOnFrame = lastClip.onframe;\n            lastClip.onframe = function (target, percent) {\n                oldOnFrame(target, percent);\n\n                for (var i = 0; i < self._onframeList.length; i++) {\n                    self._onframeList[i](target, percent);\n                }\n            };\n        }\n\n        // This optimization will help the case that in the upper application\n        // the view may be refreshed frequently, where animation will be\n        // called repeatly but nothing changed.\n        if (!clipCount) {\n            this._doneCallback();\n        }\n        return this;\n    },\n    /**\n     * \n     * @param {boolean} forwardToLast If move to last frame before stop\n     */\n    stop: function (forwardToLast) {\n        var clipList = this._clipList;\n        var animation = this.animation;\n        for (var i = 0; i < clipList.length; i++) {\n            var clip = clipList[i];\n            if (forwardToLast) {\n                // Move to last frame before stop\n                clip.onframe(this._target, 1);\n            }\n            animation && animation.removeClip(clip);\n        }\n        clipList.length = 0;\n    },\n    /**\n     * \n     * @param  {number} time ms\n     * @return {module:zrender/animation/Animator}\n     */\n    delay: function (time) {\n        this._delay = time;\n        return this;\n    },\n    /**\n     * \n     * @param  {Function} cb\n     * @return {module:zrender/animation/Animator}\n     */\n    done: function(cb) {\n        if (cb) {\n            this._doneList.push(cb);\n        }\n        return this;\n    },\n\n    /**\n     * @return {Array.<module:zrender/animation/Clip>}\n     */\n    getClips: function () {\n        return this._clipList;\n    }\n};\n\nvar dpr = 1;\n\n// If in browser environment\nif (typeof window !== 'undefined') {\n    dpr = Math.max(window.devicePixelRatio || 1, 1);\n}\n\n/**\n * config\n * @exports zrender/config\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\n\n/**\n * debugcatchBrushExceptiontrue\n * 0 : debug\n * 1 : \n * 2 : \n */\nvar debugMode = 0;\n\n// retina \nvar devicePixelRatio = dpr;\n\nvar log = function () {\n};\n\nif (debugMode === 1) {\n    log = function () {\n        for (var k in arguments) {\n            throw new Error(arguments[k]);\n        }\n    };\n}\nelse if (debugMode > 1) {\n    log = function () {\n        for (var k in arguments) {\n            console.log(arguments[k]);\n        }\n    };\n}\n\nvar zrLog = log;\n\n/**\n * @alias modue:zrender/mixin/Animatable\n * @constructor\n */\nvar Animatable = function () {\n\n    /**\n     * @type {Array.<module:zrender/animation/Animator>}\n     * @readOnly\n     */\n    this.animators = [];\n};\n\nAnimatable.prototype = {\n\n    constructor: Animatable,\n\n    /**\n     * \n     *\n     * @param {string} path The path to fetch value from object, like 'a.b.c'.\n     * @param {boolean} [loop] Whether to loop animation.\n     * @return {module:zrender/animation/Animator}\n     * @example:\n     *     el.animate('style', false)\n     *         .when(1000, {x: 10} )\n     *         .done(function(){ // Animation done })\n     *         .start()\n     */\n    animate: function (path, loop) {\n        var target;\n        var animatingShape = false;\n        var el = this;\n        var zr = this.__zr;\n        if (path) {\n            var pathSplitted = path.split('.');\n            var prop = el;\n            // If animating shape\n            animatingShape = pathSplitted[0] === 'shape';\n            for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                if (!prop) {\n                    continue;\n                }\n                prop = prop[pathSplitted[i]];\n            }\n            if (prop) {\n                target = prop;\n            }\n        }\n        else {\n            target = el;\n        }\n\n        if (!target) {\n            zrLog(\n                'Property \"'\n                + path\n                + '\" is not existed in element '\n                + el.id\n            );\n            return;\n        }\n\n        var animators = el.animators;\n\n        var animator = new Animator(target, loop);\n\n        animator.during(function (target) {\n            el.dirty(animatingShape);\n        })\n        .done(function () {\n            // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n            animators.splice(indexOf(animators, animator), 1);\n        });\n\n        animators.push(animator);\n\n        // If animate after added to the zrender\n        if (zr) {\n            zr.animation.addAnimator(animator);\n        }\n\n        return animator;\n    },\n\n    /**\n     * \n     * @param {boolean} forwardToLast If move to last frame before stop\n     */\n    stopAnimation: function (forwardToLast) {\n        var animators = this.animators;\n        var len = animators.length;\n        for (var i = 0; i < len; i++) {\n            animators[i].stop(forwardToLast);\n        }\n        animators.length = 0;\n\n        return this;\n    },\n\n    /**\n     * Caution: this method will stop previous animation.\n     * So do not use this method to one element twice before\n     * animation starts, unless you know what you are doing.\n     * @param {Object} target\n     * @param {number} [time=500] Time in ms\n     * @param {string} [easing='linear']\n     * @param {number} [delay=0]\n     * @param {Function} [callback]\n     * @param {Function} [forceAnimate] Prevent stop animation and callback\n     *        immediently when target values are the same as current values.\n     *\n     * @example\n     *  // Animate position\n     *  el.animateTo({\n     *      position: [10, 10]\n     *  }, function () { // done })\n     *\n     *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n     *  el.animateTo({\n     *      shape: {\n     *          width: 500\n     *      },\n     *      style: {\n     *          fill: 'red'\n     *      }\n     *      position: [10, 10]\n     *  }, 100, 100, 'cubicOut', function () { // done })\n     */\n        // TODO Return animation key\n    animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n        // animateTo(target, time, easing, callback);\n        if (isString(delay)) {\n            callback = easing;\n            easing = delay;\n            delay = 0;\n        }\n        // animateTo(target, time, delay, callback);\n        else if (isFunction(easing)) {\n            callback = easing;\n            easing = 'linear';\n            delay = 0;\n        }\n        // animateTo(target, time, callback);\n        else if (isFunction(delay)) {\n            callback = delay;\n            delay = 0;\n        }\n        // animateTo(target, callback)\n        else if (isFunction(time)) {\n            callback = time;\n            time = 500;\n        }\n        // animateTo(target)\n        else if (!time) {\n            time = 500;\n        }\n        // Stop all previous animations\n        this.stopAnimation();\n        this._animateToShallow('', this, target, time, delay);\n\n        // Animators may be removed immediately after start\n        // if there is nothing to animate\n        var animators = this.animators.slice();\n        var count = animators.length;\n        function done() {\n            count--;\n            if (!count) {\n                callback && callback();\n            }\n        }\n\n        // No animators. This should be checked before animators[i].start(),\n        // because 'done' may be executed immediately if no need to animate.\n        if (!count) {\n            callback && callback();\n        }\n        // Start after all animators created\n        // Incase any animator is done immediately when all animation properties are not changed\n        for (var i = 0; i < animators.length; i++) {\n            animators[i]\n                .done(done)\n                .start(easing, forceAnimate);\n        }\n    },\n\n    /**\n     * @private\n     * @param {string} path=''\n     * @param {Object} source=this\n     * @param {Object} target\n     * @param {number} [time=500]\n     * @param {number} [delay=0]\n     *\n     * @example\n     *  // Animate position\n     *  el._animateToShallow({\n     *      position: [10, 10]\n     *  })\n     *\n     *  // Animate shape, style and position in 100ms, delayed 100ms\n     *  el._animateToShallow({\n     *      shape: {\n     *          width: 500\n     *      },\n     *      style: {\n     *          fill: 'red'\n     *      }\n     *      position: [10, 10]\n     *  }, 100, 100)\n     */\n    _animateToShallow: function (path, source, target, time, delay) {\n        var objShallow = {};\n        var propertyCount = 0;\n        for (var name in target) {\n            if (!target.hasOwnProperty(name)) {\n                continue;\n            }\n\n            if (source[name] != null) {\n                if (isObject(target[name]) && !isArrayLike(target[name])) {\n                    this._animateToShallow(\n                        path ? path + '.' + name : name,\n                        source[name],\n                        target[name],\n                        time,\n                        delay\n                    );\n                }\n                else {\n                    objShallow[name] = target[name];\n                    propertyCount++;\n                }\n            }\n            else if (target[name] != null) {\n                // Attr directly if not has property\n                // FIXME, if some property not needed for element ?\n                if (!path) {\n                    this.attr(name, target[name]);\n                }\n                else {  // Shape or style\n                    var props = {};\n                    props[path] = {};\n                    props[path][name] = target[name];\n                    this.attr(props);\n                }\n            }\n        }\n\n        if (propertyCount > 0) {\n            this.animate(path, false)\n                .when(time == null ? 500 : time, objShallow)\n                .delay(delay || 0);\n        }\n\n        return this;\n    }\n};\n\n/**\n * @alias module:zrender/Element\n * @constructor\n * @extends {module:zrender/mixin/Animatable}\n * @extends {module:zrender/mixin/Transformable}\n * @extends {module:zrender/mixin/Eventful}\n */\nvar Element = function (opts) { // jshint ignore:line\n\n    Transformable.call(this, opts);\n    Eventful.call(this, opts);\n    Animatable.call(this, opts);\n\n    /**\n     * ID\n     * @type {string}\n     */\n    this.id = opts.id || guid();\n};\n\nElement.prototype = {\n\n    /**\n     * \n     * Element type\n     * @type {string}\n     */\n    type: 'element',\n\n    /**\n     * \n     * Element name\n     * @type {string}\n     */\n    name: '',\n\n    /**\n     * ZRender  element  zrender \n     * ZRender instance will be assigned when element is associated with zrender\n     * @name module:/zrender/Element#__zr\n     * @type {module:zrender/ZRender}\n     */\n    __zr: null,\n\n    /**\n     * true\n     * If ignore drawing and events of the element object\n     * @name module:/zrender/Element#ignore\n     * @type {boolean}\n     * @default false\n     */\n    ignore: false,\n\n    /**\n     * (shape) Group \n     * \n     * @type {module:zrender/graphic/Path}\n     * @see http://www.w3.org/TR/2dcontext/#clipping-region\n     * @readOnly\n     */\n    clipPath: null,\n\n    /**\n     * Drift element\n     * @param  {number} dx dx on the global space\n     * @param  {number} dy dy on the global space\n     */\n    drift: function (dx, dy) {\n        switch (this.draggable) {\n            case 'horizontal':\n                dy = 0;\n                break;\n            case 'vertical':\n                dx = 0;\n                break;\n        }\n\n        var m = this.transform;\n        if (!m) {\n            m = this.transform = [1, 0, 0, 1, 0, 0];\n        }\n        m[4] += dx;\n        m[5] += dy;\n\n        this.decomposeTransform();\n        this.dirty(false);\n    },\n\n    /**\n     * Hook before update\n     */\n    beforeUpdate: function () {},\n    /**\n     * Hook after update\n     */\n    afterUpdate: function () {},\n    /**\n     * Update each frame\n     */\n    update: function () {\n        this.updateTransform();\n    },\n\n    /**\n     * @param  {Function} cb\n     * @param  {}   context\n     */\n    traverse: function (cb, context) {},\n\n    /**\n     * @protected\n     */\n    attrKV: function (key, value) {\n        if (key === 'position' || key === 'scale' || key === 'origin') {\n            // Copy the array\n            if (value) {\n                var target = this[key];\n                if (!target) {\n                    target = this[key] = [];\n                }\n                target[0] = value[0];\n                target[1] = value[1];\n            }\n        }\n        else {\n            this[key] = value;\n        }\n    },\n\n    /**\n     * Hide the element\n     */\n    hide: function () {\n        this.ignore = true;\n        this.__zr && this.__zr.refresh();\n    },\n\n    /**\n     * Show the element\n     */\n    show: function () {\n        this.ignore = false;\n        this.__zr && this.__zr.refresh();\n    },\n\n    /**\n     * @param {string|Object} key\n     * @param {*} value\n     */\n    attr: function (key, value) {\n        if (typeof key === 'string') {\n            this.attrKV(key, value);\n        }\n        else if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.attrKV(name, key[name]);\n                }\n            }\n        }\n\n        this.dirty(false);\n\n        return this;\n    },\n\n    /**\n     * @param {module:zrender/graphic/Path} clipPath\n     */\n    setClipPath: function (clipPath) {\n        var zr = this.__zr;\n        if (zr) {\n            clipPath.addSelfToZr(zr);\n        }\n\n        // Remove previous clip path\n        if (this.clipPath && this.clipPath !== clipPath) {\n            this.removeClipPath();\n        }\n\n        this.clipPath = clipPath;\n        clipPath.__zr = zr;\n        clipPath.__clipTarget = this;\n\n        this.dirty(false);\n    },\n\n    /**\n     */\n    removeClipPath: function () {\n        var clipPath = this.clipPath;\n        if (clipPath) {\n            if (clipPath.__zr) {\n                clipPath.removeSelfFromZr(clipPath.__zr);\n            }\n\n            clipPath.__zr = null;\n            clipPath.__clipTarget = null;\n            this.clipPath = null;\n\n            this.dirty(false);\n        }\n    },\n\n    /**\n     * Add self from zrender instance.\n     * Not recursively because it will be invoked when element added to storage.\n     * @param {module:zrender/ZRender} zr\n     */\n    addSelfToZr: function (zr) {\n        this.__zr = zr;\n        // \n        var animators = this.animators;\n        if (animators) {\n            for (var i = 0; i < animators.length; i++) {\n                zr.animation.addAnimator(animators[i]);\n            }\n        }\n\n        if (this.clipPath) {\n            this.clipPath.addSelfToZr(zr);\n        }\n    },\n\n    /**\n     * Remove self from zrender instance.\n     * Not recursively because it will be invoked when element added to storage.\n     * @param {module:zrender/ZRender} zr\n     */\n    removeSelfFromZr: function (zr) {\n        this.__zr = null;\n        // \n        var animators = this.animators;\n        if (animators) {\n            for (var i = 0; i < animators.length; i++) {\n                zr.animation.removeAnimator(animators[i]);\n            }\n        }\n\n        if (this.clipPath) {\n            this.clipPath.removeSelfFromZr(zr);\n        }\n    }\n};\n\nmixin(Element, Animatable);\nmixin(Element, Transformable);\nmixin(Element, Eventful);\n\n/**\n * @module echarts/core/BoundingRect\n */\n\nvar v2ApplyTransform = applyTransform;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\n\n/**\n * @alias module:echarts/core/BoundingRect\n */\nfunction BoundingRect(x, y, width, height) {\n\n    if (width < 0) {\n        x = x + width;\n        width = -width;\n    }\n    if (height < 0) {\n        y = y + height;\n        height = -height;\n    }\n\n    /**\n     * @type {number}\n     */\n    this.x = x;\n    /**\n     * @type {number}\n     */\n    this.y = y;\n    /**\n     * @type {number}\n     */\n    this.width = width;\n    /**\n     * @type {number}\n     */\n    this.height = height;\n}\n\nBoundingRect.prototype = {\n\n    constructor: BoundingRect,\n\n    /**\n     * @param {module:echarts/core/BoundingRect} other\n     */\n    union: function (other) {\n        var x = mathMin(other.x, this.x);\n        var y = mathMin(other.y, this.y);\n\n        this.width = mathMax(\n                other.x + other.width,\n                this.x + this.width\n            ) - x;\n        this.height = mathMax(\n                other.y + other.height,\n                this.y + this.height\n            ) - y;\n        this.x = x;\n        this.y = y;\n    },\n\n    /**\n     * @param {Array.<number>} m\n     * @methods\n     */\n    applyTransform: (function () {\n        var lt = [];\n        var rb = [];\n        var lb = [];\n        var rt = [];\n        return function (m) {\n            // In case usage like this\n            // el.getBoundingRect().applyTransform(el.transform)\n            // And element has no transform\n            if (!m) {\n                return;\n            }\n            lt[0] = lb[0] = this.x;\n            lt[1] = rt[1] = this.y;\n            rb[0] = rt[0] = this.x + this.width;\n            rb[1] = lb[1] = this.y + this.height;\n\n            v2ApplyTransform(lt, lt, m);\n            v2ApplyTransform(rb, rb, m);\n            v2ApplyTransform(lb, lb, m);\n            v2ApplyTransform(rt, rt, m);\n\n            this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n            this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n            var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n            var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n            this.width = maxX - this.x;\n            this.height = maxY - this.y;\n        };\n    })(),\n\n    /**\n     * Calculate matrix of transforming from self to target rect\n     * @param  {module:zrender/core/BoundingRect} b\n     * @return {Array.<number>}\n     */\n    calculateTransform: function (b) {\n        var a = this;\n        var sx = b.width / a.width;\n        var sy = b.height / a.height;\n\n        var m = create$1();\n\n        // \n        translate(m, m, [-a.x, -a.y]);\n        scale$1(m, m, [sx, sy]);\n        translate(m, m, [b.x, b.y]);\n\n        return m;\n    },\n\n    /**\n     * @param {(module:echarts/core/BoundingRect|Object)} b\n     * @return {boolean}\n     */\n    intersect: function (b) {\n        if (!b) {\n            return false;\n        }\n\n        if (!(b instanceof BoundingRect)) {\n            // Normalize negative width/height.\n            b = BoundingRect.create(b);\n        }\n\n        var a = this;\n        var ax0 = a.x;\n        var ax1 = a.x + a.width;\n        var ay0 = a.y;\n        var ay1 = a.y + a.height;\n\n        var bx0 = b.x;\n        var bx1 = b.x + b.width;\n        var by0 = b.y;\n        var by1 = b.y + b.height;\n\n        return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n    },\n\n    contain: function (x, y) {\n        var rect = this;\n        return x >= rect.x\n            && x <= (rect.x + rect.width)\n            && y >= rect.y\n            && y <= (rect.y + rect.height);\n    },\n\n    /**\n     * @return {module:echarts/core/BoundingRect}\n     */\n    clone: function () {\n        return new BoundingRect(this.x, this.y, this.width, this.height);\n    },\n\n    /**\n     * Copy from another rect\n     */\n    copy: function (other) {\n        this.x = other.x;\n        this.y = other.y;\n        this.width = other.width;\n        this.height = other.height;\n    },\n\n    plain: function () {\n        return {\n            x: this.x,\n            y: this.y,\n            width: this.width,\n            height: this.height\n        };\n    }\n};\n\n/**\n * @param {Object|module:zrender/core/BoundingRect} rect\n * @param {number} rect.x\n * @param {number} rect.y\n * @param {number} rect.width\n * @param {number} rect.height\n * @return {module:zrender/core/BoundingRect}\n */\nBoundingRect.create = function (rect) {\n    return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n};\n\n/**\n * GroupGroup\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/container/Group');\n *     var Circle = require('zrender/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n/**\n * @alias module:zrender/graphic/Group\n * @constructor\n * @extends module:zrender/mixin/Transformable\n * @extends module:zrender/mixin/Eventful\n */\nvar Group = function (opts) {\n\n    opts = opts || {};\n\n    Element.call(this, opts);\n\n    for (var key in opts) {\n        if (opts.hasOwnProperty(key)) {\n            this[key] = opts[key];\n        }\n    }\n\n    this._children = [];\n\n    this.__storage = null;\n\n    this.__dirty = true;\n};\n\nGroup.prototype = {\n\n    constructor: Group,\n\n    isGroup: true,\n\n    /**\n     * @type {string}\n     */\n    type: 'group',\n\n    /**\n     * \n     * @name module:/zrender/container/Group#silent\n     * @type {boolean}\n     * @default false\n     */\n    silent: false,\n\n    /**\n     * @return {Array.<module:zrender/Element>}\n     */\n    children: function () {\n        return this._children.slice();\n    },\n\n    /**\n     *  index \n     * @param  {number} idx\n     * @return {module:zrender/Element}\n     */\n    childAt: function (idx) {\n        return this._children[idx];\n    },\n\n    /**\n     * \n     * @param  {string} name\n     * @return {module:zrender/Element}\n     */\n    childOfName: function (name) {\n        var children = this._children;\n        for (var i = 0; i < children.length; i++) {\n            if (children[i].name === name) {\n                return children[i];\n            }\n            }\n    },\n\n    /**\n     * @return {number}\n     */\n    childCount: function () {\n        return this._children.length;\n    },\n\n    /**\n     * \n     * @param {module:zrender/Element} child\n     */\n    add: function (child) {\n        if (child && child !== this && child.parent !== this) {\n\n            this._children.push(child);\n\n            this._doAdd(child);\n        }\n\n        return this;\n    },\n\n    /**\n     *  nextSibling \n     * @param {module:zrender/Element} child\n     * @param {module:zrender/Element} nextSibling\n     */\n    addBefore: function (child, nextSibling) {\n        if (child && child !== this && child.parent !== this\n            && nextSibling && nextSibling.parent === this) {\n\n            var children = this._children;\n            var idx = children.indexOf(nextSibling);\n\n            if (idx >= 0) {\n                children.splice(idx, 0, child);\n                this._doAdd(child);\n            }\n        }\n\n        return this;\n    },\n\n    _doAdd: function (child) {\n        if (child.parent) {\n            child.parent.remove(child);\n        }\n\n        child.parent = this;\n\n        var storage = this.__storage;\n        var zr = this.__zr;\n        if (storage && storage !== child.__storage) {\n\n            storage.addToStorage(child);\n\n            if (child instanceof Group) {\n                child.addChildrenToStorage(storage);\n            }\n        }\n\n        zr && zr.refresh();\n    },\n\n    /**\n     * \n     * @param {module:zrender/Element} child\n     */\n    remove: function (child) {\n        var zr = this.__zr;\n        var storage = this.__storage;\n        var children = this._children;\n\n        var idx = indexOf(children, child);\n        if (idx < 0) {\n            return this;\n        }\n        children.splice(idx, 1);\n\n        child.parent = null;\n\n        if (storage) {\n\n            storage.delFromStorage(child);\n\n            if (child instanceof Group) {\n                child.delChildrenFromStorage(storage);\n            }\n        }\n\n        zr && zr.refresh();\n\n        return this;\n    },\n\n    /**\n     * \n     */\n    removeAll: function () {\n        var children = this._children;\n        var storage = this.__storage;\n        var child;\n        var i;\n        for (i = 0; i < children.length; i++) {\n            child = children[i];\n            if (storage) {\n                storage.delFromStorage(child);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n            child.parent = null;\n        }\n        children.length = 0;\n\n        return this;\n    },\n\n    /**\n     * \n     * @param  {Function} cb\n     * @param  {}   context\n     */\n    eachChild: function (cb, context) {\n        var children = this._children;\n        for (var i = 0; i < children.length; i++) {\n            var child = children[i];\n            cb.call(context, child, i);\n        }\n        return this;\n    },\n\n    /**\n     * \n     * @param  {Function} cb\n     * @param  {}   context\n     */\n    traverse: function (cb, context) {\n        for (var i = 0; i < this._children.length; i++) {\n            var child = this._children[i];\n            cb.call(context, child);\n\n            if (child.type === 'group') {\n                child.traverse(cb, context);\n            }\n        }\n        return this;\n    },\n\n    addChildrenToStorage: function (storage) {\n        for (var i = 0; i < this._children.length; i++) {\n            var child = this._children[i];\n            storage.addToStorage(child);\n            if (child instanceof Group) {\n                child.addChildrenToStorage(storage);\n            }\n        }\n    },\n\n    delChildrenFromStorage: function (storage) {\n        for (var i = 0; i < this._children.length; i++) {\n            var child = this._children[i];\n            storage.delFromStorage(child);\n            if (child instanceof Group) {\n                child.delChildrenFromStorage(storage);\n            }\n        }\n    },\n\n    dirty: function () {\n        this.__dirty = true;\n        this.__zr && this.__zr.refresh();\n        return this;\n    },\n\n    /**\n     * @return {module:zrender/core/BoundingRect}\n     */\n    getBoundingRect: function (includeChildren) {\n        // TODO Caching\n        var rect = null;\n        var tmpRect = new BoundingRect(0, 0, 0, 0);\n        var children = includeChildren || this._children;\n        var tmpMat = [];\n\n        for (var i = 0; i < children.length; i++) {\n            var child = children[i];\n            if (child.ignore || child.invisible) {\n                continue;\n            }\n\n            var childRect = child.getBoundingRect();\n            var transform = child.getLocalTransform(tmpMat);\n            // TODO\n            // The boundingRect cacluated by transforming original\n            // rect may be bigger than the actual bundingRect when rotation\n            // is used. (Consider a circle rotated aginst its center, where\n            // the actual boundingRect should be the same as that not be\n            // rotated.) But we can not find better approach to calculate\n            // actual boundingRect yet, considering performance.\n            if (transform) {\n                tmpRect.copy(childRect);\n                tmpRect.applyTransform(transform);\n                rect = rect || tmpRect.clone();\n                rect.union(tmpRect);\n            }\n            else {\n                rect = rect || childRect.clone();\n                rect.union(childRect);\n            }\n        }\n        return rect || tmpRect;\n    }\n};\n\ninherits(Group, Element);\n\n// https://github.com/mziccard/node-timsort\nvar DEFAULT_MIN_MERGE = 32;\n\nvar DEFAULT_MIN_GALLOPING = 7;\n\nfunction minRunLength(n) {\n    var r = 0;\n\n    while (n >= DEFAULT_MIN_MERGE) {\n        r |= n & 1;\n        n >>= 1;\n    }\n\n    return n + r;\n}\n\nfunction makeAscendingRun(array, lo, hi, compare) {\n    var runHi = lo + 1;\n\n    if (runHi === hi) {\n        return 1;\n    }\n\n    if (compare(array[runHi++], array[lo]) < 0) {\n        while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n            runHi++;\n        }\n\n        reverseRun(array, lo, runHi);\n    }\n    else {\n        while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n            runHi++;\n        }\n    }\n\n    return runHi - lo;\n}\n\nfunction reverseRun(array, lo, hi) {\n    hi--;\n\n    while (lo < hi) {\n        var t = array[lo];\n        array[lo++] = array[hi];\n        array[hi--] = t;\n    }\n}\n\nfunction binaryInsertionSort(array, lo, hi, start, compare) {\n    if (start === lo) {\n        start++;\n    }\n\n    for (; start < hi; start++) {\n        var pivot = array[start];\n\n        var left = lo;\n        var right = start;\n        var mid;\n\n        while (left < right) {\n            mid = left + right >>> 1;\n\n            if (compare(pivot, array[mid]) < 0) {\n                right = mid;\n            }\n            else {\n                left = mid + 1;\n            }\n        }\n\n        var n = start - left;\n\n        switch (n) {\n            case 3:\n                array[left + 3] = array[left + 2];\n\n            case 2:\n                array[left + 2] = array[left + 1];\n\n            case 1:\n                array[left + 1] = array[left];\n                break;\n            default:\n                while (n > 0) {\n                    array[left + n] = array[left + n - 1];\n                    n--;\n                }\n        }\n\n        array[left] = pivot;\n    }\n}\n\nfunction gallopLeft(value, array, start, length, hint, compare) {\n    var lastOffset = 0;\n    var maxOffset = 0;\n    var offset = 1;\n\n    if (compare(value, array[start + hint]) > 0) {\n        maxOffset = length - hint;\n\n        while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n            lastOffset = offset;\n            offset = (offset << 1) + 1;\n\n            if (offset <= 0) {\n                offset = maxOffset;\n            }\n        }\n\n        if (offset > maxOffset) {\n            offset = maxOffset;\n        }\n\n        lastOffset += hint;\n        offset += hint;\n    }\n    else {\n        maxOffset = hint + 1;\n        while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n            lastOffset = offset;\n            offset = (offset << 1) + 1;\n\n            if (offset <= 0) {\n                offset = maxOffset;\n            }\n        }\n        if (offset > maxOffset) {\n            offset = maxOffset;\n        }\n\n        var tmp = lastOffset;\n        lastOffset = hint - offset;\n        offset = hint - tmp;\n    }\n\n    lastOffset++;\n    while (lastOffset < offset) {\n        var m = lastOffset + (offset - lastOffset >>> 1);\n\n        if (compare(value, array[start + m]) > 0) {\n            lastOffset = m + 1;\n        }\n        else {\n            offset = m;\n        }\n    }\n    return offset;\n}\n\nfunction gallopRight(value, array, start, length, hint, compare) {\n    var lastOffset = 0;\n    var maxOffset = 0;\n    var offset = 1;\n\n    if (compare(value, array[start + hint]) < 0) {\n        maxOffset = hint + 1;\n\n        while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n            lastOffset = offset;\n            offset = (offset << 1) + 1;\n\n            if (offset <= 0) {\n                offset = maxOffset;\n            }\n        }\n\n        if (offset > maxOffset) {\n            offset = maxOffset;\n        }\n\n        var tmp = lastOffset;\n        lastOffset = hint - offset;\n        offset = hint - tmp;\n    }\n    else {\n        maxOffset = length - hint;\n\n        while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n            lastOffset = offset;\n            offset = (offset << 1) + 1;\n\n            if (offset <= 0) {\n                offset = maxOffset;\n            }\n        }\n\n        if (offset > maxOffset) {\n            offset = maxOffset;\n        }\n\n        lastOffset += hint;\n        offset += hint;\n    }\n\n    lastOffset++;\n\n    while (lastOffset < offset) {\n        var m = lastOffset + (offset - lastOffset >>> 1);\n\n        if (compare(value, array[start + m]) < 0) {\n            offset = m;\n        }\n        else {\n            lastOffset = m + 1;\n        }\n    }\n\n    return offset;\n}\n\nfunction TimSort(array, compare) {\n    var minGallop = DEFAULT_MIN_GALLOPING;\n    var runStart;\n    var runLength;\n    var stackSize = 0;\n\n    var tmp = [];\n\n    runStart = [];\n    runLength = [];\n\n    function pushRun(_runStart, _runLength) {\n        runStart[stackSize] = _runStart;\n        runLength[stackSize] = _runLength;\n        stackSize += 1;\n    }\n\n    function mergeRuns() {\n        while (stackSize > 1) {\n            var n = stackSize - 2;\n\n            if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                if (runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n            }\n            else if (runLength[n] > runLength[n + 1]) {\n                break;\n            }\n            mergeAt(n);\n        }\n    }\n\n    function forceMergeRuns() {\n        while (stackSize > 1) {\n            var n = stackSize - 2;\n\n            if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                n--;\n            }\n\n            mergeAt(n);\n        }\n    }\n\n    function mergeAt(i) {\n        var start1 = runStart[i];\n        var length1 = runLength[i];\n        var start2 = runStart[i + 1];\n        var length2 = runLength[i + 1];\n\n        runLength[i] = length1 + length2;\n\n        if (i === stackSize - 3) {\n            runStart[i + 1] = runStart[i + 2];\n            runLength[i + 1] = runLength[i + 2];\n        }\n\n        stackSize--;\n\n        var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n        start1 += k;\n        length1 -= k;\n\n        if (length1 === 0) {\n            return;\n        }\n\n        length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n        if (length2 === 0) {\n            return;\n        }\n\n        if (length1 <= length2) {\n            mergeLow(start1, length1, start2, length2);\n        }\n        else {\n            mergeHigh(start1, length1, start2, length2);\n        }\n    }\n\n    function mergeLow(start1, length1, start2, length2) {\n        var i = 0;\n\n        for (i = 0; i < length1; i++) {\n            tmp[i] = array[start1 + i];\n        }\n\n        var cursor1 = 0;\n        var cursor2 = start2;\n        var dest = start1;\n\n        array[dest++] = array[cursor2++];\n\n        if (--length2 === 0) {\n            for (i = 0; i < length1; i++) {\n                array[dest + i] = tmp[cursor1 + i];\n            }\n            return;\n        }\n\n        if (length1 === 1) {\n            for (i = 0; i < length2; i++) {\n                array[dest + i] = array[cursor2 + i];\n            }\n            array[dest + length2] = tmp[cursor1];\n            return;\n        }\n\n        var _minGallop = minGallop;\n        var count1, count2, exit;\n\n        while (1) {\n            count1 = 0;\n            count2 = 0;\n            exit = false;\n\n            do {\n                if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                    array[dest++] = array[cursor2++];\n                    count2++;\n                    count1 = 0;\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n                }\n                else {\n                    array[dest++] = tmp[cursor1++];\n                    count1++;\n                    count2 = 0;\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n                }\n            } while ((count1 | count2) < _minGallop);\n\n            if (exit) {\n                break;\n            }\n\n            do {\n                count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                if (count1 !== 0) {\n                    for (i = 0; i < count1; i++) {\n                        array[dest + i] = tmp[cursor1 + i];\n                    }\n\n                    dest += count1;\n                    cursor1 += count1;\n                    length1 -= count1;\n                    if (length1 <= 1) {\n                        exit = true;\n                        break;\n                    }\n                }\n\n                array[dest++] = array[cursor2++];\n\n                if (--length2 === 0) {\n                    exit = true;\n                    break;\n                }\n\n                count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                if (count2 !== 0) {\n                    for (i = 0; i < count2; i++) {\n                        array[dest + i] = array[cursor2 + i];\n                    }\n\n                    dest += count2;\n                    cursor2 += count2;\n                    length2 -= count2;\n\n                    if (length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n                }\n                array[dest++] = tmp[cursor1++];\n\n                if (--length1 === 1) {\n                    exit = true;\n                    break;\n                }\n\n                _minGallop--;\n            } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n            if (exit) {\n                break;\n            }\n\n            if (_minGallop < 0) {\n                _minGallop = 0;\n            }\n\n            _minGallop += 2;\n        }\n\n        minGallop = _minGallop;\n\n        minGallop < 1 && (minGallop = 1);\n\n        if (length1 === 1) {\n            for (i = 0; i < length2; i++) {\n                array[dest + i] = array[cursor2 + i];\n            }\n            array[dest + length2] = tmp[cursor1];\n        }\n        else if (length1 === 0) {\n            throw new Error();\n            // throw new Error('mergeLow preconditions were not respected');\n        }\n        else {\n            for (i = 0; i < length1; i++) {\n                array[dest + i] = tmp[cursor1 + i];\n            }\n        }\n    }\n\n    function mergeHigh (start1, length1, start2, length2) {\n        var i = 0;\n\n        for (i = 0; i < length2; i++) {\n            tmp[i] = array[start2 + i];\n        }\n\n        var cursor1 = start1 + length1 - 1;\n        var cursor2 = length2 - 1;\n        var dest = start2 + length2 - 1;\n        var customCursor = 0;\n        var customDest = 0;\n\n        array[dest--] = array[cursor1--];\n\n        if (--length1 === 0) {\n            customCursor = dest - (length2 - 1);\n\n            for (i = 0; i < length2; i++) {\n                array[customCursor + i] = tmp[i];\n            }\n\n            return;\n        }\n\n        if (length2 === 1) {\n            dest -= length1;\n            cursor1 -= length1;\n            customDest = dest + 1;\n            customCursor = cursor1 + 1;\n\n            for (i = length1 - 1; i >= 0; i--) {\n                array[customDest + i] = array[customCursor + i];\n            }\n\n            array[dest] = tmp[cursor2];\n            return;\n        }\n\n        var _minGallop = minGallop;\n\n        while (true) {\n            var count1 = 0;\n            var count2 = 0;\n            var exit = false;\n\n            do {\n                if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                    array[dest--] = array[cursor1--];\n                    count1++;\n                    count2 = 0;\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n                }\n                else {\n                    array[dest--] = tmp[cursor2--];\n                    count2++;\n                    count1 = 0;\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n                }\n            } while ((count1 | count2) < _minGallop);\n\n            if (exit) {\n                break;\n            }\n\n            do {\n                count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                if (count1 !== 0) {\n                    dest -= count1;\n                    cursor1 -= count1;\n                    length1 -= count1;\n                    customDest = dest + 1;\n                    customCursor = cursor1 + 1;\n\n                    for (i = count1 - 1; i >= 0; i--) {\n                        array[customDest + i] = array[customCursor + i];\n                    }\n\n                    if (length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n                }\n\n                array[dest--] = tmp[cursor2--];\n\n                if (--length2 === 1) {\n                    exit = true;\n                    break;\n                }\n\n                count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                if (count2 !== 0) {\n                    dest -= count2;\n                    cursor2 -= count2;\n                    length2 -= count2;\n                    customDest = dest + 1;\n                    customCursor = cursor2 + 1;\n\n                    for (i = 0; i < count2; i++) {\n                        array[customDest + i] = tmp[customCursor + i];\n                    }\n\n                    if (length2 <= 1) {\n                        exit = true;\n                        break;\n                    }\n                }\n\n                array[dest--] = array[cursor1--];\n\n                if (--length1 === 0) {\n                    exit = true;\n                    break;\n                }\n\n                _minGallop--;\n            } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n            if (exit) {\n                break;\n            }\n\n            if (_minGallop < 0) {\n                _minGallop = 0;\n            }\n\n            _minGallop += 2;\n        }\n\n        minGallop = _minGallop;\n\n        if (minGallop < 1) {\n            minGallop = 1;\n        }\n\n        if (length2 === 1) {\n            dest -= length1;\n            cursor1 -= length1;\n            customDest = dest + 1;\n            customCursor = cursor1 + 1;\n\n            for (i = length1 - 1; i >= 0; i--) {\n                array[customDest + i] = array[customCursor + i];\n            }\n\n            array[dest] = tmp[cursor2];\n        }\n        else if (length2 === 0) {\n            throw new Error();\n            // throw new Error('mergeHigh preconditions were not respected');\n        }\n        else {\n            customCursor = dest - (length2 - 1);\n            for (i = 0; i < length2; i++) {\n                array[customCursor + i] = tmp[i];\n            }\n        }\n    }\n\n    this.mergeRuns = mergeRuns;\n    this.forceMergeRuns = forceMergeRuns;\n    this.pushRun = pushRun;\n}\n\nfunction sort(array, compare, lo, hi) {\n    if (!lo) {\n        lo = 0;\n    }\n    if (!hi) {\n        hi = array.length;\n    }\n\n    var remaining = hi - lo;\n\n    if (remaining < 2) {\n        return;\n    }\n\n    var runLength = 0;\n\n    if (remaining < DEFAULT_MIN_MERGE) {\n        runLength = makeAscendingRun(array, lo, hi, compare);\n        binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n        return;\n    }\n\n    var ts = new TimSort(array, compare);\n\n    var minRun = minRunLength(remaining);\n\n    do {\n        runLength = makeAscendingRun(array, lo, hi, compare);\n        if (runLength < minRun) {\n            var force = remaining;\n            if (force > minRun) {\n                force = minRun;\n            }\n\n            binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n            runLength = force;\n        }\n\n        ts.pushRun(lo, runLength);\n        ts.mergeRuns();\n\n        remaining -= runLength;\n        lo += runLength;\n    } while (remaining !== 0);\n\n    ts.forceMergeRuns();\n}\n\n/**\n * Storage\n * @module zrender/Storage\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n// Use timsort because in most case elements are partially sorted\n// https://jsfiddle.net/pissang/jr4x7mdm/8/\nfunction shapeCompareFunc(a, b) {\n    if (a.zlevel === b.zlevel) {\n        if (a.z === b.z) {\n            // if (a.z2 === b.z2) {\n            //     // FIXME Slow has renderidx compare\n            //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n            //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n            //     return a.__renderidx - b.__renderidx;\n            // }\n            return a.z2 - b.z2;\n        }\n        return a.z - b.z;\n    }\n    return a.zlevel - b.zlevel;\n}\n/**\n *  (M)\n * @alias module:zrender/Storage\n * @constructor\n */\nvar Storage = function () { // jshint ignore:line\n    this._roots = [];\n\n    this._displayList = [];\n\n    this._displayListLen = 0;\n};\n\nStorage.prototype = {\n\n    constructor: Storage,\n\n    /**\n     * @param  {Function} cb\n     *\n     */\n    traverse: function (cb, context) {\n        for (var i = 0; i < this._roots.length; i++) {\n            this._roots[i].traverse(cb, context);\n        }\n    },\n\n    /**\n     * \n     * @param {boolean} [update=false] \n     * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n     *\n     * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n     * @return {Array.<module:zrender/graphic/Displayable>}\n     */\n    getDisplayList: function (update, includeIgnore) {\n        includeIgnore = includeIgnore || false;\n        if (update) {\n            this.updateDisplayList(includeIgnore);\n        }\n        return this._displayList;\n    },\n\n    /**\n     * \n     * GroupShapeShape\n     * zlevel > z > \n     * @param {boolean} [includeIgnore=false]  ignore \n     */\n    updateDisplayList: function (includeIgnore) {\n        this._displayListLen = 0;\n        var roots = this._roots;\n        var displayList = this._displayList;\n        for (var i = 0, len = roots.length; i < len; i++) {\n            this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n        }\n        displayList.length = this._displayListLen;\n\n        // for (var i = 0, len = displayList.length; i < len; i++) {\n        //     displayList[i].__renderidx = i;\n        // }\n\n        // displayList.sort(shapeCompareFunc);\n        env$1.canvasSupported && sort(displayList, shapeCompareFunc);\n    },\n\n    _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n        if (el.ignore && !includeIgnore) {\n            return;\n        }\n\n        el.beforeUpdate();\n\n        if (el.__dirty) {\n\n            el.update();\n\n        }\n\n        el.afterUpdate();\n\n        var userSetClipPath = el.clipPath;\n        if (userSetClipPath) {\n\n            // FIXME \n            if (clipPaths) {\n                clipPaths = clipPaths.slice();\n            }\n            else {\n                clipPaths = [];\n            }\n\n            var currentClipPath = userSetClipPath;\n            var parentClipPath = el;\n            // Recursively add clip path\n            while (currentClipPath) {\n                // clipPath  clipPath \n                currentClipPath.parent = parentClipPath;\n                currentClipPath.updateTransform();\n\n                clipPaths.push(currentClipPath);\n\n                parentClipPath = currentClipPath;\n                currentClipPath = currentClipPath.clipPath;\n            }\n        }\n\n        if (el.isGroup) {\n            var children = el._children;\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n\n                // Force to mark as dirty if group is dirty\n                // FIXME __dirtyPath ?\n                if (el.__dirty) {\n                    child.__dirty = true;\n                }\n\n                this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n            }\n\n            // Mark group clean here\n            el.__dirty = false;\n\n        }\n        else {\n            el.__clipPaths = clipPaths;\n\n            this._displayList[this._displayListLen++] = el;\n        }\n    },\n\n    /**\n     * (Shape)(Group)\n     * @param {module:zrender/Element} el\n     */\n    addRoot: function (el) {\n        if (el.__storage === this) {\n            return;\n        }\n\n        if (el instanceof Group) {\n            el.addChildrenToStorage(this);\n        }\n\n        this.addToStorage(el);\n        this._roots.push(el);\n    },\n\n    /**\n     * (Shape)(Group)\n     * @param {string|Array.<string>} [el] Storage\n     */\n    delRoot: function (el) {\n        if (el == null) {\n            // el\n            for (var i = 0; i < this._roots.length; i++) {\n                var root = this._roots[i];\n                if (root instanceof Group) {\n                    root.delChildrenFromStorage(this);\n                }\n            }\n\n            this._roots = [];\n            this._displayList = [];\n            this._displayListLen = 0;\n\n            return;\n        }\n\n        if (el instanceof Array) {\n            for (var i = 0, l = el.length; i < l; i++) {\n                this.delRoot(el[i]);\n            }\n            return;\n        }\n\n\n        var idx = indexOf(this._roots, el);\n        if (idx >= 0) {\n            this.delFromStorage(el);\n            this._roots.splice(idx, 1);\n            if (el instanceof Group) {\n                el.delChildrenFromStorage(this);\n            }\n        }\n    },\n\n    addToStorage: function (el) {\n        el.__storage = this;\n        el.dirty(false);\n\n        return this;\n    },\n\n    delFromStorage: function (el) {\n        if (el) {\n            el.__storage = null;\n        }\n\n        return this;\n    },\n\n    /**\n     * Storage\n     */\n    dispose: function () {\n        this._renderList =\n        this._roots = null;\n    },\n\n    displayableSortFunc: shapeCompareFunc\n};\n\nvar STYLE_COMMON_PROPS = [\n    ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n    ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n];\n\n// var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\nvar Style = function (opts, host) {\n    this.extendFrom(opts, false);\n    this.host = host;\n};\n\nfunction createLinearGradient(ctx, obj, rect) {\n    var x = obj.x == null ? 0 : obj.x;\n    var x2 = obj.x2 == null ? 1 : obj.x2;\n    var y = obj.y == null ? 0 : obj.y;\n    var y2 = obj.y2 == null ? 0 : obj.y2;\n\n    if (!obj.global) {\n        x = x * rect.width + rect.x;\n        x2 = x2 * rect.width + rect.x;\n        y = y * rect.height + rect.y;\n        y2 = y2 * rect.height + rect.y;\n    }\n\n    var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n    return canvasGradient;\n}\n\nfunction createRadialGradient(ctx, obj, rect) {\n    var width = rect.width;\n    var height = rect.height;\n    var min = Math.min(width, height);\n\n    var x = obj.x == null ? 0.5 : obj.x;\n    var y = obj.y == null ? 0.5 : obj.y;\n    var r = obj.r == null ? 0.5 : obj.r;\n    if (!obj.global) {\n        x = x * width + rect.x;\n        y = y * height + rect.y;\n        r = r * min;\n    }\n\n    var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n    return canvasGradient;\n}\n\n\nStyle.prototype = {\n\n    constructor: Style,\n\n    /**\n     * @type {module:zrender/graphic/Displayable}\n     */\n    host: null,\n\n    /**\n     * @type {string}\n     */\n    fill: '#000',\n\n    /**\n     * @type {string}\n     */\n    stroke: null,\n\n    /**\n     * @type {number}\n     */\n    opacity: 1,\n\n    /**\n     * @type {Array.<number>}\n     */\n    lineDash: null,\n\n    /**\n     * @type {number}\n     */\n    lineDashOffset: 0,\n\n    /**\n     * @type {number}\n     */\n    shadowBlur: 0,\n\n    /**\n     * @type {number}\n     */\n    shadowOffsetX: 0,\n\n    /**\n     * @type {number}\n     */\n    shadowOffsetY: 0,\n\n    /**\n     * @type {number}\n     */\n    lineWidth: 1,\n\n    /**\n     * If stroke ignore scale\n     * @type {Boolean}\n     */\n    strokeNoScale: false,\n\n    // Bounding rect text configuration\n    // Not affected by element transform\n    /**\n     * @type {string}\n     */\n    text: null,\n\n    /**\n     * If `fontSize` or `fontFamily` exists, `font` will be reset by\n     * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.\n     * So do not visit it directly in upper application (like echarts),\n     * but use `contain/text#makeFont` instead.\n     * @type {string}\n     */\n    font: null,\n\n    /**\n     * The same as font. Use font please.\n     * @deprecated\n     * @type {string}\n     */\n    textFont: null,\n\n    /**\n     * It helps merging respectively, rather than parsing an entire font string.\n     * @type {string}\n     */\n    fontStyle: null,\n\n    /**\n     * It helps merging respectively, rather than parsing an entire font string.\n     * @type {string}\n     */\n    fontWeight: null,\n\n    /**\n     * It helps merging respectively, rather than parsing an entire font string.\n     * Should be 12 but not '12px'.\n     * @type {number}\n     */\n    fontSize: null,\n\n    /**\n     * It helps merging respectively, rather than parsing an entire font string.\n     * @type {string}\n     */\n    fontFamily: null,\n\n    /**\n     * Reserved for special functinality, like 'hr'.\n     * @type {string}\n     */\n    textTag: null,\n\n    /**\n     * @type {string}\n     */\n    textFill: '#000',\n\n    /**\n     * @type {string}\n     */\n    textStroke: null,\n\n    /**\n     * @type {number}\n     */\n    textWidth: null,\n\n    /**\n     * Only for textBackground.\n     * @type {number}\n     */\n    textHeight: null,\n\n    /**\n     * textStroke may be set as some color as a default\n     * value in upper applicaion, where the default value\n     * of textStrokeWidth should be 0 to make sure that\n     * user can choose to do not use text stroke.\n     * @type {number}\n     */\n    textStrokeWidth: 0,\n\n    /**\n     * @type {number}\n     */\n    textLineHeight: null,\n\n    /**\n     * 'inside', 'left', 'right', 'top', 'bottom'\n     * [x, y]\n     * Based on x, y of rect.\n     * @type {string|Array.<number>}\n     * @default 'inside'\n     */\n    textPosition: 'inside',\n\n    /**\n     * If not specified, use the boundingRect of a `displayable`.\n     * @type {Object}\n     */\n    textRect: null,\n\n    /**\n     * [x, y]\n     * @type {Array.<number>}\n     */\n    textOffset: null,\n\n    /**\n     * @type {string}\n     */\n    textAlign: null,\n\n    /**\n     * @type {string}\n     */\n    textVerticalAlign: null,\n\n    /**\n     * @type {number}\n     */\n    textDistance: 5,\n\n    /**\n     * @type {string}\n     */\n    textShadowColor: 'transparent',\n\n    /**\n     * @type {number}\n     */\n    textShadowBlur: 0,\n\n    /**\n     * @type {number}\n     */\n    textShadowOffsetX: 0,\n\n    /**\n     * @type {number}\n     */\n    textShadowOffsetY: 0,\n\n    /**\n     * @type {string}\n     */\n    textBoxShadowColor: 'transparent',\n\n    /**\n     * @type {number}\n     */\n    textBoxShadowBlur: 0,\n\n    /**\n     * @type {number}\n     */\n    textBoxShadowOffsetX: 0,\n\n    /**\n     * @type {number}\n     */\n    textBoxShadowOffsetY: 0,\n\n    /**\n     * Whether transform text.\n     * Only useful in Path and Image element\n     * @type {boolean}\n     */\n    transformText: false,\n\n    /**\n     * Text rotate around position of Path or Image\n     * Only useful in Path and Image element and transformText is false.\n     */\n    textRotation: 0,\n\n    /**\n     * Text origin of text rotation, like [10, 40].\n     * Based on x, y of rect.\n     * Useful in label rotation of circular symbol.\n     * By default, this origin is textPosition.\n     * Can be 'center'.\n     * @type {string|Array.<number>}\n     */\n    textOrigin: null,\n\n    /**\n     * @type {string}\n     */\n    textBackgroundColor: null,\n\n    /**\n     * @type {string}\n     */\n    textBorderColor: null,\n\n    /**\n     * @type {number}\n     */\n    textBorderWidth: 0,\n\n    /**\n     * @type {number}\n     */\n    textBorderRadius: 0,\n\n    /**\n     * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`\n     * @type {number|Array.<number>}\n     */\n    textPadding: null,\n\n    /**\n     * Text styles for rich text.\n     * @type {Object}\n     */\n    rich: null,\n\n    /**\n     * {outerWidth, outerHeight, ellipsis, placeholder}\n     * @type {Object}\n     */\n    truncate: null,\n\n    /**\n     * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n     * @type {string}\n     */\n    blend: null,\n\n    /**\n     * @param {CanvasRenderingContext2D} ctx\n     */\n    bind: function (ctx, el, prevEl) {\n        var style = this;\n        var prevStyle = prevEl && prevEl.style;\n        var firstDraw = !prevStyle;\n\n        for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n            var prop = STYLE_COMMON_PROPS[i];\n            var styleName = prop[0];\n\n            if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                // FIXME Invalid property value will cause style leak from previous element.\n                ctx[styleName] = style[styleName] || prop[1];\n            }\n        }\n\n        if ((firstDraw || style.fill !== prevStyle.fill)) {\n            ctx.fillStyle = style.fill;\n        }\n        if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n            ctx.strokeStyle = style.stroke;\n        }\n        if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n            ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n        }\n\n        if ((firstDraw || style.blend !== prevStyle.blend)) {\n            ctx.globalCompositeOperation = style.blend || 'source-over';\n        }\n        if (this.hasStroke()) {\n            var lineWidth = style.lineWidth;\n            ctx.lineWidth = lineWidth / (\n                (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n            );\n        }\n    },\n\n    hasFill: function () {\n        var fill = this.fill;\n        return fill != null && fill !== 'none';\n    },\n\n    hasStroke: function () {\n        var stroke = this.stroke;\n        return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n    },\n\n    /**\n     * Extend from other style\n     * @param {zrender/graphic/Style} otherStyle\n     * @param {boolean} overwrite true: overwrirte any way.\n     *                            false: overwrite only when !target.hasOwnProperty\n     *                            others: overwrite when property is not null/undefined.\n     */\n    extendFrom: function (otherStyle, overwrite) {\n        if (otherStyle) {\n            for (var name in otherStyle) {\n                if (otherStyle.hasOwnProperty(name)\n                    && (overwrite === true\n                        || (\n                            overwrite === false\n                                ? !this.hasOwnProperty(name)\n                                : otherStyle[name] != null\n                        )\n                    )\n                ) {\n                    this[name] = otherStyle[name];\n                }\n            }\n        }\n    },\n\n    /**\n     * Batch setting style with a given object\n     * @param {Object|string} obj\n     * @param {*} [obj]\n     */\n    set: function (obj, value) {\n        if (typeof obj === 'string') {\n            this[obj] = value;\n        }\n        else {\n            this.extendFrom(obj, true);\n        }\n    },\n\n    /**\n     * Clone\n     * @return {zrender/graphic/Style} [description]\n     */\n    clone: function () {\n        var newStyle = new this.constructor();\n        newStyle.extendFrom(this, true);\n        return newStyle;\n    },\n\n    getGradient: function (ctx, obj, rect) {\n        var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n        var canvasGradient = method(ctx, obj, rect);\n        var colorStops = obj.colorStops;\n        for (var i = 0; i < colorStops.length; i++) {\n            canvasGradient.addColorStop(\n                colorStops[i].offset, colorStops[i].color\n            );\n        }\n        return canvasGradient;\n    }\n\n};\n\nvar styleProto = Style.prototype;\nfor (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n    var prop = STYLE_COMMON_PROPS[i];\n    if (!(prop[0] in styleProto)) {\n        styleProto[prop[0]] = prop[1];\n    }\n}\n\n// Provide for others\nStyle.getGradient = styleProto.getGradient;\n\nvar Pattern = function (image, repeat) {\n    // Should do nothing more in this constructor. Because gradient can be\n    // declard by `color: {image: ...}`, where this constructor will not be called.\n\n    this.image = image;\n    this.repeat = repeat;\n\n    // Can be cloned\n    this.type = 'pattern';\n};\n\nPattern.prototype.getCanvasPattern = function (ctx) {\n    return ctx.createPattern(this.image, this.repeat || 'repeat');\n};\n\n/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\nfunction returnFalse() {\n    return false;\n}\n\n/**\n * dom\n *\n * @inner\n * @param {string} id dom id \n * @param {Painter} painter painter instance\n * @param {number} number\n */\nfunction createDom(id, painter, dpr) {\n    var newDom = createCanvas();\n    var width = painter.getWidth();\n    var height = painter.getHeight();\n\n    var newDomStyle = newDom.style;\n    // append~\n    newDomStyle.position = 'absolute';\n    newDomStyle.left = 0;\n    newDomStyle.top = 0;\n    newDomStyle.width = width + 'px';\n    newDomStyle.height = height + 'px';\n    newDom.width = width * dpr;\n    newDom.height = height * dpr;\n\n    // id\n    newDom.setAttribute('data-zr-dom-id', id);\n    return newDom;\n}\n\n/**\n * @alias module:zrender/Layer\n * @constructor\n * @extends module:zrender/mixin/Transformable\n * @param {string} id\n * @param {module:zrender/Painter} painter\n * @param {number} [dpr]\n */\nvar Layer = function(id, painter, dpr) {\n    var dom;\n    dpr = dpr || devicePixelRatio;\n    if (typeof id === 'string') {\n        dom = createDom(id, painter, dpr);\n    }\n    // Not using isDom because in node it will return false\n    else if (isObject(id)) {\n        dom = id;\n        id = dom.id;\n    }\n    this.id = id;\n    this.dom = dom;\n\n    var domStyle = dom.style;\n    if (domStyle) { // Not in node\n        dom.onselectstart = returnFalse; // \n        domStyle['-webkit-user-select'] = 'none';\n        domStyle['user-select'] = 'none';\n        domStyle['-webkit-touch-callout'] = 'none';\n        domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n        domStyle['padding'] = 0;\n        domStyle['margin'] = 0;\n        domStyle['border-width'] = 0;\n    }\n\n    this.domBack = null;\n    this.ctxBack = null;\n\n    this.painter = painter;\n\n    this.config = null;\n\n    // Configs\n    /**\n     * \n     * @type {string}\n     * @default 0\n     */\n    this.clearColor = 0;\n    /**\n     * \n     * @type {boolean}\n     * @default false\n     */\n    this.motionBlur = false;\n    /**\n     * alpha\n     * @type {number}\n     * @default 0.7\n     */\n    this.lastFrameAlpha = 0.7;\n\n    /**\n     * Layer dpr\n     * @type {number}\n     */\n    this.dpr = dpr;\n};\n\nLayer.prototype = {\n\n    constructor: Layer,\n\n    elCount: 0,\n\n    __dirty: true,\n\n    initContext: function () {\n        this.ctx = this.dom.getContext('2d');\n        this.ctx.__currentValues = {};\n        this.ctx.dpr = this.dpr;\n    },\n\n    createBackBuffer: function () {\n        var dpr = this.dpr;\n\n        this.domBack = createDom('back-' + this.id, this.painter, dpr);\n        this.ctxBack = this.domBack.getContext('2d');\n        this.ctxBack.__currentValues = {};\n\n        if (dpr != 1) {\n            this.ctxBack.scale(dpr, dpr);\n        }\n    },\n\n    /**\n     * @param  {number} width\n     * @param  {number} height\n     */\n    resize: function (width, height) {\n        var dpr = this.dpr;\n\n        var dom = this.dom;\n        var domStyle = dom.style;\n        var domBack = this.domBack;\n\n        domStyle.width = width + 'px';\n        domStyle.height = height + 'px';\n\n        dom.width = width * dpr;\n        dom.height = height * dpr;\n\n        if (domBack) {\n            domBack.width = width * dpr;\n            domBack.height = height * dpr;\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        }\n    },\n\n    /**\n     * \n     * @param {boolean} clearAll Clear all with out motion blur\n     */\n    clear: function (clearAll) {\n        var dom = this.dom;\n        var ctx = this.ctx;\n        var width = dom.width;\n        var height = dom.height;\n\n        var clearColor = this.clearColor;\n        var haveMotionBLur = this.motionBlur && !clearAll;\n        var lastFrameAlpha = this.lastFrameAlpha;\n\n        var dpr = this.dpr;\n\n        if (haveMotionBLur) {\n            if (!this.domBack) {\n                this.createBackBuffer();\n            }\n\n            this.ctxBack.globalCompositeOperation = 'copy';\n            this.ctxBack.drawImage(\n                dom, 0, 0,\n                width / dpr,\n                height / dpr\n            );\n        }\n\n        ctx.clearRect(0, 0, width, height);\n        if (clearColor) {\n            var clearColorGradientOrPattern;\n            // Gradient\n            if (clearColor.colorStops) {\n                // Cache canvas gradient\n                clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                    x: 0,\n                    y: 0,\n                    width: width,\n                    height: height\n                });\n\n                clearColor.__canvasGradient = clearColorGradientOrPattern;\n            }\n            // Pattern\n            else if (clearColor.image) {\n                clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n            }\n            ctx.save();\n            ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n            ctx.fillRect(0, 0, width, height);\n            ctx.restore();\n        }\n\n        if (haveMotionBLur) {\n            var domBack = this.domBack;\n            ctx.save();\n            ctx.globalAlpha = lastFrameAlpha;\n            ctx.drawImage(domBack, 0, 0, width, height);\n            ctx.restore();\n        }\n    }\n};\n\nvar requestAnimationFrame = (\n    typeof window !== 'undefined'\n    && (\n        (window.requestAnimationFrame && window.requestAnimationFrame.bind(window))\n        // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\n        || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window))\n        || window.mozRequestAnimationFrame\n        || window.webkitRequestAnimationFrame\n    )\n) || function (func) {\n    setTimeout(func, 16);\n};\n\nvar globalImageCache = new LRU(50);\n\n/**\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\nfunction findExistImage(newImageOrSrc) {\n    if (typeof newImageOrSrc === 'string') {\n        var cachedImgObj = globalImageCache.get(newImageOrSrc);\n        return cachedImgObj && cachedImgObj.image;\n    }\n    else {\n        return newImageOrSrc;\n    }\n}\n\n/**\n * Caution: User should cache loaded images, but not just count on LRU.\n * Consider if required images more than LRU size, will dead loop occur?\n *\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\n * @param {module:zrender/Element} [hostEl] For calling `dirty`.\n * @param {Function} [cb] params: (image, cbPayload)\n * @param {Object} [cbPayload] Payload on cb calling.\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\nfunction createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {\n    if (!newImageOrSrc) {\n        return image;\n    }\n    else if (typeof newImageOrSrc === 'string') {\n\n        // Image should not be loaded repeatly.\n        if ((image && image.__zrImageSrc === newImageOrSrc) || !hostEl) {\n            return image;\n        }\n\n        // Only when there is no existent image or existent image src\n        // is different, this method is responsible for load.\n        var cachedImgObj = globalImageCache.get(newImageOrSrc);\n\n        var pendingWrap = {hostEl: hostEl, cb: cb, cbPayload: cbPayload};\n\n        if (cachedImgObj) {\n            image = cachedImgObj.image;\n            !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n        }\n        else {\n            !image && (image = new Image());\n            image.onload = imageOnLoad;\n\n            globalImageCache.put(\n                newImageOrSrc,\n                image.__cachedImgObj = {\n                    image: image,\n                    pending: [pendingWrap]\n                }\n            );\n\n            image.src = image.__zrImageSrc = newImageOrSrc;\n        }\n\n        return image;\n    }\n    // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n    else {\n        return newImageOrSrc;\n    }\n}\n\nfunction imageOnLoad() {\n    var cachedImgObj = this.__cachedImgObj;\n    this.onload = this.__cachedImgObj = null;\n\n    for (var i = 0; i < cachedImgObj.pending.length; i++) {\n        var pendingWrap = cachedImgObj.pending[i];\n        var cb = pendingWrap.cb;\n        cb && cb(this, pendingWrap.cbPayload);\n        pendingWrap.hostEl.dirty();\n    }\n    cachedImgObj.pending.length = 0;\n}\n\nfunction isImageReady(image) {\n    return image && image.width && image.height;\n}\n\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\n\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\n\nvar DEFAULT_FONT = '12px sans-serif';\n\n// Avoid assign to an exported variable, for transforming to cjs.\nvar methods$1 = {};\n\nfunction $override$1(name, fn) {\n    methods$1[name] = fn;\n}\n\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\nfunction getWidth(text, font) {\n    font = font || DEFAULT_FONT;\n    var key = text + ':' + font;\n    if (textWidthCache[key]) {\n        return textWidthCache[key];\n    }\n\n    var textLines = (text + '').split('\\n');\n    var width = 0;\n\n    for (var i = 0, l = textLines.length; i < l; i++) {\n        // textContain.measureText may be overrided in SVG or VML\n        width = Math.max(measureText(textLines[i], font).width, width);\n    }\n\n    if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n        textWidthCacheCounter = 0;\n        textWidthCache = {};\n    }\n    textWidthCacheCounter++;\n    textWidthCache[key] = width;\n\n    return width;\n}\n\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n    return rich\n        ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate)\n        : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n    var contentBlock = parsePlainText(text, font, textPadding, truncate);\n    var outerWidth = getWidth(text, font);\n    if (textPadding) {\n        outerWidth += textPadding[1] + textPadding[3];\n    }\n    var outerHeight = contentBlock.outerHeight;\n\n    var x = adjustTextX(0, outerWidth, textAlign);\n    var y = adjustTextY(0, outerHeight, textVerticalAlign);\n\n    var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n    rect.lineHeight = contentBlock.lineHeight;\n\n    return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n    var contentBlock = parseRichText(text, {\n        rich: rich,\n        truncate: truncate,\n        font: font,\n        textAlign: textAlign,\n        textPadding: textPadding\n    });\n    var outerWidth = contentBlock.outerWidth;\n    var outerHeight = contentBlock.outerHeight;\n\n    var x = adjustTextX(0, outerWidth, textAlign);\n    var y = adjustTextY(0, outerHeight, textVerticalAlign);\n\n    return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\nfunction adjustTextX(x, width, textAlign) {\n    // FIXME Right to left language\n    if (textAlign === 'right') {\n        x -= width;\n    }\n    else if (textAlign === 'center') {\n        x -= width / 2;\n    }\n    return x;\n}\n\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\nfunction adjustTextY(y, height, textVerticalAlign) {\n    if (textVerticalAlign === 'middle') {\n        y -= height / 2;\n    }\n    else if (textVerticalAlign === 'bottom') {\n        y -= height;\n    }\n    return y;\n}\n\n/**\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n\n    var x = rect.x;\n    var y = rect.y;\n\n    var height = rect.height;\n    var width = rect.width;\n    var halfHeight = height / 2;\n\n    var textAlign = 'left';\n    var textVerticalAlign = 'top';\n\n    switch (textPosition) {\n        case 'left':\n            x -= distance;\n            y += halfHeight;\n            textAlign = 'right';\n            textVerticalAlign = 'middle';\n            break;\n        case 'right':\n            x += distance + width;\n            y += halfHeight;\n            textVerticalAlign = 'middle';\n            break;\n        case 'top':\n            x += width / 2;\n            y -= distance;\n            textAlign = 'center';\n            textVerticalAlign = 'bottom';\n            break;\n        case 'bottom':\n            x += width / 2;\n            y += height + distance;\n            textAlign = 'center';\n            break;\n        case 'inside':\n            x += width / 2;\n            y += halfHeight;\n            textAlign = 'center';\n            textVerticalAlign = 'middle';\n            break;\n        case 'insideLeft':\n            x += distance;\n            y += halfHeight;\n            textVerticalAlign = 'middle';\n            break;\n        case 'insideRight':\n            x += width - distance;\n            y += halfHeight;\n            textAlign = 'right';\n            textVerticalAlign = 'middle';\n            break;\n        case 'insideTop':\n            x += width / 2;\n            y += distance;\n            textAlign = 'center';\n            break;\n        case 'insideBottom':\n            x += width / 2;\n            y += height - distance;\n            textAlign = 'center';\n            textVerticalAlign = 'bottom';\n            break;\n        case 'insideTopLeft':\n            x += distance;\n            y += distance;\n            break;\n        case 'insideTopRight':\n            x += width - distance;\n            y += distance;\n            textAlign = 'right';\n            break;\n        case 'insideBottomLeft':\n            x += distance;\n            y += height - distance;\n            textVerticalAlign = 'bottom';\n            break;\n        case 'insideBottomRight':\n            x += width - distance;\n            y += height - distance;\n            textAlign = 'right';\n            textVerticalAlign = 'bottom';\n            break;\n    }\n\n    return {\n        x: x,\n        y: y,\n        textAlign: textAlign,\n        textVerticalAlign: textVerticalAlign\n    };\n}\n\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n    if (!containerWidth) {\n        return '';\n    }\n\n    var textLines = (text + '').split('\\n');\n    options = prepareTruncateOptions(containerWidth, font, ellipsis, options);\n\n    // FIXME\n    // It is not appropriate that every line has '...' when truncate multiple lines.\n    for (var i = 0, len = textLines.length; i < len; i++) {\n        textLines[i] = truncateSingleLine(textLines[i], options);\n    }\n\n    return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n    options = extend({}, options);\n\n    options.font = font;\n    var ellipsis = retrieve2(ellipsis, '...');\n    options.maxIterations = retrieve2(options.maxIterations, 2);\n    var minChar = options.minChar = retrieve2(options.minChar, 0);\n    // FIXME\n    // Other languages?\n    options.cnCharWidth = getWidth('', font);\n    // FIXME\n    // Consider proportional font?\n    var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n    options.placeholder = retrieve2(options.placeholder, '');\n\n    // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n    // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n    var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n    for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n        contentWidth -= ascCharWidth;\n    }\n\n    var ellipsisWidth = getWidth(ellipsis);\n    if (ellipsisWidth > contentWidth) {\n        ellipsis = '';\n        ellipsisWidth = 0;\n    }\n\n    contentWidth = containerWidth - ellipsisWidth;\n\n    options.ellipsis = ellipsis;\n    options.ellipsisWidth = ellipsisWidth;\n    options.contentWidth = contentWidth;\n    options.containerWidth = containerWidth;\n\n    return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n    var containerWidth = options.containerWidth;\n    var font = options.font;\n    var contentWidth = options.contentWidth;\n\n    if (!containerWidth) {\n        return '';\n    }\n\n    var lineWidth = getWidth(textLine, font);\n\n    if (lineWidth <= containerWidth) {\n        return textLine;\n    }\n\n    for (var j = 0;; j++) {\n        if (lineWidth <= contentWidth || j >= options.maxIterations) {\n            textLine += options.ellipsis;\n            break;\n        }\n\n        var subLength = j === 0\n            ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth)\n            : lineWidth > 0\n            ? Math.floor(textLine.length * contentWidth / lineWidth)\n            : 0;\n\n        textLine = textLine.substr(0, subLength);\n        lineWidth = getWidth(textLine, font);\n    }\n\n    if (textLine === '') {\n        textLine = options.placeholder;\n    }\n\n    return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n    var width = 0;\n    var i = 0;\n    for (var len = text.length; i < len && width < contentWidth; i++) {\n        var charCode = text.charCodeAt(i);\n        width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n    }\n    return i;\n}\n\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\nfunction getLineHeight(font) {\n    // FIXME A rough approach.\n    return getWidth('', font);\n}\n\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\nfunction measureText(text, font) {\n    return methods$1.measureText(text, font);\n}\n\n// Avoid assign to an exported variable, for transforming to cjs.\nmethods$1.measureText = function (text, font) {\n    var ctx = getContext();\n    ctx.font = font || DEFAULT_FONT;\n    return ctx.measureText(text);\n};\n\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight}\n *  Notice: for performance, do not calculate outerWidth util needed.\n */\nfunction parsePlainText(text, font, padding, truncate) {\n    text != null && (text += '');\n\n    var lineHeight = getLineHeight(font);\n    var lines = text ? text.split('\\n') : [];\n    var height = lines.length * lineHeight;\n    var outerHeight = height;\n\n    if (padding) {\n        outerHeight += padding[0] + padding[2];\n    }\n\n    if (text && truncate) {\n        var truncOuterHeight = truncate.outerHeight;\n        var truncOuterWidth = truncate.outerWidth;\n        if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n            text = '';\n            lines = [];\n        }\n        else if (truncOuterWidth != null) {\n            var options = prepareTruncateOptions(\n                truncOuterWidth - (padding ? padding[1] + padding[3] : 0),\n                font,\n                truncate.ellipsis,\n                {minChar: truncate.minChar, placeholder: truncate.placeholder}\n            );\n\n            // FIXME\n            // It is not appropriate that every line has '...' when truncate multiple lines.\n            for (var i = 0, len = lines.length; i < len; i++) {\n                lines[i] = truncateSingleLine(lines[i], options);\n            }\n        }\n    }\n\n    return {\n        lines: lines,\n        height: height,\n        outerHeight: outerHeight,\n        lineHeight: lineHeight\n    };\n}\n\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\nfunction parseRichText(text, style) {\n    var contentBlock = {lines: [], width: 0, height: 0};\n\n    text != null && (text += '');\n    if (!text) {\n        return contentBlock;\n    }\n\n    var lastIndex = STYLE_REG.lastIndex = 0;\n    var result;\n    while ((result = STYLE_REG.exec(text)) != null) {\n        var matchedIndex = result.index;\n        if (matchedIndex > lastIndex) {\n            pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n        }\n        pushTokens(contentBlock, result[2], result[1]);\n        lastIndex = STYLE_REG.lastIndex;\n    }\n\n    if (lastIndex < text.length) {\n        pushTokens(contentBlock, text.substring(lastIndex, text.length));\n    }\n\n    var lines = contentBlock.lines;\n    var contentHeight = 0;\n    var contentWidth = 0;\n    // For `textWidth: 100%`\n    var pendingList = [];\n\n    var stlPadding = style.textPadding;\n\n    var truncate = style.truncate;\n    var truncateWidth = truncate && truncate.outerWidth;\n    var truncateHeight = truncate && truncate.outerHeight;\n    if (stlPadding) {\n        truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n        truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n    }\n\n    // Calculate layout info of tokens.\n    for (var i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        var lineHeight = 0;\n        var lineWidth = 0;\n\n        for (var j = 0; j < line.tokens.length; j++) {\n            var token = line.tokens[j];\n            var tokenStyle = token.styleName && style.rich[token.styleName] || {};\n            // textPadding should not inherit from style.\n            var textPadding = token.textPadding = tokenStyle.textPadding;\n\n            // textFont has been asigned to font by `normalizeStyle`.\n            var font = token.font = tokenStyle.font || style.font;\n\n            // textHeight can be used when textVerticalAlign is specified in token.\n            var tokenHeight = token.textHeight = retrieve2(\n                // textHeight should not be inherited, consider it can be specified\n                // as box height of the block.\n                tokenStyle.textHeight, getLineHeight(font)\n            );\n            textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n            token.height = tokenHeight;\n            token.lineHeight = retrieve3(\n                tokenStyle.textLineHeight, style.textLineHeight, tokenHeight\n            );\n\n            token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n            token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n            if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n                return {lines: [], width: 0, height: 0};\n            }\n\n            token.textWidth = getWidth(token.text, font);\n            var tokenWidth = tokenStyle.textWidth;\n            var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto';\n\n            // Percent width, can be `100%`, can be used in drawing separate\n            // line when box width is needed to be auto.\n            if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n                token.percentWidth = tokenWidth;\n                pendingList.push(token);\n                tokenWidth = 0;\n                // Do not truncate in this case, because there is no user case\n                // and it is too complicated.\n            }\n            else {\n                if (tokenWidthNotSpecified) {\n                    tokenWidth = token.textWidth;\n\n                    // FIXME: If image is not loaded and textWidth is not specified, calling\n                    // `getBoundingRect()` will not get correct result.\n                    var textBackgroundColor = tokenStyle.textBackgroundColor;\n                    var bgImg = textBackgroundColor && textBackgroundColor.image;\n\n                    // Use cases:\n                    // (1) If image is not loaded, it will be loaded at render phase and call\n                    // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n                    // image, and then the right size will be calculated here at the next tick.\n                    // See `graphic/helper/text.js`.\n                    // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n                    // use `imageHelper.findExistImage` to find cached image.\n                    // `imageHelper.findExistImage` will always be called here before\n                    // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n                    // which ensures that image will not be rendered before correct size calcualted.\n                    if (bgImg) {\n                        bgImg = findExistImage(bgImg);\n                        if (isImageReady(bgImg)) {\n                            tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n                        }\n                    }\n                }\n\n                var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n                tokenWidth += paddingW;\n\n                var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n                if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n                    if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n                        token.text = '';\n                        token.textWidth = tokenWidth = 0;\n                    }\n                    else {\n                        token.text = truncateText(\n                            token.text, remianTruncWidth - paddingW, font, truncate.ellipsis,\n                            {minChar: truncate.minChar}\n                        );\n                        token.textWidth = getWidth(token.text, font);\n                        tokenWidth = token.textWidth + paddingW;\n                    }\n                }\n            }\n\n            lineWidth += (token.width = tokenWidth);\n            tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n        }\n\n        line.width = lineWidth;\n        line.lineHeight = lineHeight;\n        contentHeight += lineHeight;\n        contentWidth = Math.max(contentWidth, lineWidth);\n    }\n\n    contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n    contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n    if (stlPadding) {\n        contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n        contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n    }\n\n    for (var i = 0; i < pendingList.length; i++) {\n        var token = pendingList[i];\n        var percentWidth = token.percentWidth;\n        // Should not base on outerWidth, because token can not be placed out of padding.\n        token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n    }\n\n    return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n    var isEmptyStr = str === '';\n    var strs = str.split('\\n');\n    var lines = block.lines;\n\n    for (var i = 0; i < strs.length; i++) {\n        var text = strs[i];\n        var token = {\n            styleName: styleName,\n            text: text,\n            isLineHolder: !text && !isEmptyStr\n        };\n\n        // The first token should be appended to the last line.\n        if (!i) {\n            var tokens = (lines[lines.length - 1] || (lines[0] = {tokens: []})).tokens;\n\n            // Consider cases:\n            // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n            // (which is a placeholder) should be replaced by new token.\n            // (2) A image backage, where token likes {a|}.\n            // (3) A redundant '' will affect textAlign in line.\n            // (4) tokens with the same tplName should not be merged, because\n            // they should be displayed in different box (with border and padding).\n            var tokensLen = tokens.length;\n            (tokensLen === 1 && tokens[0].isLineHolder)\n                ? (tokens[0] = token)\n                // Consider text is '', only insert when it is the \"lineHolder\" or\n                // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n                : ((text || !tokensLen || isEmptyStr) && tokens.push(token));\n        }\n        // Other tokens always start a new line.\n        else {\n            // If there is '', insert it as a placeholder.\n            lines.push({tokens: [token]});\n        }\n    }\n}\n\nfunction makeFont(style) {\n    // FIXME in node-canvas fontWeight is before fontStyle\n    // Use `fontSize` `fontFamily` to check whether font properties are defined.\n    return (style.fontSize || style.fontFamily) && [\n        style.fontStyle,\n        style.fontWeight,\n        (style.fontSize || 12) + 'px',\n        // If font properties are defined, `fontFamily` should not be ignored.\n        style.fontFamily || 'sans-serif'\n    ].join(' ') || style.textFont || style.font;\n}\n\nfunction buildPath(ctx, shape) {\n    var x = shape.x;\n    var y = shape.y;\n    var width = shape.width;\n    var height = shape.height;\n    var r = shape.r;\n    var r1;\n    var r2;\n    var r3;\n    var r4;\n\n    // Convert width and height to positive for better borderRadius\n    if (width < 0) {\n        x = x + width;\n        width = -width;\n    }\n    if (height < 0) {\n        y = y + height;\n        height = -height;\n    }\n\n    if (typeof r === 'number') {\n        r1 = r2 = r3 = r4 = r;\n    }\n    else if (r instanceof Array) {\n        if (r.length === 1) {\n            r1 = r2 = r3 = r4 = r[0];\n        }\n        else if (r.length === 2) {\n            r1 = r3 = r[0];\n            r2 = r4 = r[1];\n        }\n        else if (r.length === 3) {\n            r1 = r[0];\n            r2 = r4 = r[1];\n            r3 = r[2];\n        }\n        else {\n            r1 = r[0];\n            r2 = r[1];\n            r3 = r[2];\n            r4 = r[3];\n        }\n    }\n    else {\n        r1 = r2 = r3 = r4 = 0;\n    }\n\n    var total;\n    if (r1 + r2 > width) {\n        total = r1 + r2;\n        r1 *= width / total;\n        r2 *= width / total;\n    }\n    if (r3 + r4 > width) {\n        total = r3 + r4;\n        r3 *= width / total;\n        r4 *= width / total;\n    }\n    if (r2 + r3 > height) {\n        total = r2 + r3;\n        r2 *= height / total;\n        r3 *= height / total;\n    }\n    if (r1 + r4 > height) {\n        total = r1 + r4;\n        r1 *= height / total;\n        r4 *= height / total;\n    }\n    ctx.moveTo(x + r1, y);\n    ctx.lineTo(x + width - r2, y);\n    r2 !== 0 && ctx.quadraticCurveTo(\n        x + width, y, x + width, y + r2\n    );\n    ctx.lineTo(x + width, y + height - r3);\n    r3 !== 0 && ctx.quadraticCurveTo(\n        x + width, y + height, x + width - r3, y + height\n    );\n    ctx.lineTo(x + r4, y + height);\n    r4 !== 0 && ctx.quadraticCurveTo(\n        x, y + height, x, y + height - r4\n    );\n    ctx.lineTo(x, y + r1);\n    r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n}\n\n// TODO: Have not support 'start', 'end' yet.\nvar VALID_TEXT_ALIGN = {left: 1, right: 1, center: 1};\nvar VALID_TEXT_VERTICAL_ALIGN = {top: 1, bottom: 1, middle: 1};\n\n/**\n * @param {module:zrender/graphic/Style} style\n * @return {module:zrender/graphic/Style} The input style.\n */\nfunction normalizeTextStyle(style) {\n    normalizeStyle(style);\n    each$1(style.rich, normalizeStyle);\n    return style;\n}\n\nfunction normalizeStyle(style) {\n    if (style) {\n\n        style.font = makeFont(style);\n\n        var textAlign = style.textAlign;\n        textAlign === 'middle' && (textAlign = 'center');\n        style.textAlign = (\n            textAlign == null || VALID_TEXT_ALIGN[textAlign]\n        ) ? textAlign : 'left';\n\n        // Compatible with textBaseline.\n        var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n        textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n        style.textVerticalAlign = (\n            textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign]\n        ) ? textVerticalAlign : 'top';\n\n        var textPadding = style.textPadding;\n        if (textPadding) {\n            style.textPadding = normalizeCssArray(style.textPadding);\n        }\n    }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {string} text\n * @param {module:zrender/graphic/Style} style\n * @param {Object|boolean} [rect] {x, y, width, height}\n *                  If set false, rect text is not used.\n */\nfunction renderText(hostEl, ctx, text, style, rect) {\n    style.rich\n        ? renderRichText(hostEl, ctx, text, style, rect)\n        : renderPlainText(hostEl, ctx, text, style, rect);\n}\n\nfunction renderPlainText(hostEl, ctx, text, style, rect) {\n    var font = setCtx(ctx, 'font', style.font || DEFAULT_FONT);\n\n    var textPadding = style.textPadding;\n\n    var contentBlock = hostEl.__textCotentBlock;\n    if (!contentBlock || hostEl.__dirty) {\n        contentBlock = hostEl.__textCotentBlock = parsePlainText(\n            text, font, textPadding, style.truncate\n        );\n    }\n\n    var outerHeight = contentBlock.outerHeight;\n\n    var textLines = contentBlock.lines;\n    var lineHeight = contentBlock.lineHeight;\n\n    var boxPos = getBoxPosition(outerHeight, style, rect);\n    var baseX = boxPos.baseX;\n    var baseY = boxPos.baseY;\n    var textAlign = boxPos.textAlign;\n    var textVerticalAlign = boxPos.textVerticalAlign;\n\n    // Origin of textRotation should be the base point of text drawing.\n    applyTextRotation(ctx, style, rect, baseX, baseY);\n\n    var boxY = adjustTextY(baseY, outerHeight, textVerticalAlign);\n    var textX = baseX;\n    var textY = boxY;\n\n    var needDrawBg = needDrawBackground(style);\n    if (needDrawBg || textPadding) {\n        // Consider performance, do not call getTextWidth util necessary.\n        var textWidth = getWidth(text, font);\n        var outerWidth = textWidth;\n        textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n        var boxX = adjustTextX(baseX, outerWidth, textAlign);\n\n        needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n        if (textPadding) {\n            textX = getTextXForPadding(baseX, textAlign, textPadding);\n            textY += textPadding[0];\n        }\n    }\n\n    setCtx(ctx, 'textAlign', textAlign || 'left');\n    // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n    // text will offset downward a little bit in font \"Microsoft YaHei\".\n    setCtx(ctx, 'textBaseline', 'middle');\n\n    // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n    setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n    setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n    setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n    setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0);\n\n    // `textBaseline` is set as 'middle'.\n    textY += lineHeight / 2;\n\n    var textStrokeWidth = style.textStrokeWidth;\n    var textStroke = getStroke(style.textStroke, textStrokeWidth);\n    var textFill = getFill(style.textFill);\n\n    if (textStroke) {\n        setCtx(ctx, 'lineWidth', textStrokeWidth);\n        setCtx(ctx, 'strokeStyle', textStroke);\n    }\n    if (textFill) {\n        setCtx(ctx, 'fillStyle', textFill);\n    }\n\n    for (var i = 0; i < textLines.length; i++) {\n        // Fill after stroke so the outline will not cover the main part.\n        textStroke && ctx.strokeText(textLines[i], textX, textY);\n        textFill && ctx.fillText(textLines[i], textX, textY);\n        textY += lineHeight;\n    }\n}\n\nfunction renderRichText(hostEl, ctx, text, style, rect) {\n    var contentBlock = hostEl.__textCotentBlock;\n\n    if (!contentBlock || hostEl.__dirty) {\n        contentBlock = hostEl.__textCotentBlock = parseRichText(text, style);\n    }\n\n    drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\n\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n    var contentWidth = contentBlock.width;\n    var outerWidth = contentBlock.outerWidth;\n    var outerHeight = contentBlock.outerHeight;\n    var textPadding = style.textPadding;\n\n    var boxPos = getBoxPosition(outerHeight, style, rect);\n    var baseX = boxPos.baseX;\n    var baseY = boxPos.baseY;\n    var textAlign = boxPos.textAlign;\n    var textVerticalAlign = boxPos.textVerticalAlign;\n\n    // Origin of textRotation should be the base point of text drawing.\n    applyTextRotation(ctx, style, rect, baseX, baseY);\n\n    var boxX = adjustTextX(baseX, outerWidth, textAlign);\n    var boxY = adjustTextY(baseY, outerHeight, textVerticalAlign);\n    var xLeft = boxX;\n    var lineTop = boxY;\n    if (textPadding) {\n        xLeft += textPadding[3];\n        lineTop += textPadding[0];\n    }\n    var xRight = xLeft + contentWidth;\n\n    needDrawBackground(style) && drawBackground(\n        hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight\n    );\n\n    for (var i = 0; i < contentBlock.lines.length; i++) {\n        var line = contentBlock.lines[i];\n        var tokens = line.tokens;\n        var tokenCount = tokens.length;\n        var lineHeight = line.lineHeight;\n        var usedWidth = line.width;\n\n        var leftIndex = 0;\n        var lineXLeft = xLeft;\n        var lineXRight = xRight;\n        var rightIndex = tokenCount - 1;\n        var token;\n\n        while (\n            leftIndex < tokenCount\n            && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')\n        ) {\n            placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n            usedWidth -= token.width;\n            lineXLeft += token.width;\n            leftIndex++;\n        }\n\n        while (\n            rightIndex >= 0\n            && (token = tokens[rightIndex], token.textAlign === 'right')\n        ) {\n            placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n            usedWidth -= token.width;\n            lineXRight -= token.width;\n            rightIndex--;\n        }\n\n        // The other tokens are placed as textAlign 'center' if there is enough space.\n        lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n        while (leftIndex <= rightIndex) {\n            token = tokens[leftIndex];\n            // Consider width specified by user, use 'center' rather than 'left'.\n            placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n            lineXLeft += token.width;\n            leftIndex++;\n        }\n\n        lineTop += lineHeight;\n    }\n}\n\nfunction applyTextRotation(ctx, style, rect, x, y) {\n    // textRotation only apply in RectText.\n    if (rect && style.textRotation) {\n        var origin = style.textOrigin;\n        if (origin === 'center') {\n            x = rect.width / 2 + rect.x;\n            y = rect.height / 2 + rect.y;\n        }\n        else if (origin) {\n            x = origin[0] + rect.x;\n            y = origin[1] + rect.y;\n        }\n\n        ctx.translate(x, y);\n        // Positive: anticlockwise\n        ctx.rotate(-style.textRotation);\n        ctx.translate(-x, -y);\n    }\n}\n\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n    var tokenStyle = style.rich[token.styleName] || {};\n\n    // 'ctx.textBaseline' is always set as 'middle', for sake of\n    // the bias of \"Microsoft YaHei\".\n    var textVerticalAlign = token.textVerticalAlign;\n    var y = lineTop + lineHeight / 2;\n    if (textVerticalAlign === 'top') {\n        y = lineTop + token.height / 2;\n    }\n    else if (textVerticalAlign === 'bottom') {\n        y = lineTop + lineHeight - token.height / 2;\n    }\n\n    !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(\n        hostEl,\n        ctx,\n        tokenStyle,\n        textAlign === 'right'\n            ? x - token.width\n            : textAlign === 'center'\n            ? x - token.width / 2\n            : x,\n        y - token.height / 2,\n        token.width,\n        token.height\n    );\n\n    var textPadding = token.textPadding;\n    if (textPadding) {\n        x = getTextXForPadding(x, textAlign, textPadding);\n        y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n    }\n\n    setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n    setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n    setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n    setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n\n    setCtx(ctx, 'textAlign', textAlign);\n    // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n    // text will offset downward a little bit in font \"Microsoft YaHei\".\n    setCtx(ctx, 'textBaseline', 'middle');\n\n    setCtx(ctx, 'font', token.font || DEFAULT_FONT);\n\n    var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n    var textFill = getFill(tokenStyle.textFill || style.textFill);\n    var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth);\n\n    // Fill after stroke so the outline will not cover the main part.\n    if (textStroke) {\n        setCtx(ctx, 'lineWidth', textStrokeWidth);\n        setCtx(ctx, 'strokeStyle', textStroke);\n        ctx.strokeText(token.text, x, y);\n    }\n    if (textFill) {\n        setCtx(ctx, 'fillStyle', textFill);\n        ctx.fillText(token.text, x, y);\n    }\n}\n\nfunction needDrawBackground(style) {\n    return style.textBackgroundColor\n        || (style.textBorderWidth && style.textBorderColor);\n}\n\n// style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n// shape: {x, y, width, height}\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n    var textBackgroundColor = style.textBackgroundColor;\n    var textBorderWidth = style.textBorderWidth;\n    var textBorderColor = style.textBorderColor;\n    var isPlainBg = isString(textBackgroundColor);\n\n    setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n    setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n    setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n    setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n    if (isPlainBg || (textBorderWidth && textBorderColor)) {\n        ctx.beginPath();\n        var textBorderRadius = style.textBorderRadius;\n        if (!textBorderRadius) {\n            ctx.rect(x, y, width, height);\n        }\n        else {\n            buildPath(ctx, {\n                x: x, y: y, width: width, height: height, r: textBorderRadius\n            });\n        }\n        ctx.closePath();\n    }\n\n    if (isPlainBg) {\n        setCtx(ctx, 'fillStyle', textBackgroundColor);\n        ctx.fill();\n    }\n    else if (isObject(textBackgroundColor)) {\n        var image = textBackgroundColor.image;\n\n        image = createOrUpdateImage(\n            image, null, hostEl, onBgImageLoaded, textBackgroundColor\n        );\n        if (image && isImageReady(image)) {\n            ctx.drawImage(image, x, y, width, height);\n        }\n    }\n\n    if (textBorderWidth && textBorderColor) {\n        setCtx(ctx, 'lineWidth', textBorderWidth);\n        setCtx(ctx, 'strokeStyle', textBorderColor);\n        ctx.stroke();\n    }\n}\n\nfunction onBgImageLoaded(image, textBackgroundColor) {\n    // Replace image, so that `contain/text.js#parseRichText`\n    // will get correct result in next tick.\n    textBackgroundColor.image = image;\n}\n\nfunction getBoxPosition(blockHeiht, style, rect) {\n    var baseX = style.x || 0;\n    var baseY = style.y || 0;\n    var textAlign = style.textAlign;\n    var textVerticalAlign = style.textVerticalAlign;\n\n    // Text position represented by coord\n    if (rect) {\n        var textPosition = style.textPosition;\n        if (textPosition instanceof Array) {\n            // Percent\n            baseX = rect.x + parsePercent(textPosition[0], rect.width);\n            baseY = rect.y + parsePercent(textPosition[1], rect.height);\n        }\n        else {\n            var res = adjustTextPositionOnRect(\n                textPosition, rect, style.textDistance\n            );\n            baseX = res.x;\n            baseY = res.y;\n            // Default align and baseline when has textPosition\n            textAlign = textAlign || res.textAlign;\n            textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n        }\n\n        // textOffset is only support in RectText, otherwise\n        // we have to adjust boundingRect for textOffset.\n        var textOffset = style.textOffset;\n        if (textOffset) {\n            baseX += textOffset[0];\n            baseY += textOffset[1];\n        }\n    }\n\n    return {\n        baseX: baseX,\n        baseY: baseY,\n        textAlign: textAlign,\n        textVerticalAlign: textVerticalAlign\n    };\n}\n\nfunction setCtx(ctx, prop, value) {\n    // FIXME ??? performance try\n    // if (ctx.__currentValues[prop] !== value) {\n        // ctx[prop] = ctx.__currentValues[prop] = value;\n    ctx[prop] = value;\n    // }\n    return ctx[prop];\n}\n\n/**\n * @param {string} [stroke] If specified, do not check style.textStroke.\n * @param {string} [lineWidth] If specified, do not check style.textStroke.\n * @param {number} style\n */\nfunction getStroke(stroke, lineWidth) {\n    return (stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none')\n        ? null\n        // TODO pattern and gradient?\n        : (stroke.image || stroke.colorStops)\n        ? '#000'\n        : stroke;\n}\n\nfunction getFill(fill) {\n    return (fill == null || fill === 'none')\n        ? null\n        // TODO pattern and gradient?\n        : (fill.image || fill.colorStops)\n        ? '#000'\n        : fill;\n}\n\nfunction parsePercent(value, maxValue) {\n    if (typeof value === 'string') {\n        if (value.lastIndexOf('%') >= 0) {\n            return parseFloat(value) / 100 * maxValue;\n        }\n        return parseFloat(value);\n    }\n    return value;\n}\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n    return textAlign === 'right'\n        ? (x - textPadding[1])\n        : textAlign === 'center'\n        ? (x + textPadding[3] / 2 - textPadding[1] / 2)\n        : (x + textPadding[3]);\n}\n\n/**\n * @param {string} text\n * @param {module:zrender/Style} style\n * @return {boolean}\n */\nfunction needDrawText(text, style) {\n    return text != null\n        && (text\n            || style.textBackgroundColor\n            || (style.textBorderWidth && style.textBorderColor)\n            || style.textPadding\n        );\n}\n\n/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\nvar tmpRect$1 = new BoundingRect();\n\nvar RectText = function () {};\n\nRectText.prototype = {\n\n    constructor: RectText,\n\n    /**\n     * Draw text in a rect with specified position.\n     * @param  {CanvasRenderingContext2D} ctx\n     * @param  {Object} rect Displayable rect\n     */\n    drawRectText: function (ctx, rect) {\n        var style = this.style;\n\n        rect = style.textRect || rect;\n\n        // Optimize, avoid normalize every time.\n        this.__dirty && normalizeTextStyle(style, true);\n\n        var text = style.text;\n\n        // Convert to string\n        text != null && (text += '');\n\n        if (!needDrawText(text, style)) {\n            return;\n        }\n\n        // FIXME\n        ctx.save();\n\n        // Transform rect to view space\n        var transform = this.transform;\n        if (!style.transformText) {\n            if (transform) {\n                tmpRect$1.copy(rect);\n                tmpRect$1.applyTransform(transform);\n                rect = tmpRect$1;\n            }\n        }\n        else {\n            this.setTransform(ctx);\n        }\n\n        // transformText and textRotation can not be used at the same time.\n        renderText(this, ctx, text, style, rect);\n\n        ctx.restore();\n    }\n};\n\n/**\n * \n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n/**\n * @alias module:zrender/graphic/Displayable\n * @extends module:zrender/Element\n * @extends module:zrender/graphic/mixin/RectText\n */\nfunction Displayable(opts) {\n\n    opts = opts || {};\n\n    Element.call(this, opts);\n\n    // Extend properties\n    for (var name in opts) {\n        if (\n            opts.hasOwnProperty(name) &&\n            name !== 'style'\n        ) {\n            this[name] = opts[name];\n        }\n    }\n\n    /**\n     * @type {module:zrender/graphic/Style}\n     */\n    this.style = new Style(opts.style, this);\n\n    this._rect = null;\n    // Shapes for cascade clipping.\n    this.__clipPaths = [];\n\n    // FIXME Stateful must be mixined after style is setted\n    // Stateful.call(this, opts);\n}\n\nDisplayable.prototype = {\n\n    constructor: Displayable,\n\n    type: 'displayable',\n\n    /**\n     * Displayable Painter \n     * Dirty flag. From which painter will determine if this displayable object needs brush\n     * @name module:zrender/graphic/Displayable#__dirty\n     * @type {boolean}\n     */\n    __dirty: true,\n\n    /**\n     * true\n     * If ignore drawing of the displayable object. Mouse event will still be triggered\n     * @name module:/zrender/graphic/Displayable#invisible\n     * @type {boolean}\n     * @default false\n     */\n    invisible: false,\n\n    /**\n     * @name module:/zrender/graphic/Displayable#z\n     * @type {number}\n     * @default 0\n     */\n    z: 0,\n\n    /**\n     * @name module:/zrender/graphic/Displayable#z\n     * @type {number}\n     * @default 0\n     */\n    z2: 0,\n\n    /**\n     * zlevelcanvas\n     * @name module:/zrender/graphic/Displayable#zlevel\n     * @type {number}\n     * @default 0\n     */\n    zlevel: 0,\n\n    /**\n     * \n     * @name module:/zrender/graphic/Displayable#draggable\n     * @type {boolean}\n     * @default false\n     */\n    draggable: false,\n\n    /**\n     * \n     * @name module:/zrender/graphic/Displayable#draggable\n     * @type {boolean}\n     * @default false\n     */\n    dragging: false,\n\n    /**\n     * \n     * @name module:/zrender/graphic/Displayable#silent\n     * @type {boolean}\n     * @default false\n     */\n    silent: false,\n\n    /**\n     * If enable culling\n     * @type {boolean}\n     * @default false\n     */\n    culling: false,\n\n    /**\n     * Mouse cursor when hovered\n     * @name module:/zrender/graphic/Displayable#cursor\n     * @type {string}\n     */\n    cursor: 'pointer',\n\n    /**\n     * If hover area is bounding rect\n     * @name module:/zrender/graphic/Displayable#rectHover\n     * @type {string}\n     */\n    rectHover: false,\n\n    /**\n     * Render the element progressively when the value >= 0,\n     * usefull for large data.\n     * @type {number}\n     */\n    progressive: -1,\n\n    beforeBrush: function (ctx) {},\n\n    afterBrush: function (ctx) {},\n\n    /**\n     * \n     * @param {CanvasRenderingContext2D} ctx\n     */\n    // Interface\n    brush: function (ctx, prevEl) {},\n\n    /**\n     * \n     * @return {module:zrender/core/BoundingRect}\n     */\n    // Interface\n    getBoundingRect: function () {},\n\n    /**\n     *  x, y \n     * If displayable element contain coord x, y\n     * @param  {number} x\n     * @param  {number} y\n     * @return {boolean}\n     */\n    contain: function (x, y) {\n        return this.rectContain(x, y);\n    },\n\n    /**\n     * @param  {Function} cb\n     * @param  {}   context\n     */\n    traverse: function (cb, context) {\n        cb.call(context, this);\n    },\n\n    /**\n     *  x, y \n     * If bounding rect of element contain coord x, y\n     * @param  {number} x\n     * @param  {number} y\n     * @return {boolean}\n     */\n    rectContain: function (x, y) {\n        var coord = this.transformCoordToLocal(x, y);\n        var rect = this.getBoundingRect();\n        return rect.contain(coord[0], coord[1]);\n    },\n\n    /**\n     * \n     * Mark displayable element dirty and refresh next frame\n     */\n    dirty: function () {\n        this.__dirty = true;\n\n        this._rect = null;\n\n        this.__zr && this.__zr.refresh();\n    },\n\n    /**\n     * \n     * If displayable object binded any event\n     * @return {boolean}\n     */\n    // TODO,  bind \n    // isSilent: function () {\n    //     return !(\n    //         this.hoverable || this.draggable\n    //         || this.onmousemove || this.onmouseover || this.onmouseout\n    //         || this.onmousedown || this.onmouseup || this.onclick\n    //         || this.ondragenter || this.ondragover || this.ondragleave\n    //         || this.ondrop\n    //     );\n    // },\n    /**\n     * Alias for animate('style')\n     * @param {boolean} loop\n     */\n    animateStyle: function (loop) {\n        return this.animate('style', loop);\n    },\n\n    attrKV: function (key, value) {\n        if (key !== 'style') {\n            Element.prototype.attrKV.call(this, key, value);\n        }\n        else {\n            this.style.set(value);\n        }\n    },\n\n    /**\n     * @param {Object|string} key\n     * @param {*} value\n     */\n    setStyle: function (key, value) {\n        this.style.set(key, value);\n        this.dirty(false);\n        return this;\n    },\n\n    /**\n     * Use given style object\n     * @param  {Object} obj\n     */\n    useStyle: function (obj) {\n        this.style = new Style(obj, this);\n        this.dirty(false);\n        return this;\n    }\n};\n\ninherits(Displayable, Element);\n\nmixin(Displayable, RectText);\n\n/**\n * @alias zrender/graphic/Image\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nfunction ZImage(opts) {\n    Displayable.call(this, opts);\n}\n\nZImage.prototype = {\n\n    constructor: ZImage,\n\n    type: 'image',\n\n    brush: function (ctx, prevEl) {\n        var style = this.style;\n        var src = style.image;\n\n        // Must bind each time\n        style.bind(ctx, this, prevEl);\n\n        var image = this._image = createOrUpdateImage(\n            src,\n            this._image,\n            this,\n            this.onload\n        );\n\n        if (!image || !isImageReady(image)) {\n            return;\n        }\n\n        // \n        // if (image.nodeName.toUpperCase() == 'IMG') {\n        //     if (!image.complete) {\n        //         return;\n        //     }\n        // }\n        // Else is canvas\n\n        var x = style.x || 0;\n        var y = style.y || 0;\n        var width = style.width;\n        var height = style.height;\n        var aspect = image.width / image.height;\n        if (width == null && height != null) {\n            // Keep image/height ratio\n            width = height * aspect;\n        }\n        else if (height == null && width != null) {\n            height = width / aspect;\n        }\n        else if (width == null && height == null) {\n            width = image.width;\n            height = image.height;\n        }\n\n        // transform\n        this.setTransform(ctx);\n\n        if (style.sWidth && style.sHeight) {\n            var sx = style.sx || 0;\n            var sy = style.sy || 0;\n            ctx.drawImage(\n                image,\n                sx, sy, style.sWidth, style.sHeight,\n                x, y, width, height\n            );\n        }\n        else if (style.sx && style.sy) {\n            var sx = style.sx;\n            var sy = style.sy;\n            var sWidth = width - sx;\n            var sHeight = height - sy;\n            ctx.drawImage(\n                image,\n                sx, sy, sWidth, sHeight,\n                x, y, width, height\n            );\n        }\n        else {\n            ctx.drawImage(image, x, y, width, height);\n        }\n\n        this.restoreTransform(ctx);\n\n        // Draw rect text\n        if (style.text != null) {\n            this.drawRectText(ctx, this.getBoundingRect());\n        }\n    },\n\n    getBoundingRect: function () {\n        var style = this.style;\n        if (! this._rect) {\n            this._rect = new BoundingRect(\n                style.x || 0, style.y || 0, style.width || 0, style.height || 0\n            );\n        }\n        return this._rect;\n    }\n};\n\ninherits(ZImage, Displayable);\n\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n// PENDIGN\n// Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n//\n// Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\nvar MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\nfunction parseInt10(val) {\n    return parseInt(val, 10);\n}\n\nfunction isLayerValid(layer) {\n    if (!layer) {\n        return false;\n    }\n\n    if (layer.__builtin__) {\n        return true;\n    }\n\n    if (typeof(layer.resize) !== 'function'\n        || typeof(layer.refresh) !== 'function'\n    ) {\n        return false;\n    }\n\n    return true;\n}\n\nfunction preProcessLayer(layer) {\n    layer.__unusedCount++;\n}\n\nfunction postProcessLayer(layer) {\n    if (layer.__unusedCount == 1) {\n        layer.clear();\n    }\n}\n\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\nfunction isDisplayableCulled(el, width, height) {\n    tmpRect.copy(el.getBoundingRect());\n    if (el.transform) {\n        tmpRect.applyTransform(el.transform);\n    }\n    viewRect.width = width;\n    viewRect.height = height;\n    return !tmpRect.intersect(viewRect);\n}\n\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n    if (clipPaths == prevClipPaths) { // Can both be null or undefined\n        return false;\n    }\n\n    if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n        return true;\n    }\n    for (var i = 0; i < clipPaths.length; i++) {\n        if (clipPaths[i] !== prevClipPaths[i]) {\n            return true;\n        }\n    }\n}\n\nfunction doClip(clipPaths, ctx) {\n    for (var i = 0; i < clipPaths.length; i++) {\n        var clipPath = clipPaths[i];\n\n        clipPath.setTransform(ctx);\n        ctx.beginPath();\n        clipPath.buildPath(ctx, clipPath.shape);\n        ctx.clip();\n        // Transform back\n        clipPath.restoreTransform(ctx);\n    }\n}\n\nfunction createRoot(width, height) {\n    var domRoot = document.createElement('div');\n\n    // domRoot.onselectstart = returnFalse; // \n    domRoot.style.cssText = [\n        'position:relative',\n        'overflow:hidden',\n        'width:' + width + 'px',\n        'height:' + height + 'px',\n        'padding:0',\n        'margin:0',\n        'border-width:0'\n    ].join(';') + ';';\n\n    return domRoot;\n}\n\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {HTMLElement} root \n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\nvar Painter = function (root, storage, opts) {\n\n    this.type = 'canvas';\n\n    // In node environment using node-canvas\n    var singleCanvas = !root.nodeName // In node ?\n        || root.nodeName.toUpperCase() === 'CANVAS';\n\n    this._opts = opts = extend({}, opts || {});\n\n    /**\n     * @type {number}\n     */\n    this.dpr = opts.devicePixelRatio || devicePixelRatio;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this._singleCanvas = singleCanvas;\n    /**\n     * \n     * @type {HTMLElement}\n     */\n    this.root = root;\n\n    var rootStyle = root.style;\n\n    if (rootStyle) {\n        rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n        rootStyle['-webkit-user-select'] =\n        rootStyle['user-select'] =\n        rootStyle['-webkit-touch-callout'] = 'none';\n\n        root.innerHTML = '';\n    }\n\n    /**\n     * @type {module:zrender/Storage}\n     */\n    this.storage = storage;\n\n    /**\n     * @type {Array.<number>}\n     * @private\n     */\n    var zlevelList = this._zlevelList = [];\n\n    /**\n     * @type {Object.<string, module:zrender/Layer>}\n     * @private\n     */\n    var layers = this._layers = {};\n\n    /**\n     * @type {Object.<string, Object>}\n     * @type {private}\n     */\n    this._layerConfig = {};\n\n    if (!singleCanvas) {\n        this._width = this._getSize(0);\n        this._height = this._getSize(1);\n\n        var domRoot = this._domRoot = createRoot(\n            this._width, this._height\n        );\n        root.appendChild(domRoot);\n    }\n    else {\n        if (opts.width != null) {\n            root.width = opts.width;\n        }\n        if (opts.height != null) {\n            root.height = opts.height;\n        }\n        // Use canvas width and height directly\n        var width = root.width;\n        var height = root.height;\n        this._width = width;\n        this._height = height;\n\n        // Create layer if only one given canvas\n        // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n        var mainLayer = new Layer(root, this, 1);\n        mainLayer.initContext();\n        // FIXME Use canvas width and height\n        // mainLayer.resize(width, height);\n        layers[0] = mainLayer;\n        zlevelList.push(0);\n\n        this._domRoot = root;\n    }\n\n    // Layers for progressive rendering\n    this._progressiveLayers = [];\n\n    /**\n     * @type {module:zrender/Layer}\n     * @private\n     */\n    this._hoverlayer;\n\n    this._hoverElements = [];\n};\n\nPainter.prototype = {\n\n    constructor: Painter,\n\n    getType: function () {\n        return 'canvas';\n    },\n\n    /**\n     * If painter use a single canvas\n     * @return {boolean}\n     */\n    isSingleCanvas: function () {\n        return this._singleCanvas;\n    },\n    /**\n     * @return {HTMLDivElement}\n     */\n    getViewportRoot: function () {\n        return this._domRoot;\n    },\n\n    getViewportRootOffset: function () {\n        var viewportRoot = this.getViewportRoot();\n        if (viewportRoot) {\n            return {\n                offsetLeft: viewportRoot.offsetLeft || 0,\n                offsetTop: viewportRoot.offsetTop || 0\n            };\n        }\n    },\n\n    /**\n     * \n     * @param {boolean} [paintAll=false] displayable\n     */\n    refresh: function (paintAll) {\n\n        var list = this.storage.getDisplayList(true);\n\n        var zlevelList = this._zlevelList;\n\n        this._paintList(list, paintAll);\n\n        // Paint custum layers\n        for (var i = 0; i < zlevelList.length; i++) {\n            var z = zlevelList[i];\n            var layer = this._layers[z];\n            if (!layer.__builtin__ && layer.refresh) {\n                layer.refresh();\n            }\n        }\n\n        this.refreshHover();\n\n        if (this._progressiveLayers.length) {\n            this._startProgessive();\n        }\n\n        return this;\n    },\n\n    addHover: function (el, hoverStyle) {\n        if (el.__hoverMir) {\n            return;\n        }\n        var elMirror = new el.constructor({\n            style: el.style,\n            shape: el.shape\n        });\n        elMirror.__from = el;\n        el.__hoverMir = elMirror;\n        elMirror.setStyle(hoverStyle);\n        this._hoverElements.push(elMirror);\n    },\n\n    removeHover: function (el) {\n        var elMirror = el.__hoverMir;\n        var hoverElements = this._hoverElements;\n        var idx = indexOf(hoverElements, elMirror);\n        if (idx >= 0) {\n            hoverElements.splice(idx, 1);\n        }\n        el.__hoverMir = null;\n    },\n\n    clearHover: function (el) {\n        var hoverElements = this._hoverElements;\n        for (var i = 0; i < hoverElements.length; i++) {\n            var from = hoverElements[i].__from;\n            if (from) {\n                from.__hoverMir = null;\n            }\n        }\n        hoverElements.length = 0;\n    },\n\n    refreshHover: function () {\n        var hoverElements = this._hoverElements;\n        var len = hoverElements.length;\n        var hoverLayer = this._hoverlayer;\n        hoverLayer && hoverLayer.clear();\n\n        if (!len) {\n            return;\n        }\n        sort(hoverElements, this.storage.displayableSortFunc);\n\n        // Use a extream large zlevel\n        // FIXME?\n        if (!hoverLayer) {\n            hoverLayer = this._hoverlayer = this.getLayer(1e5);\n        }\n\n        var scope = {};\n        hoverLayer.ctx.save();\n        for (var i = 0; i < len;) {\n            var el = hoverElements[i];\n            var originalEl = el.__from;\n            // Original el is removed\n            // PENDING\n            if (!(originalEl && originalEl.__zr)) {\n                hoverElements.splice(i, 1);\n                originalEl.__hoverMir = null;\n                len--;\n                continue;\n            }\n            i++;\n\n            // Use transform\n            // FIXME style and shape ?\n            if (!originalEl.invisible) {\n                el.transform = originalEl.transform;\n                el.invTransform = originalEl.invTransform;\n                el.__clipPaths = originalEl.__clipPaths;\n                // el.\n                this._doPaintEl(el, hoverLayer, true, scope);\n            }\n        }\n        hoverLayer.ctx.restore();\n    },\n\n    _startProgessive: function () {\n        var self = this;\n\n        if (!self._furtherProgressive) {\n            return;\n        }\n\n        // Use a token to stop progress steps triggered by\n        // previous zr.refresh calling.\n        var token = self._progressiveToken = +new Date();\n\n        self._progress++;\n        requestAnimationFrame(step);\n\n        function step() {\n            // In case refreshed or disposed\n            if (token === self._progressiveToken && self.storage) {\n\n                self._doPaintList(self.storage.getDisplayList());\n\n                if (self._furtherProgressive) {\n                    self._progress++;\n                    requestAnimationFrame(step);\n                }\n                else {\n                    self._progressiveToken = -1;\n                }\n            }\n        }\n    },\n\n    _clearProgressive: function () {\n        this._progressiveToken = -1;\n        this._progress = 0;\n        each$1(this._progressiveLayers, function (layer) {\n            layer.__dirty && layer.clear();\n        });\n    },\n\n    _paintList: function (list, paintAll) {\n\n        if (paintAll == null) {\n            paintAll = false;\n        }\n\n        this._updateLayerStatus(list);\n\n        this._clearProgressive();\n\n        this.eachBuiltinLayer(preProcessLayer);\n\n        this._doPaintList(list, paintAll);\n\n        this.eachBuiltinLayer(postProcessLayer);\n    },\n\n    _doPaintList: function (list, paintAll) {\n        var currentLayer;\n        var currentZLevel;\n        var ctx;\n\n        // var invTransform = [];\n        var scope;\n\n        var progressiveLayerIdx = 0;\n        var currentProgressiveLayer;\n\n        var width = this._width;\n        var height = this._height;\n        var layerProgress;\n        var frame = this._progress;\n        function flushProgressiveLayer(layer) {\n            var dpr = ctx.dpr || 1;\n            ctx.save();\n            ctx.globalAlpha = 1;\n            ctx.shadowBlur = 0;\n            // Avoid layer don't clear in next progressive frame\n            currentLayer.__dirty = true;\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\n            ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n            ctx.restore();\n        }\n\n        for (var i = 0, l = list.length; i < l; i++) {\n            var el = list[i];\n            var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n            var elFrame = el.__frame;\n\n            // Flush at current context\n            // PENDING\n            if (elFrame < 0 && currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n                currentProgressiveLayer = null;\n            }\n\n            // Change draw layer\n            if (currentZLevel !== elZLevel) {\n                if (ctx) {\n                    ctx.restore();\n                }\n\n                // Reset scope\n                scope = {};\n\n                // Only 0 zlevel if only has one canvas\n                currentZLevel = elZLevel;\n                currentLayer = this.getLayer(currentZLevel);\n\n                if (!currentLayer.__builtin__) {\n                    zrLog(\n                        'ZLevel ' + currentZLevel\n                        + ' has been used by unkown layer ' + currentLayer.id\n                    );\n                }\n\n                ctx = currentLayer.ctx;\n                ctx.save();\n\n                // Reset the count\n                currentLayer.__unusedCount = 0;\n\n                if (currentLayer.__dirty || paintAll) {\n                    currentLayer.clear();\n                }\n            }\n\n            if (!(currentLayer.__dirty || paintAll)) {\n                continue;\n            }\n\n            if (elFrame >= 0) {\n                // Progressive layer changed\n                if (!currentProgressiveLayer) {\n                    currentProgressiveLayer = this._progressiveLayers[\n                        Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                    ];\n\n                    currentProgressiveLayer.ctx.save();\n                    currentProgressiveLayer.renderScope = {};\n\n                    if (currentProgressiveLayer\n                        && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                    ) {\n                        // flushProgressiveLayer(currentProgressiveLayer);\n                        // Quick jump all progressive elements\n                        // All progressive element are not dirty, jump over and flush directly\n                        i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                        // currentProgressiveLayer = null;\n                        continue;\n                    }\n\n                    layerProgress = currentProgressiveLayer.__progress;\n\n                    if (!currentProgressiveLayer.__dirty) {\n                        // Keep rendering\n                        frame = layerProgress;\n                    }\n\n                    currentProgressiveLayer.__progress = frame + 1;\n                }\n\n                if (elFrame === frame) {\n                    this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                }\n            }\n            else {\n                this._doPaintEl(el, currentLayer, paintAll, scope);\n            }\n\n            el.__dirty = false;\n        }\n\n        if (currentProgressiveLayer) {\n            flushProgressiveLayer(currentProgressiveLayer);\n        }\n\n        // Restore the lastLayer ctx\n        ctx && ctx.restore();\n        // If still has clipping state\n        // if (scope.prevElClipPaths) {\n        //     ctx.restore();\n        // }\n\n        this._furtherProgressive = false;\n        each$1(this._progressiveLayers, function (layer) {\n            if (layer.__maxProgress >= layer.__progress) {\n                this._furtherProgressive = true;\n            }\n        }, this);\n    },\n\n    _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n        var ctx = currentLayer.ctx;\n        var m = el.transform;\n        if (\n            (currentLayer.__dirty || forcePaint)\n            // Ignore invisible element\n            && !el.invisible\n            // Ignore transparent element\n            && el.style.opacity !== 0\n            // Ignore scale 0 element, in some environment like node-canvas\n            // Draw a scale 0 element can cause all following draw wrong\n            // And setTransform with scale 0 will cause set back transform failed.\n            && !(m && !m[0] && !m[3])\n            // Ignore culled element\n            && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n        ) {\n\n            var clipPaths = el.__clipPaths;\n\n            // Optimize when clipping on group with several elements\n            if (scope.prevClipLayer !== currentLayer\n                || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n            ) {\n                // If has previous clipping state, restore from it\n                if (scope.prevElClipPaths) {\n                    scope.prevClipLayer.ctx.restore();\n                    scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                    // Reset prevEl since context has been restored\n                    scope.prevEl = null;\n                }\n                // New clipping state\n                if (clipPaths) {\n                    ctx.save();\n                    doClip(clipPaths, ctx);\n                    scope.prevClipLayer = currentLayer;\n                    scope.prevElClipPaths = clipPaths;\n                }\n            }\n            el.beforeBrush && el.beforeBrush(ctx);\n\n            el.brush(ctx, scope.prevEl || null);\n            scope.prevEl = el;\n\n            el.afterBrush && el.afterBrush(ctx);\n        }\n    },\n\n    /**\n     *  zlevel \n     * @param {number} zlevel\n     * @return {module:zrender/Layer}\n     */\n    getLayer: function (zlevel) {\n        if (this._singleCanvas) {\n            return this._layers[0];\n        }\n\n        var layer = this._layers[zlevel];\n        if (!layer) {\n            // Create a new layer\n            layer = new Layer('zr_' + zlevel, this, this.dpr);\n            layer.__builtin__ = true;\n\n            if (this._layerConfig[zlevel]) {\n                merge(layer, this._layerConfig[zlevel], true);\n            }\n\n            this.insertLayer(zlevel, layer);\n\n            // Context is created after dom inserted to document\n            // Or excanvas will get 0px clientWidth and clientHeight\n            layer.initContext();\n        }\n\n        return layer;\n    },\n\n    insertLayer: function (zlevel, layer) {\n\n        var layersMap = this._layers;\n        var zlevelList = this._zlevelList;\n        var len = zlevelList.length;\n        var prevLayer = null;\n        var i = -1;\n        var domRoot = this._domRoot;\n\n        if (layersMap[zlevel]) {\n            zrLog('ZLevel ' + zlevel + ' has been used already');\n            return;\n        }\n        // Check if is a valid layer\n        if (!isLayerValid(layer)) {\n            zrLog('Layer of zlevel ' + zlevel + ' is not valid');\n            return;\n        }\n\n        if (len > 0 && zlevel > zlevelList[0]) {\n            for (i = 0; i < len - 1; i++) {\n                if (\n                    zlevelList[i] < zlevel\n                    && zlevelList[i + 1] > zlevel\n                ) {\n                    break;\n                }\n            }\n            prevLayer = layersMap[zlevelList[i]];\n        }\n        zlevelList.splice(i + 1, 0, zlevel);\n\n        layersMap[zlevel] = layer;\n\n        // Vitual layer will not directly show on the screen.\n        // (It can be a WebGL layer and assigned to a ZImage element)\n        // But it still under management of zrender.\n        if (!layer.virtual) {\n            if (prevLayer) {\n                var prevDom = prevLayer.dom;\n                if (prevDom.nextSibling) {\n                    domRoot.insertBefore(\n                        layer.dom,\n                        prevDom.nextSibling\n                    );\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n            else {\n                if (domRoot.firstChild) {\n                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n        }\n    },\n\n    // Iterate each layer\n    eachLayer: function (cb, context) {\n        var zlevelList = this._zlevelList;\n        var z;\n        var i;\n        for (i = 0; i < zlevelList.length; i++) {\n            z = zlevelList[i];\n            cb.call(context, this._layers[z], z);\n        }\n    },\n\n    // Iterate each buildin layer\n    eachBuiltinLayer: function (cb, context) {\n        var zlevelList = this._zlevelList;\n        var layer;\n        var z;\n        var i;\n        for (i = 0; i < zlevelList.length; i++) {\n            z = zlevelList[i];\n            layer = this._layers[z];\n            if (layer.__builtin__) {\n                cb.call(context, layer, z);\n            }\n        }\n    },\n\n    // Iterate each other layer except buildin layer\n    eachOtherLayer: function (cb, context) {\n        var zlevelList = this._zlevelList;\n        var layer;\n        var z;\n        var i;\n        for (i = 0; i < zlevelList.length; i++) {\n            z = zlevelList[i];\n            layer = this._layers[z];\n            if (!layer.__builtin__) {\n                cb.call(context, layer, z);\n            }\n        }\n    },\n\n    /**\n     * \n     * @param {Array.<module:zrender/Layer>} [prevLayer]\n     */\n    getLayers: function () {\n        return this._layers;\n    },\n\n    _updateLayerStatus: function (list) {\n\n        var layers = this._layers;\n        var progressiveLayers = this._progressiveLayers;\n\n        var elCountsLastFrame = {};\n        var progressiveElCountsLastFrame = {};\n\n        this.eachBuiltinLayer(function (layer, z) {\n            elCountsLastFrame[z] = layer.elCount;\n            layer.elCount = 0;\n            layer.__dirty = false;\n        });\n\n        each$1(progressiveLayers, function (layer, idx) {\n            progressiveElCountsLastFrame[idx] = layer.elCount;\n            layer.elCount = 0;\n            layer.__dirty = false;\n        });\n\n        var progressiveLayerCount = 0;\n        var currentProgressiveLayer;\n        var lastProgressiveKey;\n        var frameCount = 0;\n        for (var i = 0, l = list.length; i < l; i++) {\n            var el = list[i];\n            var zlevel = this._singleCanvas ? 0 : el.zlevel;\n            var layer = layers[zlevel];\n            var elProgress = el.progressive;\n            if (layer) {\n                layer.elCount++;\n                layer.__dirty = layer.__dirty || el.__dirty;\n            }\n\n            /////// Update progressive\n            if (elProgress >= 0) {\n                // Fix wrong progressive sequence problem.\n                if (lastProgressiveKey !== elProgress) {\n                    lastProgressiveKey = elProgress;\n                    frameCount++;\n                }\n                var elFrame = el.__frame = frameCount - 1;\n                if (!currentProgressiveLayer) {\n                    var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                    currentProgressiveLayer = progressiveLayers[idx];\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                            'progressive', this, this.dpr\n                        );\n                        currentProgressiveLayer.initContext();\n                    }\n                    currentProgressiveLayer.__maxProgress = 0;\n                }\n                currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                currentProgressiveLayer.elCount++;\n\n                currentProgressiveLayer.__maxProgress = Math.max(\n                    currentProgressiveLayer.__maxProgress, elFrame\n                );\n\n                if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                    // Should keep rendering this  layer because progressive rendering is not finished yet\n                    layer.__dirty = true;\n                }\n            }\n            else {\n                el.__frame = -1;\n\n                if (currentProgressiveLayer) {\n                    currentProgressiveLayer.__nextIdxNotProg = i;\n                    progressiveLayerCount++;\n                    currentProgressiveLayer = null;\n                }\n            }\n        }\n\n        if (currentProgressiveLayer) {\n            progressiveLayerCount++;\n            currentProgressiveLayer.__nextIdxNotProg = i;\n        }\n\n        // \n        this.eachBuiltinLayer(function (layer, z) {\n            if (elCountsLastFrame[z] !== layer.elCount) {\n                layer.__dirty = true;\n            }\n        });\n\n        progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n        each$1(progressiveLayers, function (layer, idx) {\n            if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                el.__dirty = true;\n            }\n            if (layer.__dirty) {\n                layer.__progress = 0;\n            }\n        });\n    },\n\n    /**\n     * hover\n     */\n    clear: function () {\n        this.eachBuiltinLayer(this._clearLayer);\n        return this;\n    },\n\n    _clearLayer: function (layer) {\n        layer.clear();\n    },\n\n    /**\n     * zlevel\n     *\n     * @param {string} zlevel\n     * @param {Object} config \n     * @param {string} [config.clearColor=0] \n     * @param {string} [config.motionBlur=false] \n     * @param {number} [config.lastFrameAlpha=0.7]\n     *                 alpha\n     */\n    configLayer: function (zlevel, config) {\n        if (config) {\n            var layerConfig = this._layerConfig;\n            if (!layerConfig[zlevel]) {\n                layerConfig[zlevel] = config;\n            }\n            else {\n                merge(layerConfig[zlevel], config, true);\n            }\n\n            var layer = this._layers[zlevel];\n\n            if (layer) {\n                merge(layer, layerConfig[zlevel], true);\n            }\n        }\n    },\n\n    /**\n     * \n     * @param {number} zlevel zlevel\n     */\n    delLayer: function (zlevel) {\n        var layers = this._layers;\n        var zlevelList = this._zlevelList;\n        var layer = layers[zlevel];\n        if (!layer) {\n            return;\n        }\n        layer.dom.parentNode.removeChild(layer.dom);\n        delete layers[zlevel];\n\n        zlevelList.splice(indexOf(zlevelList, zlevel), 1);\n    },\n\n    /**\n     * \n     */\n    resize: function (width, height) {\n        var domRoot = this._domRoot;\n        // FIXME Why ?\n        domRoot.style.display = 'none';\n\n        // Save input w/h\n        var opts = this._opts;\n        width != null && (opts.width = width);\n        height != null && (opts.height = height);\n\n        width = this._getSize(0);\n        height = this._getSize(1);\n\n        domRoot.style.display = '';\n\n        // resize\n        if (this._width != width || height != this._height) {\n            domRoot.style.width = width + 'px';\n            domRoot.style.height = height + 'px';\n\n            for (var id in this._layers) {\n                if (this._layers.hasOwnProperty(id)) {\n                    this._layers[id].resize(width, height);\n                }\n            }\n            each$1(this._progressiveLayers, function (layer) {\n                layer.resize(width, height);\n            });\n\n            this.refresh(true);\n        }\n\n        this._width = width;\n        this._height = height;\n\n        return this;\n    },\n\n    /**\n     * \n     * @param {number} zlevel\n     */\n    clearLayer: function (zlevel) {\n        var layer = this._layers[zlevel];\n        if (layer) {\n            layer.clear();\n        }\n    },\n\n    /**\n     * \n     */\n    dispose: function () {\n        this.root.innerHTML = '';\n\n        this.root =\n        this.storage =\n\n        this._domRoot =\n        this._layers = null;\n    },\n\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     * @param {number} [opts.pixelRatio]\n     */\n    getRenderedCanvas: function (opts) {\n        opts = opts || {};\n        if (this._singleCanvas) {\n            return this._layers[0].dom;\n        }\n\n        var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n        imageLayer.initContext();\n\n        imageLayer.clearColor = opts.backgroundColor;\n        imageLayer.clear();\n\n        var displayList = this.storage.getDisplayList(true);\n\n        var scope = {};\n        var zlevel;\n\n        var self = this;\n        function findAndDrawOtherLayer(smaller, larger) {\n            var zlevelList = self._zlevelList;\n            if (smaller == null) {\n                smaller = -Infinity;\n            }\n            var intermediateLayer;\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = self._layers[z];\n                if (!layer.__builtin__ && z > smaller && z < larger) {\n                    intermediateLayer = layer;\n                    break;\n                }\n            }\n            if (intermediateLayer && intermediateLayer.renderToCanvas) {\n                imageLayer.ctx.save();\n                intermediateLayer.renderToCanvas(imageLayer.ctx);\n                imageLayer.ctx.restore();\n            }\n        }\n        for (var i = 0; i < displayList.length; i++) {\n            var el = displayList[i];\n\n            if (el.zlevel !== zlevel) {\n                findAndDrawOtherLayer(zlevel, el.zlevel);\n                zlevel = el.zlevel;\n            }\n            this._doPaintEl(el, imageLayer, true, scope);\n        }\n\n        findAndDrawOtherLayer(zlevel, Infinity);\n\n        return imageLayer.dom;\n    },\n    /**\n     * \n     */\n    getWidth: function () {\n        return this._width;\n    },\n\n    /**\n     * \n     */\n    getHeight: function () {\n        return this._height;\n    },\n\n    _getSize: function (whIdx) {\n        var opts = this._opts;\n        var wh = ['width', 'height'][whIdx];\n        var cwh = ['clientWidth', 'clientHeight'][whIdx];\n        var plt = ['paddingLeft', 'paddingTop'][whIdx];\n        var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n        if (opts[wh] != null && opts[wh] !== 'auto') {\n            return parseFloat(opts[wh]);\n        }\n\n        var root = this.root;\n        // IE8 does not support getComputedStyle, but it use VML.\n        var stl = document.defaultView.getComputedStyle(root);\n\n        return (\n            (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n            - (parseInt10(stl[plt]) || 0)\n            - (parseInt10(stl[prb]) || 0)\n        ) | 0;\n    },\n\n    pathToImage: function (path, dpr) {\n        dpr = dpr || this.dpr;\n\n        var canvas = document.createElement('canvas');\n        var ctx = canvas.getContext('2d');\n        var rect = path.getBoundingRect();\n        var style = path.style;\n        var shadowBlurSize = style.shadowBlur;\n        var shadowOffsetX = style.shadowOffsetX;\n        var shadowOffsetY = style.shadowOffsetY;\n        var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\n        var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n        var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n        var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n        var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n        var width = rect.width + leftMargin + rightMargin;\n        var height = rect.height + topMargin + bottomMargin;\n\n        canvas.width = width * dpr;\n        canvas.height = height * dpr;\n\n        ctx.scale(dpr, dpr);\n        ctx.clearRect(0, 0, width, height);\n        ctx.dpr = dpr;\n\n        var pathTransform = {\n            position: path.position,\n            rotation: path.rotation,\n            scale: path.scale\n        };\n        path.position = [leftMargin - rect.x, topMargin - rect.y];\n        path.rotation = 0;\n        path.scale = [1, 1];\n        path.updateTransform();\n        if (path) {\n            path.brush(ctx);\n        }\n\n        var ImageShape = ZImage;\n        var imgShape = new ImageShape({\n            style: {\n                x: 0,\n                y: 0,\n                image: canvas\n            }\n        });\n\n        if (pathTransform.position != null) {\n            imgShape.position = path.position = pathTransform.position;\n        }\n\n        if (pathTransform.rotation != null) {\n            imgShape.rotation = path.rotation = pathTransform.rotation;\n        }\n\n        if (pathTransform.scale != null) {\n            imgShape.scale = path.scale = pathTransform.scale;\n        }\n\n        return imgShape;\n    }\n};\n\n/**\n * \n * @module zrender/core/event\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\n\nvar isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\nvar MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\n\nfunction getBoundingClientRect(el) {\n    // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n    return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n}\n\n// `calculate` is optional, default false\nfunction clientToLocal(el, e, out, calculate) {\n    out = out || {};\n\n    // According to the W3C Working Draft, offsetX and offsetY should be relative\n    // to the padding edge of the target element. The only browser using this convention\n    // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n    // not support the properties.\n    // (see http://www.jacklmoore.com/notes/mouse-position/)\n    // In zr painter.dom, padding edge equals to border edge.\n\n    // FIXME\n    // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n    // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n    // is too complex. So css-transfrom dont support in this case temporarily.\n    if (calculate || !env$1.canvasSupported) {\n        defaultGetZrXY(el, e, out);\n    }\n    // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n    // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n    // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n    // zoom-factor, overflow / opacity layers, transforms ...)\n    // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n    // <https://bugs.jquery.com/ticket/8523#comment:14>\n    // BTW3, In ff, offsetX/offsetY is always 0.\n    else if (env$1.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n        out.zrX = e.layerX;\n        out.zrY = e.layerY;\n    }\n    // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n    else if (e.offsetX != null) {\n        out.zrX = e.offsetX;\n        out.zrY = e.offsetY;\n    }\n    // For some other device, e.g., IOS safari.\n    else {\n        defaultGetZrXY(el, e, out);\n    }\n\n    return out;\n}\n\nfunction defaultGetZrXY(el, e, out) {\n    // This well-known method below does not support css transform.\n    var box = getBoundingClientRect(el);\n    out.zrX = e.clientX - box.left;\n    out.zrY = e.clientY - box.top;\n}\n\n/**\n * domtouch.\n * `calculate` is optional, default false.\n */\nfunction normalizeEvent(el, e, calculate) {\n\n    e = e || window.event;\n\n    if (e.zrX != null) {\n        return e;\n    }\n\n    var eventType = e.type;\n    var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n    if (!isTouch) {\n        clientToLocal(el, e, e, calculate);\n        e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n    }\n    else {\n        var touch = eventType != 'touchend'\n            ? e.targetTouches[0]\n            : e.changedTouches[0];\n        touch && clientToLocal(el, touch, e, calculate);\n    }\n\n    // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n    // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n    // If e.which has been defined, if may be readonly,\n    // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n    var button = e.button;\n    if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n        e.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));\n    }\n\n    return e;\n}\n\nfunction addEventListener(el, name, handler) {\n    if (isDomLevel2) {\n        el.addEventListener(name, handler);\n    }\n    else {\n        el.attachEvent('on' + name, handler);\n    }\n}\n\nfunction removeEventListener(el, name, handler) {\n    if (isDomLevel2) {\n        el.removeEventListener(name, handler);\n    }\n    else {\n        el.detachEvent('on' + name, handler);\n    }\n}\n\n/**\n * preventDefault and stopPropagation.\n * Notice: do not do that in zrender. Upper application\n * do that if necessary.\n *\n * @memberOf module:zrender/core/event\n * @method\n * @param {Event} e : event\n */\nvar stop = isDomLevel2\n    ? function (e) {\n        e.preventDefault();\n        e.stopPropagation();\n        e.cancelBubble = true;\n    }\n    : function (e) {\n        e.returnValue = false;\n        e.cancelBubble = true;\n    };\n\nfunction notLeftMouse(e) {\n    // If e.which is undefined, considered as left mouse event.\n    return e.which > 1;\n}\n\n/**\n * , \n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n/**\n * @typedef {Object} IZRenderStage\n * @property {Function} update\n */\n\n/**\n * @alias module:zrender/animation/Animation\n * @constructor\n * @param {Object} [options]\n * @param {Function} [options.onframe]\n * @param {IZRenderStage} [options.stage]\n * @example\n *     var animation = new Animation();\n *     var obj = {\n *         x: 100,\n *         y: 100\n *     };\n *     animation.animate(node.position)\n *         .when(1000, {\n *             x: 500,\n *             y: 500\n *         })\n *         .when(2000, {\n *             x: 100,\n *             y: 100\n *         })\n *         .start('spline');\n */\nvar Animation = function (options) {\n\n    options = options || {};\n\n    this.stage = options.stage || {};\n\n    this.onframe = options.onframe || function() {};\n\n    // private properties\n    this._clips = [];\n\n    this._running = false;\n\n    this._time;\n\n    this._pausedTime;\n\n    this._pauseStart;\n\n    this._paused = false;\n\n    Eventful.call(this);\n};\n\nAnimation.prototype = {\n\n    constructor: Animation,\n    /**\n     *  clip\n     * @param {module:zrender/animation/Clip} clip\n     */\n    addClip: function (clip) {\n        this._clips.push(clip);\n    },\n    /**\n     *  animator\n     * @param {module:zrender/animation/Animator} animator\n     */\n    addAnimator: function (animator) {\n        animator.animation = this;\n        var clips = animator.getClips();\n        for (var i = 0; i < clips.length; i++) {\n            this.addClip(clips[i]);\n        }\n    },\n    /**\n     * \n     * @param {module:zrender/animation/Clip} clip\n     */\n    removeClip: function(clip) {\n        var idx = indexOf(this._clips, clip);\n        if (idx >= 0) {\n            this._clips.splice(idx, 1);\n        }\n    },\n\n    /**\n     * \n     * @param {module:zrender/animation/Animator} animator\n     */\n    removeAnimator: function (animator) {\n        var clips = animator.getClips();\n        for (var i = 0; i < clips.length; i++) {\n            this.removeClip(clips[i]);\n        }\n        animator.animation = null;\n    },\n\n    _update: function() {\n\n        var time = new Date().getTime() - this._pausedTime;\n        var delta = time - this._time;\n        var clips = this._clips;\n        var len = clips.length;\n\n        var deferredEvents = [];\n        var deferredClips = [];\n        for (var i = 0; i < len; i++) {\n            var clip = clips[i];\n            var e = clip.step(time, delta);\n            // Throw out the events need to be called after\n            // stage.update, like destroy\n            if (e) {\n                deferredEvents.push(e);\n                deferredClips.push(clip);\n            }\n        }\n\n        // Remove the finished clip\n        for (var i = 0; i < len;) {\n            if (clips[i]._needsRemove) {\n                clips[i] = clips[len - 1];\n                clips.pop();\n                len--;\n            }\n            else {\n                i++;\n            }\n        }\n\n        len = deferredEvents.length;\n        for (var i = 0; i < len; i++) {\n            deferredClips[i].fire(deferredEvents[i]);\n        }\n\n        this._time = time;\n\n        this.onframe(delta);\n\n        this.trigger('frame', delta);\n\n        if (this.stage.update) {\n            this.stage.update();\n        }\n    },\n\n    _startLoop: function () {\n        var self = this;\n\n        this._running = true;\n\n        function step() {\n            if (self._running) {\n\n                requestAnimationFrame(step);\n\n                !self._paused && self._update();\n            }\n        }\n\n        requestAnimationFrame(step);\n    },\n\n    /**\n     * \n     */\n    start: function () {\n\n        this._time = new Date().getTime();\n        this._pausedTime = 0;\n\n        this._startLoop();\n    },\n    /**\n     * \n     */\n    stop: function () {\n        this._running = false;\n    },\n\n    /**\n     * Pause\n     */\n    pause: function () {\n        if (!this._paused) {\n            this._pauseStart = new Date().getTime();\n            this._paused = true;\n        }\n    },\n\n    /**\n     * Resume\n     */\n    resume: function () {\n        if (this._paused) {\n            this._pausedTime += (new Date().getTime()) - this._pauseStart;\n            this._paused = false;\n        }\n    },\n\n    /**\n     * \n     */\n    clear: function () {\n        this._clips = [];\n    },\n    /**\n     * animator\n     * @param  {Object} target\n     * @param  {Object} options\n     * @param  {boolean} [options.loop=false] \n     * @param  {Function} [options.getter=null]\n     *         gettergetter\n     * @param  {Function} [options.setter=null]\n     *         settersetter\n     * @return {module:zrender/animation/Animation~Animator}\n     */\n    // TODO Gap\n    animate: function (target, options) {\n        options = options || {};\n\n        var animator = new Animator(\n            target,\n            options.loop,\n            options.getter,\n            options.setter\n        );\n\n        this.addAnimator(animator);\n\n        return animator;\n    }\n};\n\nmixin(Animation, Eventful);\n\n/**\n * Only implements needed gestures for mobile.\n */\n\nvar GestureMgr = function () {\n\n    /**\n     * @private\n     * @type {Array.<Object>}\n     */\n    this._track = [];\n};\n\nGestureMgr.prototype = {\n\n    constructor: GestureMgr,\n\n    recognize: function (event, target, root) {\n        this._doTrack(event, target, root);\n        return this._recognize(event);\n    },\n\n    clear: function () {\n        this._track.length = 0;\n        return this;\n    },\n\n    _doTrack: function (event, target, root) {\n        var touches = event.touches;\n\n        if (!touches) {\n            return;\n        }\n\n        var trackItem = {\n            points: [],\n            touches: [],\n            target: target,\n            event: event\n        };\n\n        for (var i = 0, len = touches.length; i < len; i++) {\n            var touch = touches[i];\n            var pos = clientToLocal(root, touch, {});\n            trackItem.points.push([pos.zrX, pos.zrY]);\n            trackItem.touches.push(touch);\n        }\n\n        this._track.push(trackItem);\n    },\n\n    _recognize: function (event) {\n        for (var eventName in recognizers) {\n            if (recognizers.hasOwnProperty(eventName)) {\n                var gestureInfo = recognizers[eventName](this._track, event);\n                if (gestureInfo) {\n                    return gestureInfo;\n                }\n            }\n        }\n    }\n};\n\nfunction dist$1(pointPair) {\n    var dx = pointPair[1][0] - pointPair[0][0];\n    var dy = pointPair[1][1] - pointPair[0][1];\n\n    return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction center(pointPair) {\n    return [\n        (pointPair[0][0] + pointPair[1][0]) / 2,\n        (pointPair[0][1] + pointPair[1][1]) / 2\n    ];\n}\n\nvar recognizers = {\n\n    pinch: function (track, event) {\n        var trackLen = track.length;\n\n        if (!trackLen) {\n            return;\n        }\n\n        var pinchEnd = (track[trackLen - 1] || {}).points;\n        var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n        if (pinchPre\n            && pinchPre.length > 1\n            && pinchEnd\n            && pinchEnd.length > 1\n        ) {\n            var pinchScale = dist$1(pinchEnd) / dist$1(pinchPre);\n            !isFinite(pinchScale) && (pinchScale = 1);\n\n            event.pinchScale = pinchScale;\n\n            var pinchCenter = center(pinchEnd);\n            event.pinchX = pinchCenter[0];\n            event.pinchY = pinchCenter[1];\n\n            return {\n                type: 'pinch',\n                target: track[0].target,\n                event: event\n            };\n        }\n    }\n\n    // Only pinch currently.\n};\n\nvar TOUCH_CLICK_DELAY = 300;\n\nvar mouseHandlerNames = [\n    'click', 'dblclick', 'mousewheel', 'mouseout',\n    'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n];\n\nvar touchHandlerNames = [\n    'touchstart', 'touchend', 'touchmove'\n];\n\nvar pointerEventNames = {\n    pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n};\n\nvar pointerHandlerNames = map(mouseHandlerNames, function (name) {\n    var nm = name.replace('mouse', 'pointer');\n    return pointerEventNames[nm] ? nm : name;\n});\n\nfunction eventNameFix(name) {\n    return (name === 'mousewheel' && env$1.browser.firefox) ? 'DOMMouseScroll' : name;\n}\n\nfunction processGesture(proxy, event, stage) {\n    var gestureMgr = proxy._gestureMgr;\n\n    stage === 'start' && gestureMgr.clear();\n\n    var gestureInfo = gestureMgr.recognize(\n        event,\n        proxy.handler.findHover(event.zrX, event.zrY, null).target,\n        proxy.dom\n    );\n\n    stage === 'end' && gestureMgr.clear();\n\n    // Do not do any preventDefault here. Upper application do that if necessary.\n    if (gestureInfo) {\n        var type = gestureInfo.type;\n        event.gestureEvent = type;\n\n        proxy.handler.dispatchToElement({target: gestureInfo.target}, type, gestureInfo.event);\n    }\n}\n\n// function onMSGestureChange(proxy, event) {\n//     if (event.translationX || event.translationY) {\n//         // mousemove is carried by MSGesture to reduce the sensitivity.\n//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n//     }\n//     if (event.scale !== 1) {\n//         event.pinchX = event.offsetX;\n//         event.pinchY = event.offsetY;\n//         event.pinchScale = event.scale;\n//         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n//     }\n// }\n\n/**\n * Prevent mouse event from being dispatched after Touch Events action\n * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n * Result: Blocking Mouse Events for 700ms.\n */\nfunction setTouchTimer(instance) {\n    instance._touching = true;\n    clearTimeout(instance._touchTimer);\n    instance._touchTimer = setTimeout(function () {\n        instance._touching = false;\n    }, 700);\n}\n\n\nvar domHandlers = {\n    /**\n     * Mouse move handler\n     * @inner\n     * @param {Event} event\n     */\n    mousemove: function (event) {\n        event = normalizeEvent(this.dom, event);\n\n        this.trigger('mousemove', event);\n    },\n\n    /**\n     * Mouse out handler\n     * @inner\n     * @param {Event} event\n     */\n    mouseout: function (event) {\n        event = normalizeEvent(this.dom, event);\n\n        var element = event.toElement || event.relatedTarget;\n        if (element != this.dom) {\n            while (element && element.nodeType != 9) {\n                // rootdommouseOut\n                if (element === this.dom) {\n                    return;\n                }\n\n                element = element.parentNode;\n            }\n        }\n\n        this.trigger('mouseout', event);\n    },\n\n    /**\n     * Touch\n     * @inner\n     * @param {Event} event\n     */\n    touchstart: function (event) {\n        // Default mouse behaviour should not be disabled here.\n        // For example, page may needs to be slided.\n        event = normalizeEvent(this.dom, event);\n\n        // Mark touch, which is useful in distinguish touch and\n        // mouse event in upper applicatoin.\n        event.zrByTouch = true;\n\n        this._lastTouchMoment = new Date();\n\n        processGesture(this, event, 'start');\n\n        // In touch device, trigger `mousemove`(`mouseover`) should\n        // be triggered, and must before `mousedown` triggered.\n        domHandlers.mousemove.call(this, event);\n\n        domHandlers.mousedown.call(this, event);\n\n        setTouchTimer(this);\n    },\n\n    /**\n     * Touch\n     * @inner\n     * @param {Event} event\n     */\n    touchmove: function (event) {\n\n        event = normalizeEvent(this.dom, event);\n\n        // Mark touch, which is useful in distinguish touch and\n        // mouse event in upper applicatoin.\n        event.zrByTouch = true;\n\n        processGesture(this, event, 'change');\n\n        // Mouse move should always be triggered no matter whether\n        // there is gestrue event, because mouse move and pinch may\n        // be used at the same time.\n        domHandlers.mousemove.call(this, event);\n\n        setTouchTimer(this);\n    },\n\n    /**\n     * Touch\n     * @inner\n     * @param {Event} event\n     */\n    touchend: function (event) {\n\n        event = normalizeEvent(this.dom, event);\n\n        // Mark touch, which is useful in distinguish touch and\n        // mouse event in upper applicatoin.\n        event.zrByTouch = true;\n\n        processGesture(this, event, 'end');\n\n        domHandlers.mouseup.call(this, event);\n\n        // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n        // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n        // we can conveniently implement \"hover style\" in both PC and touch device just\n        // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n        // to remove \"hover style\" on an element, without any additional code for\n        // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n        // style\" will remain for user view)\n\n        // click event should always be triggered no matter whether\n        // there is gestrue event. System click can not be prevented.\n        if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n            domHandlers.click.call(this, event);\n        }\n\n        setTouchTimer(this);\n    },\n\n    pointerdown: function (event) {\n        domHandlers.mousedown.call(this, event);\n\n        // if (useMSGuesture(this, event)) {\n        //     this._msGesture.addPointer(event.pointerId);\n        // }\n    },\n\n    pointermove: function (event) {\n        // FIXME\n        // pointermove is so sensitive that it always triggered when\n        // tap(click) on touch screen, which affect some judgement in\n        // upper application. So, we dont support mousemove on MS touch\n        // device yet.\n        if (!isPointerFromTouch(event)) {\n            domHandlers.mousemove.call(this, event);\n        }\n    },\n\n    pointerup: function (event) {\n        domHandlers.mouseup.call(this, event);\n    },\n\n    pointerout: function (event) {\n        // pointerout will be triggered when tap on touch screen\n        // (IE11+/Edge on MS Surface) after click event triggered,\n        // which is inconsistent with the mousout behavior we defined\n        // in touchend. So we unify them.\n        // (check domHandlers.touchend for detailed explanation)\n        if (!isPointerFromTouch(event)) {\n            domHandlers.mouseout.call(this, event);\n        }\n    }\n};\n\nfunction isPointerFromTouch(event) {\n    var pointerType = event.pointerType;\n    return pointerType === 'pen' || pointerType === 'touch';\n}\n\n// function useMSGuesture(handlerProxy, event) {\n//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n// }\n\n// Common handlers\neach$1(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n    domHandlers[name] = function (event) {\n        event = normalizeEvent(this.dom, event);\n        this.trigger(name, event);\n    };\n});\n\n/**\n * dom \n *\n * @inner\n * @param {module:zrender/Handler} instance \n */\nfunction initDomHandler(instance) {\n    each$1(touchHandlerNames, function (name) {\n        instance._handlers[name] = bind(domHandlers[name], instance);\n    });\n\n    each$1(pointerHandlerNames, function (name) {\n        instance._handlers[name] = bind(domHandlers[name], instance);\n    });\n\n    each$1(mouseHandlerNames, function (name) {\n        instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n    });\n\n    function makeMouseHandler(fn, instance) {\n        return function () {\n            if (instance._touching) {\n                return;\n            }\n            return fn.apply(instance, arguments);\n        };\n    }\n}\n\n\nfunction HandlerDomProxy(dom) {\n    Eventful.call(this);\n\n    this.dom = dom;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this._touching = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this._touchTimer;\n\n    /**\n     * @private\n     * @type {module:zrender/core/GestureMgr}\n     */\n    this._gestureMgr = new GestureMgr();\n\n    this._handlers = {};\n\n    initDomHandler(this);\n\n    if (env$1.pointerEventsSupported) { // Only IE11+/Edge\n        // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n        // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n        // at the same time.\n        // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n        // screen, which do not occurs in pointer event.\n        // So we use pointer event to both detect touch gesture and mouse behavior.\n        mountHandlers(pointerHandlerNames, this);\n\n        // FIXME\n        // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n        // which does not prevent defuault behavior occasionally (which may cause view port\n        // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n        // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n        // touch screen. And we only support click behavior on MS touch screen now.\n\n        // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n        // We dont support touch on IE on win7.\n        // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n        // if (typeof MSGesture === 'function') {\n        //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n        //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n        // }\n    }\n    else {\n        if (env$1.touchEventsSupported) {\n            mountHandlers(touchHandlerNames, this);\n            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n            // addEventListener(root, 'mouseout', this._mouseoutHandler);\n        }\n\n        // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n        // mouse event can not be handle in those devices.\n        // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n        // mouseevent after touch event triggered, see `setTouchTimer`.\n        mountHandlers(mouseHandlerNames, this);\n    }\n\n    function mountHandlers(handlerNames, instance) {\n        each$1(handlerNames, function (name) {\n            addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n        }, instance);\n    }\n}\n\nvar handlerDomProxyProto = HandlerDomProxy.prototype;\nhandlerDomProxyProto.dispose = function () {\n    var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n    for (var i = 0; i < handlerNames.length; i++) {\n        var name = handlerNames[i];\n        removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n    }\n};\n\nhandlerDomProxyProto.setCursor = function (cursorStyle) {\n    this.dom.style.cursor = cursorStyle || 'default';\n};\n\nmixin(HandlerDomProxy, Eventful);\n\n/*!\n* ZRender, a high performance 2d drawing library.\n*\n* Copyright (c) 2013, Baidu Inc.\n* All rights reserved.\n*\n* LICENSE\n* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n*/\n\nvar useVML = !env$1.canvasSupported;\n\nvar painterCtors = {\n    canvas: Painter\n};\n\nvar instances$1 = {};    // ZRendermap\n\n/**\n * @type {string}\n */\nvar version$1 = '3.7.3';\n\n/**\n * Initializing a zrender instance\n * @param {HTMLElement} dom\n * @param {Object} opts\n * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n * @param {number} [opts.devicePixelRatio]\n * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n * @return {module:zrender/ZRender}\n */\nfunction init$1(dom, opts) {\n    var zr = new ZRender(guid(), dom, opts);\n    instances$1[zr.id] = zr;\n    return zr;\n}\n\n/**\n * Dispose zrender instance\n * @param {module:zrender/ZRender} zr\n */\nfunction dispose$1(zr) {\n    if (zr) {\n        zr.dispose();\n    }\n    else {\n        for (var key in instances$1) {\n            if (instances$1.hasOwnProperty(key)) {\n                instances$1[key].dispose();\n            }\n        }\n        instances$1 = {};\n    }\n\n    return this;\n}\n\n/**\n * Get zrender instance by id\n * @param {string} id zrender instance id\n * @return {module:zrender/ZRender}\n */\nfunction getInstance(id) {\n    return instances$1[id];\n}\n\nfunction registerPainter(name, Ctor) {\n    painterCtors[name] = Ctor;\n}\n\nfunction delInstance(id) {\n    delete instances$1[id];\n}\n\n/**\n * @module zrender/ZRender\n */\n/**\n * @constructor\n * @alias module:zrender/ZRender\n * @param {string} id\n * @param {HTMLElement} dom\n * @param {Object} opts\n * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n * @param {number} [opts.devicePixelRatio]\n * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n */\nvar ZRender = function (id, dom, opts) {\n\n    opts = opts || {};\n\n    /**\n     * @type {HTMLDomElement}\n     */\n    this.dom = dom;\n\n    /**\n     * @type {string}\n     */\n    this.id = id;\n\n    var self = this;\n    var storage = new Storage();\n\n    var rendererType = opts.renderer;\n    // TODO WebGL\n    if (useVML) {\n        if (!painterCtors.vml) {\n            throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n        }\n        rendererType = 'vml';\n    }\n    else if (!rendererType || !painterCtors[rendererType]) {\n        rendererType = 'canvas';\n    }\n    var painter = new painterCtors[rendererType](dom, storage, opts);\n\n    this.storage = storage;\n    this.painter = painter;\n\n    var handerProxy = !env$1.node ? new HandlerDomProxy(painter.getViewportRoot()) : null;\n    this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n    /**\n     * @type {module:zrender/animation/Animation}\n     */\n    this.animation = new Animation({\n        stage: {\n            update: bind(this.flush, this)\n        }\n    });\n    this.animation.start();\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this._needsRefresh;\n\n    //  storage.delFromStorage, \n    // FIXME ugly\n    var oldDelFromStorage = storage.delFromStorage;\n    var oldAddToStorage = storage.addToStorage;\n\n    storage.delFromStorage = function (el) {\n        oldDelFromStorage.call(storage, el);\n\n        el && el.removeSelfFromZr(self);\n    };\n\n    storage.addToStorage = function (el) {\n        oldAddToStorage.call(storage, el);\n\n        el.addSelfToZr(self);\n    };\n};\n\nZRender.prototype = {\n\n    constructor: ZRender,\n    /**\n     * \n     * @return {string}\n     */\n    getId: function () {\n        return this.id;\n    },\n\n    /**\n     * \n     * @param  {module:zrender/Element} el\n     */\n    add: function (el) {\n        this.storage.addRoot(el);\n        this._needsRefresh = true;\n    },\n\n    /**\n     * \n     * @param  {module:zrender/Element} el\n     */\n    remove: function (el) {\n        this.storage.delRoot(el);\n        this._needsRefresh = true;\n    },\n\n    /**\n     * Change configuration of layer\n     * @param {string} zLevel\n     * @param {Object} config\n     * @param {string} [config.clearColor=0] Clear color\n     * @param {string} [config.motionBlur=false] If enable motion blur\n     * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n    */\n    configLayer: function (zLevel, config) {\n        this.painter.configLayer(zLevel, config);\n        this._needsRefresh = true;\n    },\n\n    /**\n     * Repaint the canvas immediately\n     */\n    refreshImmediately: function () {\n        // var start = new Date();\n        // Clear needsRefresh ahead to avoid something wrong happens in refresh\n        // Or it will cause zrender refreshes again and again.\n        this._needsRefresh = false;\n        this.painter.refresh();\n        /**\n         * Avoid trigger zr.refresh in Element#beforeUpdate hook\n         */\n        this._needsRefresh = false;\n        // var end = new Date();\n\n        // var log = document.getElementById('log');\n        // if (log) {\n        //     log.innerHTML = log.innerHTML + '<br>' + (end - start);\n        // }\n    },\n\n    /**\n     * Mark and repaint the canvas in the next frame of browser\n     */\n    refresh: function() {\n        this._needsRefresh = true;\n    },\n\n    /**\n     * Perform all refresh\n     */\n    flush: function () {\n        if (this._needsRefresh) {\n            this.refreshImmediately();\n        }\n        if (this._needsRefreshHover) {\n            this.refreshHoverImmediately();\n        }\n    },\n\n    /**\n     * Add element to hover layer\n     * @param  {module:zrender/Element} el\n     * @param {Object} style\n     */\n    addHover: function (el, style) {\n        if (this.painter.addHover) {\n            this.painter.addHover(el, style);\n            this.refreshHover();\n        }\n    },\n\n    /**\n     * Add element from hover layer\n     * @param  {module:zrender/Element} el\n     */\n    removeHover: function (el) {\n        if (this.painter.removeHover) {\n            this.painter.removeHover(el);\n            this.refreshHover();\n        }\n    },\n\n    /**\n     * Clear all hover elements in hover layer\n     * @param  {module:zrender/Element} el\n     */\n    clearHover: function () {\n        if (this.painter.clearHover) {\n            this.painter.clearHover();\n            this.refreshHover();\n        }\n    },\n\n    /**\n     * Refresh hover in next frame\n     */\n    refreshHover: function () {\n        this._needsRefreshHover = true;\n    },\n\n    /**\n     * Refresh hover immediately\n     */\n    refreshHoverImmediately: function () {\n        this._needsRefreshHover = false;\n        this.painter.refreshHover && this.painter.refreshHover();\n    },\n\n    /**\n     * Resize the canvas.\n     * Should be invoked when container size is changed\n     * @param {Object} [opts]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    resize: function(opts) {\n        opts = opts || {};\n        this.painter.resize(opts.width, opts.height);\n        this.handler.resize();\n    },\n\n    /**\n     * Stop and clear all animation immediately\n     */\n    clearAnimation: function () {\n        this.animation.clear();\n    },\n\n    /**\n     * Get container width\n     */\n    getWidth: function() {\n        return this.painter.getWidth();\n    },\n\n    /**\n     * Get container height\n     */\n    getHeight: function() {\n        return this.painter.getHeight();\n    },\n\n    /**\n     * Export the canvas as Base64 URL\n     * @param {string} type\n     * @param {string} [backgroundColor='#fff']\n     * @return {string} Base64 URL\n     */\n    // toDataURL: function(type, backgroundColor) {\n    //     return this.painter.getRenderedCanvas({\n    //         backgroundColor: backgroundColor\n    //     }).toDataURL(type);\n    // },\n\n    /**\n     * Converting a path to image.\n     * It has much better performance of drawing image rather than drawing a vector path.\n     * @param {module:zrender/graphic/Path} e\n     * @param {number} width\n     * @param {number} height\n     */\n    pathToImage: function(e, dpr) {\n        return this.painter.pathToImage(e, dpr);\n    },\n\n    /**\n     * Set default cursor\n     * @param {string} [cursorStyle='default']  crosshair\n     */\n    setCursorStyle: function (cursorStyle) {\n        this.handler.setCursorStyle(cursorStyle);\n    },\n\n    /**\n     * Find hovered element\n     * @param {number} x\n     * @param {number} y\n     * @return {Object} {target, topTarget}\n     */\n    findHover: function (x, y) {\n        return this.handler.findHover(x, y);\n    },\n\n    /**\n     * Bind event\n     *\n     * @param {string} eventName Event name\n     * @param {Function} eventHandler Handler function\n     * @param {Object} [context] Context object\n     */\n    on: function(eventName, eventHandler, context) {\n        this.handler.on(eventName, eventHandler, context);\n    },\n\n    /**\n     * Unbind event\n     * @param {string} eventName Event name\n     * @param {Function} [eventHandler] Handler function\n     */\n    off: function(eventName, eventHandler) {\n        this.handler.off(eventName, eventHandler);\n    },\n\n    /**\n     * Trigger event manually\n     *\n     * @param {string} eventName Event name\n     * @param {event=} event Event object\n     */\n    trigger: function (eventName, event) {\n        this.handler.trigger(eventName, event);\n    },\n\n\n    /**\n     * Clear all objects and the canvas.\n     */\n    clear: function () {\n        this.storage.delRoot();\n        this.painter.clear();\n    },\n\n    /**\n     * Dispose self.\n     */\n    dispose: function () {\n        this.animation.stop();\n\n        this.clear();\n        this.storage.dispose();\n        this.painter.dispose();\n        this.handler.dispose();\n\n        this.animation =\n        this.storage =\n        this.painter =\n        this.handler = null;\n\n        delInstance(this.id);\n    }\n};\n\n\n\nvar zrender = (Object.freeze || Object)({\n\tversion: version$1,\n\tinit: init$1,\n\tdispose: dispose$1,\n\tgetInstance: getInstance,\n\tregisterPainter: registerPainter\n});\n\nvar RADIAN_EPSILON = 1e-4;\n\nfunction _trim(str) {\n    return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n}\n\n/**\n * Linear mapping a value from domain to range\n * @memberOf module:echarts/util/number\n * @param  {(number|Array.<number>)} val\n * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n * @param  {boolean} clamp\n * @return {(number|Array.<number>}\n */\nfunction linearMap(val, domain, range, clamp) {\n    var subDomain = domain[1] - domain[0];\n    var subRange = range[1] - range[0];\n\n    if (subDomain === 0) {\n        return subRange === 0\n            ? range[0]\n            : (range[0] + range[1]) / 2;\n    }\n\n    // Avoid accuracy problem in edge, such as\n    // 146.39 - 62.83 === 83.55999999999999.\n    // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n    // It is a little verbose for efficiency considering this method\n    // is a hotspot.\n    if (clamp) {\n        if (subDomain > 0) {\n            if (val <= domain[0]) {\n                return range[0];\n            }\n            else if (val >= domain[1]) {\n                return range[1];\n            }\n        }\n        else {\n            if (val >= domain[0]) {\n                return range[0];\n            }\n            else if (val <= domain[1]) {\n                return range[1];\n            }\n        }\n    }\n    else {\n        if (val === domain[0]) {\n            return range[0];\n        }\n        if (val === domain[1]) {\n            return range[1];\n        }\n    }\n\n    return (val - domain[0]) / subDomain * subRange + range[0];\n}\n\n/**\n * Convert a percent string to absolute number.\n * Returns NaN if percent is not a valid string or number\n * @memberOf module:echarts/util/number\n * @param {string|number} percent\n * @param {number} all\n * @return {number}\n */\nfunction parsePercent$1(percent, all) {\n    switch (percent) {\n        case 'center':\n        case 'middle':\n            percent = '50%';\n            break;\n        case 'left':\n        case 'top':\n            percent = '0%';\n            break;\n        case 'right':\n        case 'bottom':\n            percent = '100%';\n            break;\n    }\n    if (typeof percent === 'string') {\n        if (_trim(percent).match(/%$/)) {\n            return parseFloat(percent) / 100 * all;\n        }\n\n        return parseFloat(percent);\n    }\n\n    return percent == null ? NaN : +percent;\n}\n\n/**\n * (1) Fix rounding error of float numbers.\n * (2) Support return string to avoid scientific notation like '3.5e-7'.\n *\n * @param {number} x\n * @param {number} [precision]\n * @param {boolean} [returnStr]\n * @return {number|string}\n */\nfunction round(x, precision, returnStr) {\n    if (precision == null) {\n        precision = 10;\n    }\n    // Avoid range error\n    precision = Math.min(Math.max(0, precision), 20);\n    x = (+x).toFixed(precision);\n    return returnStr ? x : +x;\n}\n\nfunction asc(arr) {\n    arr.sort(function (a, b) {\n        return a - b;\n    });\n    return arr;\n}\n\n/**\n * Get precision\n * @param {number} val\n */\nfunction getPrecision(val) {\n    val = +val;\n    if (isNaN(val)) {\n        return 0;\n    }\n    // It is much faster than methods converting number to string as follows\n    //      var tmp = val.toString();\n    //      return tmp.length - 1 - tmp.indexOf('.');\n    // especially when precision is low\n    var e = 1;\n    var count = 0;\n    while (Math.round(val * e) / e !== val) {\n        e *= 10;\n        count++;\n    }\n    return count;\n}\n\n/**\n * @param {string|number} val\n * @return {number}\n */\nfunction getPrecisionSafe(val) {\n    var str = val.toString();\n\n    // Consider scientific notation: '3.4e-12' '3.4e+12'\n    var eIndex = str.indexOf('e');\n    if (eIndex > 0) {\n        var precision = +str.slice(eIndex + 1);\n        return precision < 0 ? -precision : 0;\n    }\n    else {\n        var dotIndex = str.indexOf('.');\n        return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n    }\n}\n\n/**\n * Minimal dicernible data precisioin according to a single pixel.\n *\n * @param {Array.<number>} dataExtent\n * @param {Array.<number>} pixelExtent\n * @return {number} precision\n */\nfunction getPixelPrecision(dataExtent, pixelExtent) {\n    var log = Math.log;\n    var LN10 = Math.LN10;\n    var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n    var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n    // toFixed() digits argument must be between 0 and 20.\n    var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n    return !isFinite(precision) ? 20 : precision;\n}\n\n/**\n * Get a data of given precision, assuring the sum of percentages\n * in valueList is 1.\n * The largest remainer method is used.\n * https://en.wikipedia.org/wiki/Largest_remainder_method\n *\n * @param {Array.<number>} valueList a list of all data\n * @param {number} idx index of the data to be processed in valueList\n * @param {number} precision integer number showing digits of precision\n * @return {number} percent ranging from 0 to 100\n */\nfunction getPercentWithPrecision(valueList, idx, precision) {\n    if (!valueList[idx]) {\n        return 0;\n    }\n\n    var sum = reduce(valueList, function (acc, val) {\n        return acc + (isNaN(val) ? 0 : val);\n    }, 0);\n    if (sum === 0) {\n        return 0;\n    }\n\n    var digits = Math.pow(10, precision);\n    var votesPerQuota = map(valueList, function (val) {\n        return (isNaN(val) ? 0 : val) / sum * digits * 100;\n    });\n    var targetSeats = digits * 100;\n\n    var seats = map(votesPerQuota, function (votes) {\n        // Assign automatic seats.\n        return Math.floor(votes);\n    });\n    var currentSum = reduce(seats, function (acc, val) {\n        return acc + val;\n    }, 0);\n\n    var remainder = map(votesPerQuota, function (votes, idx) {\n        return votes - seats[idx];\n    });\n\n    // Has remainding votes.\n    while (currentSum < targetSeats) {\n        // Find next largest remainder.\n        var max = Number.NEGATIVE_INFINITY;\n        var maxId = null;\n        for (var i = 0, len = remainder.length; i < len; ++i) {\n            if (remainder[i] > max) {\n                max = remainder[i];\n                maxId = i;\n            }\n        }\n\n        // Add a vote to max remainder.\n        ++seats[maxId];\n        remainder[maxId] = 0;\n        ++currentSum;\n    }\n\n    return seats[idx] / digits;\n}\n\n// Number.MAX_SAFE_INTEGER, ie do not support.\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * To 0 - 2 * PI, considering negative radian.\n * @param {number} radian\n * @return {number}\n */\nfunction remRadian(radian) {\n    var pi2 = Math.PI * 2;\n    return (radian % pi2 + pi2) % pi2;\n}\n\n/**\n * @param {type} radian\n * @return {boolean}\n */\nfunction isRadianAroundZero(val) {\n    return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n}\n\nvar TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d\\d)(?::(\\d\\d)(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/; // jshint ignore:line\n\n/**\n * @param {string|Date|number} value These values can be accepted:\n *   + An instance of Date, represent a time in its own time zone.\n *   + Or string in a subset of ISO 8601, only including:\n *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',\n *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',\n *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',\n *     all of which will be treated as local time if time zone is not specified\n *     (see <https://momentjs.com/>).\n *   + Or other string format, including (all of which will be treated as loacal time):\n *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',\n *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'\n *   + a timestamp, which represent a time in UTC.\n * @return {Date} date\n */\nfunction parseDate(value) {\n    if (value instanceof Date) {\n        return value;\n    }\n    else if (typeof value === 'string') {\n        // Different browsers parse date in different way, so we parse it manually.\n        // Some other issues:\n        // new Date('1970-01-01') is UTC,\n        // new Date('1970/01/01') and new Date('1970-1-01') is local.\n        // See issue #3623\n        var match = TIME_REG.exec(value);\n\n        if (!match) {\n            // return Invalid Date.\n            return new Date(NaN);\n        }\n\n        // Use local time when no timezone offset specifed.\n        if (!match[8]) {\n            // match[n] can only be string or undefined.\n            // But take care of '12' + 1 => '121'.\n            return new Date(\n                +match[1],\n                +(match[2] || 1) - 1,\n                +match[3] || 1,\n                +match[4] || 0,\n                +(match[5] || 0),\n                +match[6] || 0,\n                +match[7] || 0\n            );\n        }\n        // Timezoneoffset of Javascript Date has considered DST (Daylight Saving Time,\n        // https://tc39.github.io/ecma262/#sec-daylight-saving-time-adjustment).\n        // For example, system timezone is set as \"Time Zone: America/Toronto\",\n        // then these code will get different result:\n        // `new Date(1478411999999).getTimezoneOffset();  // get 240`\n        // `new Date(1478412000000).getTimezoneOffset();  // get 300`\n        // So we should not use `new Date`, but use `Date.UTC`.\n        else {\n            var hour = +match[4] || 0;\n            if (match[8].toUpperCase() !== 'Z') {\n                hour -= match[8].slice(0, 3);\n            }\n            return new Date(Date.UTC(\n                +match[1],\n                +(match[2] || 1) - 1,\n                +match[3] || 1,\n                hour,\n                +(match[5] || 0),\n                +match[6] || 0,\n                +match[7] || 0\n            ));\n        }\n    }\n    else if (value == null) {\n        return new Date(NaN);\n    }\n\n    return new Date(Math.round(value));\n}\n\n/**\n * Quantity of a number. e.g. 0.1, 1, 10, 100\n *\n * @param  {number} val\n * @return {number}\n */\nfunction quantity(val) {\n    return Math.pow(10, quantityExponent(val));\n}\n\nfunction quantityExponent(val) {\n    return Math.floor(Math.log(val) / Math.LN10);\n}\n\n/**\n * find a nice number approximately equal to x. Round the number if round = true,\n * take ceiling if round = false. The primary observation is that the nicest\n * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n *\n * See \"Nice Numbers for Graph Labels\" of Graphic Gems.\n *\n * @param  {number} val Non-negative value.\n * @param  {boolean} round\n * @return {number}\n */\nfunction nice(val, round) {\n    var exponent = quantityExponent(val);\n    var exp10 = Math.pow(10, exponent);\n    var f = val / exp10; // 1 <= f < 10\n    var nf;\n    if (round) {\n        if (f < 1.5) { nf = 1; }\n        else if (f < 2.5) { nf = 2; }\n        else if (f < 4) { nf = 3; }\n        else if (f < 7) { nf = 5; }\n        else { nf = 10; }\n    }\n    else {\n        if (f < 1) { nf = 1; }\n        else if (f < 2) { nf = 2; }\n        else if (f < 3) { nf = 3; }\n        else if (f < 5) { nf = 5; }\n        else { nf = 10; }\n    }\n    val = nf * exp10;\n\n    // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).\n    // 20 is the uppper bound of toFixed.\n    return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;\n}\n\n/**\n * Order intervals asc, and split them when overlap.\n * expect(numberUtil.reformIntervals([\n *     {interval: [18, 62], close: [1, 1]},\n *     {interval: [-Infinity, -70], close: [0, 0]},\n *     {interval: [-70, -26], close: [1, 1]},\n *     {interval: [-26, 18], close: [1, 1]},\n *     {interval: [62, 150], close: [1, 1]},\n *     {interval: [106, 150], close: [1, 1]},\n *     {interval: [150, Infinity], close: [0, 0]}\n * ])).toEqual([\n *     {interval: [-Infinity, -70], close: [0, 0]},\n *     {interval: [-70, -26], close: [1, 1]},\n *     {interval: [-26, 18], close: [0, 1]},\n *     {interval: [18, 62], close: [0, 1]},\n *     {interval: [62, 150], close: [0, 1]},\n *     {interval: [150, Infinity], close: [0, 0]}\n * ]);\n * @param {Array.<Object>} list, where `close` mean open or close\n *        of the interval, and Infinity can be used.\n * @return {Array.<Object>} The origin list, which has been reformed.\n */\nfunction reformIntervals(list) {\n    list.sort(function (a, b) {\n        return littleThan(a, b, 0) ? -1 : 1;\n    });\n\n    var curr = -Infinity;\n    var currClose = 1;\n    for (var i = 0; i < list.length;) {\n        var interval = list[i].interval;\n        var close = list[i].close;\n\n        for (var lg = 0; lg < 2; lg++) {\n            if (interval[lg] <= curr) {\n                interval[lg] = curr;\n                close[lg] = !lg ? 1 - currClose : 1;\n            }\n            curr = interval[lg];\n            currClose = close[lg];\n        }\n\n        if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n            list.splice(i, 1);\n        }\n        else {\n            i++;\n        }\n    }\n\n    return list;\n\n    function littleThan(a, b, lg) {\n        return a.interval[lg] < b.interval[lg]\n            || (\n                a.interval[lg] === b.interval[lg]\n                && (\n                    (a.close[lg] - b.close[lg] === (!lg ? 1 : -1))\n                    || (!lg && littleThan(a, b, 1))\n                )\n            );\n    }\n}\n\n/**\n * parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n * ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n * subtraction forces infinities to NaN\n *\n * @param {*} v\n * @return {boolean}\n */\nfunction isNumeric(v) {\n    return v - parseFloat(v) >= 0;\n}\n\n\nvar number = (Object.freeze || Object)({\n\tlinearMap: linearMap,\n\tparsePercent: parsePercent$1,\n\tround: round,\n\tasc: asc,\n\tgetPrecision: getPrecision,\n\tgetPrecisionSafe: getPrecisionSafe,\n\tgetPixelPrecision: getPixelPrecision,\n\tgetPercentWithPrecision: getPercentWithPrecision,\n\tMAX_SAFE_INTEGER: MAX_SAFE_INTEGER,\n\tremRadian: remRadian,\n\tisRadianAroundZero: isRadianAroundZero,\n\tparseDate: parseDate,\n\tquantity: quantity,\n\tnice: nice,\n\treformIntervals: reformIntervals,\n\tisNumeric: isNumeric\n});\n\n/**\n * ,\n * @param {string|number} x\n * @return {string}\n */\nfunction addCommas(x) {\n    if (isNaN(x)) {\n        return '-';\n    }\n    x = (x + '').split('.');\n    return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n            + (x.length > 1 ? ('.' + x[1]) : '');\n}\n\n/**\n * @param {string} str\n * @param {boolean} [upperCaseFirst=false]\n * @return {string} str\n */\nfunction toCamelCase(str, upperCaseFirst) {\n    str = (str || '').toLowerCase().replace(/-(.)/g, function(match, group1) {\n        return group1.toUpperCase();\n    });\n\n    if (upperCaseFirst && str) {\n        str = str.charAt(0).toUpperCase() + str.slice(1);\n    }\n\n    return str;\n}\n\nvar normalizeCssArray$1 = normalizeCssArray;\n\nfunction encodeHTML(source) {\n    return String(source)\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#39;');\n}\n\nvar TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\nvar wrapVar = function (varName, seriesIdx) {\n    return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n};\n\n/**\n * Template formatter\n * @param {string} tpl\n * @param {Array.<Object>|Object} paramsList\n * @param {boolean} [encode=false]\n * @return {string}\n */\nfunction formatTpl(tpl, paramsList, encode) {\n    if (!isArray(paramsList)) {\n        paramsList = [paramsList];\n    }\n    var seriesLen = paramsList.length;\n    if (!seriesLen) {\n        return '';\n    }\n\n    var $vars = paramsList[0].$vars || [];\n    for (var i = 0; i < $vars.length; i++) {\n        var alias = TPL_VAR_ALIAS[i];\n        var val = wrapVar(alias, 0);\n        tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\n    }\n    for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n        for (var k = 0; k < $vars.length; k++) {\n            var val = paramsList[seriesIdx][$vars[k]];\n            tpl = tpl.replace(\n                wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n                encode ? encodeHTML(val) : val\n            );\n        }\n    }\n\n    return tpl;\n}\n\n/**\n * simple Template formatter\n *\n * @param {string} tpl\n * @param {Object} param\n * @param {boolean} [encode=false]\n * @return {string}\n */\nfunction formatTplSimple(tpl, param, encode) {\n    each$1(param, function (value, key) {\n        tpl = tpl.replace(\n            '{' + key + '}',\n            encode ? encodeHTML(value) : value\n        );\n    });\n    return tpl;\n}\n\n/**\n * @param {string} color\n * @param {string} [extraCssText]\n * @return {string}\n */\nfunction getTooltipMarker(color, extraCssText) {\n    return color\n        ? '<span style=\"display:inline-block;margin-right:5px;'\n            + 'border-radius:10px;width:9px;height:9px;background-color:'\n            + encodeHTML(color) + ';' + (extraCssText || '') + '\"></span>'\n        : '';\n}\n\n/**\n * @param {string} str\n * @return {string}\n * @inner\n */\nvar s2d = function (str) {\n    return str < 10 ? ('0' + str) : str;\n};\n\n/**\n * ISO Date format\n * @param {string} tpl\n * @param {number} value\n * @param {boolean} [isUTC=false] Default in local time.\n *           see `module:echarts/scale/Time`\n *           and `module:echarts/util/number#parseDate`.\n * @inner\n */\nfunction formatTime(tpl, value, isUTC) {\n    if (tpl === 'week'\n        || tpl === 'month'\n        || tpl === 'quarter'\n        || tpl === 'half-year'\n        || tpl === 'year'\n    ) {\n        tpl = 'MM-dd\\nyyyy';\n    }\n\n    var date = parseDate(value);\n    var utc = isUTC ? 'UTC' : '';\n    var y = date['get' + utc + 'FullYear']();\n    var M = date['get' + utc + 'Month']() + 1;\n    var d = date['get' + utc + 'Date']();\n    var h = date['get' + utc + 'Hours']();\n    var m = date['get' + utc + 'Minutes']();\n    var s = date['get' + utc + 'Seconds']();\n\n    tpl = tpl.replace('MM', s2d(M))\n        .replace('M', M)\n        .replace('yyyy', y)\n        .replace('yy', y % 100)\n        .replace('dd', s2d(d))\n        .replace('d', d)\n        .replace('hh', s2d(h))\n        .replace('h', h)\n        .replace('mm', s2d(m))\n        .replace('m', m)\n        .replace('ss', s2d(s))\n        .replace('s', s);\n\n    return tpl;\n}\n\n/**\n * Capital first\n * @param {string} str\n * @return {string}\n */\nfunction capitalFirst(str) {\n    return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n}\n\nvar truncateText$1 = truncateText;\n\nvar getTextRect = getBoundingRect;\n\n\nvar format = (Object.freeze || Object)({\n\taddCommas: addCommas,\n\ttoCamelCase: toCamelCase,\n\tnormalizeCssArray: normalizeCssArray$1,\n\tencodeHTML: encodeHTML,\n\tformatTpl: formatTpl,\n\tformatTplSimple: formatTplSimple,\n\tgetTooltipMarker: getTooltipMarker,\n\tformatTime: formatTime,\n\tcapitalFirst: capitalFirst,\n\ttruncateText: truncateText$1,\n\tgetTextRect: getTextRect\n});\n\nvar TYPE_DELIMITER = '.';\nvar IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\nvar MEMBER_PRIFIX = '\\0ec_\\0';\n\n/**\n * Hide private class member.\n * The same behavior as `host[name] = value;` (can be right-value)\n * @public\n */\nfunction set$1(host, name, value) {\n    return (host[MEMBER_PRIFIX + name] = value);\n}\n\n/**\n * Hide private class member.\n * The same behavior as `host[name];`\n * @public\n */\nfunction get(host, name) {\n    return host[MEMBER_PRIFIX + name];\n}\n\n/**\n * For hidden private class member.\n * The same behavior as `host.hasOwnProperty(name);`\n * @public\n */\nfunction hasOwn(host, name) {\n    return host.hasOwnProperty(MEMBER_PRIFIX + name);\n}\n\n/**\n * Notice, parseClassType('') should returns {main: '', sub: ''}\n * @public\n */\nfunction parseClassType$1(componentType) {\n    var ret = {main: '', sub: ''};\n    if (componentType) {\n        componentType = componentType.split(TYPE_DELIMITER);\n        ret.main = componentType[0] || '';\n        ret.sub = componentType[1] || '';\n    }\n    return ret;\n}\n\n/**\n * @public\n */\nfunction checkClassType(componentType) {\n    assert(\n        /^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType),\n        'componentType \"' + componentType + '\" illegal'\n    );\n}\n\n/**\n * @public\n */\nfunction enableClassExtend(RootClass, mandatoryMethods) {\n\n    RootClass.$constructor = RootClass;\n    RootClass.extend = function (proto) {\n\n        if (__DEV__) {\n            each$1(mandatoryMethods, function (method) {\n                if (!proto[method]) {\n                    console.warn(\n                        'Method `' + method + '` should be implemented'\n                        + (proto.type ? ' in ' + proto.type : '') + '.'\n                    );\n                }\n            });\n        }\n\n        var superClass = this;\n        var ExtendedClass = function () {\n            if (!proto.$constructor) {\n                superClass.apply(this, arguments);\n            }\n            else {\n                proto.$constructor.apply(this, arguments);\n            }\n        };\n\n        extend(ExtendedClass.prototype, proto);\n\n        ExtendedClass.extend = this.extend;\n        ExtendedClass.superCall = superCall;\n        ExtendedClass.superApply = superApply;\n        inherits(ExtendedClass, this);\n        ExtendedClass.superClass = superClass;\n\n        return ExtendedClass;\n    };\n}\n\n// superCall should have class info, which can not be fetch from 'this'.\n// Consider this case:\n// class A has method f,\n// class B inherits class A, overrides method f, f call superApply('f'),\n// class C inherits class B, do not overrides method f,\n// then when method of class C is called, dead loop occured.\nfunction superCall(context, methodName) {\n    var args = slice(arguments, 2);\n    return this.superClass.prototype[methodName].apply(context, args);\n}\n\nfunction superApply(context, methodName, args) {\n    return this.superClass.prototype[methodName].apply(context, args);\n}\n\n/**\n * @param {Object} entity\n * @param {Object} options\n * @param {boolean} [options.registerWhenExtend]\n * @public\n */\nfunction enableClassManagement(entity, options) {\n    options = options || {};\n\n    /**\n     * Component model classes\n     * key: componentType,\n     * value:\n     *     componentClass, when componentType is 'xxx'\n     *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n     * @type {Object}\n     */\n    var storage = {};\n\n    entity.registerClass = function (Clazz, componentType) {\n        if (componentType) {\n            checkClassType(componentType);\n            componentType = parseClassType$1(componentType);\n\n            if (!componentType.sub) {\n                if (__DEV__) {\n                    if (storage[componentType.main]) {\n                        console.warn(componentType.main + ' exists.');\n                    }\n                }\n                storage[componentType.main] = Clazz;\n            }\n            else if (componentType.sub !== IS_CONTAINER) {\n                var container = makeContainer(componentType);\n                container[componentType.sub] = Clazz;\n            }\n        }\n        return Clazz;\n    };\n\n    entity.getClass = function (componentMainType, subType, throwWhenNotFound) {\n        var Clazz = storage[componentMainType];\n\n        if (Clazz && Clazz[IS_CONTAINER]) {\n            Clazz = subType ? Clazz[subType] : null;\n        }\n\n        if (throwWhenNotFound && !Clazz) {\n            throw new Error(\n                !subType\n                    ? componentMainType + '.' + 'type should be specified.'\n                    : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.'\n            );\n        }\n\n        return Clazz;\n    };\n\n    entity.getClassesByMainType = function (componentType) {\n        componentType = parseClassType$1(componentType);\n\n        var result = [];\n        var obj = storage[componentType.main];\n\n        if (obj && obj[IS_CONTAINER]) {\n            each$1(obj, function (o, type) {\n                type !== IS_CONTAINER && result.push(o);\n            });\n        }\n        else {\n            result.push(obj);\n        }\n\n        return result;\n    };\n\n    entity.hasClass = function (componentType) {\n        // Just consider componentType.main.\n        componentType = parseClassType$1(componentType);\n        return !!storage[componentType.main];\n    };\n\n    /**\n     * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n     */\n    entity.getAllClassMainTypes = function () {\n        var types = [];\n        each$1(storage, function (obj, type) {\n            types.push(type);\n        });\n        return types;\n    };\n\n    /**\n     * If a main type is container and has sub types\n     * @param  {string}  mainType\n     * @return {boolean}\n     */\n    entity.hasSubTypes = function (componentType) {\n        componentType = parseClassType$1(componentType);\n        var obj = storage[componentType.main];\n        return obj && obj[IS_CONTAINER];\n    };\n\n    entity.parseClassType = parseClassType$1;\n\n    function makeContainer(componentType) {\n        var container = storage[componentType.main];\n        if (!container || !container[IS_CONTAINER]) {\n            container = storage[componentType.main] = {};\n            container[IS_CONTAINER] = true;\n        }\n        return container;\n    }\n\n    if (options.registerWhenExtend) {\n        var originalExtend = entity.extend;\n        if (originalExtend) {\n            entity.extend = function (proto) {\n                var ExtendedClass = originalExtend.call(this, proto);\n                return entity.registerClass(ExtendedClass, proto.type);\n            };\n        }\n    }\n\n    return entity;\n}\n\n/**\n * @param {string|Array.<string>} properties\n */\n\n// TODO Parse shadow style\n// TODO Only shallow path support\nvar makeStyleMapper = function (properties) {\n    // Normalize\n    for (var i = 0; i < properties.length; i++) {\n        if (!properties[i][1]) {\n            properties[i][1] = properties[i][0];\n        }\n    }\n    return function (model, excludes, includes) {\n        var style = {};\n        for (var i = 0; i < properties.length; i++) {\n            var propName = properties[i][1];\n            if ((excludes && indexOf(excludes, propName) >= 0)\n                || (includes && indexOf(includes, propName) < 0)\n            ) {\n                continue;\n            }\n            var val = model.getShallow(propName);\n            if (val != null) {\n                style[properties[i][0]] = val;\n            }\n        }\n        return style;\n    };\n};\n\nvar getLineStyle = makeStyleMapper(\n    [\n        ['lineWidth', 'width'],\n        ['stroke', 'color'],\n        ['opacity'],\n        ['shadowBlur'],\n        ['shadowOffsetX'],\n        ['shadowOffsetY'],\n        ['shadowColor']\n    ]\n);\n\nvar lineStyleMixin = {\n    getLineStyle: function (excludes) {\n        var style = getLineStyle(this, excludes);\n        var lineDash = this.getLineDash(style.lineWidth);\n        lineDash && (style.lineDash = lineDash);\n        return style;\n    },\n\n    getLineDash: function (lineWidth) {\n        if (lineWidth == null) {\n            lineWidth = 1;\n        }\n        var lineType = this.get('type');\n        var dotSize = Math.max(lineWidth, 2);\n        var dashSize = lineWidth * 4;\n        return (lineType === 'solid' || lineType == null) ? null\n            : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n    }\n};\n\nvar getAreaStyle = makeStyleMapper(\n    [\n        ['fill', 'color'],\n        ['shadowBlur'],\n        ['shadowOffsetX'],\n        ['shadowOffsetY'],\n        ['opacity'],\n        ['shadowColor']\n    ]\n);\n\nvar areaStyleMixin = {\n    getAreaStyle: function (excludes, includes) {\n        return getAreaStyle(this, excludes, includes);\n    }\n};\n\n/**\n * \n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\nvar mathPow = Math.pow;\nvar mathSqrt$2 = Math.sqrt;\n\nvar EPSILON$1 = 1e-8;\nvar EPSILON_NUMERIC = 1e-4;\n\nvar THREE_SQRT = mathSqrt$2(3);\nvar ONE_THIRD = 1 / 3;\n\n// \nvar _v0 = create();\nvar _v1 = create();\nvar _v2 = create();\n\nfunction isAroundZero(val) {\n    return val > -EPSILON$1 && val < EPSILON$1;\n}\nfunction isNotAroundZero$1(val) {\n    return val > EPSILON$1 || val < -EPSILON$1;\n}\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @return {number}\n */\nfunction cubicAt(p0, p1, p2, p3, t) {\n    var onet = 1 - t;\n    return onet * onet * (onet * p0 + 3 * t * p1)\n            + t * t * (t * p3 + 3 * onet * p2);\n}\n\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @return {number}\n */\nfunction cubicDerivativeAt(p0, p1, p2, p3, t) {\n    var onet = 1 - t;\n    return 3 * (\n        ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n        + (p3 - p2) * t * t\n    );\n}\n\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} val\n * @param  {Array.<number>} roots\n * @return {number} \n */\nfunction cubicRootAt(p0, p1, p2, p3, val, roots) {\n    // Evaluate roots of cubic functions\n    var a = p3 + 3 * (p1 - p2) - p0;\n    var b = 3 * (p2 - p1 * 2 + p0);\n    var c = 3 * (p1  - p0);\n    var d = p0 - val;\n\n    var A = b * b - 3 * a * c;\n    var B = b * c - 9 * a * d;\n    var C = c * c - 3 * b * d;\n\n    var n = 0;\n\n    if (isAroundZero(A) && isAroundZero(B)) {\n        if (isAroundZero(b)) {\n            roots[0] = 0;\n        }\n        else {\n            var t1 = -c / b;  //t1, t2, t3, b is not zero\n            if (t1 >= 0 && t1 <= 1) {\n                roots[n++] = t1;\n            }\n        }\n    }\n    else {\n        var disc = B * B - 4 * A * C;\n\n        if (isAroundZero(disc)) {\n            var K = B / A;\n            var t1 = -b / a + K;  // t1, a is not zero\n            var t2 = -K / 2;  // t2, t3\n            if (t1 >= 0 && t1 <= 1) {\n                roots[n++] = t1;\n            }\n            if (t2 >= 0 && t2 <= 1) {\n                roots[n++] = t2;\n            }\n        }\n        else if (disc > 0) {\n            var discSqrt = mathSqrt$2(disc);\n            var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n            var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n            if (Y1 < 0) {\n                Y1 = -mathPow(-Y1, ONE_THIRD);\n            }\n            else {\n                Y1 = mathPow(Y1, ONE_THIRD);\n            }\n            if (Y2 < 0) {\n                Y2 = -mathPow(-Y2, ONE_THIRD);\n            }\n            else {\n                Y2 = mathPow(Y2, ONE_THIRD);\n            }\n            var t1 = (-b - (Y1 + Y2)) / (3 * a);\n            if (t1 >= 0 && t1 <= 1) {\n                roots[n++] = t1;\n            }\n        }\n        else {\n            var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt$2(A * A * A));\n            var theta = Math.acos(T) / 3;\n            var ASqrt = mathSqrt$2(A);\n            var tmp = Math.cos(theta);\n\n            var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n            var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n            var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n            if (t1 >= 0 && t1 <= 1) {\n                roots[n++] = t1;\n            }\n            if (t2 >= 0 && t2 <= 1) {\n                roots[n++] = t2;\n            }\n            if (t3 >= 0 && t3 <= 1) {\n                roots[n++] = t3;\n            }\n        }\n    }\n    return n;\n}\n\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {Array.<number>} extrema\n * @return {number} \n */\nfunction cubicExtrema(p0, p1, p2, p3, extrema) {\n    var b = 6 * p2 - 12 * p1 + 6 * p0;\n    var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n    var c = 3 * p1 - 3 * p0;\n\n    var n = 0;\n    if (isAroundZero(a)) {\n        if (isNotAroundZero$1(b)) {\n            var t1 = -c / b;\n            if (t1 >= 0 && t1 <=1) {\n                extrema[n++] = t1;\n            }\n        }\n    }\n    else {\n        var disc = b * b - 4 * a * c;\n        if (isAroundZero(disc)) {\n            extrema[0] = -b / (2 * a);\n        }\n        else if (disc > 0) {\n            var discSqrt = mathSqrt$2(disc);\n            var t1 = (-b + discSqrt) / (2 * a);\n            var t2 = (-b - discSqrt) / (2 * a);\n            if (t1 >= 0 && t1 <= 1) {\n                extrema[n++] = t1;\n            }\n            if (t2 >= 0 && t2 <= 1) {\n                extrema[n++] = t2;\n            }\n        }\n    }\n    return n;\n}\n\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @param  {Array.<number>} out\n */\nfunction cubicSubdivide(p0, p1, p2, p3, t, out) {\n    var p01 = (p1 - p0) * t + p0;\n    var p12 = (p2 - p1) * t + p1;\n    var p23 = (p3 - p2) * t + p2;\n\n    var p012 = (p12 - p01) * t + p01;\n    var p123 = (p23 - p12) * t + p12;\n\n    var p0123 = (p123 - p012) * t + p012;\n    // Seg0\n    out[0] = p0;\n    out[1] = p01;\n    out[2] = p012;\n    out[3] = p0123;\n    // Seg1\n    out[4] = p0123;\n    out[5] = p123;\n    out[6] = p23;\n    out[7] = p3;\n}\n\n/**\n * \n * \n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {number} x\n * @param {number} y\n * @param {Array.<number>} [out] \n * @return {number}\n */\nfunction cubicProjectPoint(\n    x0, y0, x1, y1, x2, y2, x3, y3,\n    x, y, out\n) {\n    // http://pomax.github.io/bezierinfo/#projections\n    var t;\n    var interval = 0.005;\n    var d = Infinity;\n    var prev;\n    var next;\n    var d1;\n    var d2;\n\n    _v0[0] = x;\n    _v0[1] = y;\n\n    //  t \n    // PENDING\n    for (var _t = 0; _t < 1; _t += 0.05) {\n        _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n        _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n        d1 = distSquare(_v0, _v1);\n        if (d1 < d) {\n            t = _t;\n            d = d1;\n        }\n    }\n    d = Infinity;\n\n    // At most 32 iteration\n    for (var i = 0; i < 32; i++) {\n        if (interval < EPSILON_NUMERIC) {\n            break;\n        }\n        prev = t - interval;\n        next = t + interval;\n        // t - interval\n        _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n        _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n        d1 = distSquare(_v1, _v0);\n\n        if (prev >= 0 && d1 < d) {\n            t = prev;\n            d = d1;\n        }\n        else {\n            // t + interval\n            _v2[0] = cubicAt(x0, x1, x2, x3, next);\n            _v2[1] = cubicAt(y0, y1, y2, y3, next);\n            d2 = distSquare(_v2, _v0);\n\n            if (next <= 1 && d2 < d) {\n                t = next;\n                d = d2;\n            }\n            else {\n                interval *= 0.5;\n            }\n        }\n    }\n    // t\n    if (out) {\n        out[0] = cubicAt(x0, x1, x2, x3, t);\n        out[1] = cubicAt(y0, y1, y2, y3, t);\n    }\n    // console.log(interval, i);\n    return mathSqrt$2(d);\n}\n\n/**\n * \n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @return {number}\n */\nfunction quadraticAt(p0, p1, p2, t) {\n    var onet = 1 - t;\n    return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n}\n\n/**\n * \n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @return {number}\n */\nfunction quadraticDerivativeAt(p0, p1, p2, t) {\n    return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n}\n\n/**\n * \n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @param  {Array.<number>} roots\n * @return {number} \n */\nfunction quadraticRootAt(p0, p1, p2, val, roots) {\n    var a = p0 - 2 * p1 + p2;\n    var b = 2 * (p1 - p0);\n    var c = p0 - val;\n\n    var n = 0;\n    if (isAroundZero(a)) {\n        if (isNotAroundZero$1(b)) {\n            var t1 = -c / b;\n            if (t1 >= 0 && t1 <= 1) {\n                roots[n++] = t1;\n            }\n        }\n    }\n    else {\n        var disc = b * b - 4 * a * c;\n        if (isAroundZero(disc)) {\n            var t1 = -b / (2 * a);\n            if (t1 >= 0 && t1 <= 1) {\n                roots[n++] = t1;\n            }\n        }\n        else if (disc > 0) {\n            var discSqrt = mathSqrt$2(disc);\n            var t1 = (-b + discSqrt) / (2 * a);\n            var t2 = (-b - discSqrt) / (2 * a);\n            if (t1 >= 0 && t1 <= 1) {\n                roots[n++] = t1;\n            }\n            if (t2 >= 0 && t2 <= 1) {\n                roots[n++] = t2;\n            }\n        }\n    }\n    return n;\n}\n\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @return {number}\n */\nfunction quadraticExtremum(p0, p1, p2) {\n    var divider = p0 + p2 - 2 * p1;\n    if (divider === 0) {\n        // p1 is center of p0 and p2\n        return 0.5;\n    }\n    else {\n        return (p0 - p1) / divider;\n    }\n}\n\n/**\n * \n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @param  {Array.<number>} out\n */\nfunction quadraticSubdivide(p0, p1, p2, t, out) {\n    var p01 = (p1 - p0) * t + p0;\n    var p12 = (p2 - p1) * t + p1;\n    var p012 = (p12 - p01) * t + p01;\n\n    // Seg0\n    out[0] = p0;\n    out[1] = p01;\n    out[2] = p012;\n\n    // Seg1\n    out[3] = p012;\n    out[4] = p12;\n    out[5] = p2;\n}\n\n/**\n * \n * \n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x\n * @param {number} y\n * @param {Array.<number>} out \n * @return {number}\n */\nfunction quadraticProjectPoint(\n    x0, y0, x1, y1, x2, y2,\n    x, y, out\n) {\n    // http://pomax.github.io/bezierinfo/#projections\n    var t;\n    var interval = 0.005;\n    var d = Infinity;\n\n    _v0[0] = x;\n    _v0[1] = y;\n\n    //  t \n    // PENDING\n    for (var _t = 0; _t < 1; _t += 0.05) {\n        _v1[0] = quadraticAt(x0, x1, x2, _t);\n        _v1[1] = quadraticAt(y0, y1, y2, _t);\n        var d1 = distSquare(_v0, _v1);\n        if (d1 < d) {\n            t = _t;\n            d = d1;\n        }\n    }\n    d = Infinity;\n\n    // At most 32 iteration\n    for (var i = 0; i < 32; i++) {\n        if (interval < EPSILON_NUMERIC) {\n            break;\n        }\n        var prev = t - interval;\n        var next = t + interval;\n        // t - interval\n        _v1[0] = quadraticAt(x0, x1, x2, prev);\n        _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n        var d1 = distSquare(_v1, _v0);\n\n        if (prev >= 0 && d1 < d) {\n            t = prev;\n            d = d1;\n        }\n        else {\n            // t + interval\n            _v2[0] = quadraticAt(x0, x1, x2, next);\n            _v2[1] = quadraticAt(y0, y1, y2, next);\n            var d2 = distSquare(_v2, _v0);\n            if (next <= 1 && d2 < d) {\n                t = next;\n                d = d2;\n            }\n            else {\n                interval *= 0.5;\n            }\n        }\n    }\n    // t\n    if (out) {\n        out[0] = quadraticAt(x0, x1, x2, t);\n        out[1] = quadraticAt(y0, y1, y2, t);\n    }\n    // console.log(interval, i);\n    return mathSqrt$2(d);\n}\n\n/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\nvar mathMin$3 = Math.min;\nvar mathMax$3 = Math.max;\nvar mathSin$2 = Math.sin;\nvar mathCos$2 = Math.cos;\nvar PI2 = Math.PI * 2;\n\nvar start = create();\nvar end = create();\nvar extremity = create();\n\n/**\n * `min``max`\n * @module zrender/core/bbox\n * @param {Array<Object>} points \n * @param {number} min\n * @param {number} max\n */\nfunction fromPoints(points, min$$1, max$$1) {\n    if (points.length === 0) {\n        return;\n    }\n    var p = points[0];\n    var left = p[0];\n    var right = p[0];\n    var top = p[1];\n    var bottom = p[1];\n    var i;\n\n    for (i = 1; i < points.length; i++) {\n        p = points[i];\n        left = mathMin$3(left, p[0]);\n        right = mathMax$3(right, p[0]);\n        top = mathMin$3(top, p[1]);\n        bottom = mathMax$3(bottom, p[1]);\n    }\n\n    min$$1[0] = left;\n    min$$1[1] = top;\n    max$$1[0] = right;\n    max$$1[1] = bottom;\n}\n\n/**\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\nfunction fromLine(x0, y0, x1, y1, min$$1, max$$1) {\n    min$$1[0] = mathMin$3(x0, x1);\n    min$$1[1] = mathMin$3(y0, y1);\n    max$$1[0] = mathMax$3(x0, x1);\n    max$$1[1] = mathMax$3(y0, y1);\n}\n\nvar xDim = [];\nvar yDim = [];\n/**\n * (p0, p1, p2, p3)`min``max`\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\nfunction fromCubic(\n    x0, y0, x1, y1, x2, y2, x3, y3, min$$1, max$$1\n) {\n    var cubicExtrema$$1 = cubicExtrema;\n    var cubicAt$$1 = cubicAt;\n    var i;\n    var n = cubicExtrema$$1(x0, x1, x2, x3, xDim);\n    min$$1[0] = Infinity;\n    min$$1[1] = Infinity;\n    max$$1[0] = -Infinity;\n    max$$1[1] = -Infinity;\n\n    for (i = 0; i < n; i++) {\n        var x = cubicAt$$1(x0, x1, x2, x3, xDim[i]);\n        min$$1[0] = mathMin$3(x, min$$1[0]);\n        max$$1[0] = mathMax$3(x, max$$1[0]);\n    }\n    n = cubicExtrema$$1(y0, y1, y2, y3, yDim);\n    for (i = 0; i < n; i++) {\n        var y = cubicAt$$1(y0, y1, y2, y3, yDim[i]);\n        min$$1[1] = mathMin$3(y, min$$1[1]);\n        max$$1[1] = mathMax$3(y, max$$1[1]);\n    }\n\n    min$$1[0] = mathMin$3(x0, min$$1[0]);\n    max$$1[0] = mathMax$3(x0, max$$1[0]);\n    min$$1[0] = mathMin$3(x3, min$$1[0]);\n    max$$1[0] = mathMax$3(x3, max$$1[0]);\n\n    min$$1[1] = mathMin$3(y0, min$$1[1]);\n    max$$1[1] = mathMax$3(y0, max$$1[1]);\n    min$$1[1] = mathMin$3(y3, min$$1[1]);\n    max$$1[1] = mathMax$3(y3, max$$1[1]);\n}\n\n/**\n * (p0, p1, p2)`min``max`\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\nfunction fromQuadratic(x0, y0, x1, y1, x2, y2, min$$1, max$$1) {\n    var quadraticExtremum$$1 = quadraticExtremum;\n    var quadraticAt$$1 = quadraticAt;\n    // Find extremities, where derivative in x dim or y dim is zero\n    var tx =\n        mathMax$3(\n            mathMin$3(quadraticExtremum$$1(x0, x1, x2), 1), 0\n        );\n    var ty =\n        mathMax$3(\n            mathMin$3(quadraticExtremum$$1(y0, y1, y2), 1), 0\n        );\n\n    var x = quadraticAt$$1(x0, x1, x2, tx);\n    var y = quadraticAt$$1(y0, y1, y2, ty);\n\n    min$$1[0] = mathMin$3(x0, x2, x);\n    min$$1[1] = mathMin$3(y0, y2, y);\n    max$$1[0] = mathMax$3(x0, x2, x);\n    max$$1[1] = mathMax$3(y0, y2, y);\n}\n\n/**\n * `min``max`\n * @method\n * @memberOf module:zrender/core/bbox\n * @param {number} x\n * @param {number} y\n * @param {number} rx\n * @param {number} ry\n * @param {number} startAngle\n * @param {number} endAngle\n * @param {number} anticlockwise\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\nfunction fromArc(\n    x, y, rx, ry, startAngle, endAngle, anticlockwise, min$$1, max$$1\n) {\n    var vec2Min = min;\n    var vec2Max = max;\n\n    var diff = Math.abs(startAngle - endAngle);\n\n\n    if (diff % PI2 < 1e-4 && diff > 1e-4) {\n        // Is a circle\n        min$$1[0] = x - rx;\n        min$$1[1] = y - ry;\n        max$$1[0] = x + rx;\n        max$$1[1] = y + ry;\n        return;\n    }\n\n    start[0] = mathCos$2(startAngle) * rx + x;\n    start[1] = mathSin$2(startAngle) * ry + y;\n\n    end[0] = mathCos$2(endAngle) * rx + x;\n    end[1] = mathSin$2(endAngle) * ry + y;\n\n    vec2Min(min$$1, start, end);\n    vec2Max(max$$1, start, end);\n\n    // Thresh to [0, Math.PI * 2]\n    startAngle = startAngle % (PI2);\n    if (startAngle < 0) {\n        startAngle = startAngle + PI2;\n    }\n    endAngle = endAngle % (PI2);\n    if (endAngle < 0) {\n        endAngle = endAngle + PI2;\n    }\n\n    if (startAngle > endAngle && !anticlockwise) {\n        endAngle += PI2;\n    }\n    else if (startAngle < endAngle && anticlockwise) {\n        startAngle += PI2;\n    }\n    if (anticlockwise) {\n        var tmp = endAngle;\n        endAngle = startAngle;\n        startAngle = tmp;\n    }\n\n    // var number = 0;\n    // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n    for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n        if (angle > startAngle) {\n            extremity[0] = mathCos$2(angle) * rx + x;\n            extremity[1] = mathSin$2(angle) * ry + y;\n\n            vec2Min(min$$1, extremity, min$$1);\n            vec2Max(max$$1, extremity, max$$1);\n        }\n    }\n}\n\n/**\n * Path `buildPath``ctx`, pathpathCommands\n *  isInsidePath boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n// TODO getTotalLength, getPointAtLength\n\nvar CMD = {\n    M: 1,\n    L: 2,\n    C: 3,\n    Q: 4,\n    A: 5,\n    Z: 6,\n    // Rect\n    R: 7\n};\n\n// var CMD_MEM_SIZE = {\n//     M: 3,\n//     L: 3,\n//     C: 7,\n//     Q: 5,\n//     A: 9,\n//     R: 5,\n//     Z: 1\n// };\n\nvar min$1 = [];\nvar max$1 = [];\nvar min2 = [];\nvar max2 = [];\nvar mathMin$2 = Math.min;\nvar mathMax$2 = Math.max;\nvar mathCos$1 = Math.cos;\nvar mathSin$1 = Math.sin;\nvar mathSqrt$1 = Math.sqrt;\nvar mathAbs = Math.abs;\n\nvar hasTypedArray = typeof Float32Array != 'undefined';\n\n/**\n * @alias module:zrender/core/PathProxy\n * @constructor\n */\nvar PathProxy = function (notSaveData) {\n\n    this._saveData = !(notSaveData || false);\n\n    if (this._saveData) {\n        /**\n         * Path data. Stored as flat array\n         * @type {Array.<Object>}\n         */\n        this.data = [];\n    }\n\n    this._ctx = null;\n};\n\n/**\n * Path\n * @return {Object}\n */\nPathProxy.prototype = {\n\n    constructor: PathProxy,\n\n    _xi: 0,\n    _yi: 0,\n\n    _x0: 0,\n    _y0: 0,\n    // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n    _ux: 0,\n    _uy: 0,\n\n    _len: 0,\n\n    _lineDash: null,\n\n    _dashOffset: 0,\n\n    _dashIdx: 0,\n\n    _dashSum: 0,\n\n    /**\n     * @readOnly\n     */\n    setScale: function (sx, sy) {\n        this._ux = mathAbs(1 / devicePixelRatio / sx) || 0;\n        this._uy = mathAbs(1 / devicePixelRatio / sy) || 0;\n    },\n\n    getContext: function () {\n        return this._ctx;\n    },\n\n    /**\n     * @param  {CanvasRenderingContext2D} ctx\n     * @return {module:zrender/core/PathProxy}\n     */\n    beginPath: function (ctx) {\n\n        this._ctx = ctx;\n\n        ctx && ctx.beginPath();\n\n        ctx && (this.dpr = ctx.dpr);\n\n        // Reset\n        if (this._saveData) {\n            this._len = 0;\n        }\n\n        if (this._lineDash) {\n            this._lineDash = null;\n\n            this._dashOffset = 0;\n        }\n\n        return this;\n    },\n\n    /**\n     * @param  {number} x\n     * @param  {number} y\n     * @return {module:zrender/core/PathProxy}\n     */\n    moveTo: function (x, y) {\n        this.addData(CMD.M, x, y);\n        this._ctx && this._ctx.moveTo(x, y);\n\n        // x0, y0, xi, yi  _dashedXXXXTo \n        // xi, yi , x0, y0  closePath \n        //  beginPath  lineTo x0, y0 \n        //  lineTo dashed line  IE10- \n        this._x0 = x;\n        this._y0 = y;\n\n        this._xi = x;\n        this._yi = y;\n\n        return this;\n    },\n\n    /**\n     * @param  {number} x\n     * @param  {number} y\n     * @return {module:zrender/core/PathProxy}\n     */\n    lineTo: function (x, y) {\n        var exceedUnit = mathAbs(x - this._xi) > this._ux\n            || mathAbs(y - this._yi) > this._uy\n            // Force draw the first segment\n            || this._len < 5;\n\n        this.addData(CMD.L, x, y);\n\n        if (this._ctx && exceedUnit) {\n            this._needsDash() ? this._dashedLineTo(x, y)\n                : this._ctx.lineTo(x, y);\n        }\n        if (exceedUnit) {\n            this._xi = x;\n            this._yi = y;\n        }\n\n        return this;\n    },\n\n    /**\n     * @param  {number} x1\n     * @param  {number} y1\n     * @param  {number} x2\n     * @param  {number} y2\n     * @param  {number} x3\n     * @param  {number} y3\n     * @return {module:zrender/core/PathProxy}\n     */\n    bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n        this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n        if (this._ctx) {\n            this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n        }\n        this._xi = x3;\n        this._yi = y3;\n        return this;\n    },\n\n    /**\n     * @param  {number} x1\n     * @param  {number} y1\n     * @param  {number} x2\n     * @param  {number} y2\n     * @return {module:zrender/core/PathProxy}\n     */\n    quadraticCurveTo: function (x1, y1, x2, y2) {\n        this.addData(CMD.Q, x1, y1, x2, y2);\n        if (this._ctx) {\n            this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n        }\n        this._xi = x2;\n        this._yi = y2;\n        return this;\n    },\n\n    /**\n     * @param  {number} cx\n     * @param  {number} cy\n     * @param  {number} r\n     * @param  {number} startAngle\n     * @param  {number} endAngle\n     * @param  {boolean} anticlockwise\n     * @return {module:zrender/core/PathProxy}\n     */\n    arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n        this.addData(\n            CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n        );\n        this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n        this._xi = mathCos$1(endAngle) * r + cx;\n        this._yi = mathSin$1(endAngle) * r + cx;\n        return this;\n    },\n\n    // TODO\n    arcTo: function (x1, y1, x2, y2, radius) {\n        if (this._ctx) {\n            this._ctx.arcTo(x1, y1, x2, y2, radius);\n        }\n        return this;\n    },\n\n    // TODO\n    rect: function (x, y, w, h) {\n        this._ctx && this._ctx.rect(x, y, w, h);\n        this.addData(CMD.R, x, y, w, h);\n        return this;\n    },\n\n    /**\n     * @return {module:zrender/core/PathProxy}\n     */\n    closePath: function () {\n        this.addData(CMD.Z);\n\n        var ctx = this._ctx;\n        var x0 = this._x0;\n        var y0 = this._y0;\n        if (ctx) {\n            this._needsDash() && this._dashedLineTo(x0, y0);\n            ctx.closePath();\n        }\n\n        this._xi = x0;\n        this._yi = y0;\n        return this;\n    },\n\n    /**\n     * Context  rebuildPath  fill\n     * stroke \n     * @param {CanvasRenderingContext2D} ctx\n     * @return {module:zrender/core/PathProxy}\n     */\n    fill: function (ctx) {\n        ctx && ctx.fill();\n        this.toStatic();\n    },\n\n    /**\n     * @param {CanvasRenderingContext2D} ctx\n     * @return {module:zrender/core/PathProxy}\n     */\n    stroke: function (ctx) {\n        ctx && ctx.stroke();\n        this.toStatic();\n    },\n\n    /**\n     * \n     * Must be invoked before all other path drawing methods\n     * @return {module:zrender/core/PathProxy}\n     */\n    setLineDash: function (lineDash) {\n        if (lineDash instanceof Array) {\n            this._lineDash = lineDash;\n\n            this._dashIdx = 0;\n\n            var lineDashSum = 0;\n            for (var i = 0; i < lineDash.length; i++) {\n                lineDashSum += lineDash[i];\n            }\n            this._dashSum = lineDashSum;\n        }\n        return this;\n    },\n\n    /**\n     * \n     * Must be invoked before all other path drawing methods\n     * @return {module:zrender/core/PathProxy}\n     */\n    setLineDashOffset: function (offset) {\n        this._dashOffset = offset;\n        return this;\n    },\n\n    /**\n     *\n     * @return {boolean}\n     */\n    len: function () {\n        return this._len;\n    },\n\n    /**\n     *  Path \n     */\n    setData: function (data) {\n\n        var len$$1 = data.length;\n\n        if (! (this.data && this.data.length == len$$1) && hasTypedArray) {\n            this.data = new Float32Array(len$$1);\n        }\n\n        for (var i = 0; i < len$$1; i++) {\n            this.data[i] = data[i];\n        }\n\n        this._len = len$$1;\n    },\n\n    /**\n     * \n     * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n     */\n    appendPath: function (path) {\n        if (!(path instanceof Array)) {\n            path = [path];\n        }\n        var len$$1 = path.length;\n        var appendSize = 0;\n        var offset = this._len;\n        for (var i = 0; i < len$$1; i++) {\n            appendSize += path[i].len();\n        }\n        if (hasTypedArray && (this.data instanceof Float32Array)) {\n            this.data = new Float32Array(offset + appendSize);\n        }\n        for (var i = 0; i < len$$1; i++) {\n            var appendPathData = path[i].data;\n            for (var k = 0; k < appendPathData.length; k++) {\n                this.data[offset++] = appendPathData[k];\n            }\n        }\n        this._len = offset;\n    },\n\n    /**\n     *  Path \n     * \n     */\n    addData: function (cmd) {\n        if (!this._saveData) {\n            return;\n        }\n\n        var data = this.data;\n        if (this._len + arguments.length > data.length) {\n            //  Float32Array\n            // \n            this._expandData();\n            data = this.data;\n        }\n        for (var i = 0; i < arguments.length; i++) {\n            data[this._len++] = arguments[i];\n        }\n\n        this._prevCmd = cmd;\n    },\n\n    _expandData: function () {\n        // Only if data is Float32Array\n        if (!(this.data instanceof Array)) {\n            var newData = [];\n            for (var i = 0; i < this._len; i++) {\n                newData[i] = this.data[i];\n            }\n            this.data = newData;\n        }\n    },\n\n    /**\n     * If needs js implemented dashed line\n     * @return {boolean}\n     * @private\n     */\n    _needsDash: function () {\n        return this._lineDash;\n    },\n\n    _dashedLineTo: function (x1, y1) {\n        var dashSum = this._dashSum;\n        var offset = this._dashOffset;\n        var lineDash = this._lineDash;\n        var ctx = this._ctx;\n\n        var x0 = this._xi;\n        var y0 = this._yi;\n        var dx = x1 - x0;\n        var dy = y1 - y0;\n        var dist$$1 = mathSqrt$1(dx * dx + dy * dy);\n        var x = x0;\n        var y = y0;\n        var dash;\n        var nDash = lineDash.length;\n        var idx;\n        dx /= dist$$1;\n        dy /= dist$$1;\n\n        if (offset < 0) {\n            // Convert to positive offset\n            offset = dashSum + offset;\n        }\n        offset %= dashSum;\n        x -= offset * dx;\n        y -= offset * dy;\n\n        while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n        || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n            idx = this._dashIdx;\n            dash = lineDash[idx];\n            x += dx * dash;\n            y += dy * dash;\n            this._dashIdx = (idx + 1) % nDash;\n            // Skip positive offset\n            if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                continue;\n            }\n            ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                dx >= 0 ? mathMin$2(x, x1) : mathMax$2(x, x1),\n                dy >= 0 ? mathMin$2(y, y1) : mathMax$2(y, y1)\n            );\n        }\n        // Offset for next lineTo\n        dx = x - x1;\n        dy = y - y1;\n        this._dashOffset = -mathSqrt$1(dx * dx + dy * dy);\n    },\n\n    // Not accurate dashed line to\n    _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n        var dashSum = this._dashSum;\n        var offset = this._dashOffset;\n        var lineDash = this._lineDash;\n        var ctx = this._ctx;\n\n        var x0 = this._xi;\n        var y0 = this._yi;\n        var t;\n        var dx;\n        var dy;\n        var cubicAt$$1 = cubicAt;\n        var bezierLen = 0;\n        var idx = this._dashIdx;\n        var nDash = lineDash.length;\n\n        var x;\n        var y;\n\n        var tmpLen = 0;\n\n        if (offset < 0) {\n            // Convert to positive offset\n            offset = dashSum + offset;\n        }\n        offset %= dashSum;\n        // Bezier approx length\n        for (t = 0; t < 1; t += 0.1) {\n            dx = cubicAt$$1(x0, x1, x2, x3, t + 0.1)\n                - cubicAt$$1(x0, x1, x2, x3, t);\n            dy = cubicAt$$1(y0, y1, y2, y3, t + 0.1)\n                - cubicAt$$1(y0, y1, y2, y3, t);\n            bezierLen += mathSqrt$1(dx * dx + dy * dy);\n        }\n\n        // Find idx after add offset\n        for (; idx < nDash; idx++) {\n            tmpLen += lineDash[idx];\n            if (tmpLen > offset) {\n                break;\n            }\n        }\n        t = (tmpLen - offset) / bezierLen;\n\n        while (t <= 1) {\n\n            x = cubicAt$$1(x0, x1, x2, x3, t);\n            y = cubicAt$$1(y0, y1, y2, y3, t);\n\n            // Use line to approximate dashed bezier\n            // Bad result if dash is long\n            idx % 2 ? ctx.moveTo(x, y)\n                : ctx.lineTo(x, y);\n\n            t += lineDash[idx] / bezierLen;\n\n            idx = (idx + 1) % nDash;\n        }\n\n        // Finish the last segment and calculate the new offset\n        (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n        dx = x3 - x;\n        dy = y3 - y;\n        this._dashOffset = -mathSqrt$1(dx * dx + dy * dy);\n    },\n\n    _dashedQuadraticTo: function (x1, y1, x2, y2) {\n        // Convert quadratic to cubic using degree elevation\n        var x3 = x2;\n        var y3 = y2;\n        x2 = (x2 + 2 * x1) / 3;\n        y2 = (y2 + 2 * y1) / 3;\n        x1 = (this._xi + 2 * x1) / 3;\n        y1 = (this._yi + 2 * y1) / 3;\n\n        this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n    },\n\n    /**\n     *  Float32Array \n     * Convert dynamic array to static Float32Array\n     */\n    toStatic: function () {\n        var data = this.data;\n        if (data instanceof Array) {\n            data.length = this._len;\n            if (hasTypedArray) {\n                this.data = new Float32Array(data);\n            }\n        }\n    },\n\n    /**\n     * @return {module:zrender/core/BoundingRect}\n     */\n    getBoundingRect: function () {\n        min$1[0] = min$1[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n        max$1[0] = max$1[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n        var data = this.data;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n\n            if (i == 1) {\n                //  L, C, Q\n                //  previous point  point\n                //\n                //  Arc \n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo  subpath, \n                    //  closePath \n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    min2[0] = x0;\n                    min2[1] = y0;\n                    max2[0] = x0;\n                    max2[1] = y0;\n                    break;\n                case CMD.L:\n                    fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    fromCubic(\n                        xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                        min2, max2\n                    );\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    fromQuadratic(\n                        xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                        min2, max2\n                    );\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc \n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var startAngle = data[i++];\n                    var endAngle = data[i++] + startAngle;\n                    // TODO Arc \n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n\n                    if (i == 1) {\n                        //  arc \n                        // \n                        x0 = mathCos$1(startAngle) * rx + cx;\n                        y0 = mathSin$1(startAngle) * ry + cy;\n                    }\n\n                    fromArc(\n                        cx, cy, rx, ry, startAngle, endAngle,\n                        anticlockwise, min2, max2\n                    );\n\n                    xi = mathCos$1(endAngle) * rx + cx;\n                    yi = mathSin$1(endAngle) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    // Use fromLine\n                    fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                    break;\n                case CMD.Z:\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n\n            // Union\n            min(min$1, min$1, min2);\n            max(max$1, max$1, max2);\n        }\n\n        // No data\n        if (i === 0) {\n            min$1[0] = min$1[1] = max$1[0] = max$1[1] = 0;\n        }\n\n        return new BoundingRect(\n            min$1[0], min$1[1], max$1[0] - min$1[0], max$1[1] - min$1[1]\n        );\n    },\n\n    /**\n     * Rebuild path from current data\n     * Rebuild path will not consider javascript implemented line dash.\n     * @param {CanvasRenderingContext2D} ctx\n     */\n    rebuildPath: function (ctx) {\n        var d = this.data;\n        var x0, y0;\n        var xi, yi;\n        var x, y;\n        var ux = this._ux;\n        var uy = this._uy;\n        var len$$1 = this._len;\n        for (var i = 0; i < len$$1;) {\n            var cmd = d[i++];\n\n            if (i == 1) {\n                //  L, C, Q\n                //  previous point  point\n                //\n                //  Arc \n                xi = d[i];\n                yi = d[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n            switch (cmd) {\n                case CMD.M:\n                    x0 = xi = d[i++];\n                    y0 = yi = d[i++];\n                    ctx.moveTo(xi, yi);\n                    break;\n                case CMD.L:\n                    x = d[i++];\n                    y = d[i++];\n                    // Not draw too small seg between\n                    if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len$$1 - 1) {\n                        ctx.lineTo(x, y);\n                        xi = x;\n                        yi = y;\n                    }\n                    break;\n                case CMD.C:\n                    ctx.bezierCurveTo(\n                        d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                    );\n                    xi = d[i - 2];\n                    yi = d[i - 1];\n                    break;\n                case CMD.Q:\n                    ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                    xi = d[i - 2];\n                    yi = d[i - 1];\n                    break;\n                case CMD.A:\n                    var cx = d[i++];\n                    var cy = d[i++];\n                    var rx = d[i++];\n                    var ry = d[i++];\n                    var theta = d[i++];\n                    var dTheta = d[i++];\n                    var psi = d[i++];\n                    var fs = d[i++];\n                    var r = (rx > ry) ? rx : ry;\n                    var scaleX = (rx > ry) ? 1 : rx / ry;\n                    var scaleY = (rx > ry) ? ry / rx : 1;\n                    var isEllipse = Math.abs(rx - ry) > 1e-3;\n                    var endAngle = theta + dTheta;\n                    if (isEllipse) {\n                        ctx.translate(cx, cy);\n                        ctx.rotate(psi);\n                        ctx.scale(scaleX, scaleY);\n                        ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                        ctx.scale(1 / scaleX, 1 / scaleY);\n                        ctx.rotate(-psi);\n                        ctx.translate(-cx, -cy);\n                    }\n                    else {\n                        ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                    }\n\n                    if (i == 1) {\n                        //  arc \n                        // \n                        x0 = mathCos$1(theta) * rx + cx;\n                        y0 = mathSin$1(theta) * ry + cy;\n                    }\n                    xi = mathCos$1(endAngle) * rx + cx;\n                    yi = mathSin$1(endAngle) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = d[i];\n                    y0 = yi = d[i + 1];\n                    ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                    break;\n                case CMD.Z:\n                    ctx.closePath();\n                    xi = x0;\n                    yi = y0;\n            }\n        }\n    }\n};\n\nPathProxy.CMD = CMD;\n\n/**\n * \n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke$1(x0, y0, x1, y1, lineWidth, x, y) {\n    if (lineWidth === 0) {\n        return false;\n    }\n    var _l = lineWidth;\n    var _a = 0;\n    var _b = x0;\n    // Quick reject\n    if (\n        (y > y0 + _l && y > y1 + _l)\n        || (y < y0 - _l && y < y1 - _l)\n        || (x > x0 + _l && x > x1 + _l)\n        || (x < x0 - _l && x < x1 - _l)\n    ) {\n        return false;\n    }\n\n    if (x0 !== x1) {\n        _a = (y0 - y1) / (x0 - x1);\n        _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n    }\n    else {\n        return Math.abs(x - x0) <= _l / 2;\n    }\n    var tmp = _a * x - y + _b;\n    var _s = tmp * tmp / (_a * _a + 1);\n    return _s <= _l / 2 * _l / 2;\n}\n\n/**\n * \n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  x2\n * @param  {number}  y2\n * @param  {number}  x3\n * @param  {number}  y3\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke$2(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n    if (lineWidth === 0) {\n        return false;\n    }\n    var _l = lineWidth;\n    // Quick reject\n    if (\n        (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n        || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n        || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n        || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n    ) {\n        return false;\n    }\n    var d = cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, null\n    );\n    return d <= _l / 2;\n}\n\n/**\n * \n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  x2\n * @param  {number}  y2\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke$3(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n    if (lineWidth === 0) {\n        return false;\n    }\n    var _l = lineWidth;\n    // Quick reject\n    if (\n        (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n        || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n        || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n        || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n    ) {\n        return false;\n    }\n    var d = quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, null\n    );\n    return d <= _l / 2;\n}\n\nvar PI2$3 = Math.PI * 2;\n\nfunction normalizeRadian(angle) {\n    angle %= PI2$3;\n    if (angle < 0) {\n        angle += PI2$3;\n    }\n    return angle;\n}\n\nvar PI2$2 = Math.PI * 2;\n\n/**\n * \n * @param  {number}  cx\n * @param  {number}  cy\n * @param  {number}  r\n * @param  {number}  startAngle\n * @param  {number}  endAngle\n * @param  {boolean}  anticlockwise\n * @param  {number} lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {Boolean}\n */\nfunction containStroke$4(\n    cx, cy, r, startAngle, endAngle, anticlockwise,\n    lineWidth, x, y\n) {\n\n    if (lineWidth === 0) {\n        return false;\n    }\n    var _l = lineWidth;\n\n    x -= cx;\n    y -= cy;\n    var d = Math.sqrt(x * x + y * y);\n\n    if ((d - _l > r) || (d + _l < r)) {\n        return false;\n    }\n    if (Math.abs(startAngle - endAngle) % PI2$2 < 1e-4) {\n        // Is a circle\n        return true;\n    }\n    if (anticlockwise) {\n        var tmp = startAngle;\n        startAngle = normalizeRadian(endAngle);\n        endAngle = normalizeRadian(tmp);\n    } else {\n        startAngle = normalizeRadian(startAngle);\n        endAngle = normalizeRadian(endAngle);\n    }\n    if (startAngle > endAngle) {\n        endAngle += PI2$2;\n    }\n\n    var angle = Math.atan2(y, x);\n    if (angle < 0) {\n        angle += PI2$2;\n    }\n    return (angle >= startAngle && angle <= endAngle)\n        || (angle + PI2$2 >= startAngle && angle + PI2$2 <= endAngle);\n}\n\nfunction windingLine(x0, y0, x1, y1, x, y) {\n    if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n        return 0;\n    }\n    // Ignore horizontal line\n    if (y1 === y0) {\n        return 0;\n    }\n    var dir = y1 < y0 ? 1 : -1;\n    var t = (y - y0) / (y1 - y0);\n\n    // Avoid winding error when intersection point is the connect point of two line of polygon\n    if (t === 1 || t === 0) {\n        dir = y1 < y0 ? 0.5 : -0.5;\n    }\n\n    var x_ = t * (x1 - x0) + x0;\n\n    return x_ > x ? dir : 0;\n}\n\nvar CMD$1 = PathProxy.CMD;\nvar PI2$1 = Math.PI * 2;\n\nvar EPSILON$2 = 1e-4;\n\nfunction isAroundEqual(a, b) {\n    return Math.abs(a - b) < EPSILON$2;\n}\n\n// \nvar roots = [-1, -1, -1];\nvar extrema = [-1, -1];\n\nfunction swapExtrema() {\n    var tmp = extrema[0];\n    extrema[0] = extrema[1];\n    extrema[1] = tmp;\n}\n\nfunction windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n    // Quick reject\n    if (\n        (y > y0 && y > y1 && y > y2 && y > y3)\n        || (y < y0 && y < y1 && y < y2 && y < y3)\n    ) {\n        return 0;\n    }\n    var nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);\n    if (nRoots === 0) {\n        return 0;\n    }\n    else {\n        var w = 0;\n        var nExtrema = -1;\n        var y0_, y1_;\n        for (var i = 0; i < nRoots; i++) {\n            var t = roots[i];\n\n            // Avoid winding error when intersection point is the connect point of two line of polygon\n            var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n            var x_ = cubicAt(x0, x1, x2, x3, t);\n            if (x_ < x) { // Quick reject\n                continue;\n            }\n            if (nExtrema < 0) {\n                nExtrema = cubicExtrema(y0, y1, y2, y3, extrema);\n                if (extrema[1] < extrema[0] && nExtrema > 1) {\n                    swapExtrema();\n                }\n                y0_ = cubicAt(y0, y1, y2, y3, extrema[0]);\n                if (nExtrema > 1) {\n                    y1_ = cubicAt(y0, y1, y2, y3, extrema[1]);\n                }\n            }\n            if (nExtrema == 2) {\n                // \n                if (t < extrema[0]) {\n                    w += y0_ < y0 ? unit : -unit;\n                }\n                else if (t < extrema[1]) {\n                    w += y1_ < y0_ ? unit : -unit;\n                }\n                else {\n                    w += y3 < y1_ ? unit : -unit;\n                }\n            }\n            else {\n                // \n                if (t < extrema[0]) {\n                    w += y0_ < y0 ? unit : -unit;\n                }\n                else {\n                    w += y3 < y0_ ? unit : -unit;\n                }\n            }\n        }\n        return w;\n    }\n}\n\nfunction windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n    // Quick reject\n    if (\n        (y > y0 && y > y1 && y > y2)\n        || (y < y0 && y < y1 && y < y2)\n    ) {\n        return 0;\n    }\n    var nRoots = quadraticRootAt(y0, y1, y2, y, roots);\n    if (nRoots === 0) {\n        return 0;\n    }\n    else {\n        var t = quadraticExtremum(y0, y1, y2);\n        if (t >= 0 && t <= 1) {\n            var w = 0;\n            var y_ = quadraticAt(y0, y1, y2, t);\n            for (var i = 0; i < nRoots; i++) {\n                // Remove one endpoint.\n                var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                var x_ = quadraticAt(x0, x1, x2, roots[i]);\n                if (x_ < x) {   // Quick reject\n                    continue;\n                }\n                if (roots[i] < t) {\n                    w += y_ < y0 ? unit : -unit;\n                }\n                else {\n                    w += y2 < y_ ? unit : -unit;\n                }\n            }\n            return w;\n        }\n        else {\n            // Remove one endpoint.\n            var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n            var x_ = quadraticAt(x0, x1, x2, roots[0]);\n            if (x_ < x) {   // Quick reject\n                return 0;\n            }\n            return y2 < y0 ? unit : -unit;\n        }\n    }\n}\n\n// TODO\n// Arc \nfunction windingArc(\n    cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n) {\n    y -= cy;\n    if (y > r || y < -r) {\n        return 0;\n    }\n    var tmp = Math.sqrt(r * r - y * y);\n    roots[0] = -tmp;\n    roots[1] = tmp;\n\n    var diff = Math.abs(startAngle - endAngle);\n    if (diff < 1e-4) {\n        return 0;\n    }\n    if (diff % PI2$1 < 1e-4) {\n        // Is a circle\n        startAngle = 0;\n        endAngle = PI2$1;\n        var dir = anticlockwise ? 1 : -1;\n        if (x >= roots[0] + cx && x <= roots[1] + cx) {\n            return dir;\n        } else {\n            return 0;\n        }\n    }\n\n    if (anticlockwise) {\n        var tmp = startAngle;\n        startAngle = normalizeRadian(endAngle);\n        endAngle = normalizeRadian(tmp);\n    }\n    else {\n        startAngle = normalizeRadian(startAngle);\n        endAngle = normalizeRadian(endAngle);\n    }\n    if (startAngle > endAngle) {\n        endAngle += PI2$1;\n    }\n\n    var w = 0;\n    for (var i = 0; i < 2; i++) {\n        var x_ = roots[i];\n        if (x_ + cx > x) {\n            var angle = Math.atan2(y, x_);\n            var dir = anticlockwise ? 1 : -1;\n            if (angle < 0) {\n                angle = PI2$1 + angle;\n            }\n            if (\n                (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2$1 >= startAngle && angle + PI2$1 <= endAngle)\n            ) {\n                if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                    dir = -dir;\n                }\n                w += dir;\n            }\n        }\n    }\n    return w;\n}\n\nfunction containPath(data, lineWidth, isStroke, x, y) {\n    var w = 0;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n\n    for (var i = 0; i < data.length;) {\n        var cmd = data[i++];\n        // Begin a new subpath\n        if (cmd === CMD$1.M && i > 1) {\n            // Close previous subpath\n            if (!isStroke) {\n                w += windingLine(xi, yi, x0, y0, x, y);\n            }\n            //  subpath \n            // if (w !== 0) {\n            //     return true;\n            // }\n        }\n\n        if (i == 1) {\n            //  L, C, Q\n            //  previous point  point\n            //\n            //  Arc \n            xi = data[i];\n            yi = data[i + 1];\n\n            x0 = xi;\n            y0 = yi;\n        }\n\n        switch (cmd) {\n            case CMD$1.M:\n                // moveTo  subpath, \n                //  closePath \n                x0 = data[i++];\n                y0 = data[i++];\n                xi = x0;\n                yi = y0;\n                break;\n            case CMD$1.L:\n                if (isStroke) {\n                    if (containStroke$1(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                        return true;\n                    }\n                }\n                else {\n                    // NOTE  L, C, Q  NaN\n                    w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                }\n                xi = data[i++];\n                yi = data[i++];\n                break;\n            case CMD$1.C:\n                if (isStroke) {\n                    if (containStroke$2(xi, yi,\n                        data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                        lineWidth, x, y\n                    )) {\n                        return true;\n                    }\n                }\n                else {\n                    w += windingCubic(\n                        xi, yi,\n                        data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                        x, y\n                    ) || 0;\n                }\n                xi = data[i++];\n                yi = data[i++];\n                break;\n            case CMD$1.Q:\n                if (isStroke) {\n                    if (containStroke$3(xi, yi,\n                        data[i++], data[i++], data[i], data[i + 1],\n                        lineWidth, x, y\n                    )) {\n                        return true;\n                    }\n                }\n                else {\n                    w += windingQuadratic(\n                        xi, yi,\n                        data[i++], data[i++], data[i], data[i + 1],\n                        x, y\n                    ) || 0;\n                }\n                xi = data[i++];\n                yi = data[i++];\n                break;\n            case CMD$1.A:\n                // TODO Arc \n                var cx = data[i++];\n                var cy = data[i++];\n                var rx = data[i++];\n                var ry = data[i++];\n                var theta = data[i++];\n                var dTheta = data[i++];\n                // TODO Arc \n                var psi = data[i++];\n                var anticlockwise = 1 - data[i++];\n                var x1 = Math.cos(theta) * rx + cx;\n                var y1 = Math.sin(theta) * ry + cy;\n                //  arc \n                if (i > 1) {\n                    w += windingLine(xi, yi, x1, y1, x, y);\n                }\n                else {\n                    // \n                    x0 = x1;\n                    y0 = y1;\n                }\n                // zr scale, x\n                var _x = (x - cx) * ry / rx + cx;\n                if (isStroke) {\n                    if (containStroke$4(\n                        cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                        lineWidth, _x, y\n                    )) {\n                        return true;\n                    }\n                }\n                else {\n                    w += windingArc(\n                        cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                        _x, y\n                    );\n                }\n                xi = Math.cos(theta + dTheta) * rx + cx;\n                yi = Math.sin(theta + dTheta) * ry + cy;\n                break;\n            case CMD$1.R:\n                x0 = xi = data[i++];\n                y0 = yi = data[i++];\n                var width = data[i++];\n                var height = data[i++];\n                var x1 = x0 + width;\n                var y1 = y0 + height;\n                if (isStroke) {\n                    if (containStroke$1(x0, y0, x1, y0, lineWidth, x, y)\n                        || containStroke$1(x1, y0, x1, y1, lineWidth, x, y)\n                        || containStroke$1(x1, y1, x0, y1, lineWidth, x, y)\n                        || containStroke$1(x0, y1, x0, y0, lineWidth, x, y)\n                    ) {\n                        return true;\n                    }\n                }\n                else {\n                    // FIXME Clockwise ?\n                    w += windingLine(x1, y0, x1, y1, x, y);\n                    w += windingLine(x0, y1, x0, y0, x, y);\n                }\n                break;\n            case CMD$1.Z:\n                if (isStroke) {\n                    if (containStroke$1(\n                        xi, yi, x0, y0, lineWidth, x, y\n                    )) {\n                        return true;\n                    }\n                }\n                else {\n                    // Close a subpath\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                    //  subpath \n                    // FIXME subpaths may overlap\n                    // if (w !== 0) {\n                    //     return true;\n                    // }\n                }\n                xi = x0;\n                yi = y0;\n                break;\n        }\n    }\n    if (!isStroke && !isAroundEqual(yi, y0)) {\n        w += windingLine(xi, yi, x0, y0, x, y) || 0;\n    }\n    return w !== 0;\n}\n\nfunction contain(pathData, x, y) {\n    return containPath(pathData, 0, false, x, y);\n}\n\nfunction containStroke(pathData, lineWidth, x, y) {\n    return containPath(pathData, lineWidth, true, x, y);\n}\n\nvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\nvar abs = Math.abs;\n\nvar pathProxyForDraw = new PathProxy(true);\n/**\n * @alias module:zrender/graphic/Path\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nfunction Path(opts) {\n    Displayable.call(this, opts);\n\n    /**\n     * @type {module:zrender/core/PathProxy}\n     * @readOnly\n     */\n    this.path = null;\n}\n\nPath.prototype = {\n\n    constructor: Path,\n\n    type: 'path',\n\n    __dirtyPath: true,\n\n    strokeContainThreshold: 5,\n\n    brush: function (ctx, prevEl) {\n        var style = this.style;\n        var path = this.path || pathProxyForDraw;\n        var hasStroke = style.hasStroke();\n        var hasFill = style.hasFill();\n        var fill = style.fill;\n        var stroke = style.stroke;\n        var hasFillGradient = hasFill && !!(fill.colorStops);\n        var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n        var hasFillPattern = hasFill && !!(fill.image);\n        var hasStrokePattern = hasStroke && !!(stroke.image);\n\n        style.bind(ctx, this, prevEl);\n        this.setTransform(ctx);\n\n        if (this.__dirty) {\n            var rect;\n            // Update gradient because bounding rect may changed\n            if (hasFillGradient) {\n                rect = rect || this.getBoundingRect();\n                this._fillGradient = style.getGradient(ctx, fill, rect);\n            }\n            if (hasStrokeGradient) {\n                rect = rect || this.getBoundingRect();\n                this._strokeGradient = style.getGradient(ctx, stroke, rect);\n            }\n        }\n        // Use the gradient or pattern\n        if (hasFillGradient) {\n            // PENDING If may have affect the state\n            ctx.fillStyle = this._fillGradient;\n        }\n        else if (hasFillPattern) {\n            ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n        }\n        if (hasStrokeGradient) {\n            ctx.strokeStyle = this._strokeGradient;\n        }\n        else if (hasStrokePattern) {\n            ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n        }\n\n        var lineDash = style.lineDash;\n        var lineDashOffset = style.lineDashOffset;\n\n        var ctxLineDash = !!ctx.setLineDash;\n\n        // Update path sx, sy\n        var scale = this.getGlobalScale();\n        path.setScale(scale[0], scale[1]);\n\n        // Proxy context\n        // Rebuild path in following 2 cases\n        // 1. Path is dirty\n        // 2. Path needs javascript implemented lineDash stroking.\n        //    In this case, lineDash information will not be saved in PathProxy\n        if (this.__dirtyPath\n            || (lineDash && !ctxLineDash && hasStroke)\n        ) {\n            path.beginPath(ctx);\n\n            // Setting line dash before build path\n            if (lineDash && !ctxLineDash) {\n                path.setLineDash(lineDash);\n                path.setLineDashOffset(lineDashOffset);\n            }\n\n            this.buildPath(path, this.shape, false);\n\n            // Clear path dirty flag\n            if (this.path) {\n                this.__dirtyPath = false;\n            }\n        }\n        else {\n            // Replay path building\n            ctx.beginPath();\n            this.path.rebuildPath(ctx);\n        }\n\n        hasFill && path.fill(ctx);\n\n        if (lineDash && ctxLineDash) {\n            ctx.setLineDash(lineDash);\n            ctx.lineDashOffset = lineDashOffset;\n        }\n\n        hasStroke && path.stroke(ctx);\n\n        if (lineDash && ctxLineDash) {\n            // PENDING\n            // Remove lineDash\n            ctx.setLineDash([]);\n        }\n\n        this.restoreTransform(ctx);\n\n        // Draw rect text\n        if (style.text != null) {\n            this.drawRectText(ctx, this.getBoundingRect());\n        }\n    },\n\n    // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n    // Like in circle\n    buildPath: function (ctx, shapeCfg, inBundle) {},\n\n    createPathProxy: function () {\n        this.path = new PathProxy();\n    },\n\n    getBoundingRect: function () {\n        var rect = this._rect;\n        var style = this.style;\n        var needsUpdateRect = !rect;\n        if (needsUpdateRect) {\n            var path = this.path;\n            if (!path) {\n                // Create path on demand.\n                path = this.path = new PathProxy();\n            }\n            if (this.__dirtyPath) {\n                path.beginPath();\n                this.buildPath(path, this.shape, false);\n            }\n            rect = path.getBoundingRect();\n        }\n        this._rect = rect;\n\n        if (style.hasStroke()) {\n            // Needs update rect with stroke lineWidth when\n            // 1. Element changes scale or lineWidth\n            // 2. Shape is changed\n            var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n            if (this.__dirty || needsUpdateRect) {\n                rectWithStroke.copy(rect);\n                // FIXME Must after updateTransform\n                var w = style.lineWidth;\n                // PENDING, Min line width is needed when line is horizontal or vertical\n                var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                // Only add extra hover lineWidth when there are no fill\n                if (!style.hasFill()) {\n                    w = Math.max(w, this.strokeContainThreshold || 4);\n                }\n                // Consider line width\n                // Line scale can't be 0;\n                if (lineScale > 1e-10) {\n                    rectWithStroke.width += w / lineScale;\n                    rectWithStroke.height += w / lineScale;\n                    rectWithStroke.x -= w / lineScale / 2;\n                    rectWithStroke.y -= w / lineScale / 2;\n                }\n            }\n\n            // Return rect with stroke\n            return rectWithStroke;\n        }\n\n        return rect;\n    },\n\n    contain: function (x, y) {\n        var localPos = this.transformCoordToLocal(x, y);\n        var rect = this.getBoundingRect();\n        var style = this.style;\n        x = localPos[0];\n        y = localPos[1];\n\n        if (rect.contain(x, y)) {\n            var pathData = this.path.data;\n            if (style.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                // Line scale can't be 0;\n                if (lineScale > 1e-10) {\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                    }\n                    if (containStroke(\n                        pathData, lineWidth / lineScale, x, y\n                    )) {\n                        return true;\n                    }\n                }\n            }\n            if (style.hasFill()) {\n                return contain(pathData, x, y);\n            }\n        }\n        return false;\n    },\n\n    /**\n     * @param  {boolean} dirtyPath\n     */\n    dirty: function (dirtyPath) {\n        if (dirtyPath == null) {\n            dirtyPath = true;\n        }\n        // Only mark dirty, not mark clean\n        if (dirtyPath) {\n            this.__dirtyPath = dirtyPath;\n            this._rect = null;\n        }\n\n        this.__dirty = true;\n\n        this.__zr && this.__zr.refresh();\n\n        // Used as a clipping path\n        if (this.__clipTarget) {\n            this.__clipTarget.dirty();\n        }\n    },\n\n    /**\n     * Alias for animate('shape')\n     * @param {boolean} loop\n     */\n    animateShape: function (loop) {\n        return this.animate('shape', loop);\n    },\n\n    // Overwrite attrKV\n    attrKV: function (key, value) {\n        // FIXME\n        if (key === 'shape') {\n            this.setShape(value);\n            this.__dirtyPath = true;\n            this._rect = null;\n        }\n        else {\n            Displayable.prototype.attrKV.call(this, key, value);\n        }\n    },\n\n    /**\n     * @param {Object|string} key\n     * @param {*} value\n     */\n    setShape: function (key, value) {\n        var shape = this.shape;\n        // Path from string may not have shape\n        if (shape) {\n            if (isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        shape[name] = key[name];\n                    }\n                }\n            }\n            else {\n                shape[key] = value;\n            }\n            this.dirty(true);\n        }\n        return this;\n    },\n\n    getLineScale: function () {\n        var m = this.transform;\n        // Get the line scale.\n        // Determinant of `m` means how much the area is enlarged by the\n        // transformation. So its square root can be used as a scale factor\n        // for width.\n        return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n            ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n            : 1;\n    }\n};\n\n/**\n *  Path element, \n * Extend a path element\n * @param {Object} props\n * @param {string} props.type Path type\n * @param {Function} props.init Initialize\n * @param {Function} props.buildPath Overwrite buildPath method\n * @param {Object} [props.style] Extended default style config\n * @param {Object} [props.shape] Extended default shape config\n */\nPath.extend = function (defaults$$1) {\n    var Sub = function (opts) {\n        Path.call(this, opts);\n\n        if (defaults$$1.style) {\n            // Extend default style\n            this.style.extendFrom(defaults$$1.style, false);\n        }\n\n        // Extend default shape\n        var defaultShape = defaults$$1.shape;\n        if (defaultShape) {\n            this.shape = this.shape || {};\n            var thisShape = this.shape;\n            for (var name in defaultShape) {\n                if (\n                    ! thisShape.hasOwnProperty(name)\n                    && defaultShape.hasOwnProperty(name)\n                ) {\n                    thisShape[name] = defaultShape[name];\n                }\n            }\n        }\n\n        defaults$$1.init && defaults$$1.init.call(this, opts);\n    };\n\n    inherits(Sub, Path);\n\n    // FIXME  extend position, rotation \n    for (var name in defaults$$1) {\n        // Extending prototype values and methods\n        if (name !== 'style' && name !== 'shape') {\n            Sub.prototype[name] = defaults$$1[name];\n        }\n    }\n\n    return Sub;\n};\n\ninherits(Path, Displayable);\n\nvar CMD$2 = PathProxy.CMD;\n\nvar points = [[], [], []];\nvar mathSqrt$3 = Math.sqrt;\nvar mathAtan2 = Math.atan2;\n\nvar transformPath = function (path, m) {\n    var data = path.data;\n    var cmd;\n    var nPoint;\n    var i;\n    var j;\n    var k;\n    var p;\n\n    var M = CMD$2.M;\n    var C = CMD$2.C;\n    var L = CMD$2.L;\n    var R = CMD$2.R;\n    var A = CMD$2.A;\n    var Q = CMD$2.Q;\n\n    for (i = 0, j = 0; i < data.length;) {\n        cmd = data[i++];\n        j = i;\n        nPoint = 0;\n\n        switch (cmd) {\n            case M:\n                nPoint = 1;\n                break;\n            case L:\n                nPoint = 1;\n                break;\n            case C:\n                nPoint = 3;\n                break;\n            case Q:\n                nPoint = 2;\n                break;\n            case A:\n                var x = m[4];\n                var y = m[5];\n                var sx = mathSqrt$3(m[0] * m[0] + m[1] * m[1]);\n                var sy = mathSqrt$3(m[2] * m[2] + m[3] * m[3]);\n                var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                // cx\n                data[i] *= sx;\n                data[i++] += x;\n                // cy\n                data[i] *= sy;\n                data[i++] += y;\n                // Scale rx and ry\n                // FIXME Assume psi is 0 here\n                data[i++] *= sx;\n                data[i++] *= sy;\n\n                // Start angle\n                data[i++] += angle;\n                // end angle\n                data[i++] += angle;\n                // FIXME psi\n                i += 2;\n                j = i;\n                break;\n            case R:\n                // x0, y0\n                p[0] = data[i++];\n                p[1] = data[i++];\n                applyTransform(p, p, m);\n                data[j++] = p[0];\n                data[j++] = p[1];\n                // x1, y1\n                p[0] += data[i++];\n                p[1] += data[i++];\n                applyTransform(p, p, m);\n                data[j++] = p[0];\n                data[j++] = p[1];\n        }\n\n        for (k = 0; k < nPoint; k++) {\n            var p = points[k];\n            p[0] = data[i++];\n            p[1] = data[i++];\n\n            applyTransform(p, p, m);\n            // Write back\n            data[j++] = p[0];\n            data[j++] = p[1];\n        }\n    }\n};\n\n// command chars\nvar cc = [\n    'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n    'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n];\n\nvar mathSqrt = Math.sqrt;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI = Math.PI;\n\nvar vMag = function(v) {\n    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n};\nvar vRatio = function(u, v) {\n    return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n};\nvar vAngle = function(u, v) {\n    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n            * Math.acos(vRatio(u, v));\n};\n\nfunction processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n    var psi = psiDeg * (PI / 180.0);\n    var xp = mathCos(psi) * (x1 - x2) / 2.0\n                + mathSin(psi) * (y1 - y2) / 2.0;\n    var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                + mathCos(psi) * (y1 - y2) / 2.0;\n\n    var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n    if (lambda > 1) {\n        rx *= mathSqrt(lambda);\n        ry *= mathSqrt(lambda);\n    }\n\n    var f = (fa === fs ? -1 : 1)\n        * mathSqrt((((rx * rx) * (ry * ry))\n                - ((rx * rx) * (yp * yp))\n                - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                + (ry * ry) * (xp * xp))\n            ) || 0;\n\n    var cxp = f * rx * yp / ry;\n    var cyp = f * -ry * xp / rx;\n\n    var cx = (x1 + x2) / 2.0\n                + mathCos(psi) * cxp\n                - mathSin(psi) * cyp;\n    var cy = (y1 + y2) / 2.0\n            + mathSin(psi) * cxp\n            + mathCos(psi) * cyp;\n\n    var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n    var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n    var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n    var dTheta = vAngle(u, v);\n\n    if (vRatio(u, v) <= -1) {\n        dTheta = PI;\n    }\n    if (vRatio(u, v) >= 1) {\n        dTheta = 0;\n    }\n    if (fs === 0 && dTheta > 0) {\n        dTheta = dTheta - 2 * PI;\n    }\n    if (fs === 1 && dTheta < 0) {\n        dTheta = dTheta + 2 * PI;\n    }\n\n    path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n}\n\nfunction createPathProxyFromString(data) {\n    if (!data) {\n        return [];\n    }\n\n    // command string\n    var cs = data.replace(/-/g, ' -')\n        .replace(/  /g, ' ')\n        .replace(/ /g, ',')\n        .replace(/,,/g, ',');\n\n    var n;\n    // create pipes so that we can split the data\n    for (n = 0; n < cc.length; n++) {\n        cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n    }\n\n    // create array\n    var arr = cs.split('|');\n    // init context point\n    var cpx = 0;\n    var cpy = 0;\n\n    var path = new PathProxy();\n    var CMD = PathProxy.CMD;\n\n    var prevCmd;\n    for (n = 1; n < arr.length; n++) {\n        var str = arr[n];\n        var c = str.charAt(0);\n        var off = 0;\n        var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n        var cmd;\n\n        if (p.length > 0 && p[0] === '') {\n            p.shift();\n        }\n\n        for (var i = 0; i < p.length; i++) {\n            p[i] = parseFloat(p[i]);\n        }\n        while (off < p.length && !isNaN(p[off])) {\n            if (isNaN(p[0])) {\n                break;\n            }\n            var ctlPtx;\n            var ctlPty;\n\n            var rx;\n            var ry;\n            var psi;\n            var fa;\n            var fs;\n\n            var x1 = cpx;\n            var y1 = cpy;\n\n            // convert l, H, h, V, and v to L\n            switch (c) {\n                case 'l':\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'L':\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'm':\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.M;\n                    path.addData(cmd, cpx, cpy);\n                    c = 'l';\n                    break;\n                case 'M':\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.M;\n                    path.addData(cmd, cpx, cpy);\n                    c = 'L';\n                    break;\n                case 'h':\n                    cpx += p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'H':\n                    cpx = p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'v':\n                    cpy += p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'V':\n                    cpy = p[off++];\n                    cmd = CMD.L;\n                    path.addData(cmd, cpx, cpy);\n                    break;\n                case 'C':\n                    cmd = CMD.C;\n                    path.addData(\n                        cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                    );\n                    cpx = p[off - 2];\n                    cpy = p[off - 1];\n                    break;\n                case 'c':\n                    cmd = CMD.C;\n                    path.addData(\n                        cmd,\n                        p[off++] + cpx, p[off++] + cpy,\n                        p[off++] + cpx, p[off++] + cpy,\n                        p[off++] + cpx, p[off++] + cpy\n                    );\n                    cpx += p[off - 2];\n                    cpy += p[off - 1];\n                    break;\n                case 'S':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.C) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cmd = CMD.C;\n                    x1 = p[off++];\n                    y1 = p[off++];\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                    break;\n                case 's':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.C) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cmd = CMD.C;\n                    x1 = cpx + p[off++];\n                    y1 = cpy + p[off++];\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                    break;\n                case 'Q':\n                    x1 = p[off++];\n                    y1 = p[off++];\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, x1, y1, cpx, cpy);\n                    break;\n                case 'q':\n                    x1 = p[off++] + cpx;\n                    y1 = p[off++] + cpy;\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, x1, y1, cpx, cpy);\n                    break;\n                case 'T':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.Q) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                    break;\n                case 't':\n                    ctlPtx = cpx;\n                    ctlPty = cpy;\n                    var len = path.len();\n                    var pathData = path.data;\n                    if (prevCmd === CMD.Q) {\n                        ctlPtx += cpx - pathData[len - 4];\n                        ctlPty += cpy - pathData[len - 3];\n                    }\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.Q;\n                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                    break;\n                case 'A':\n                    rx = p[off++];\n                    ry = p[off++];\n                    psi = p[off++];\n                    fa = p[off++];\n                    fs = p[off++];\n\n                    x1 = cpx, y1 = cpy;\n                    cpx = p[off++];\n                    cpy = p[off++];\n                    cmd = CMD.A;\n                    processArc(\n                        x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                    );\n                    break;\n                case 'a':\n                    rx = p[off++];\n                    ry = p[off++];\n                    psi = p[off++];\n                    fa = p[off++];\n                    fs = p[off++];\n\n                    x1 = cpx, y1 = cpy;\n                    cpx += p[off++];\n                    cpy += p[off++];\n                    cmd = CMD.A;\n                    processArc(\n                        x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                    );\n                    break;\n            }\n        }\n\n        if (c === 'z' || c === 'Z') {\n            cmd = CMD.Z;\n            path.addData(cmd);\n        }\n\n        prevCmd = cmd;\n    }\n\n    path.toStatic();\n\n    return path;\n}\n\n// TODO Optimize double memory cost problem\nfunction createPathOptions(str, opts) {\n    var pathProxy = createPathProxyFromString(str);\n    opts = opts || {};\n    opts.buildPath = function (path) {\n        if (path.setData) {\n            path.setData(pathProxy.data);\n            // Svg and vml renderer don't have context\n            var ctx = path.getContext();\n            if (ctx) {\n                path.rebuildPath(ctx);\n            }\n        }\n        else {\n            var ctx = path;\n            pathProxy.rebuildPath(ctx);\n        }\n    };\n\n    opts.applyTransform = function (m) {\n        transformPath(pathProxy, m);\n\n        this.dirty(true);\n    };\n\n    return opts;\n}\n\n/**\n * Create a Path object from path string data\n * http://www.w3.org/TR/SVG/paths.html#PathData\n * @param  {Object} opts Other options\n */\nfunction createFromString(str, opts) {\n    return new Path(createPathOptions(str, opts));\n}\n\n/**\n * Create a Path class from path string data\n * @param  {string} str\n * @param  {Object} opts Other options\n */\nfunction extendFromString(str, opts) {\n    return Path.extend(createPathOptions(str, opts));\n}\n\n/**\n * Merge multiple paths\n */\n// TODO Apply transform\n// TODO stroke dash\n// TODO Optimize double memory cost problem\nfunction mergePath$1(pathEls, opts) {\n    var pathList = [];\n    var len = pathEls.length;\n    for (var i = 0; i < len; i++) {\n        var pathEl = pathEls[i];\n        if (!pathEl.path) {\n            pathEl.createPathProxy();\n        }\n        if (pathEl.__dirtyPath) {\n            pathEl.buildPath(pathEl.path, pathEl.shape, true);\n        }\n        pathList.push(pathEl.path);\n    }\n\n    var pathBundle = new Path(opts);\n    // Need path proxy.\n    pathBundle.createPathProxy();\n    pathBundle.buildPath = function (path) {\n        path.appendPath(pathList);\n        // Svg and vml renderer don't have context\n        var ctx = path.getContext();\n        if (ctx) {\n            path.rebuildPath(ctx);\n        }\n    };\n\n    return pathBundle;\n}\n\n/**\n * @alias zrender/graphic/Text\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nvar Text = function (opts) { // jshint ignore:line\n    Displayable.call(this, opts);\n};\n\nText.prototype = {\n\n    constructor: Text,\n\n    type: 'text',\n\n    brush: function (ctx, prevEl) {\n        var style = this.style;\n\n        // Optimize, avoid normalize every time.\n        this.__dirty && normalizeTextStyle(style, true);\n\n        // Use props with prefix 'text'.\n        style.fill = style.stroke = style.shadowBlur = style.shadowColor =\n            style.shadowOffsetX = style.shadowOffsetY = null;\n\n        var text = style.text;\n        // Convert to string\n        text != null && (text += '');\n\n        // Always bind style\n        style.bind(ctx, this, prevEl);\n\n        if (!needDrawText(text, style)) {\n            return;\n        }\n\n        this.setTransform(ctx);\n\n        renderText(this, ctx, text, style);\n\n        this.restoreTransform(ctx);\n    },\n\n    getBoundingRect: function () {\n        var style = this.style;\n\n        // Optimize, avoid normalize every time.\n        this.__dirty && normalizeTextStyle(style, true);\n\n        if (!this._rect) {\n            var text = style.text;\n            text != null ? (text += '') : (text = '');\n\n            var rect = getBoundingRect(\n                style.text + '',\n                style.font,\n                style.textAlign,\n                style.textVerticalAlign,\n                style.textPadding,\n                style.rich\n            );\n\n            rect.x += style.x || 0;\n            rect.y += style.y || 0;\n\n            if (getStroke(style.textStroke, style.textStrokeWidth)) {\n                var w = style.textStrokeWidth;\n                rect.x -= w / 2;\n                rect.y -= w / 2;\n                rect.width += w;\n                rect.height += w;\n            }\n\n            this._rect = rect;\n        }\n\n        return this._rect;\n    }\n};\n\ninherits(Text, Displayable);\n\n/**\n * \n * @module zrender/shape/Circle\n */\n\nvar Circle = Path.extend({\n\n    type: 'circle',\n\n    shape: {\n        cx: 0,\n        cy: 0,\n        r: 0\n    },\n\n\n    buildPath : function (ctx, shape, inBundle) {\n        // Better stroking in ShapeBundle\n        // Always do it may have performence issue ( fill may be 2x more cost)\n        if (inBundle) {\n            ctx.moveTo(shape.cx + shape.r, shape.cy);\n        }\n        // else {\n        //     if (ctx.allocate && !ctx.data.length) {\n        //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n        //     }\n        // }\n        // Better stroking in ShapeBundle\n        // ctx.moveTo(shape.cx + shape.r, shape.cy);\n        ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n    }\n});\n\n// Fix weird bug in some version of IE11 (like 11.0.9600.178**),\n// where exception \"unexpected call to method or property access\"\n// might be thrown when calling ctx.fill or ctx.stroke after a path\n// whose area size is zero is drawn and ctx.clip() is called and\n// shadowBlur is set. See #4572, #3112, #5777.\n// (e.g.,\n//  ctx.moveTo(10, 10);\n//  ctx.lineTo(20, 10);\n//  ctx.closePath();\n//  ctx.clip();\n//  ctx.shadowBlur = 10;\n//  ...\n//  ctx.fill();\n// )\n\nvar shadowTemp = [\n    ['shadowBlur', 0],\n    ['shadowColor', '#000'],\n    ['shadowOffsetX', 0],\n    ['shadowOffsetY', 0]\n];\n\nvar fixClipWithShadow = function (orignalBrush) {\n\n    // version string can be: '11.0'\n    return (env$1.browser.ie && env$1.browser.version >= 11)\n\n        ? function () {\n            var clipPaths = this.__clipPaths;\n            var style = this.style;\n            var modified;\n\n            if (clipPaths) {\n                for (var i = 0; i < clipPaths.length; i++) {\n                    var clipPath = clipPaths[i];\n                    var shape = clipPath && clipPath.shape;\n                    var type = clipPath && clipPath.type;\n\n                    if (shape && (\n                        (type === 'sector' && shape.startAngle === shape.endAngle)\n                        || (type === 'rect' && (!shape.width || !shape.height))\n                    )) {\n                        for (var j = 0; j < shadowTemp.length; j++) {\n                            // It is save to put shadowTemp static, because shadowTemp\n                            // will be all modified each item brush called.\n                            shadowTemp[j][2] = style[shadowTemp[j][0]];\n                            style[shadowTemp[j][0]] = shadowTemp[j][1];\n                        }\n                        modified = true;\n                        break;\n                    }\n                }\n            }\n\n            orignalBrush.apply(this, arguments);\n\n            if (modified) {\n                for (var j = 0; j < shadowTemp.length; j++) {\n                    style[shadowTemp[j][0]] = shadowTemp[j][2];\n                }\n            }\n        }\n\n        : orignalBrush;\n};\n\n/**\n * \n * @module zrender/graphic/shape/Sector\n */\n\nvar Sector = Path.extend({\n\n    type: 'sector',\n\n    shape: {\n\n        cx: 0,\n\n        cy: 0,\n\n        r0: 0,\n\n        r: 0,\n\n        startAngle: 0,\n\n        endAngle: Math.PI * 2,\n\n        clockwise: true\n    },\n\n    brush: fixClipWithShadow(Path.prototype.brush),\n\n    buildPath: function (ctx, shape) {\n\n        var x = shape.cx;\n        var y = shape.cy;\n        var r0 = Math.max(shape.r0 || 0, 0);\n        var r = Math.max(shape.r, 0);\n        var startAngle = shape.startAngle;\n        var endAngle = shape.endAngle;\n        var clockwise = shape.clockwise;\n\n        var unitX = Math.cos(startAngle);\n        var unitY = Math.sin(startAngle);\n\n        ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n        ctx.lineTo(unitX * r + x, unitY * r + y);\n\n        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n        ctx.lineTo(\n            Math.cos(endAngle) * r0 + x,\n            Math.sin(endAngle) * r0 + y\n        );\n\n        if (r0 !== 0) {\n            ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n        }\n\n        ctx.closePath();\n    }\n});\n\n/**\n * \n * @module zrender/graphic/shape/Ring\n */\n\nvar Ring = Path.extend({\n\n    type: 'ring',\n\n    shape: {\n        cx: 0,\n        cy: 0,\n        r: 0,\n        r0: 0\n    },\n\n    buildPath: function (ctx, shape) {\n        var x = shape.cx;\n        var y = shape.cy;\n        var PI2 = Math.PI * 2;\n        ctx.moveTo(x + shape.r, y);\n        ctx.arc(x, y, shape.r, 0, PI2, false);\n        ctx.moveTo(x + shape.r0, y);\n        ctx.arc(x, y, shape.r0, 0, PI2, true);\n    }\n});\n\n/**\n * Catmull-Rom spline \n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n/**\n * @inner\n */\nfunction interpolate(p0, p1, p2, p3, t, t2, t3) {\n    var v0 = (p2 - p0) * 0.5;\n    var v1 = (p3 - p1) * 0.5;\n    return (2 * (p1 - p2) + v0 + v1) * t3\n            + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n            + v0 * t + p1;\n}\n\n/**\n * @alias module:zrender/shape/util/smoothSpline\n * @param {Array} points \n * @param {boolean} isLoop\n * @return {Array}\n */\nvar smoothSpline = function (points, isLoop) {\n    var len$$1 = points.length;\n    var ret = [];\n\n    var distance$$1 = 0;\n    for (var i = 1; i < len$$1; i++) {\n        distance$$1 += distance(points[i - 1], points[i]);\n    }\n\n    var segs = distance$$1 / 2;\n    segs = segs < len$$1 ? len$$1 : segs;\n    for (var i = 0; i < segs; i++) {\n        var pos = i / (segs - 1) * (isLoop ? len$$1 : len$$1 - 1);\n        var idx = Math.floor(pos);\n\n        var w = pos - idx;\n\n        var p0;\n        var p1 = points[idx % len$$1];\n        var p2;\n        var p3;\n        if (!isLoop) {\n            p0 = points[idx === 0 ? idx : idx - 1];\n            p2 = points[idx > len$$1 - 2 ? len$$1 - 1 : idx + 1];\n            p3 = points[idx > len$$1 - 3 ? len$$1 - 1 : idx + 2];\n        }\n        else {\n            p0 = points[(idx - 1 + len$$1) % len$$1];\n            p2 = points[(idx + 1) % len$$1];\n            p3 = points[(idx + 2) % len$$1];\n        }\n\n        var w2 = w * w;\n        var w3 = w * w2;\n\n        ret.push([\n            interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n            interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n        ]);\n    }\n    return ret;\n};\n\n/**\n * \n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n/**\n * \n * @alias module:zrender/shape/util/smoothBezier\n * @param {Array} points \n * @param {number} smooth , 0-1\n * @param {boolean} isLoop\n * @param {Array} constraint \n *                            [[0, 0], [100, 100]], \n *                           \n * @param {Array} \n */\nvar smoothBezier = function (points, smooth, isLoop, constraint) {\n    var cps = [];\n\n    var v = [];\n    var v1 = [];\n    var v2 = [];\n    var prevPoint;\n    var nextPoint;\n\n    var min$$1, max$$1;\n    if (constraint) {\n        min$$1 = [Infinity, Infinity];\n        max$$1 = [-Infinity, -Infinity];\n        for (var i = 0, len$$1 = points.length; i < len$$1; i++) {\n            min(min$$1, min$$1, points[i]);\n            max(max$$1, max$$1, points[i]);\n        }\n        // \n        min(min$$1, min$$1, constraint[0]);\n        max(max$$1, max$$1, constraint[1]);\n    }\n\n    for (var i = 0, len$$1 = points.length; i < len$$1; i++) {\n        var point = points[i];\n\n        if (isLoop) {\n            prevPoint = points[i ? i - 1 : len$$1 - 1];\n            nextPoint = points[(i + 1) % len$$1];\n        }\n        else {\n            if (i === 0 || i === len$$1 - 1) {\n                cps.push(clone$1(points[i]));\n                continue;\n            }\n            else {\n                prevPoint = points[i - 1];\n                nextPoint = points[i + 1];\n            }\n        }\n\n        sub(v, nextPoint, prevPoint);\n\n        // use degree to scale the handle length\n        scale(v, v, smooth);\n\n        var d0 = distance(point, prevPoint);\n        var d1 = distance(point, nextPoint);\n        var sum = d0 + d1;\n        if (sum !== 0) {\n            d0 /= sum;\n            d1 /= sum;\n        }\n\n        scale(v1, v, -d0);\n        scale(v2, v, d1);\n        var cp0 = add([], point, v1);\n        var cp1 = add([], point, v2);\n        if (constraint) {\n            max(cp0, cp0, min$$1);\n            min(cp0, cp0, max$$1);\n            max(cp1, cp1, min$$1);\n            min(cp1, cp1, max$$1);\n        }\n        cps.push(cp0);\n        cps.push(cp1);\n    }\n\n    if (isLoop) {\n        cps.push(cps.shift());\n    }\n\n    return cps;\n};\n\nfunction buildPath$1(ctx, shape, closePath) {\n    var points = shape.points;\n    var smooth = shape.smooth;\n    if (points && points.length >= 2) {\n        if (smooth && smooth !== 'spline') {\n            var controlPoints = smoothBezier(\n                points, smooth, closePath, shape.smoothConstraint\n            );\n\n            ctx.moveTo(points[0][0], points[0][1]);\n            var len = points.length;\n            for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                var cp1 = controlPoints[i * 2];\n                var cp2 = controlPoints[i * 2 + 1];\n                var p = points[(i + 1) % len];\n                ctx.bezierCurveTo(\n                    cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                );\n            }\n        }\n        else {\n            if (smooth === 'spline') {\n                points = smoothSpline(points, closePath);\n            }\n\n            ctx.moveTo(points[0][0], points[0][1]);\n            for (var i = 1, l = points.length; i < l; i++) {\n                ctx.lineTo(points[i][0], points[i][1]);\n            }\n        }\n\n        closePath && ctx.closePath();\n    }\n}\n\n/**\n * \n * @module zrender/shape/Polygon\n */\n\nvar Polygon = Path.extend({\n\n    type: 'polygon',\n\n    shape: {\n        points: null,\n\n        smooth: false,\n\n        smoothConstraint: null\n    },\n\n    buildPath: function (ctx, shape) {\n        buildPath$1(ctx, shape, true);\n    }\n});\n\n/**\n * @module zrender/graphic/shape/Polyline\n */\n\nvar Polyline = Path.extend({\n\n    type: 'polyline',\n\n    shape: {\n        points: null,\n\n        smooth: false,\n\n        smoothConstraint: null\n    },\n\n    style: {\n        stroke: '#000',\n\n        fill: null\n    },\n\n    buildPath: function (ctx, shape) {\n        buildPath$1(ctx, shape, false);\n    }\n});\n\n/**\n * \n * @module zrender/graphic/shape/Rect\n */\n\nvar Rect = Path.extend({\n\n    type: 'rect',\n\n    shape: {\n        // r1r2r3r4\n        // r1          [1, 1, 1, 1]\n        // r[1]        [1, 1, 1, 1]\n        // r[1, 2]     [1, 2, 1, 2]\n        // r[1, 2, 3]  [1, 2, 3, 2]\n        r: 0,\n\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n    },\n\n    buildPath: function (ctx, shape) {\n        var x = shape.x;\n        var y = shape.y;\n        var width = shape.width;\n        var height = shape.height;\n        if (!shape.r) {\n            ctx.rect(x, y, width, height);\n        }\n        else {\n            buildPath(ctx, shape);\n        }\n        ctx.closePath();\n        return;\n    }\n});\n\n/**\n * \n * @module zrender/graphic/shape/Line\n */\n\nvar Line = Path.extend({\n\n    type: 'line',\n\n    shape: {\n        // Start point\n        x1: 0,\n        y1: 0,\n        // End point\n        x2: 0,\n        y2: 0,\n\n        percent: 1\n    },\n\n    style: {\n        stroke: '#000',\n        fill: null\n    },\n\n    buildPath: function (ctx, shape) {\n        var x1 = shape.x1;\n        var y1 = shape.y1;\n        var x2 = shape.x2;\n        var y2 = shape.y2;\n        var percent = shape.percent;\n\n        if (percent === 0) {\n            return;\n        }\n\n        ctx.moveTo(x1, y1);\n\n        if (percent < 1) {\n            x2 = x1 * (1 - percent) + x2 * percent;\n            y2 = y1 * (1 - percent) + y2 * percent;\n        }\n        ctx.lineTo(x2, y2);\n    },\n\n    /**\n     * Get point at percent\n     * @param  {number} percent\n     * @return {Array.<number>}\n     */\n    pointAt: function (p) {\n        var shape = this.shape;\n        return [\n            shape.x1 * (1 - p) + shape.x2 * p,\n            shape.y1 * (1 - p) + shape.y2 * p\n        ];\n    }\n});\n\n/**\n * \n * @module zrender/shape/BezierCurve\n */\n\nvar out = [];\n\nfunction someVectorAt(shape, t, isTangent) {\n    var cpx2 = shape.cpx2;\n    var cpy2 = shape.cpy2;\n    if (cpx2 === null || cpy2 === null) {\n        return [\n            (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n            (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n        ];\n    }\n    else {\n        return [\n            (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n            (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n        ];\n    }\n}\n\nvar BezierCurve = Path.extend({\n\n    type: 'bezier-curve',\n\n    shape: {\n        x1: 0,\n        y1: 0,\n        x2: 0,\n        y2: 0,\n        cpx1: 0,\n        cpy1: 0,\n        // cpx2: 0,\n        // cpy2: 0\n\n        // Curve show percent, for animating\n        percent: 1\n    },\n\n    style: {\n        stroke: '#000',\n        fill: null\n    },\n\n    buildPath: function (ctx, shape) {\n        var x1 = shape.x1;\n        var y1 = shape.y1;\n        var x2 = shape.x2;\n        var y2 = shape.y2;\n        var cpx1 = shape.cpx1;\n        var cpy1 = shape.cpy1;\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        var percent = shape.percent;\n        if (percent === 0) {\n            return;\n        }\n\n        ctx.moveTo(x1, y1);\n\n        if (cpx2 == null || cpy2 == null) {\n            if (percent < 1) {\n                quadraticSubdivide(\n                    x1, cpx1, x2, percent, out\n                );\n                cpx1 = out[1];\n                x2 = out[2];\n                quadraticSubdivide(\n                    y1, cpy1, y2, percent, out\n                );\n                cpy1 = out[1];\n                y2 = out[2];\n            }\n\n            ctx.quadraticCurveTo(\n                cpx1, cpy1,\n                x2, y2\n            );\n        }\n        else {\n            if (percent < 1) {\n                cubicSubdivide(\n                    x1, cpx1, cpx2, x2, percent, out\n                );\n                cpx1 = out[1];\n                cpx2 = out[2];\n                x2 = out[3];\n                cubicSubdivide(\n                    y1, cpy1, cpy2, y2, percent, out\n                );\n                cpy1 = out[1];\n                cpy2 = out[2];\n                y2 = out[3];\n            }\n            ctx.bezierCurveTo(\n                cpx1, cpy1,\n                cpx2, cpy2,\n                x2, y2\n            );\n        }\n    },\n\n    /**\n     * Get point at percent\n     * @param  {number} t\n     * @return {Array.<number>}\n     */\n    pointAt: function (t) {\n        return someVectorAt(this.shape, t, false);\n    },\n\n    /**\n     * Get tangent at percent\n     * @param  {number} t\n     * @return {Array.<number>}\n     */\n    tangentAt: function (t) {\n        var p = someVectorAt(this.shape, t, true);\n        return normalize(p, p);\n    }\n});\n\n/**\n * \n * @module zrender/graphic/shape/Arc\n */\n\nvar Arc = Path.extend({\n\n    type: 'arc',\n\n    shape: {\n\n        cx: 0,\n\n        cy: 0,\n\n        r: 0,\n\n        startAngle: 0,\n\n        endAngle: Math.PI * 2,\n\n        clockwise: true\n    },\n\n    style: {\n\n        stroke: '#000',\n\n        fill: null\n    },\n\n    buildPath: function (ctx, shape) {\n\n        var x = shape.cx;\n        var y = shape.cy;\n        var r = Math.max(shape.r, 0);\n        var startAngle = shape.startAngle;\n        var endAngle = shape.endAngle;\n        var clockwise = shape.clockwise;\n\n        var unitX = Math.cos(startAngle);\n        var unitY = Math.sin(startAngle);\n\n        ctx.moveTo(unitX * r + x, unitY * r + y);\n        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n    }\n});\n\n// CompoundPath to improve performance\n\nvar CompoundPath = Path.extend({\n\n    type: 'compound',\n\n    shape: {\n\n        paths: null\n    },\n\n    _updatePathDirty: function () {\n        var dirtyPath = this.__dirtyPath;\n        var paths = this.shape.paths;\n        for (var i = 0; i < paths.length; i++) {\n            // Mark as dirty if any subpath is dirty\n            dirtyPath = dirtyPath || paths[i].__dirtyPath;\n        }\n        this.__dirtyPath = dirtyPath;\n        this.__dirty = this.__dirty || dirtyPath;\n    },\n\n    beforeBrush: function () {\n        this._updatePathDirty();\n        var paths = this.shape.paths || [];\n        var scale = this.getGlobalScale();\n        // Update path scale\n        for (var i = 0; i < paths.length; i++) {\n            if (!paths[i].path) {\n                paths[i].createPathProxy();\n            }\n            paths[i].path.setScale(scale[0], scale[1]);\n        }\n    },\n\n    buildPath: function (ctx, shape) {\n        var paths = shape.paths || [];\n        for (var i = 0; i < paths.length; i++) {\n            paths[i].buildPath(ctx, paths[i].shape, true);\n        }\n    },\n\n    afterBrush: function () {\n        var paths = this.shape.paths || [];\n        for (var i = 0; i < paths.length; i++) {\n            paths[i].__dirtyPath = false;\n        }\n    },\n\n    getBoundingRect: function () {\n        this._updatePathDirty();\n        return Path.prototype.getBoundingRect.call(this);\n    }\n});\n\n/**\n * @param {Array.<Object>} colorStops\n */\nvar Gradient = function (colorStops) {\n\n    this.colorStops = colorStops || [];\n\n};\n\nGradient.prototype = {\n\n    constructor: Gradient,\n\n    addColorStop: function (offset, color) {\n        this.colorStops.push({\n\n            offset: offset,\n\n            color: color\n        });\n    }\n\n};\n\n/**\n * x, y, x2, y2 are all percent from 0 to 1\n * @param {number} [x=0]\n * @param {number} [y=0]\n * @param {number} [x2=1]\n * @param {number} [y2=0]\n * @param {Array.<Object>} colorStops\n * @param {boolean} [globalCoord=false]\n */\nvar LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n    // Should do nothing more in this constructor. Because gradient can be\n    // declard by `color: {type: 'linear', colorStops: ...}`, where\n    // this constructor will not be called.\n\n    this.x = x == null ? 0 : x;\n\n    this.y = y == null ? 0 : y;\n\n    this.x2 = x2 == null ? 1 : x2;\n\n    this.y2 = y2 == null ? 0 : y2;\n\n    // Can be cloned\n    this.type = 'linear';\n\n    // If use global coord\n    this.global = globalCoord || false;\n\n    Gradient.call(this, colorStops);\n};\n\nLinearGradient.prototype = {\n\n    constructor: LinearGradient\n};\n\ninherits(LinearGradient, Gradient);\n\n/**\n * x, y, r are all percent from 0 to 1\n * @param {number} [x=0.5]\n * @param {number} [y=0.5]\n * @param {number} [r=0.5]\n * @param {Array.<Object>} [colorStops]\n * @param {boolean} [globalCoord=false]\n */\nvar RadialGradient = function (x, y, r, colorStops, globalCoord) {\n    // Should do nothing more in this constructor. Because gradient can be\n    // declard by `color: {type: 'radial', colorStops: ...}`, where\n    // this constructor will not be called.\n\n    this.x = x == null ? 0.5 : x;\n\n    this.y = y == null ? 0.5 : y;\n\n    this.r = r == null ? 0.5 : r;\n\n    // Can be cloned\n    this.type = 'radial';\n\n    // If use global coord\n    this.global = globalCoord || false;\n\n    Gradient.call(this, colorStops);\n};\n\nRadialGradient.prototype = {\n\n    constructor: RadialGradient\n};\n\ninherits(RadialGradient, Gradient);\n\nvar round$1 = Math.round;\nvar mathMax$1 = Math.max;\nvar mathMin$1 = Math.min;\n\nvar EMPTY_OBJ = {};\n\n/**\n * Extend shape with parameters\n */\nfunction extendShape(opts) {\n    return Path.extend(opts);\n}\n\n/**\n * Extend path\n */\nfunction extendPath(pathData, opts) {\n    return extendFromString(pathData, opts);\n}\n\n/**\n * Create a path element from path data string\n * @param {string} pathData\n * @param {Object} opts\n * @param {module:zrender/core/BoundingRect} rect\n * @param {string} [layout=cover] 'center' or 'cover'\n */\nfunction makePath(pathData, opts, rect, layout) {\n    var path = createFromString(pathData, opts);\n    var boundingRect = path.getBoundingRect();\n    if (rect) {\n        if (layout === 'center') {\n            rect = centerGraphic(rect, boundingRect);\n        }\n\n        resizePath(path, rect);\n    }\n    return path;\n}\n\n/**\n * Create a image element from image url\n * @param {string} imageUrl image url\n * @param {Object} opts options\n * @param {module:zrender/core/BoundingRect} rect constrain rect\n * @param {string} [layout=cover] 'center' or 'cover'\n */\nfunction makeImage(imageUrl, rect, layout) {\n    var path = new ZImage({\n        style: {\n            image: imageUrl,\n            x: rect.x,\n            y: rect.y,\n            width: rect.width,\n            height: rect.height\n        },\n        onload: function (img) {\n            if (layout === 'center') {\n                var boundingRect = {\n                    width: img.width,\n                    height: img.height\n                };\n                path.setStyle(centerGraphic(rect, boundingRect));\n            }\n        }\n    });\n    return path;\n}\n\n/**\n * Get position of centered element in bounding box.\n *\n * @param  {Object} rect         element local bounding box\n * @param  {Object} boundingRect constraint bounding box\n * @return {Object} element position containing x, y, width, and height\n */\nfunction centerGraphic(rect, boundingRect) {\n    // Set rect to center, keep width / height ratio.\n    var aspect = boundingRect.width / boundingRect.height;\n    var width = rect.height * aspect;\n    var height;\n    if (width <= rect.width) {\n        height = rect.height;\n    }\n    else {\n        width = rect.width;\n        height = width / aspect;\n    }\n    var cx = rect.x + rect.width / 2;\n    var cy = rect.y + rect.height / 2;\n\n    return {\n        x: cx - width / 2,\n        y: cy - height / 2,\n        width: width,\n        height: height\n    };\n}\n\nvar mergePath = mergePath$1;\n\n/**\n * Resize a path to fit the rect\n * @param {module:zrender/graphic/Path} path\n * @param {Object} rect\n */\nfunction resizePath(path, rect) {\n    if (!path.applyTransform) {\n        return;\n    }\n\n    var pathRect = path.getBoundingRect();\n\n    var m = pathRect.calculateTransform(rect);\n\n    path.applyTransform(m);\n}\n\n/**\n * Sub pixel optimize line for canvas\n *\n * @param {Object} param\n * @param {Object} [param.shape]\n * @param {number} [param.shape.x1]\n * @param {number} [param.shape.y1]\n * @param {number} [param.shape.x2]\n * @param {number} [param.shape.y2]\n * @param {Object} [param.style]\n * @param {number} [param.style.lineWidth]\n * @return {Object} Modified param\n */\nfunction subPixelOptimizeLine(param) {\n    var shape = param.shape;\n    var lineWidth = param.style.lineWidth;\n\n    if (round$1(shape.x1 * 2) === round$1(shape.x2 * 2)) {\n        shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n    }\n    if (round$1(shape.y1 * 2) === round$1(shape.y2 * 2)) {\n        shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n    }\n    return param;\n}\n\n/**\n * Sub pixel optimize rect for canvas\n *\n * @param {Object} param\n * @param {Object} [param.shape]\n * @param {number} [param.shape.x]\n * @param {number} [param.shape.y]\n * @param {number} [param.shape.width]\n * @param {number} [param.shape.height]\n * @param {Object} [param.style]\n * @param {number} [param.style.lineWidth]\n * @return {Object} Modified param\n */\nfunction subPixelOptimizeRect(param) {\n    var shape = param.shape;\n    var lineWidth = param.style.lineWidth;\n    var originX = shape.x;\n    var originY = shape.y;\n    var originWidth = shape.width;\n    var originHeight = shape.height;\n    shape.x = subPixelOptimize(shape.x, lineWidth, true);\n    shape.y = subPixelOptimize(shape.y, lineWidth, true);\n    shape.width = Math.max(\n        subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n        originWidth === 0 ? 0 : 1\n    );\n    shape.height = Math.max(\n        subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n        originHeight === 0 ? 0 : 1\n    );\n    return param;\n}\n\n/**\n * Sub pixel optimize for canvas\n *\n * @param {number} position Coordinate, such as x, y\n * @param {number} lineWidth Should be nonnegative integer.\n * @param {boolean=} positiveOrNegative Default false (negative).\n * @return {number} Optimized position.\n */\nfunction subPixelOptimize(position, lineWidth, positiveOrNegative) {\n    // Assure that (position + lineWidth / 2) is near integer edge,\n    // otherwise line will be fuzzy in canvas.\n    var doubledPosition = round$1(position * 2);\n    return (doubledPosition + round$1(lineWidth)) % 2 === 0\n        ? doubledPosition / 2\n        : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n}\n\nfunction hasFillOrStroke(fillOrStroke) {\n    return fillOrStroke != null && fillOrStroke != 'none';\n}\n\nfunction liftColor(color) {\n    return typeof color === 'string' ? lift(color, -0.1) : color;\n}\n\n/**\n * @private\n */\nfunction cacheElementStl(el) {\n    if (el.__hoverStlDirty) {\n        var stroke = el.style.stroke;\n        var fill = el.style.fill;\n\n        // Create hoverStyle on mouseover\n        var hoverStyle = el.__hoverStl;\n        hoverStyle.fill = hoverStyle.fill\n            || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n        hoverStyle.stroke = hoverStyle.stroke\n            || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\n        var normalStyle = {};\n        for (var name in hoverStyle) {\n            // See comment in `doSingleEnterHover`.\n            if (hoverStyle[name] != null) {\n                normalStyle[name] = el.style[name];\n            }\n        }\n\n        el.__normalStl = normalStyle;\n\n        el.__hoverStlDirty = false;\n    }\n}\n\n/**\n * @private\n */\nfunction doSingleEnterHover(el) {\n    if (el.__isHover) {\n        return;\n    }\n\n    cacheElementStl(el);\n\n    if (el.useHoverLayer) {\n        el.__zr && el.__zr.addHover(el, el.__hoverStl);\n    }\n    else {\n        var style = el.style;\n        var insideRollbackOpt = style.insideRollbackOpt;\n\n        // Consider case: only `position: 'top'` is set on emphasis, then text\n        // color should be returned to `autoColor`, rather than remain '#fff'.\n        // So we should rollback then apply again after style merging.\n        insideRollbackOpt && rollbackInsideStyle(style);\n\n        // styles can be:\n        // {\n        //     label: {\n        //         normal: {\n        //             show: false,\n        //             position: 'outside',\n        //             fontSize: 18\n        //         },\n        //         emphasis: {\n        //             show: true\n        //         }\n        //     }\n        // },\n        // where properties of `emphasis` may not appear in `normal`. We previously use\n        // module:echarts/util/model#defaultEmphasis to merge `normal` to `emphasis`.\n        // But consider rich text and setOption in merge mode, it is impossible to cover\n        // all properties in merge. So we use merge mode when setting style here, where\n        // only properties that is not `null/undefined` can be set. The disadventage:\n        // null/undefined can not be used to remove style any more in `emphasis`.\n        style.extendFrom(el.__hoverStl);\n\n        // Do not save `insideRollback`.\n        if (insideRollbackOpt) {\n            applyInsideStyle(style, style.insideOriginalTextPosition, insideRollbackOpt);\n\n            // textFill may be rollbacked to null.\n            if (style.textFill == null) {\n                style.textFill = insideRollbackOpt.autoColor;\n            }\n        }\n\n        el.dirty(false);\n        el.z2 += 1;\n    }\n\n    el.__isHover = true;\n}\n\n/**\n * @inner\n */\nfunction doSingleLeaveHover(el) {\n    if (!el.__isHover) {\n        return;\n    }\n\n    var normalStl = el.__normalStl;\n    if (el.useHoverLayer) {\n        el.__zr && el.__zr.removeHover(el);\n    }\n    else {\n        // Consider null/undefined value, should use\n        // `setStyle` but not `extendFrom(stl, true)`.\n        normalStl && el.setStyle(normalStl);\n        el.z2 -= 1;\n    }\n\n    el.__isHover = false;\n}\n\n/**\n * @inner\n */\nfunction doEnterHover(el) {\n    el.type === 'group'\n        ? el.traverse(function (child) {\n            if (child.type !== 'group') {\n                doSingleEnterHover(child);\n            }\n        })\n        : doSingleEnterHover(el);\n}\n\nfunction doLeaveHover(el) {\n    el.type === 'group'\n        ? el.traverse(function (child) {\n            if (child.type !== 'group') {\n                doSingleLeaveHover(child);\n            }\n        })\n        : doSingleLeaveHover(el);\n}\n\n/**\n * @inner\n */\nfunction setElementHoverStl(el, hoverStl) {\n    // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n    // Often used when item group has a label element and it's hoverStyle is different\n    el.__hoverStl = el.hoverStyle || hoverStl || {};\n    el.__hoverStlDirty = true;\n\n    if (el.__isHover) {\n        cacheElementStl(el);\n    }\n}\n\n/**\n * @inner\n */\nfunction onElementMouseOver(e) {\n    if (this.__hoverSilentOnTouch && e.zrByTouch) {\n        return;\n    }\n\n    // Only if element is not in emphasis status\n    !this.__isEmphasis && doEnterHover(this);\n}\n\n/**\n * @inner\n */\nfunction onElementMouseOut(e) {\n    if (this.__hoverSilentOnTouch && e.zrByTouch) {\n        return;\n    }\n\n    // Only if element is not in emphasis status\n    !this.__isEmphasis && doLeaveHover(this);\n}\n\n/**\n * @inner\n */\nfunction enterEmphasis() {\n    this.__isEmphasis = true;\n    doEnterHover(this);\n}\n\n/**\n * @inner\n */\nfunction leaveEmphasis() {\n    this.__isEmphasis = false;\n    doLeaveHover(this);\n}\n\n/**\n * Set hover style of element.\n * This method can be called repeatly without side-effects.\n * @param {module:zrender/Element} el\n * @param {Object} [hoverStyle]\n * @param {Object} [opt]\n * @param {boolean} [opt.hoverSilentOnTouch=false]\n *        In touch device, mouseover event will be trigger on touchstart event\n *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n *        conviniently use hoverStyle when tap on touch screen without additional\n *        code for compatibility.\n *        But if the chart/component has select feature, which usually also use\n *        hoverStyle, there might be conflict between 'select-highlight' and\n *        'hover-highlight' especially when roam is enabled (see geo for example).\n *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n *        on touch device.\n */\nfunction setHoverStyle(el, hoverStyle, opt) {\n    el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n\n    el.type === 'group'\n        ? el.traverse(function (child) {\n            if (child.type !== 'group') {\n                setElementHoverStl(child, hoverStyle);\n            }\n        })\n        : setElementHoverStl(el, hoverStyle);\n\n    // Duplicated function will be auto-ignored, see Eventful.js.\n    el.on('mouseover', onElementMouseOver)\n        .on('mouseout', onElementMouseOut);\n\n    // Emphasis, normal can be triggered manually\n    el.on('emphasis', enterEmphasis)\n        .on('normal', leaveEmphasis);\n}\n\n/**\n * @param {Object|module:zrender/graphic/Style} normalStyle\n * @param {Object} emphasisStyle\n * @param {module:echarts/model/Model} normalModel\n * @param {module:echarts/model/Model} emphasisModel\n * @param {Object} opt Check `opt` of `setTextStyleCommon` to find other props.\n * @param {Object} [opt.defaultText]\n * @param {module:echarts/model/Model} [opt.labelFetcher] Fetch text by\n *      `opt.labelFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`\n * @param {module:echarts/model/Model} [opt.labelDataIndex] Fetch text by\n *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`\n * @param {module:echarts/model/Model} [opt.labelDimIndex] Fetch text by\n *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`\n * @param {Object} [normalSpecified]\n * @param {Object} [emphasisSpecified]\n */\nfunction setLabelStyle(\n    normalStyle, emphasisStyle,\n    normalModel, emphasisModel,\n    opt,\n    normalSpecified, emphasisSpecified\n) {\n    opt = opt || EMPTY_OBJ;\n    var labelFetcher = opt.labelFetcher;\n    var labelDataIndex = opt.labelDataIndex;\n    var labelDimIndex = opt.labelDimIndex;\n\n    // This scenario, `label.normal.show = true; label.emphasis.show = false`,\n    // is not supported util someone requests.\n\n    var showNormal = normalModel.getShallow('show');\n    var showEmphasis = emphasisModel.getShallow('show');\n\n    // Consider performance, only fetch label when necessary.\n    // If `normal.show` is `false` and `emphasis.show` is `true` and `emphasis.formatter` is not set,\n    // label should be displayed, where text is fetched by `normal.formatter` or `opt.defaultText`.\n    var baseText = (showNormal || showEmphasis)\n        ? retrieve2(\n            labelFetcher\n                ? labelFetcher.getFormattedLabel(labelDataIndex, 'normal', null, labelDimIndex)\n                : null,\n            opt.defaultText\n        )\n        : null;\n    var normalStyleText = showNormal ? baseText : null;\n    var emphasisStyleText = showEmphasis\n        ? retrieve2(\n            labelFetcher\n                ? labelFetcher.getFormattedLabel(labelDataIndex, 'emphasis', null, labelDimIndex)\n                : null,\n            baseText\n        )\n        : null;\n\n    // Optimize: If style.text is null, text will not be drawn.\n    if (normalStyleText != null || emphasisStyleText != null) {\n        // Always set `textStyle` even if `normalStyle.text` is null, because default\n        // values have to be set on `normalStyle`.\n        // If we set default values on `emphasisStyle`, consider case:\n        // Firstly, `setOption(... label: {normal: {text: null}, emphasis: {show: true}} ...);`\n        // Secondly, `setOption(... label: {noraml: {show: true, text: 'abc', color: 'red'} ...);`\n        // Then the 'red' will not work on emphasis.\n        setTextStyle(normalStyle, normalModel, normalSpecified, opt);\n        setTextStyle(emphasisStyle, emphasisModel, emphasisSpecified, opt, true);\n    }\n\n    normalStyle.text = normalStyleText;\n    emphasisStyle.text = emphasisStyleText;\n}\n\n/**\n * Set basic textStyle properties.\n * @param {Object|module:zrender/graphic/Style} textStyle\n * @param {module:echarts/model/Model} model\n * @param {Object} [specifiedTextStyle] Can be overrided by settings in model.\n * @param {Object} [opt] See `opt` of `setTextStyleCommon`.\n * @param {boolean} [isEmphasis]\n */\nfunction setTextStyle(\n    textStyle, textStyleModel, specifiedTextStyle, opt, isEmphasis\n) {\n    setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis);\n    specifiedTextStyle && extend(textStyle, specifiedTextStyle);\n    textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);\n\n    return textStyle;\n}\n\n/**\n * Set text option in the style.\n * @deprecated\n * @param {Object} textStyle\n * @param {module:echarts/model/Model} labelModel\n * @param {string|boolean} defaultColor Default text color.\n *        If set as false, it will be processed as a emphasis style.\n */\nfunction setText(textStyle, labelModel, defaultColor) {\n    var opt = {isRectText: true};\n    var isEmphasis;\n\n    if (defaultColor === false) {\n        isEmphasis = true;\n    }\n    else {\n        // Support setting color as 'auto' to get visual color.\n        opt.autoColor = defaultColor;\n    }\n    setTextStyleCommon(textStyle, labelModel, opt, isEmphasis);\n    textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);\n}\n\n/**\n * {\n *      disableBox: boolean, Whether diable drawing box of block (outer most).\n *      isRectText: boolean,\n *      autoColor: string, specify a color when color is 'auto',\n *              for textFill, textStroke, textBackgroundColor, and textBorderColor.\n *              If autoColor specified, it is used as default textFill.\n *      useInsideStyle:\n *              `true`: Use inside style (textFill, textStroke, textStrokeWidth)\n *                  if `textFill` is not specified.\n *              `false`: Do not use inside style.\n *              `null/undefined`: use inside style if `isRectText` is true and\n *                  `textFill` is not specified and textPosition contains `'inside'`.\n *      forceRich: boolean\n * }\n */\nfunction setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis) {\n    // Consider there will be abnormal when merge hover style to normal style if given default value.\n    opt = opt || EMPTY_OBJ;\n\n    if (opt.isRectText) {\n        var textPosition = textStyleModel.getShallow('position')\n            || (isEmphasis ? null : 'inside');\n        // 'outside' is not a valid zr textPostion value, but used\n        // in bar series, and magric type should be considered.\n        textPosition === 'outside' && (textPosition = 'top');\n        textStyle.textPosition = textPosition;\n        textStyle.textOffset = textStyleModel.getShallow('offset');\n        var labelRotate = textStyleModel.getShallow('rotate');\n        labelRotate != null && (labelRotate *= Math.PI / 180);\n        textStyle.textRotation = labelRotate;\n        textStyle.textDistance = retrieve2(\n            textStyleModel.getShallow('distance'), isEmphasis ? null : 5\n        );\n    }\n\n    var ecModel = textStyleModel.ecModel;\n    var globalTextStyle = ecModel && ecModel.option.textStyle;\n\n    // Consider case:\n    // {\n    //     data: [{\n    //         value: 12,\n    //         label: {\n    //             normal: {\n    //                 rich: {\n    //                     // no 'a' here but using parent 'a'.\n    //                 }\n    //             }\n    //         }\n    //     }],\n    //     rich: {\n    //         a: { ... }\n    //     }\n    // }\n    var richItemNames = getRichItemNames(textStyleModel);\n    var richResult;\n    if (richItemNames) {\n        richResult = {};\n        for (var name in richItemNames) {\n            if (richItemNames.hasOwnProperty(name)) {\n                // Cascade is supported in rich.\n                var richTextStyle = textStyleModel.getModel(['rich', name]);\n                // In rich, never `disableBox`.\n                setTokenTextStyle(richResult[name] = {}, richTextStyle, globalTextStyle, opt, isEmphasis);\n            }\n        }\n    }\n    textStyle.rich = richResult;\n\n    setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, true);\n\n    if (opt.forceRich && !opt.textStyle) {\n        opt.textStyle = {};\n    }\n\n    return textStyle;\n}\n\n// Consider case:\n// {\n//     data: [{\n//         value: 12,\n//         label: {\n//             normal: {\n//                 rich: {\n//                     // no 'a' here but using parent 'a'.\n//                 }\n//             }\n//         }\n//     }],\n//     rich: {\n//         a: { ... }\n//     }\n// }\nfunction getRichItemNames(textStyleModel) {\n    // Use object to remove duplicated names.\n    var richItemNameMap;\n    while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {\n        var rich = (textStyleModel.option || EMPTY_OBJ).rich;\n        if (rich) {\n            richItemNameMap = richItemNameMap || {};\n            for (var name in rich) {\n                if (rich.hasOwnProperty(name)) {\n                    richItemNameMap[name] = 1;\n                }\n            }\n        }\n        textStyleModel = textStyleModel.parentModel;\n    }\n    return richItemNameMap;\n}\n\nfunction setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, isBlock) {\n    // In merge mode, default value should not be given.\n    globalTextStyle = !isEmphasis && globalTextStyle || EMPTY_OBJ;\n\n    textStyle.textFill = getAutoColor(textStyleModel.getShallow('color'), opt)\n        || globalTextStyle.color;\n    textStyle.textStroke = getAutoColor(textStyleModel.getShallow('textBorderColor'), opt)\n        || globalTextStyle.textBorderColor;\n    textStyle.textStrokeWidth = retrieve2(\n        textStyleModel.getShallow('textBorderWidth'),\n        globalTextStyle.textBorderWidth\n    );\n\n    if (!isEmphasis) {\n        if (isBlock) {\n            // Always set `insideRollback`, for clearing previous.\n            var originalTextPosition = textStyle.textPosition;\n            textStyle.insideRollback = applyInsideStyle(textStyle, originalTextPosition, opt);\n            // Save original textPosition, because style.textPosition will be repalced by\n            // real location (like [10, 30]) in zrender.\n            textStyle.insideOriginalTextPosition = originalTextPosition;\n            textStyle.insideRollbackOpt = opt;\n        }\n\n        // Set default finally.\n        if (textStyle.textFill == null) {\n            textStyle.textFill = opt.autoColor;\n        }\n    }\n\n    // Do not use `getFont` here, because merge should be supported, where\n    // part of these properties may be changed in emphasis style, and the\n    // others should remain their original value got from normal style.\n    textStyle.fontStyle = textStyleModel.getShallow('fontStyle') || globalTextStyle.fontStyle;\n    textStyle.fontWeight = textStyleModel.getShallow('fontWeight') || globalTextStyle.fontWeight;\n    textStyle.fontSize = textStyleModel.getShallow('fontSize') || globalTextStyle.fontSize;\n    textStyle.fontFamily = textStyleModel.getShallow('fontFamily') || globalTextStyle.fontFamily;\n\n    textStyle.textAlign = textStyleModel.getShallow('align');\n    textStyle.textVerticalAlign = textStyleModel.getShallow('verticalAlign')\n        || textStyleModel.getShallow('baseline');\n\n    textStyle.textLineHeight = textStyleModel.getShallow('lineHeight');\n    textStyle.textWidth = textStyleModel.getShallow('width');\n    textStyle.textHeight = textStyleModel.getShallow('height');\n    textStyle.textTag = textStyleModel.getShallow('tag');\n\n    if (!isBlock || !opt.disableBox) {\n        textStyle.textBackgroundColor = getAutoColor(textStyleModel.getShallow('backgroundColor'), opt);\n        textStyle.textPadding = textStyleModel.getShallow('padding');\n        textStyle.textBorderColor = getAutoColor(textStyleModel.getShallow('borderColor'), opt);\n        textStyle.textBorderWidth = textStyleModel.getShallow('borderWidth');\n        textStyle.textBorderRadius = textStyleModel.getShallow('borderRadius');\n\n        textStyle.textBoxShadowColor = textStyleModel.getShallow('shadowColor');\n        textStyle.textBoxShadowBlur = textStyleModel.getShallow('shadowBlur');\n        textStyle.textBoxShadowOffsetX = textStyleModel.getShallow('shadowOffsetX');\n        textStyle.textBoxShadowOffsetY = textStyleModel.getShallow('shadowOffsetY');\n    }\n\n    textStyle.textShadowColor = textStyleModel.getShallow('textShadowColor')\n        || globalTextStyle.textShadowColor;\n    textStyle.textShadowBlur = textStyleModel.getShallow('textShadowBlur')\n        || globalTextStyle.textShadowBlur;\n    textStyle.textShadowOffsetX = textStyleModel.getShallow('textShadowOffsetX')\n        || globalTextStyle.textShadowOffsetX;\n    textStyle.textShadowOffsetY = textStyleModel.getShallow('textShadowOffsetY')\n        || globalTextStyle.textShadowOffsetY;\n}\n\nfunction getAutoColor(color, opt) {\n    return color !== 'auto' ? color : (opt && opt.autoColor) ? opt.autoColor : null;\n}\n\nfunction applyInsideStyle(textStyle, textPosition, opt) {\n    var useInsideStyle = opt.useInsideStyle;\n    var insideRollback;\n\n    if (textStyle.textFill == null\n        && useInsideStyle !== false\n        && (useInsideStyle === true\n            || (opt.isRectText\n                && textPosition\n                // textPosition can be [10, 30]\n                && typeof textPosition === 'string'\n                && textPosition.indexOf('inside') >= 0\n            )\n        )\n    ) {\n        insideRollback = {\n            textFill: null,\n            textStroke: textStyle.textStroke,\n            textStrokeWidth: textStyle.textStrokeWidth\n        };\n        textStyle.textFill = '#fff';\n        // Consider text with #fff overflow its container.\n        if (textStyle.textStroke == null) {\n            textStyle.textStroke = opt.autoColor;\n            textStyle.textStrokeWidth == null && (textStyle.textStrokeWidth = 2);\n        }\n    }\n\n    return insideRollback;\n}\n\nfunction rollbackInsideStyle(style) {\n    var insideRollback = style.insideRollback;\n    if (insideRollback) {\n        style.textFill = insideRollback.textFill;\n        style.textStroke = insideRollback.textStroke;\n        style.textStrokeWidth = insideRollback.textStrokeWidth;\n    }\n}\n\nfunction getFont(opt, ecModel) {\n    // ecModel or default text style model.\n    var gTextStyleModel = ecModel || ecModel.getModel('textStyle');\n    return [\n        // FIXME in node-canvas fontWeight is before fontStyle\n        opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '',\n        opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '',\n        (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px',\n        opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'\n    ].join(' ');\n}\n\nfunction animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n    if (typeof dataIndex === 'function') {\n        cb = dataIndex;\n        dataIndex = null;\n    }\n    // Do not check 'animation' property directly here. Consider this case:\n    // animation model is an `itemModel`, whose does not have `isAnimationEnabled`\n    // but its parent model (`seriesModel`) does.\n    var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\n    if (animationEnabled) {\n        var postfix = isUpdate ? 'Update' : '';\n        var duration = animatableModel.getShallow('animationDuration' + postfix);\n        var animationEasing = animatableModel.getShallow('animationEasing' + postfix);\n        var animationDelay = animatableModel.getShallow('animationDelay' + postfix);\n        if (typeof animationDelay === 'function') {\n            animationDelay = animationDelay(\n                dataIndex,\n                animatableModel.getAnimationDelayParams\n                    ? animatableModel.getAnimationDelayParams(el, dataIndex)\n                    : null\n            );\n        }\n        if (typeof duration === 'function') {\n            duration = duration(dataIndex);\n        }\n\n        duration > 0\n            ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb, !!cb)\n            : (el.stopAnimation(), el.attr(props), cb && cb());\n    }\n    else {\n        el.stopAnimation();\n        el.attr(props);\n        cb && cb();\n    }\n}\n\n/**\n * Update graphic element properties with or without animation according to the\n * configuration in series.\n *\n * Caution: this method will stop previous animation.\n * So if do not use this method to one element twice before\n * animation starts, unless you know what you are doing.\n *\n * @param {module:zrender/Element} el\n * @param {Object} props\n * @param {module:echarts/model/Model} [animatableModel]\n * @param {number} [dataIndex]\n * @param {Function} [cb]\n * @example\n *     graphic.updateProps(el, {\n *         position: [100, 100]\n *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n *     // Or\n *     graphic.updateProps(el, {\n *         position: [100, 100]\n *     }, seriesModel, function () { console.log('Animation done!'); });\n */\nfunction updateProps(el, props, animatableModel, dataIndex, cb) {\n    animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n}\n\n/**\n * Init graphic element properties with or without animation according to the\n * configuration in series.\n *\n * Caution: this method will stop previous animation.\n * So if do not use this method to one element twice before\n * animation starts, unless you know what you are doing.\n *\n * @param {module:zrender/Element} el\n * @param {Object} props\n * @param {module:echarts/model/Model} [animatableModel]\n * @param {number} [dataIndex]\n * @param {Function} cb\n */\nfunction initProps(el, props, animatableModel, dataIndex, cb) {\n    animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n}\n\n/**\n * Get transform matrix of target (param target),\n * in coordinate of its ancestor (param ancestor)\n *\n * @param {module:zrender/mixin/Transformable} target\n * @param {module:zrender/mixin/Transformable} [ancestor]\n */\nfunction getTransform(target, ancestor) {\n    var mat = identity([]);\n\n    while (target && target !== ancestor) {\n        mul$1(mat, target.getLocalTransform(), mat);\n        target = target.parent;\n    }\n\n    return mat;\n}\n\n/**\n * Apply transform to an vertex.\n * @param {Array.<number>} target [x, y]\n * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:\n *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\n *      + {position, rotation, scale}, the same as `zrender/Transformable`.\n * @param {boolean=} invert Whether use invert matrix.\n * @return {Array.<number>} [x, y]\n */\nfunction applyTransform$1(target, transform, invert$$1) {\n    if (transform && !isArrayLike(transform)) {\n        transform = Transformable.getLocalTransform(transform);\n    }\n\n    if (invert$$1) {\n        transform = invert([], transform);\n    }\n    return applyTransform([], target, transform);\n}\n\n/**\n * @param {string} direction 'left' 'right' 'top' 'bottom'\n * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n * @param {boolean=} invert Whether use invert matrix.\n * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n */\nfunction transformDirection(direction, transform, invert$$1) {\n\n    // Pick a base, ensure that transform result will not be (0, 0).\n    var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n        ? 1 : Math.abs(2 * transform[4] / transform[0]);\n    var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n        ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\n    var vertex = [\n        direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n        direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n    ];\n\n    vertex = applyTransform$1(vertex, transform, invert$$1);\n\n    return Math.abs(vertex[0]) > Math.abs(vertex[1])\n        ? (vertex[0] > 0 ? 'right' : 'left')\n        : (vertex[1] > 0 ? 'bottom' : 'top');\n}\n\n/**\n * Apply group transition animation from g1 to g2.\n * If no animatableModel, no animation.\n */\nfunction groupTransition(g1, g2, animatableModel, cb) {\n    if (!g1 || !g2) {\n        return;\n    }\n\n    function getElMap(g) {\n        var elMap = {};\n        g.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                elMap[el.anid] = el;\n            }\n        });\n        return elMap;\n    }\n    function getAnimatableProps(el) {\n        var obj = {\n            position: clone$1(el.position),\n            rotation: el.rotation\n        };\n        if (el.shape) {\n            obj.shape = extend({}, el.shape);\n        }\n        return obj;\n    }\n    var elMap1 = getElMap(g1);\n\n    g2.traverse(function (el) {\n        if (!el.isGroup && el.anid) {\n            var oldEl = elMap1[el.anid];\n            if (oldEl) {\n                var newProp = getAnimatableProps(el);\n                el.attr(getAnimatableProps(oldEl));\n                updateProps(el, newProp, animatableModel, el.dataIndex);\n            }\n            // else {\n            //     if (el.previousProps) {\n            //         graphic.updateProps\n            //     }\n            // }\n        }\n    });\n}\n\n/**\n * @param {Array.<Array.<number>>} points Like: [[23, 44], [53, 66], ...]\n * @param {Object} rect {x, y, width, height}\n * @return {Array.<Array.<number>>} A new clipped points.\n */\nfunction clipPointsByRect(points, rect) {\n    return map(points, function (point) {\n        var x = point[0];\n        x = mathMax$1(x, rect.x);\n        x = mathMin$1(x, rect.x + rect.width);\n        var y = point[1];\n        y = mathMax$1(y, rect.y);\n        y = mathMin$1(y, rect.y + rect.height);\n        return [x, y];\n    });\n}\n\n/**\n * @param {Object} targetRect {x, y, width, height}\n * @param {Object} rect {x, y, width, height}\n * @return {Object} A new clipped rect. If rect size are negative, return undefined.\n */\nfunction clipRectByRect(targetRect, rect) {\n    var x = mathMax$1(targetRect.x, rect.x);\n    var x2 = mathMin$1(targetRect.x + targetRect.width, rect.x + rect.width);\n    var y = mathMax$1(targetRect.y, rect.y);\n    var y2 = mathMin$1(targetRect.y + targetRect.height, rect.y + rect.height);\n\n    if (x2 >= x && y2 >= y) {\n        return {\n            x: x,\n            y: y,\n            width: x2 - x,\n            height: y2 - y\n        };\n    }\n}\n\n/**\n * @param {string} iconStr Support 'image://' or 'path://' or direct svg path.\n * @param {Object} [opt] Properties of `module:zrender/Element`, except `style`.\n * @param {Object} [rect] {x, y, width, height}\n * @return {module:zrender/Element} Icon path or image element.\n */\nfunction createIcon(iconStr, opt, rect) {\n    opt = extend({rectHover: true}, opt);\n    var style = opt.style = {strokeNoScale: true};\n    rect = rect || {x: -1, y: -1, width: 2, height: 2};\n\n    if (iconStr) {\n        return iconStr.indexOf('image://') === 0\n            ? (\n                style.image = iconStr.slice(8),\n                defaults(style, rect),\n                new ZImage(opt)\n            )\n            : (\n                makePath(\n                    iconStr.replace('path://', ''),\n                    opt,\n                    rect,\n                    'center'\n                )\n            );\n    }\n}\n\n\n\n\nvar graphic = (Object.freeze || Object)({\n\textendShape: extendShape,\n\textendPath: extendPath,\n\tmakePath: makePath,\n\tmakeImage: makeImage,\n\tmergePath: mergePath,\n\tresizePath: resizePath,\n\tsubPixelOptimizeLine: subPixelOptimizeLine,\n\tsubPixelOptimizeRect: subPixelOptimizeRect,\n\tsubPixelOptimize: subPixelOptimize,\n\tsetHoverStyle: setHoverStyle,\n\tsetLabelStyle: setLabelStyle,\n\tsetTextStyle: setTextStyle,\n\tsetText: setText,\n\tgetFont: getFont,\n\tupdateProps: updateProps,\n\tinitProps: initProps,\n\tgetTransform: getTransform,\n\tapplyTransform: applyTransform$1,\n\ttransformDirection: transformDirection,\n\tgroupTransition: groupTransition,\n\tclipPointsByRect: clipPointsByRect,\n\tclipRectByRect: clipRectByRect,\n\tcreateIcon: createIcon,\n\tGroup: Group,\n\tImage: ZImage,\n\tText: Text,\n\tCircle: Circle,\n\tSector: Sector,\n\tRing: Ring,\n\tPolygon: Polygon,\n\tPolyline: Polyline,\n\tRect: Rect,\n\tLine: Line,\n\tBezierCurve: BezierCurve,\n\tArc: Arc,\n\tCompoundPath: CompoundPath,\n\tLinearGradient: LinearGradient,\n\tRadialGradient: RadialGradient,\n\tBoundingRect: BoundingRect\n});\n\nvar PATH_COLOR = ['textStyle', 'color'];\n\nvar textStyleMixin = {\n    /**\n     * Get color property or get color from option.textStyle.color\n     * @param {boolean} [isEmphasis]\n     * @return {string}\n     */\n    getTextColor: function (isEmphasis) {\n        var ecModel = this.ecModel;\n        return this.getShallow('color')\n            || (\n                (!isEmphasis && ecModel) ? ecModel.get(PATH_COLOR) : null\n            );\n    },\n\n    /**\n     * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n     * @return {string}\n     */\n    getFont: function () {\n        return getFont({\n            fontStyle: this.getShallow('fontStyle'),\n            fontWeight: this.getShallow('fontWeight'),\n            fontSize: this.getShallow('fontSize'),\n            fontFamily: this.getShallow('fontFamily')\n        }, this.ecModel);\n    },\n\n    getTextRect: function (text) {\n        return getBoundingRect(\n            text,\n            this.getFont(),\n            this.getShallow('align'),\n            this.getShallow('verticalAlign') || this.getShallow('baseline'),\n            this.getShallow('padding'),\n            this.getShallow('rich'),\n            this.getShallow('truncateText')\n        );\n    }\n};\n\nvar getItemStyle = makeStyleMapper(\n    [\n        ['fill', 'color'],\n        ['stroke', 'borderColor'],\n        ['lineWidth', 'borderWidth'],\n        ['opacity'],\n        ['shadowBlur'],\n        ['shadowOffsetX'],\n        ['shadowOffsetY'],\n        ['shadowColor'],\n        ['textPosition'],\n        ['textAlign']\n    ]\n);\n\nvar itemStyleMixin = {\n    getItemStyle: function (excludes, includes) {\n        var style = getItemStyle(this, excludes, includes);\n        var lineDash = this.getBorderLineDash();\n        lineDash && (style.lineDash = lineDash);\n        return style;\n    },\n\n    getBorderLineDash: function () {\n        var lineType = this.get('borderType');\n        return (lineType === 'solid' || lineType == null) ? null\n            : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n    }\n};\n\n/**\n * @module echarts/model/Model\n */\n\nvar mixin$1 = mixin;\n\n/**\n * @alias module:echarts/model/Model\n * @constructor\n * @param {Object} option\n * @param {module:echarts/model/Model} [parentModel]\n * @param {module:echarts/model/Global} [ecModel]\n */\nfunction Model(option, parentModel, ecModel) {\n    /**\n     * @type {module:echarts/model/Model}\n     * @readOnly\n     */\n    this.parentModel = parentModel;\n\n    /**\n     * @type {module:echarts/model/Global}\n     * @readOnly\n     */\n    this.ecModel = ecModel;\n\n    /**\n     * @type {Object}\n     * @protected\n     */\n    this.option = option;\n\n    // Simple optimization\n    // if (this.init) {\n    //     if (arguments.length <= 4) {\n    //         this.init(option, parentModel, ecModel, extraOpt);\n    //     }\n    //     else {\n    //         this.init.apply(this, arguments);\n    //     }\n    // }\n}\n\nModel.prototype = {\n\n    constructor: Model,\n\n    /**\n     * Model \n     * @param {Object} option\n     */\n    init: null,\n\n    /**\n     *  Option merge\n     */\n    mergeOption: function (option) {\n        merge(this.option, option, true);\n    },\n\n    /**\n     * @param {string|Array.<string>} path\n     * @param {boolean} [ignoreParent=false]\n     * @return {*}\n     */\n    get: function (path, ignoreParent) {\n        if (path == null) {\n            return this.option;\n        }\n\n        return doGet(\n            this.option,\n            this.parsePath(path),\n            !ignoreParent && getParent(this, path)\n        );\n    },\n\n    /**\n     * @param {string} key\n     * @param {boolean} [ignoreParent=false]\n     * @return {*}\n     */\n    getShallow: function (key, ignoreParent) {\n        var option = this.option;\n\n        var val = option == null ? option : option[key];\n        var parentModel = !ignoreParent && getParent(this, key);\n        if (val == null && parentModel) {\n            val = parentModel.getShallow(key);\n        }\n        return val;\n    },\n\n    /**\n     * @param {string|Array.<string>} [path]\n     * @param {module:echarts/model/Model} [parentModel]\n     * @return {module:echarts/model/Model}\n     */\n    getModel: function (path, parentModel) {\n        var obj = path == null\n            ? this.option\n            : doGet(this.option, path = this.parsePath(path));\n\n        var thisParentModel;\n        parentModel = parentModel || (\n            (thisParentModel = getParent(this, path))\n                && thisParentModel.getModel(path)\n        );\n\n        return new Model(obj, parentModel, this.ecModel);\n    },\n\n    /**\n     * If model has option\n     */\n    isEmpty: function () {\n        return this.option == null;\n    },\n\n    restoreData: function () {},\n\n    // Pending\n    clone: function () {\n        var Ctor = this.constructor;\n        return new Ctor(clone(this.option));\n    },\n\n    setReadOnly: function (properties) {\n        \n    },\n\n    // If path is null/undefined, return null/undefined.\n    parsePath: function(path) {\n        if (typeof path === 'string') {\n            path = path.split('.');\n        }\n        return path;\n    },\n\n    /**\n     * @param {Function} getParentMethod\n     *        param {Array.<string>|string} path\n     *        return {module:echarts/model/Model}\n     */\n    customizeGetParent: function (getParentMethod) {\n        set$1(this, 'getParent', getParentMethod);\n    },\n\n    isAnimationEnabled: function () {\n        if (!env$1.node) {\n            if (this.option.animation != null) {\n                return !!this.option.animation;\n            }\n            else if (this.parentModel) {\n                return this.parentModel.isAnimationEnabled();\n            }\n        }\n    }\n};\n\nfunction doGet(obj, pathArr, parentModel) {\n    for (var i = 0; i < pathArr.length; i++) {\n        // Ignore empty\n        if (!pathArr[i]) {\n            continue;\n        }\n        // obj could be number/string/... (like 0)\n        obj = (obj && typeof obj === 'object') ? obj[pathArr[i]] : null;\n        if (obj == null) {\n            break;\n        }\n    }\n    if (obj == null && parentModel) {\n        obj = parentModel.get(pathArr);\n    }\n    return obj;\n}\n\n// `path` can be null/undefined\nfunction getParent(model, path) {\n    var getParentMethod = get(model, 'getParent');\n    return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;\n}\n\n// Enable Model.extend.\nenableClassExtend(Model);\n\nmixin$1(Model, lineStyleMixin);\nmixin$1(Model, areaStyleMixin);\nmixin$1(Model, textStyleMixin);\nmixin$1(Model, itemStyleMixin);\n\nvar each$3 = each$1;\nvar isObject$2 = isObject;\n\n/**\n * If value is not array, then translate it to array.\n * @param  {*} value\n * @return {Array} [value] or value\n */\nfunction normalizeToArray(value) {\n    return value instanceof Array\n        ? value\n        : value == null\n        ? []\n        : [value];\n}\n\n/**\n * Sync default option between normal and emphasis like `position` and `show`\n * In case some one will write code like\n *     label: {\n *         normal: {\n *             show: false,\n *             position: 'outside',\n *             fontSize: 18\n *         },\n *         emphasis: {\n *             show: true\n *         }\n *     }\n * @param {Object} opt\n * @param {Array.<string>} subOpts\n */\nfunction defaultEmphasis(opt, subOpts) {\n    if (opt) {\n        var emphasisOpt = opt.emphasis = opt.emphasis || {};\n        var normalOpt = opt.normal = opt.normal || {};\n\n        // Default emphasis option from normal\n        for (var i = 0, len = subOpts.length; i < len; i++) {\n            var subOptName = subOpts[i];\n            if (!emphasisOpt.hasOwnProperty(subOptName)\n                && normalOpt.hasOwnProperty(subOptName)\n            ) {\n                emphasisOpt[subOptName] = normalOpt[subOptName];\n            }\n        }\n    }\n}\n\nvar TEXT_STYLE_OPTIONS = [\n    'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',\n    'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth',\n    'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline',\n    'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY',\n    'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY',\n    'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding'\n];\n\n// modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([\n//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',\n//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',\n//     // FIXME: deprecated, check and remove it.\n//     'textStyle'\n// ]);\n\n/**\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method retieves value from data.\n * @param {string|number|Date|Array|Object} dataItem\n * @return {number|string|Date|Array.<number|string|Date>}\n */\nfunction getDataItemValue(dataItem) {\n    // Performance sensitive.\n    return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n}\n\n/**\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method determine if dataItem has extra option besides value\n * @param {string|number|Date|Array|Object} dataItem\n */\nfunction isDataItemOption(dataItem) {\n    return isObject$2(dataItem)\n        && !(dataItem instanceof Array);\n        // // markLine data can be array\n        // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n}\n\n/**\n * This helper method convert value in data.\n * @param {string|number|Date} value\n * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n */\nfunction converDataValue(value, dimInfo) {\n    // Performance sensitive.\n    var dimType = dimInfo && dimInfo.type;\n    if (dimType === 'ordinal') {\n        return value;\n    }\n\n    if (dimType === 'time'\n        // spead up when using timestamp\n        && typeof value !== 'number'\n        && value != null\n        && value !== '-'\n    ) {\n        value = +parseDate(value);\n    }\n\n    // dimType defaults 'number'.\n    // If dimType is not ordinal and value is null or undefined or NaN or '-',\n    // parse to NaN.\n    return (value == null || value === '')\n        ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n}\n\n/**\n * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n * @param {module:echarts/data/List} data\n * @param {Object} opt\n * @param {string} [opt.seriesIndex]\n * @param {Object} [opt.name]\n * @param {Object} [opt.mainType]\n * @param {Object} [opt.subType]\n */\n\n\n// PENDING A little ugly\nvar dataFormatMixin = {\n    /**\n     * Get params for formatter\n     * @param {number} dataIndex\n     * @param {string} [dataType]\n     * @return {Object}\n     */\n    getDataParams: function (dataIndex, dataType) {\n        var data = this.getData(dataType);\n        var rawValue = this.getRawValue(dataIndex, dataType);\n        var rawDataIndex = data.getRawIndex(dataIndex);\n        var name = data.getName(dataIndex, true);\n        var itemOpt = data.getRawDataItem(dataIndex);\n        var color = data.getItemVisual(dataIndex, 'color');\n\n        return {\n            componentType: this.mainType,\n            componentSubType: this.subType,\n            seriesType: this.mainType === 'series' ? this.subType : null,\n            seriesIndex: this.seriesIndex,\n            seriesId: this.id,\n            seriesName: this.name,\n            name: name,\n            dataIndex: rawDataIndex,\n            data: itemOpt,\n            dataType: dataType,\n            value: rawValue,\n            color: color,\n            marker: getTooltipMarker(color),\n\n            // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n            $vars: ['seriesName', 'name', 'value']\n        };\n    },\n\n    /**\n     * Format label\n     * @param {number} dataIndex\n     * @param {string} [status='normal'] 'normal' or 'emphasis'\n     * @param {string} [dataType]\n     * @param {number} [dimIndex]\n     * @param {string} [labelProp='label']\n     * @return {string}\n     */\n    getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) {\n        status = status || 'normal';\n        var data = this.getData(dataType);\n        var itemModel = data.getItemModel(dataIndex);\n\n        var params = this.getDataParams(dataIndex, dataType);\n        if (dimIndex != null && (params.value instanceof Array)) {\n            params.value = params.value[dimIndex];\n        }\n\n        var formatter = itemModel.get([labelProp || 'label', status, 'formatter']);\n\n        if (typeof formatter === 'function') {\n            params.status = status;\n            return formatter(params);\n        }\n        else if (typeof formatter === 'string') {\n            return formatTpl(formatter, params);\n        }\n    },\n\n    /**\n     * Get raw value in option\n     * @param {number} idx\n     * @param {string} [dataType]\n     * @return {Object}\n     */\n    getRawValue: function (idx, dataType) {\n        var data = this.getData(dataType);\n        var dataItem = data.getRawDataItem(idx);\n        if (dataItem != null) {\n            return (isObject$2(dataItem) && !(dataItem instanceof Array))\n                ? dataItem.value : dataItem;\n        }\n    },\n\n    /**\n     * Should be implemented.\n     * @param {number} dataIndex\n     * @param {boolean} [multipleSeries=false]\n     * @param {number} [dataType]\n     * @return {string} tooltip string\n     */\n    formatTooltip: noop\n};\n\n/**\n * Mapping to exists for merge.\n *\n * @public\n * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n * @param {Object|Array.<Object>} newCptOptions\n * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n *                          index of which is the same as exists.\n */\nfunction mappingToExists(exists, newCptOptions) {\n    // Mapping by the order by original option (but not order of\n    // new option) in merge mode. Because we should ensure\n    // some specified index (like xAxisIndex) is consistent with\n    // original option, which is easy to understand, espatially in\n    // media query. And in most case, merge option is used to\n    // update partial option but not be expected to change order.\n    newCptOptions = (newCptOptions || []).slice();\n\n    var result = map(exists || [], function (obj, index) {\n        return {exist: obj};\n    });\n\n    // Mapping by id or name if specified.\n    each$3(newCptOptions, function (cptOption, index) {\n        if (!isObject$2(cptOption)) {\n            return;\n        }\n\n        // id has highest priority.\n        for (var i = 0; i < result.length; i++) {\n            if (!result[i].option // Consider name: two map to one.\n                && cptOption.id != null\n                && result[i].exist.id === cptOption.id + ''\n            ) {\n                result[i].option = cptOption;\n                newCptOptions[index] = null;\n                return;\n            }\n        }\n\n        for (var i = 0; i < result.length; i++) {\n            var exist = result[i].exist;\n            if (!result[i].option // Consider name: two map to one.\n                // Can not match when both ids exist but different.\n                && (exist.id == null || cptOption.id == null)\n                && cptOption.name != null\n                && !isIdInner(cptOption)\n                && !isIdInner(exist)\n                && exist.name === cptOption.name + ''\n            ) {\n                result[i].option = cptOption;\n                newCptOptions[index] = null;\n                return;\n            }\n        }\n    });\n\n    // Otherwise mapping by index.\n    each$3(newCptOptions, function (cptOption, index) {\n        if (!isObject$2(cptOption)) {\n            return;\n        }\n\n        var i = 0;\n        for (; i < result.length; i++) {\n            var exist = result[i].exist;\n            if (!result[i].option\n                // Existing model that already has id should be able to\n                // mapped to (because after mapping performed model may\n                // be assigned with a id, whish should not affect next\n                // mapping), except those has inner id.\n                && !isIdInner(exist)\n                // Caution:\n                // Do not overwrite id. But name can be overwritten,\n                // because axis use name as 'show label text'.\n                // 'exist' always has id and name and we dont\n                // need to check it.\n                && cptOption.id == null\n            ) {\n                result[i].option = cptOption;\n                break;\n            }\n        }\n\n        if (i >= result.length) {\n            result.push({option: cptOption});\n        }\n    });\n\n    return result;\n}\n\n/**\n * Make id and name for mapping result (result of mappingToExists)\n * into `keyInfo` field.\n *\n * @public\n * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n *                          which order is the same as exists.\n * @return {Array.<Object>} The input.\n */\nfunction makeIdAndName(mapResult) {\n    // We use this id to hash component models and view instances\n    // in echarts. id can be specified by user, or auto generated.\n\n    // The id generation rule ensures new view instance are able\n    // to mapped to old instance when setOption are called in\n    // no-merge mode. So we generate model id by name and plus\n    // type in view id.\n\n    // name can be duplicated among components, which is convenient\n    // to specify multi components (like series) by one name.\n\n    // Ensure that each id is distinct.\n    var idMap = createHashMap();\n\n    each$3(mapResult, function (item, index) {\n        var existCpt = item.exist;\n        existCpt && idMap.set(existCpt.id, item);\n    });\n\n    each$3(mapResult, function (item, index) {\n        var opt = item.option;\n\n        assert(\n            !opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item,\n            'id duplicates: ' + (opt && opt.id)\n        );\n\n        opt && opt.id != null && idMap.set(opt.id, item);\n        !item.keyInfo && (item.keyInfo = {});\n    });\n\n    // Make name and id.\n    each$3(mapResult, function (item, index) {\n        var existCpt = item.exist;\n        var opt = item.option;\n        var keyInfo = item.keyInfo;\n\n        if (!isObject$2(opt)) {\n            return;\n        }\n\n        // name can be overwitten. Consider case: axis.name = '20km'.\n        // But id generated by name will not be changed, which affect\n        // only in that case: setOption with 'not merge mode' and view\n        // instance will be recreated, which can be accepted.\n        keyInfo.name = opt.name != null\n            ? opt.name + ''\n            : existCpt\n            ? existCpt.name\n            : '\\0-'; // name may be displayed on screen, so use '-'.\n\n        if (existCpt) {\n            keyInfo.id = existCpt.id;\n        }\n        else if (opt.id != null) {\n            keyInfo.id = opt.id + '';\n        }\n        else {\n            // Consider this situatoin:\n            //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n            //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n            // Series with the same name between optionA and optionB\n            // should be mapped.\n            var idNum = 0;\n            do {\n                keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n            }\n            while (idMap.get(keyInfo.id));\n        }\n\n        idMap.set(keyInfo.id, item);\n    });\n}\n\n/**\n * @public\n * @param {Object} cptOption\n * @return {boolean}\n */\nfunction isIdInner(cptOption) {\n    return isObject$2(cptOption)\n        && cptOption.id\n        && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n}\n\n/**\n * A helper for removing duplicate items between batchA and batchB,\n * and in themselves, and categorize by series.\n *\n * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n */\nfunction compressBatches(batchA, batchB) {\n    var mapA = {};\n    var mapB = {};\n\n    makeMap(batchA || [], mapA);\n    makeMap(batchB || [], mapB, mapA);\n\n    return [mapToArray(mapA), mapToArray(mapB)];\n\n    function makeMap(sourceBatch, map$$1, otherMap) {\n        for (var i = 0, len = sourceBatch.length; i < len; i++) {\n            var seriesId = sourceBatch[i].seriesId;\n            var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);\n            var otherDataIndices = otherMap && otherMap[seriesId];\n\n            for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                var dataIndex = dataIndices[j];\n\n                if (otherDataIndices && otherDataIndices[dataIndex]) {\n                    otherDataIndices[dataIndex] = null;\n                }\n                else {\n                    (map$$1[seriesId] || (map$$1[seriesId] = {}))[dataIndex] = 1;\n                }\n            }\n        }\n    }\n\n    function mapToArray(map$$1, isData) {\n        var result = [];\n        for (var i in map$$1) {\n            if (map$$1.hasOwnProperty(i) && map$$1[i] != null) {\n                if (isData) {\n                    result.push(+i);\n                }\n                else {\n                    var dataIndices = mapToArray(map$$1[i], true);\n                    dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n                }\n            }\n        }\n        return result;\n    }\n}\n\n/**\n * @param {module:echarts/data/List} data\n * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n *                         each of which can be Array or primary type.\n * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n */\nfunction queryDataIndex(data, payload) {\n    if (payload.dataIndexInside != null) {\n        return payload.dataIndexInside;\n    }\n    else if (payload.dataIndex != null) {\n        return isArray(payload.dataIndex)\n            ? map(payload.dataIndex, function (value) {\n                return data.indexOfRawIndex(value);\n            })\n            : data.indexOfRawIndex(payload.dataIndex);\n    }\n    else if (payload.name != null) {\n        return isArray(payload.name)\n            ? map(payload.name, function (value) {\n                return data.indexOfName(value);\n            })\n            : data.indexOfName(payload.name);\n    }\n}\n\n/**\n * Enable property storage to any host object.\n * Notice: Serialization is not supported.\n *\n * For example:\n * var get = modelUitl.makeGetter();\n *\n * function some(hostObj) {\n *      get(hostObj)._someProperty = 1212;\n *      ...\n * }\n *\n * @return {Function}\n */\nvar makeGetter = (function () {\n    var index = 0;\n    return function () {\n        var key = '\\0__ec_prop_getter_' + index++;\n        return function (hostObj) {\n            return hostObj[key] || (hostObj[key] = {});\n        };\n    };\n})();\n\n/**\n * @param {module:echarts/model/Global} ecModel\n * @param {string|Object} finder\n *        If string, e.g., 'geo', means {geoIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex, seriesId, seriesName,\n *            geoIndex, geoId, geoName,\n *            bmapIndex, bmapId, bmapName,\n *            xAxisIndex, xAxisId, xAxisName,\n *            yAxisIndex, yAxisId, yAxisName,\n *            gridIndex, gridId, gridName,\n *            ... (can be extended)\n *        }\n *        Each properties can be number|string|Array.<number>|Array.<string>\n *        For example, a finder could be\n *        {\n *            seriesIndex: 3,\n *            geoId: ['aa', 'cc'],\n *            gridName: ['xx', 'rr']\n *        }\n *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)\n *        If nothing or null/undefined specified, return nothing.\n * @param {Object} [opt]\n * @param {string} [opt.defaultMainType]\n * @param {Array.<string>} [opt.includeMainTypes]\n * @return {Object} result like:\n *        {\n *            seriesModels: [seriesModel1, seriesModel2],\n *            seriesModel: seriesModel1, // The first model\n *            geoModels: [geoModel1, geoModel2],\n *            geoModel: geoModel1, // The first model\n *            ...\n *        }\n */\nfunction parseFinder(ecModel, finder, opt) {\n    if (isString(finder)) {\n        var obj = {};\n        obj[finder + 'Index'] = 0;\n        finder = obj;\n    }\n\n    var defaultMainType = opt && opt.defaultMainType;\n    if (defaultMainType\n        && !has(finder, defaultMainType + 'Index')\n        && !has(finder, defaultMainType + 'Id')\n        && !has(finder, defaultMainType + 'Name')\n    ) {\n        finder[defaultMainType + 'Index'] = 0;\n    }\n\n    var result = {};\n\n    each$3(finder, function (value, key) {\n        var value = finder[key];\n\n        // Exclude 'dataIndex' and other illgal keys.\n        if (key === 'dataIndex' || key === 'dataIndexInside') {\n            result[key] = value;\n            return;\n        }\n\n        var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n        var mainType = parsedKey[1];\n        var queryType = (parsedKey[2] || '').toLowerCase();\n\n        if (!mainType\n            || !queryType\n            || value == null\n            || (queryType === 'index' && value === 'none')\n            || (opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0)\n        ) {\n            return;\n        }\n\n        var queryParam = {mainType: mainType};\n        if (queryType !== 'index' || value !== 'all') {\n            queryParam[queryType] = value;\n        }\n\n        var models = ecModel.queryComponents(queryParam);\n        result[mainType + 'Models'] = models;\n        result[mainType + 'Model'] = models[0];\n    });\n\n    return result;\n}\n\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n * @param {module:echarts/data/List} data\n * @param {string|number} dataDim\n * @return {string}\n */\nfunction dataDimToCoordDim(data, dataDim) {\n    var dimensions = data.dimensions;\n    dataDim = data.getDimension(dataDim);\n    for (var i = 0; i < dimensions.length; i++) {\n        var dimItem = data.getDimensionInfo(dimensions[i]);\n        if (dimItem.name === dataDim) {\n            return dimItem.coordDim;\n        }\n    }\n}\n\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n * @param {module:echarts/data/List} data\n * @param {string} coordDim\n * @return {Array.<string>} data dimensions on the coordDim.\n */\nfunction coordDimToDataDim(data, coordDim) {\n    var dataDim = [];\n    each$3(data.dimensions, function (dimName) {\n        var dimItem = data.getDimensionInfo(dimName);\n        if (dimItem.coordDim === coordDim) {\n            dataDim[dimItem.coordDimIndex] = dimItem.name;\n        }\n    });\n    return dataDim;\n}\n\n/**\n * @see {module:echarts/data/helper/completeDimensions}\n * @param {module:echarts/data/List} data\n * @param {string} otherDim Can be `otherDims`\n *                        like 'label' or 'tooltip'.\n * @return {Array.<string>} data dimensions on the otherDim.\n */\nfunction otherDimToDataDim(data, otherDim) {\n    var dataDim = [];\n    each$3(data.dimensions, function (dimName) {\n        var dimItem = data.getDimensionInfo(dimName);\n        var otherDims = dimItem.otherDims;\n        var dimIndex = otherDims[otherDim];\n        if (dimIndex != null && dimIndex !== false) {\n            dataDim[dimIndex] = dimItem.name;\n        }\n    });\n    return dataDim;\n}\n\nfunction has(obj, prop) {\n    return obj && obj.hasOwnProperty(prop);\n}\n\nvar base = 0;\n\nvar DELIMITER = '_';\n\n/**\n * @public\n * @param {string} type\n * @return {string}\n */\nfunction getUID(type) {\n    // Considering the case of crossing js context,\n    // use Math.random to make id as unique as possible.\n    return [(type || ''), base++, Math.random()].join(DELIMITER);\n}\n\n/**\n * @inner\n */\nfunction enableSubTypeDefaulter(entity) {\n\n    var subTypeDefaulters = {};\n\n    entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n        componentType = parseClassType$1(componentType);\n        subTypeDefaulters[componentType.main] = defaulter;\n    };\n\n    entity.determineSubType = function (componentType, option) {\n        var type = option.type;\n        if (!type) {\n            var componentTypeMain = parseClassType$1(componentType).main;\n            if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                type = subTypeDefaulters[componentTypeMain](option);\n            }\n        }\n        return type;\n    };\n\n    return entity;\n}\n\n/**\n * Topological travel on Activity Network (Activity On Vertices).\n * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n *\n * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n *\n * If there is circle dependencey, Error will be thrown.\n *\n */\nfunction enableTopologicalTravel(entity, dependencyGetter) {\n\n    /**\n     * @public\n     * @param {Array.<string>} targetNameList Target Component type list.\n     *                                           Can be ['aa', 'bb', 'aa.xx']\n     * @param {Array.<string>} fullNameList By which we can build dependency graph.\n     * @param {Function} callback Params: componentType, dependencies.\n     * @param {Object} context Scope of callback.\n     */\n    entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n        if (!targetNameList.length) {\n            return;\n        }\n\n        var result = makeDepndencyGraph(fullNameList);\n        var graph = result.graph;\n        var stack = result.noEntryList;\n\n        var targetNameSet = {};\n        each$1(targetNameList, function (name) {\n            targetNameSet[name] = true;\n        });\n\n        while (stack.length) {\n            var currComponentType = stack.pop();\n            var currVertex = graph[currComponentType];\n            var isInTargetNameSet = !!targetNameSet[currComponentType];\n            if (isInTargetNameSet) {\n                callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                delete targetNameSet[currComponentType];\n            }\n            each$1(\n                currVertex.successor,\n                isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n            );\n        }\n\n        each$1(targetNameSet, function () {\n            throw new Error('Circle dependency may exists');\n        });\n\n        function removeEdge(succComponentType) {\n            graph[succComponentType].entryCount--;\n            if (graph[succComponentType].entryCount === 0) {\n                stack.push(succComponentType);\n            }\n        }\n\n        // Consider this case: legend depends on series, and we call\n        // chart.setOption({series: [...]}), where only series is in option.\n        // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n        // not be called, but only sereis.mergeOption is called. Thus legend\n        // have no chance to update its local record about series (like which\n        // name of series is available in legend).\n        function removeEdgeAndAdd(succComponentType) {\n            targetNameSet[succComponentType] = true;\n            removeEdge(succComponentType);\n        }\n    };\n\n    /**\n     * DepndencyGraph: {Object}\n     * key: conponentType,\n     * value: {\n     *     successor: [conponentTypes...],\n     *     originalDeps: [conponentTypes...],\n     *     entryCount: {number}\n     * }\n     */\n    function makeDepndencyGraph(fullNameList) {\n        var graph = {};\n        var noEntryList = [];\n\n        each$1(fullNameList, function (name) {\n\n            var thisItem = createDependencyGraphItem(graph, name);\n            var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\n            var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n            thisItem.entryCount = availableDeps.length;\n            if (thisItem.entryCount === 0) {\n                noEntryList.push(name);\n            }\n\n            each$1(availableDeps, function (dependentName) {\n                if (indexOf(thisItem.predecessor, dependentName) < 0) {\n                    thisItem.predecessor.push(dependentName);\n                }\n                var thatItem = createDependencyGraphItem(graph, dependentName);\n                if (indexOf(thatItem.successor, dependentName) < 0) {\n                    thatItem.successor.push(name);\n                }\n            });\n        });\n\n        return {graph: graph, noEntryList: noEntryList};\n    }\n\n    function createDependencyGraphItem(graph, name) {\n        if (!graph[name]) {\n            graph[name] = {predecessor: [], successor: []};\n        }\n        return graph[name];\n    }\n\n    function getAvailableDependencies(originalDeps, fullNameList) {\n        var availableDeps = [];\n        each$1(originalDeps, function (dep) {\n            indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n        });\n        return availableDeps;\n    }\n}\n\n// Layout helpers for each component positioning\n\nvar each$4 = each$1;\n\n/**\n * @public\n */\nvar LOCATION_PARAMS = [\n    'left', 'right', 'top', 'bottom', 'width', 'height'\n];\n\n/**\n * @public\n */\nvar HV_NAMES = [\n    ['width', 'left', 'right'],\n    ['height', 'top', 'bottom']\n];\n\nfunction boxLayout(orient, group, gap, maxWidth, maxHeight) {\n    var x = 0;\n    var y = 0;\n\n    if (maxWidth == null) {\n        maxWidth = Infinity;\n    }\n    if (maxHeight == null) {\n        maxHeight = Infinity;\n    }\n    var currentLineMaxSize = 0;\n\n    group.eachChild(function (child, idx) {\n        var position = child.position;\n        var rect = child.getBoundingRect();\n        var nextChild = group.childAt(idx + 1);\n        var nextChildRect = nextChild && nextChild.getBoundingRect();\n        var nextX;\n        var nextY;\n\n        if (orient === 'horizontal') {\n            var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n            nextX = x + moveX;\n            // Wrap when width exceeds maxWidth or meet a `newline` group\n            // FIXME compare before adding gap?\n            if (nextX > maxWidth || child.newline) {\n                x = 0;\n                nextX = moveX;\n                y += currentLineMaxSize + gap;\n                currentLineMaxSize = rect.height;\n            }\n            else {\n                // FIXME: consider rect.y is not `0`?\n                currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n            }\n        }\n        else {\n            var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n            nextY = y + moveY;\n            // Wrap when width exceeds maxHeight or meet a `newline` group\n            if (nextY > maxHeight || child.newline) {\n                x += currentLineMaxSize + gap;\n                y = 0;\n                nextY = moveY;\n                currentLineMaxSize = rect.width;\n            }\n            else {\n                currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n            }\n        }\n\n        if (child.newline) {\n            return;\n        }\n\n        position[0] = x;\n        position[1] = y;\n\n        orient === 'horizontal'\n            ? (x = nextX + gap)\n            : (y = nextY + gap);\n    });\n}\n\n/**\n * VBox or HBox layouting\n * @param {string} orient\n * @param {module:zrender/container/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\nvar box = boxLayout;\n\n/**\n * VBox layouting\n * @param {module:zrender/container/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\nvar vbox = curry(boxLayout, 'vertical');\n\n/**\n * HBox layouting\n * @param {module:zrender/container/Group} group\n * @param {number} gap\n * @param {number} [width=Infinity]\n * @param {number} [height=Infinity]\n */\nvar hbox = curry(boxLayout, 'horizontal');\n\n/**\n * If x or x2 is not specified or 'center' 'left' 'right',\n * the width would be as long as possible.\n * If y or y2 is not specified or 'middle' 'top' 'bottom',\n * the height would be as long as possible.\n *\n * @param {Object} positionInfo\n * @param {number|string} [positionInfo.x]\n * @param {number|string} [positionInfo.y]\n * @param {number|string} [positionInfo.x2]\n * @param {number|string} [positionInfo.y2]\n * @param {Object} containerRect {width, height}\n * @param {string|number} margin\n * @return {Object} {width, height}\n */\nfunction getAvailableSize(positionInfo, containerRect, margin) {\n    var containerWidth = containerRect.width;\n    var containerHeight = containerRect.height;\n\n    var x = parsePercent$1(positionInfo.x, containerWidth);\n    var y = parsePercent$1(positionInfo.y, containerHeight);\n    var x2 = parsePercent$1(positionInfo.x2, containerWidth);\n    var y2 = parsePercent$1(positionInfo.y2, containerHeight);\n\n    (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n    (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n    (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n    (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\n    margin = normalizeCssArray$1(margin || 0);\n\n    return {\n        width: Math.max(x2 - x - margin[1] - margin[3], 0),\n        height: Math.max(y2 - y - margin[0] - margin[2], 0)\n    };\n}\n\n/**\n * Parse position info.\n *\n * @param {Object} positionInfo\n * @param {number|string} [positionInfo.left]\n * @param {number|string} [positionInfo.top]\n * @param {number|string} [positionInfo.right]\n * @param {number|string} [positionInfo.bottom]\n * @param {number|string} [positionInfo.width]\n * @param {number|string} [positionInfo.height]\n * @param {number|string} [positionInfo.aspect] Aspect is width / height\n * @param {Object} containerRect\n * @param {string|number} [margin]\n *\n * @return {module:zrender/core/BoundingRect}\n */\nfunction getLayoutRect(\n    positionInfo, containerRect, margin\n) {\n    margin = normalizeCssArray$1(margin || 0);\n\n    var containerWidth = containerRect.width;\n    var containerHeight = containerRect.height;\n\n    var left = parsePercent$1(positionInfo.left, containerWidth);\n    var top = parsePercent$1(positionInfo.top, containerHeight);\n    var right = parsePercent$1(positionInfo.right, containerWidth);\n    var bottom = parsePercent$1(positionInfo.bottom, containerHeight);\n    var width = parsePercent$1(positionInfo.width, containerWidth);\n    var height = parsePercent$1(positionInfo.height, containerHeight);\n\n    var verticalMargin = margin[2] + margin[0];\n    var horizontalMargin = margin[1] + margin[3];\n    var aspect = positionInfo.aspect;\n\n    // If width is not specified, calculate width from left and right\n    if (isNaN(width)) {\n        width = containerWidth - right - horizontalMargin - left;\n    }\n    if (isNaN(height)) {\n        height = containerHeight - bottom - verticalMargin - top;\n    }\n\n    if (aspect != null) {\n        // If width and height are not given\n        // 1. Graph should not exceeds the container\n        // 2. Aspect must be keeped\n        // 3. Graph should take the space as more as possible\n        // FIXME\n        // Margin is not considered, because there is no case that both\n        // using margin and aspect so far.\n        if (isNaN(width) && isNaN(height)) {\n            if (aspect > containerWidth / containerHeight) {\n                width = containerWidth * 0.8;\n            }\n            else {\n                height = containerHeight * 0.8;\n            }\n        }\n\n        // Calculate width or height with given aspect\n        if (isNaN(width)) {\n            width = aspect * height;\n        }\n        if (isNaN(height)) {\n            height = width / aspect;\n        }\n    }\n\n    // If left is not specified, calculate left from right and width\n    if (isNaN(left)) {\n        left = containerWidth - right - width - horizontalMargin;\n    }\n    if (isNaN(top)) {\n        top = containerHeight - bottom - height - verticalMargin;\n    }\n\n    // Align left and top\n    switch (positionInfo.left || positionInfo.right) {\n        case 'center':\n            left = containerWidth / 2 - width / 2 - margin[3];\n            break;\n        case 'right':\n            left = containerWidth - width - horizontalMargin;\n            break;\n    }\n    switch (positionInfo.top || positionInfo.bottom) {\n        case 'middle':\n        case 'center':\n            top = containerHeight / 2 - height / 2 - margin[0];\n            break;\n        case 'bottom':\n            top = containerHeight - height - verticalMargin;\n            break;\n    }\n    // If something is wrong and left, top, width, height are calculated as NaN\n    left = left || 0;\n    top = top || 0;\n    if (isNaN(width)) {\n        // Width may be NaN if only one value is given except width\n        width = containerWidth - horizontalMargin - left - (right || 0);\n    }\n    if (isNaN(height)) {\n        // Height may be NaN if only one value is given except height\n        height = containerHeight - verticalMargin - top - (bottom || 0);\n    }\n\n    var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n    rect.margin = margin;\n    return rect;\n}\n\n\n/**\n * Position a zr element in viewport\n *  Group position is specified by either\n *  {left, top}, {right, bottom}\n *  If all properties exists, right and bottom will be igonred.\n *\n * Logic:\n *     1. Scale (against origin point in parent coord)\n *     2. Rotate (against origin point in parent coord)\n *     3. Traslate (with el.position by this method)\n * So this method only fixes the last step 'Traslate', which does not affect\n * scaling and rotating.\n *\n * If be called repeatly with the same input el, the same result will be gotten.\n *\n * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n * @param {Object} positionInfo\n * @param {number|string} [positionInfo.left]\n * @param {number|string} [positionInfo.top]\n * @param {number|string} [positionInfo.right]\n * @param {number|string} [positionInfo.bottom]\n * @param {number|string} [positionInfo.width] Only for opt.boundingModel: 'raw'\n * @param {number|string} [positionInfo.height] Only for opt.boundingModel: 'raw'\n * @param {Object} containerRect\n * @param {string|number} margin\n * @param {Object} [opt]\n * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n * @param {Array.<number>} [opt.boundingMode='all']\n *        Specify how to calculate boundingRect when locating.\n *        'all': Position the boundingRect that is transformed and uioned\n *               both itself and its descendants.\n *               This mode simplies confine the elements in the bounding\n *               of their container (e.g., using 'right: 0').\n *        'raw': Position the boundingRect that is not transformed and only itself.\n *               This mode is useful when you want a element can overflow its\n *               container. (Consider a rotated circle needs to be located in a corner.)\n *               In this mode positionInfo.width/height can only be number.\n */\nfunction positionElement(el, positionInfo, containerRect, margin, opt) {\n    var h = !opt || !opt.hv || opt.hv[0];\n    var v = !opt || !opt.hv || opt.hv[1];\n    var boundingMode = opt && opt.boundingMode || 'all';\n\n    if (!h && !v) {\n        return;\n    }\n\n    var rect;\n    if (boundingMode === 'raw') {\n        rect = el.type === 'group'\n            ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\n            : el.getBoundingRect();\n    }\n    else {\n        rect = el.getBoundingRect();\n        if (el.needLocalTransform()) {\n            var transform = el.getLocalTransform();\n            // Notice: raw rect may be inner object of el,\n            // which should not be modified.\n            rect = rect.clone();\n            rect.applyTransform(transform);\n        }\n    }\n\n    // The real width and height can not be specified but calculated by the given el.\n    positionInfo = getLayoutRect(\n        defaults(\n            {width: rect.width, height: rect.height},\n            positionInfo\n        ),\n        containerRect,\n        margin\n    );\n\n    // Because 'tranlate' is the last step in transform\n    // (see zrender/core/Transformable#getLocalTransfrom),\n    // we can just only modify el.position to get final result.\n    var elPos = el.position;\n    var dx = h ? positionInfo.x - rect.x : 0;\n    var dy = v ? positionInfo.y - rect.y : 0;\n\n    el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n}\n\n/**\n * @param {Object} option Contains some of the properties in HV_NAMES.\n * @param {number} hvIdx 0: horizontal; 1: vertical.\n */\nfunction sizeCalculable(option, hvIdx) {\n    return option[HV_NAMES[hvIdx][0]] != null\n        || (option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null);\n}\n\n/**\n * Consider Case:\n * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n * through setOption or media query, using normal zrUtil.merge will cause\n * {right: 0} does not take effect.\n *\n * @example\n * ComponentModel.extend({\n *     init: function () {\n *         ...\n *         var inputPositionParams = layout.getLayoutParams(option);\n *         this.mergeOption(inputPositionParams);\n *     },\n *     mergeOption: function (newOption) {\n *         newOption && zrUtil.merge(thisOption, newOption, true);\n *         layout.mergeLayoutParam(thisOption, newOption);\n *     }\n * });\n *\n * @param {Object} targetOption\n * @param {Object} newOption\n * @param {Object|string} [opt]\n * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Used for the components\n *  that width (or height) should not be calculated by left and right (or top and bottom).\n */\nfunction mergeLayoutParam(targetOption, newOption, opt) {\n    !isObject(opt) && (opt = {});\n\n    var ignoreSize = opt.ignoreSize;\n    !isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n\n    var hResult = merge$$1(HV_NAMES[0], 0);\n    var vResult = merge$$1(HV_NAMES[1], 1);\n\n    copy(HV_NAMES[0], targetOption, hResult);\n    copy(HV_NAMES[1], targetOption, vResult);\n\n    function merge$$1(names, hvIdx) {\n        var newParams = {};\n        var newValueCount = 0;\n        var merged = {};\n        var mergedValueCount = 0;\n        var enoughParamNumber = 2;\n\n        each$4(names, function (name) {\n            merged[name] = targetOption[name];\n        });\n        each$4(names, function (name) {\n            // Consider case: newOption.width is null, which is\n            // set by user for removing width setting.\n            hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n            hasValue(newParams, name) && newValueCount++;\n            hasValue(merged, name) && mergedValueCount++;\n        });\n\n        if (ignoreSize[hvIdx]) {\n            // Only one of left/right is premitted to exist.\n            if (hasValue(newOption, names[1])) {\n                merged[names[2]] = null;\n            }\n            else if (hasValue(newOption, names[2])) {\n                merged[names[1]] = null;\n            }\n            return merged;\n        }\n\n        // Case: newOption: {width: ..., right: ...},\n        // or targetOption: {right: ...} and newOption: {width: ...},\n        // There is no conflict when merged only has params count\n        // little than enoughParamNumber.\n        if (mergedValueCount === enoughParamNumber || !newValueCount) {\n            return merged;\n        }\n        // Case: newOption: {width: ..., right: ...},\n        // Than we can make sure user only want those two, and ignore\n        // all origin params in targetOption.\n        else if (newValueCount >= enoughParamNumber) {\n            return newParams;\n        }\n        else {\n            // Chose another param from targetOption by priority.\n            for (var i = 0; i < names.length; i++) {\n                var name = names[i];\n                if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                    newParams[name] = targetOption[name];\n                    break;\n                }\n            }\n            return newParams;\n        }\n    }\n\n    function hasProp(obj, name) {\n        return obj.hasOwnProperty(name);\n    }\n\n    function hasValue(obj, name) {\n        return obj[name] != null && obj[name] !== 'auto';\n    }\n\n    function copy(names, target, source) {\n        each$4(names, function (name) {\n            target[name] = source[name];\n        });\n    }\n}\n\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n * @param {Object} source\n * @return {Object} Result contains those props.\n */\nfunction getLayoutParams(source) {\n    return copyLayoutParams({}, source);\n}\n\n/**\n * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n * @param {Object} source\n * @return {Object} Result contains those props.\n */\nfunction copyLayoutParams(target, source) {\n    source && target && each$4(LOCATION_PARAMS, function (name) {\n        source.hasOwnProperty(name) && (target[name] = source[name]);\n    });\n    return target;\n}\n\nvar boxLayoutMixin = {\n    getBoxLayoutParams: function () {\n        return {\n            left: this.get('left'),\n            top: this.get('top'),\n            right: this.get('right'),\n            bottom: this.get('bottom'),\n            width: this.get('width'),\n            height: this.get('height')\n        };\n    }\n};\n\n/**\n * Component model\n *\n * @module echarts/model/Component\n */\n\nvar arrayPush = Array.prototype.push;\n\n/**\n * @alias module:echarts/model/Component\n * @constructor\n * @param {Object} option\n * @param {module:echarts/model/Model} parentModel\n * @param {module:echarts/model/Model} ecModel\n */\nvar ComponentModel = Model.extend({\n\n    type: 'component',\n\n    /**\n     * @readOnly\n     * @type {string}\n     */\n    id: '',\n\n    /**\n     * @readOnly\n     */\n    name: '',\n\n    /**\n     * @readOnly\n     * @type {string}\n     */\n    mainType: '',\n\n    /**\n     * @readOnly\n     * @type {string}\n     */\n    subType: '',\n\n    /**\n     * @readOnly\n     * @type {number}\n     */\n    componentIndex: 0,\n\n    /**\n     * @type {Object}\n     * @protected\n     */\n    defaultOption: null,\n\n    /**\n     * @type {module:echarts/model/Global}\n     * @readOnly\n     */\n    ecModel: null,\n\n    /**\n     * key: componentType\n     * value:  Component model list, can not be null.\n     * @type {Object.<string, Array.<module:echarts/model/Model>>}\n     * @readOnly\n     */\n    dependentModels: [],\n\n    /**\n     * @type {string}\n     * @readOnly\n     */\n    uid: null,\n\n    /**\n     * Support merge layout params.\n     * Only support 'box' now (left/right/top/bottom/width/height).\n     * @type {string|Object} Object can be {ignoreSize: true}\n     * @readOnly\n     */\n    layoutMode: null,\n\n    $constructor: function (option, parentModel, ecModel, extraOpt) {\n        Model.call(this, option, parentModel, ecModel, extraOpt);\n\n        this.uid = getUID('componentModel');\n    },\n\n\n    init: function (option, parentModel, ecModel, extraOpt) {\n        this.mergeDefaultAndTheme(option, ecModel);\n    },\n\n    mergeDefaultAndTheme: function (option, ecModel) {\n        var layoutMode = this.layoutMode;\n        var inputPositionParams = layoutMode\n            ? getLayoutParams(option) : {};\n\n        var themeModel = ecModel.getTheme();\n        merge(option, themeModel.get(this.mainType));\n        merge(option, this.getDefaultOption());\n\n        if (layoutMode) {\n            mergeLayoutParam(option, inputPositionParams, layoutMode);\n        }\n    },\n\n    mergeOption: function (option, extraOpt) {\n        merge(this.option, option, true);\n\n        var layoutMode = this.layoutMode;\n        if (layoutMode) {\n            mergeLayoutParam(this.option, option, layoutMode);\n        }\n    },\n\n    // Hooker after init or mergeOption\n    optionUpdated: function (newCptOption, isInit) {},\n\n    getDefaultOption: function () {\n        if (!hasOwn(this, '__defaultOption')) {\n            var optList = [];\n            var Class = this.constructor;\n            while (Class) {\n                var opt = Class.prototype.defaultOption;\n                opt && optList.push(opt);\n                Class = Class.superClass;\n            }\n\n            var defaultOption = {};\n            for (var i = optList.length - 1; i >= 0; i--) {\n                defaultOption = merge(defaultOption, optList[i], true);\n            }\n            set$1(this, '__defaultOption', defaultOption);\n        }\n        return get(this, '__defaultOption');\n    },\n\n    getReferringComponents: function (mainType) {\n        return this.ecModel.queryComponents({\n            mainType: mainType,\n            index: this.get(mainType + 'Index', true),\n            id: this.get(mainType + 'Id', true)\n        });\n    }\n\n});\n\n// Reset ComponentModel.extend, add preConstruct.\n// clazzUtil.enableClassExtend(\n//     ComponentModel,\n//     function (option, parentModel, ecModel, extraOpt) {\n//         // Set dependentModels, componentIndex, name, id, mainType, subType.\n//         zrUtil.extend(this, extraOpt);\n\n//         this.uid = componentUtil.getUID('componentModel');\n\n//         // this.setReadOnly([\n//         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n//         //     'dependentModels', 'componentIndex'\n//         // ]);\n//     }\n// );\n\n// Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\nenableClassManagement(\n    ComponentModel, {registerWhenExtend: true}\n);\nenableSubTypeDefaulter(ComponentModel);\n\n// Add capability of ComponentModel.topologicalTravel.\nenableTopologicalTravel(ComponentModel, getDependencies);\n\nfunction getDependencies(componentType) {\n    var deps = [];\n    each$1(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n        arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n    });\n    // Ensure main type\n    return map(deps, function (type) {\n        return parseClassType$1(type).main;\n    });\n}\n\nmixin(ComponentModel, boxLayoutMixin);\n\nvar platform = '';\n// Navigator not exists in node\nif (typeof navigator !== 'undefined') {\n    platform = navigator.platform || '';\n}\n\nvar globalDefault = {\n    // \n    // backgroundColor: 'rgba(0,0,0,0)',\n\n    // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n    // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n    // \n    // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n    // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n    // \n    color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\n    //  Grid \n    // grid: {},\n    // \n    textStyle: {\n        // color: '#000',\n        // decoration: 'none',\n        // PENDING\n        fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n        // fontFamily: 'Arial, Verdana, sans-serif',\n        fontSize: 12,\n        fontStyle: 'normal',\n        fontWeight: 'normal'\n    },\n\n    // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n    // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n    // Default is source-over\n    blendMode: null,\n\n    animation: 'auto',\n    animationDuration: 1000,\n    animationDurationUpdate: 300,\n    animationEasing: 'exponentialOut',\n    animationEasingUpdate: 'cubicOut',\n\n    animationThreshold: 2000,\n    // Configuration for progressive/incremental rendering\n    progressiveThreshold: 3000,\n    progressive: 400,\n\n    // Threshold of if use single hover layer to optimize.\n    // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n    // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n    // which is unexpected.\n    // see example <echarts/test/heatmap-large.html>.\n    hoverLayerThreshold: 3000,\n\n    // See: module:echarts/scale/Time\n    useUTC: false\n};\n\nvar colorPaletteMixin = {\n    clearColorPalette: function () {\n        set$1(this, 'colorIdx', 0);\n        set$1(this, 'colorNameMap', {});\n    },\n\n    getColorFromPalette: function (name, scope) {\n        scope = scope || this;\n        var colorIdx = get(scope, 'colorIdx') || 0;\n        var colorNameMap = get(scope, 'colorNameMap') || set$1(scope, 'colorNameMap', {});\n        // Use `hasOwnProperty` to avoid conflict with Object.prototype.\n        if (colorNameMap.hasOwnProperty(name)) {\n            return colorNameMap[name];\n        }\n        var colorPalette = this.get('color', true) || [];\n        if (!colorPalette.length) {\n            return;\n        }\n\n        var color = colorPalette[colorIdx];\n        if (name) {\n            colorNameMap[name] = color;\n        }\n        set$1(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);\n\n        return color;\n    }\n};\n\n/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n\n/**\n * Caution: If the mechanism should be changed some day, these cases\n * should be considered:\n *\n * (1) In `merge option` mode, if using the same option to call `setOption`\n * many times, the result should be the same (try our best to ensure that).\n * (2) In `merge option` mode, if a component has no id/name specified, it\n * will be merged by index, and the result sequence of the components is\n * consistent to the original sequence.\n * (3) `reset` feature (in toolbox). Find detailed info in comments about\n * `mergeOption` in module:echarts/model/OptionManager.\n */\n\nvar each$2 = each$1;\nvar filter$1 = filter;\nvar map$1 = map;\nvar isArray$1 = isArray;\nvar indexOf$1 = indexOf;\nvar isObject$1 = isObject;\n\nvar OPTION_INNER_KEY = '\\0_ec_inner';\n\n/**\n * @alias module:echarts/model/Global\n *\n * @param {Object} option\n * @param {module:echarts/model/Model} parentModel\n * @param {Object} theme\n */\nvar GlobalModel = Model.extend({\n\n    constructor: GlobalModel,\n\n    init: function (option, parentModel, theme, optionManager) {\n        theme = theme || {};\n\n        this.option = null; // Mark as not initialized.\n\n        /**\n         * @type {module:echarts/model/Model}\n         * @private\n         */\n        this._theme = new Model(theme);\n\n        /**\n         * @type {module:echarts/model/OptionManager}\n         */\n        this._optionManager = optionManager;\n    },\n\n    setOption: function (option, optionPreprocessorFuncs) {\n        assert(\n            !(OPTION_INNER_KEY in option),\n            'please use chart.getOption()'\n        );\n\n        this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n        this.resetOption(null);\n    },\n\n    /**\n     * @param {string} type null/undefined: reset all.\n     *                      'recreate': force recreate all.\n     *                      'timeline': only reset timeline option\n     *                      'media': only reset media query option\n     * @return {boolean} Whether option changed.\n     */\n    resetOption: function (type) {\n        var optionChanged = false;\n        var optionManager = this._optionManager;\n\n        if (!type || type === 'recreate') {\n            var baseOption = optionManager.mountOption(type === 'recreate');\n\n            if (!this.option || type === 'recreate') {\n                initBase.call(this, baseOption);\n            }\n            else {\n                this.restoreData();\n                this.mergeOption(baseOption);\n            }\n            optionChanged = true;\n        }\n\n        if (type === 'timeline' || type === 'media') {\n            this.restoreData();\n        }\n\n        if (!type || type === 'recreate' || type === 'timeline') {\n            var timelineOption = optionManager.getTimelineOption(this);\n            timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n        }\n\n        if (!type || type === 'recreate' || type === 'media') {\n            var mediaOptions = optionManager.getMediaOption(this, this._api);\n            if (mediaOptions.length) {\n                each$2(mediaOptions, function (mediaOption) {\n                    this.mergeOption(mediaOption, optionChanged = true);\n                }, this);\n            }\n        }\n\n        return optionChanged;\n    },\n\n    /**\n     * @protected\n     */\n    mergeOption: function (newOption) {\n        var option = this.option;\n        var componentsMap = this._componentsMap;\n        var newCptTypes = [];\n\n        //  component model  merge\n        each$2(newOption, function (componentOption, mainType) {\n            if (componentOption == null) {\n                return;\n            }\n\n            if (!ComponentModel.hasClass(mainType)) {\n                option[mainType] = option[mainType] == null\n                    ? clone(componentOption)\n                    : merge(option[mainType], componentOption, true);\n            }\n            else {\n                newCptTypes.push(mainType);\n            }\n        });\n\n        // FIXME OPTION \n        ComponentModel.topologicalTravel(\n            newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n        );\n\n        this._seriesIndices = this._seriesIndices || [];\n\n        function visitComponent(mainType, dependencies) {\n            var newCptOptionList = normalizeToArray(newOption[mainType]);\n\n            var mapResult = mappingToExists(\n                componentsMap.get(mainType), newCptOptionList\n            );\n\n            makeIdAndName(mapResult);\n\n            // Set mainType and complete subType.\n            each$2(mapResult, function (item, index) {\n                var opt = item.option;\n                if (isObject$1(opt)) {\n                    item.keyInfo.mainType = mainType;\n                    item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n                }\n            });\n\n            var dependentModels = getComponentsByTypes(\n                componentsMap, dependencies\n            );\n\n            option[mainType] = [];\n            componentsMap.set(mainType, []);\n\n            each$2(mapResult, function (resultItem, index) {\n                var componentModel = resultItem.exist;\n                var newCptOption = resultItem.option;\n\n                assert(\n                    isObject$1(newCptOption) || componentModel,\n                    'Empty component definition'\n                );\n\n                // Consider where is no new option and should be merged using {},\n                // see removeEdgeAndAdd in topologicalTravel and\n                // ComponentModel.getAllClassMainTypes.\n                if (!newCptOption) {\n                    componentModel.mergeOption({}, this);\n                    componentModel.optionUpdated({}, false);\n                }\n                else {\n                    var ComponentModelClass = ComponentModel.getClass(\n                        mainType, resultItem.keyInfo.subType, true\n                    );\n\n                    if (componentModel && componentModel instanceof ComponentModelClass) {\n                        componentModel.name = resultItem.keyInfo.name;\n                        componentModel.mergeOption(newCptOption, this);\n                        componentModel.optionUpdated(newCptOption, false);\n                    }\n                    else {\n                        // PENDING Global as parent ?\n                        var extraOpt = extend(\n                            {\n                                dependentModels: dependentModels,\n                                componentIndex: index\n                            },\n                            resultItem.keyInfo\n                        );\n                        componentModel = new ComponentModelClass(\n                            newCptOption, this, this, extraOpt\n                        );\n                        extend(componentModel, extraOpt);\n                        componentModel.init(newCptOption, this, this, extraOpt);\n                        // Call optionUpdated after init.\n                        // newCptOption has been used as componentModel.option\n                        // and may be merged with theme and default, so pass null\n                        // to avoid confusion.\n                        componentModel.optionUpdated(null, true);\n                    }\n                }\n\n                componentsMap.get(mainType)[index] = componentModel;\n                option[mainType][index] = componentModel.option;\n            }, this);\n\n            // Backup series for filtering.\n            if (mainType === 'series') {\n                this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n            }\n        }\n    },\n\n    /**\n     * Get option for output (cloned option and inner info removed)\n     * @public\n     * @return {Object}\n     */\n    getOption: function () {\n        var option = clone(this.option);\n\n        each$2(option, function (opts, mainType) {\n            if (ComponentModel.hasClass(mainType)) {\n                var opts = normalizeToArray(opts);\n                for (var i = opts.length - 1; i >= 0; i--) {\n                    // Remove options with inner id.\n                    if (isIdInner(opts[i])) {\n                        opts.splice(i, 1);\n                    }\n                }\n                option[mainType] = opts;\n            }\n        });\n\n        delete option[OPTION_INNER_KEY];\n\n        return option;\n    },\n\n    /**\n     * @return {module:echarts/model/Model}\n     */\n    getTheme: function () {\n        return this._theme;\n    },\n\n    /**\n     * @param {string} mainType\n     * @param {number} [idx=0]\n     * @return {module:echarts/model/Component}\n     */\n    getComponent: function (mainType, idx) {\n        var list = this._componentsMap.get(mainType);\n        if (list) {\n            return list[idx || 0];\n        }\n    },\n\n    /**\n     * If none of index and id and name used, return all components with mainType.\n     * @param {Object} condition\n     * @param {string} condition.mainType\n     * @param {string} [condition.subType] If ignore, only query by mainType\n     * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n     * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n     * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n     * @return {Array.<module:echarts/model/Component>}\n     */\n    queryComponents: function (condition) {\n        var mainType = condition.mainType;\n        if (!mainType) {\n            return [];\n        }\n\n        var index = condition.index;\n        var id = condition.id;\n        var name = condition.name;\n\n        var cpts = this._componentsMap.get(mainType);\n\n        if (!cpts || !cpts.length) {\n            return [];\n        }\n\n        var result;\n\n        if (index != null) {\n            if (!isArray$1(index)) {\n                index = [index];\n            }\n            result = filter$1(map$1(index, function (idx) {\n                return cpts[idx];\n            }), function (val) {\n                return !!val;\n            });\n        }\n        else if (id != null) {\n            var isIdArray = isArray$1(id);\n            result = filter$1(cpts, function (cpt) {\n                return (isIdArray && indexOf$1(id, cpt.id) >= 0)\n                    || (!isIdArray && cpt.id === id);\n            });\n        }\n        else if (name != null) {\n            var isNameArray = isArray$1(name);\n            result = filter$1(cpts, function (cpt) {\n                return (isNameArray && indexOf$1(name, cpt.name) >= 0)\n                    || (!isNameArray && cpt.name === name);\n            });\n        }\n        else {\n            // Return all components with mainType\n            result = cpts.slice();\n        }\n\n        return filterBySubType(result, condition);\n    },\n\n    /**\n     * The interface is different from queryComponents,\n     * which is convenient for inner usage.\n     *\n     * @usage\n     * var result = findComponents(\n     *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n     * );\n     * var result = findComponents(\n     *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n     * );\n     * var result = findComponents(\n     *     {mainType: 'series'},\n     *     function (model, index) {...}\n     * );\n     * // result like [component0, componnet1, ...]\n     *\n     * @param {Object} condition\n     * @param {string} condition.mainType Mandatory.\n     * @param {string} [condition.subType] Optional.\n     * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n     *        where xxx is mainType.\n     *        If query attribute is null/undefined or has no index/id/name,\n     *        do not filtering by query conditions, which is convenient for\n     *        no-payload situations or when target of action is global.\n     * @param {Function} [condition.filter] parameter: component, return boolean.\n     * @return {Array.<module:echarts/model/Component>}\n     */\n    findComponents: function (condition) {\n        var query = condition.query;\n        var mainType = condition.mainType;\n\n        var queryCond = getQueryCond(query);\n        var result = queryCond\n            ? this.queryComponents(queryCond)\n            : this._componentsMap.get(mainType);\n\n        return doFilter(filterBySubType(result, condition));\n\n        function getQueryCond(q) {\n            var indexAttr = mainType + 'Index';\n            var idAttr = mainType + 'Id';\n            var nameAttr = mainType + 'Name';\n            return q && (\n                    q[indexAttr] != null\n                    || q[idAttr] != null\n                    || q[nameAttr] != null\n                )\n                ? {\n                    mainType: mainType,\n                    // subType will be filtered finally.\n                    index: q[indexAttr],\n                    id: q[idAttr],\n                    name: q[nameAttr]\n                }\n                : null;\n        }\n\n        function doFilter(res) {\n            return condition.filter\n                    ? filter$1(res, condition.filter)\n                    : res;\n        }\n    },\n\n    /**\n     * @usage\n     * eachComponent('legend', function (legendModel, index) {\n     *     ...\n     * });\n     * eachComponent(function (componentType, model, index) {\n     *     // componentType does not include subType\n     *     // (componentType is 'xxx' but not 'xxx.aa')\n     * });\n     * eachComponent(\n     *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n     *     function (model, index) {...}\n     * );\n     * eachComponent(\n     *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n     *     function (model, index) {...}\n     * );\n     *\n     * @param {string|Object=} mainType When mainType is object, the definition\n     *                                  is the same as the method 'findComponents'.\n     * @param {Function} cb\n     * @param {*} context\n     */\n    eachComponent: function (mainType, cb, context) {\n        var componentsMap = this._componentsMap;\n\n        if (typeof mainType === 'function') {\n            context = cb;\n            cb = mainType;\n            componentsMap.each(function (components, componentType) {\n                each$2(components, function (component, index) {\n                    cb.call(context, componentType, component, index);\n                });\n            });\n        }\n        else if (isString(mainType)) {\n            each$2(componentsMap.get(mainType), cb, context);\n        }\n        else if (isObject$1(mainType)) {\n            var queryResult = this.findComponents(mainType);\n            each$2(queryResult, cb, context);\n        }\n    },\n\n    /**\n     * @param {string} name\n     * @return {Array.<module:echarts/model/Series>}\n     */\n    getSeriesByName: function (name) {\n        var series = this._componentsMap.get('series');\n        return filter$1(series, function (oneSeries) {\n            return oneSeries.name === name;\n        });\n    },\n\n    /**\n     * @param {number} seriesIndex\n     * @return {module:echarts/model/Series}\n     */\n    getSeriesByIndex: function (seriesIndex) {\n        return this._componentsMap.get('series')[seriesIndex];\n    },\n\n    /**\n     * @param {string} subType\n     * @return {Array.<module:echarts/model/Series>}\n     */\n    getSeriesByType: function (subType) {\n        var series = this._componentsMap.get('series');\n        return filter$1(series, function (oneSeries) {\n            return oneSeries.subType === subType;\n        });\n    },\n\n    /**\n     * @return {Array.<module:echarts/model/Series>}\n     */\n    getSeries: function () {\n        return this._componentsMap.get('series').slice();\n    },\n\n    /**\n     * After filtering, series may be different\n     * frome raw series.\n     *\n     * @param {Function} cb\n     * @param {*} context\n     */\n    eachSeries: function (cb, context) {\n        assertSeriesInitialized(this);\n        each$2(this._seriesIndices, function (rawSeriesIndex) {\n            var series = this._componentsMap.get('series')[rawSeriesIndex];\n            cb.call(context, series, rawSeriesIndex);\n        }, this);\n    },\n\n    /**\n     * Iterate raw series before filtered.\n     *\n     * @param {Function} cb\n     * @param {*} context\n     */\n    eachRawSeries: function (cb, context) {\n        each$2(this._componentsMap.get('series'), cb, context);\n    },\n\n    /**\n     * After filtering, series may be different.\n     * frome raw series.\n     *\n     * @parma {string} subType\n     * @param {Function} cb\n     * @param {*} context\n     */\n    eachSeriesByType: function (subType, cb, context) {\n        assertSeriesInitialized(this);\n        each$2(this._seriesIndices, function (rawSeriesIndex) {\n            var series = this._componentsMap.get('series')[rawSeriesIndex];\n            if (series.subType === subType) {\n                cb.call(context, series, rawSeriesIndex);\n            }\n        }, this);\n    },\n\n    /**\n     * Iterate raw series before filtered of given type.\n     *\n     * @parma {string} subType\n     * @param {Function} cb\n     * @param {*} context\n     */\n    eachRawSeriesByType: function (subType, cb, context) {\n        return each$2(this.getSeriesByType(subType), cb, context);\n    },\n\n    /**\n     * @param {module:echarts/model/Series} seriesModel\n     */\n    isSeriesFiltered: function (seriesModel) {\n        assertSeriesInitialized(this);\n        return indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n    },\n\n    /**\n     * @return {Array.<number>}\n     */\n    getCurrentSeriesIndices: function () {\n        return (this._seriesIndices || []).slice();\n    },\n\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    filterSeries: function (cb, context) {\n        assertSeriesInitialized(this);\n        var filteredSeries = filter$1(\n            this._componentsMap.get('series'), cb, context\n        );\n        this._seriesIndices = createSeriesIndices(filteredSeries);\n    },\n\n    restoreData: function () {\n        var componentsMap = this._componentsMap;\n\n        this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n\n        var componentTypes = [];\n        componentsMap.each(function (components, componentType) {\n            componentTypes.push(componentType);\n        });\n\n        ComponentModel.topologicalTravel(\n            componentTypes,\n            ComponentModel.getAllClassMainTypes(),\n            function (componentType, dependencies) {\n                each$2(componentsMap.get(componentType), function (component) {\n                    component.restoreData();\n                });\n            }\n        );\n    }\n\n});\n\n/**\n * @inner\n */\nfunction mergeTheme(option, theme) {\n    each$1(theme, function (themeItem, name) {\n        //  component model  merge  model \n        if (!ComponentModel.hasClass(name)) {\n            if (typeof themeItem === 'object') {\n                option[name] = !option[name]\n                    ? clone(themeItem)\n                    : merge(option[name], themeItem, false);\n            }\n            else {\n                if (option[name] == null) {\n                    option[name] = themeItem;\n                }\n            }\n        }\n    });\n}\n\nfunction initBase(baseOption) {\n    baseOption = baseOption;\n\n    // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n    // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n    this.option = {};\n    this.option[OPTION_INNER_KEY] = 1;\n\n    /**\n     * Init with series: [], in case of calling findSeries method\n     * before series initialized.\n     * @type {Object.<string, Array.<module:echarts/model/Model>>}\n     * @private\n     */\n    this._componentsMap = createHashMap({series: []});\n\n    /**\n     * Mapping between filtered series list and raw series list.\n     * key: filtered series indices, value: raw series indices.\n     * @type {Array.<nubmer>}\n     * @private\n     */\n    this._seriesIndices = null;\n\n    mergeTheme(baseOption, this._theme.option);\n\n    // TODO Needs clone when merging to the unexisted property\n    merge(baseOption, globalDefault, false);\n\n    this.mergeOption(baseOption);\n}\n\n/**\n * @inner\n * @param {Array.<string>|string} types model types\n * @return {Object} key: {string} type, value: {Array.<Object>} models\n */\nfunction getComponentsByTypes(componentsMap, types) {\n    if (!isArray(types)) {\n        types = types ? [types] : [];\n    }\n\n    var ret = {};\n    each$2(types, function (type) {\n        ret[type] = (componentsMap.get(type) || []).slice();\n    });\n\n    return ret;\n}\n\n/**\n * @inner\n */\nfunction determineSubType(mainType, newCptOption, existComponent) {\n    var subType = newCptOption.type\n        ? newCptOption.type\n        : existComponent\n        ? existComponent.subType\n        // Use determineSubType only when there is no existComponent.\n        : ComponentModel.determineSubType(mainType, newCptOption);\n\n    // tooltip, markline, markpoint may always has no subType\n    return subType;\n}\n\n/**\n * @inner\n */\nfunction createSeriesIndices(seriesModels) {\n    return map$1(seriesModels, function (series) {\n        return series.componentIndex;\n    }) || [];\n}\n\n/**\n * @inner\n */\nfunction filterBySubType(components, condition) {\n    // Using hasOwnProperty for restrict. Consider\n    // subType is undefined in user payload.\n    return condition.hasOwnProperty('subType')\n        ? filter$1(components, function (cpt) {\n            return cpt.subType === condition.subType;\n        })\n        : components;\n}\n\n/**\n * @inner\n */\nfunction assertSeriesInitialized(ecModel) {\n    // Components that use _seriesIndices should depends on series component,\n    // which make sure that their initialization is after series.\n    if (__DEV__) {\n        if (!ecModel._seriesIndices) {\n            throw new Error('Option should contains series.');\n        }\n    }\n}\n\nmixin(GlobalModel, colorPaletteMixin);\n\nvar echartsAPIList = [\n    'getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed',\n    'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption',\n    'getViewOfComponentModel', 'getViewOfSeriesModel'\n];\n// And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js\n\nfunction ExtensionAPI(chartInstance) {\n    each$1(echartsAPIList, function (name) {\n        this[name] = bind(chartInstance[name], chartInstance);\n    }, this);\n}\n\nvar coordinateSystemCreators = {};\n\nfunction CoordinateSystemManager() {\n\n    this._coordinateSystems = [];\n}\n\nCoordinateSystemManager.prototype = {\n\n    constructor: CoordinateSystemManager,\n\n    create: function (ecModel, api) {\n        var coordinateSystems = [];\n        each$1(coordinateSystemCreators, function (creater, type) {\n            var list = creater.create(ecModel, api);\n            coordinateSystems = coordinateSystems.concat(list || []);\n        });\n\n        this._coordinateSystems = coordinateSystems;\n    },\n\n    update: function (ecModel, api) {\n        each$1(this._coordinateSystems, function (coordSys) {\n            // FIXME MUST have\n            coordSys.update && coordSys.update(ecModel, api);\n        });\n    },\n\n    getCoordinateSystems: function () {\n        return this._coordinateSystems.slice();\n    }\n};\n\nCoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n    coordinateSystemCreators[type] = coordinateSystemCreator;\n};\n\nCoordinateSystemManager.get = function (type) {\n    return coordinateSystemCreators[type];\n};\n\n/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\n\n\nvar each$5 = each$1;\nvar clone$2 = clone;\nvar map$2 = map;\nvar merge$1 = merge;\n\nvar QUERY_REG = /^(min|max)?(.+)$/;\n\n/**\n * TERM EXPLANATIONS:\n *\n * [option]:\n *\n *     An object that contains definitions of components. For example:\n *     var option = {\n *         title: {...},\n *         legend: {...},\n *         visualMap: {...},\n *         series: [\n *             {data: [...]},\n *             {data: [...]},\n *             ...\n *         ]\n *     };\n *\n * [rawOption]:\n *\n *     An object input to echarts.setOption. 'rawOption' may be an\n *     'option', or may be an object contains multi-options. For example:\n *     var option = {\n *         baseOption: {\n *             title: {...},\n *             legend: {...},\n *             series: [\n *                 {data: [...]},\n *                 {data: [...]},\n *                 ...\n *             ]\n *         },\n *         timeline: {...},\n *         options: [\n *             {title: {...}, series: {data: [...]}},\n *             {title: {...}, series: {data: [...]}},\n *             ...\n *         ],\n *         media: [\n *             {\n *                 query: {maxWidth: 320},\n *                 option: {series: {x: 20}, visualMap: {show: false}}\n *             },\n *             {\n *                 query: {minWidth: 320, maxWidth: 720},\n *                 option: {series: {x: 500}, visualMap: {show: true}}\n *             },\n *             {\n *                 option: {series: {x: 1200}, visualMap: {show: true}}\n *             }\n *         ]\n *     };\n *\n * @alias module:echarts/model/OptionManager\n * @param {module:echarts/ExtensionAPI} api\n */\nfunction OptionManager(api) {\n\n    /**\n     * @private\n     * @type {module:echarts/ExtensionAPI}\n     */\n    this._api = api;\n\n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this._timelineOptions = [];\n\n    /**\n     * @private\n     * @type {Array.<Object>}\n     */\n    this._mediaList = [];\n\n    /**\n     * @private\n     * @type {Object}\n     */\n    this._mediaDefault;\n\n    /**\n     * -1, means default.\n     * empty means no media.\n     * @private\n     * @type {Array.<number>}\n     */\n    this._currentMediaIndices = [];\n\n    /**\n     * @private\n     * @type {Object}\n     */\n    this._optionBackup;\n\n    /**\n     * @private\n     * @type {Object}\n     */\n    this._newBaseOption;\n}\n\n// timeline.notMerge is not supported in ec3. Firstly there is rearly\n// case that notMerge is needed. Secondly supporting 'notMerge' requires\n// rawOption cloned and backuped when timeline changed, which does no\n// good to performance. What's more, that both timeline and setOption\n// method supply 'notMerge' brings complex and some problems.\n// Consider this case:\n// (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n// (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\nOptionManager.prototype = {\n\n    constructor: OptionManager,\n\n    /**\n     * @public\n     * @param {Object} rawOption Raw option.\n     * @param {module:echarts/model/Global} ecModel\n     * @param {Array.<Function>} optionPreprocessorFuncs\n     * @return {Object} Init option\n     */\n    setOption: function (rawOption, optionPreprocessorFuncs) {\n        rawOption = clone$2(rawOption, true);\n\n        // FIXME\n        //  timeline options  media baseOption\n\n        var oldOptionBackup = this._optionBackup;\n        var newParsedOption = parseRawOption.call(\n            this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n        );\n        this._newBaseOption = newParsedOption.baseOption;\n\n        // For setOption at second time (using merge mode);\n        if (oldOptionBackup) {\n            // Only baseOption can be merged.\n            mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\n            // For simplicity, timeline options and media options do not support merge,\n            // that is, if you `setOption` twice and both has timeline options, the latter\n            // timeline opitons will not be merged to the formers, but just substitude them.\n            if (newParsedOption.timelineOptions.length) {\n                oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n            }\n            if (newParsedOption.mediaList.length) {\n                oldOptionBackup.mediaList = newParsedOption.mediaList;\n            }\n            if (newParsedOption.mediaDefault) {\n                oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n            }\n        }\n        else {\n            this._optionBackup = newParsedOption;\n        }\n    },\n\n    /**\n     * @param {boolean} isRecreate\n     * @return {Object}\n     */\n    mountOption: function (isRecreate) {\n        var optionBackup = this._optionBackup;\n\n        // TODO\n        // resetclone\n\n        this._timelineOptions = map$2(optionBackup.timelineOptions, clone$2);\n        this._mediaList = map$2(optionBackup.mediaList, clone$2);\n        this._mediaDefault = clone$2(optionBackup.mediaDefault);\n        this._currentMediaIndices = [];\n\n        return clone$2(isRecreate\n            // this._optionBackup.baseOption, which is created at the first `setOption`\n            // called, and is merged into every new option by inner method `mergeOption`\n            // each time `setOption` called, can be only used in `isRecreate`, because\n            // its reliability is under suspicion. In other cases option merge is\n            // performed by `model.mergeOption`.\n            ? optionBackup.baseOption : this._newBaseOption\n        );\n    },\n\n    /**\n     * @param {module:echarts/model/Global} ecModel\n     * @return {Object}\n     */\n    getTimelineOption: function (ecModel) {\n        var option;\n        var timelineOptions = this._timelineOptions;\n\n        if (timelineOptions.length) {\n            // getTimelineOption can only be called after ecModel inited,\n            // so we can get currentIndex from timelineModel.\n            var timelineModel = ecModel.getComponent('timeline');\n            if (timelineModel) {\n                option = clone$2(\n                    timelineOptions[timelineModel.getCurrentIndex()],\n                    true\n                );\n            }\n        }\n\n        return option;\n    },\n\n    /**\n     * @param {module:echarts/model/Global} ecModel\n     * @return {Array.<Object>}\n     */\n    getMediaOption: function (ecModel) {\n        var ecWidth = this._api.getWidth();\n        var ecHeight = this._api.getHeight();\n        var mediaList = this._mediaList;\n        var mediaDefault = this._mediaDefault;\n        var indices = [];\n        var result = [];\n\n        // No media defined.\n        if (!mediaList.length && !mediaDefault) {\n            return result;\n        }\n\n        // Multi media may be applied, the latter defined media has higher priority.\n        for (var i = 0, len = mediaList.length; i < len; i++) {\n            if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                indices.push(i);\n            }\n        }\n\n        // FIXME\n        // mediaDefault\n        if (!indices.length && mediaDefault) {\n            indices = [-1];\n        }\n\n        if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n            result = map$2(indices, function (index) {\n                return clone$2(\n                    index === -1 ? mediaDefault.option : mediaList[index].option\n                );\n            });\n        }\n        // Otherwise return nothing.\n\n        this._currentMediaIndices = indices;\n\n        return result;\n    }\n};\n\nfunction parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n    var timelineOptions = [];\n    var mediaList = [];\n    var mediaDefault;\n    var baseOption;\n\n    // Compatible with ec2.\n    var timelineOpt = rawOption.timeline;\n\n    if (rawOption.baseOption) {\n        baseOption = rawOption.baseOption;\n    }\n\n    // For timeline\n    if (timelineOpt || rawOption.options) {\n        baseOption = baseOption || {};\n        timelineOptions = (rawOption.options || []).slice();\n    }\n\n    // For media query\n    if (rawOption.media) {\n        baseOption = baseOption || {};\n        var media = rawOption.media;\n        each$5(media, function (singleMedia) {\n            if (singleMedia && singleMedia.option) {\n                if (singleMedia.query) {\n                    mediaList.push(singleMedia);\n                }\n                else if (!mediaDefault) {\n                    // Use the first media default.\n                    mediaDefault = singleMedia;\n                }\n            }\n        });\n    }\n\n    // For normal option\n    if (!baseOption) {\n        baseOption = rawOption;\n    }\n\n    // Set timelineOpt to baseOption in ec3,\n    // which is convenient for merge option.\n    if (!baseOption.timeline) {\n        baseOption.timeline = timelineOpt;\n    }\n\n    // Preprocess.\n    each$5([baseOption].concat(timelineOptions)\n        .concat(map(mediaList, function (media) {\n            return media.option;\n        })),\n        function (option) {\n            each$5(optionPreprocessorFuncs, function (preProcess) {\n                preProcess(option, isNew);\n            });\n        }\n    );\n\n    return {\n        baseOption: baseOption,\n        timelineOptions: timelineOptions,\n        mediaDefault: mediaDefault,\n        mediaList: mediaList\n    };\n}\n\n/**\n * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n * Support: width, height, aspectRatio\n * Can use max or min as prefix.\n */\nfunction applyMediaQuery(query, ecWidth, ecHeight) {\n    var realMap = {\n        width: ecWidth,\n        height: ecHeight,\n        aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n    };\n\n    var applicatable = true;\n\n    each$1(query, function (value, attr) {\n        var matched = attr.match(QUERY_REG);\n\n        if (!matched || !matched[1] || !matched[2]) {\n            return;\n        }\n\n        var operator = matched[1];\n        var realAttr = matched[2].toLowerCase();\n\n        if (!compare(realMap[realAttr], value, operator)) {\n            applicatable = false;\n        }\n    });\n\n    return applicatable;\n}\n\nfunction compare(real, expect, operator) {\n    if (operator === 'min') {\n        return real >= expect;\n    }\n    else if (operator === 'max') {\n        return real <= expect;\n    }\n    else { // Equals\n        return real === expect;\n    }\n}\n\nfunction indicesEquals(indices1, indices2) {\n    // indices is always order by asc and has only finite number.\n    return indices1.join(',') === indices2.join(',');\n}\n\n/**\n * Consider case:\n * `chart.setOption(opt1);`\n * Then user do some interaction like dataZoom, dataView changing.\n * `chart.setOption(opt2);`\n * Then user press 'reset button' in toolbox.\n *\n * After doing that all of the interaction effects should be reset, the\n * chart should be the same as the result of invoke\n * `chart.setOption(opt1); chart.setOption(opt2);`.\n *\n * Although it is not able ensure that\n * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n * `chart.setOption(merge(opt1, opt2));` exactly,\n * this might be the only simple way to implement that feature.\n *\n * MEMO: We've considered some other approaches:\n * 1. Each model handle its self restoration but not uniform treatment.\n *     (Too complex in logic and error-prone)\n * 2. Use a shadow ecModel. (Performace expensive)\n */\nfunction mergeOption(oldOption, newOption) {\n    newOption = newOption || {};\n\n    each$5(newOption, function (newCptOpt, mainType) {\n        if (newCptOpt == null) {\n            return;\n        }\n\n        var oldCptOpt = oldOption[mainType];\n\n        if (!ComponentModel.hasClass(mainType)) {\n            oldOption[mainType] = merge$1(oldCptOpt, newCptOpt, true);\n        }\n        else {\n            newCptOpt = normalizeToArray(newCptOpt);\n            oldCptOpt = normalizeToArray(oldCptOpt);\n\n            var mapResult = mappingToExists(oldCptOpt, newCptOpt);\n\n            oldOption[mainType] = map$2(mapResult, function (item) {\n                return (item.option && item.exist)\n                    ? merge$1(item.exist, item.option, true)\n                    : (item.exist || item.option);\n            });\n        }\n    });\n}\n\nvar each$6 = each$1;\nvar isObject$3 = isObject;\n\nvar POSSIBLE_STYLES = [\n    'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n    'chordStyle', 'label', 'labelLine'\n];\n\nfunction compatItemStyle(opt) {\n    var itemStyleOpt = opt && opt.itemStyle;\n    if (!itemStyleOpt) {\n        return;\n    }\n    for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {\n        var styleName = POSSIBLE_STYLES[i];\n        var normalItemStyleOpt = itemStyleOpt.normal;\n        var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n        if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n            opt[styleName] = opt[styleName] || {};\n            if (!opt[styleName].normal) {\n                opt[styleName].normal = normalItemStyleOpt[styleName];\n            }\n            else {\n                merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n            }\n            normalItemStyleOpt[styleName] = null;\n        }\n        if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n            opt[styleName] = opt[styleName] || {};\n            if (!opt[styleName].emphasis) {\n                opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n            }\n            else {\n                merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n            }\n            emphasisItemStyleOpt[styleName] = null;\n        }\n    }\n}\n\nfunction compatTextStyle(opt, propName) {\n    var labelOptSingle = isObject$3(opt) && opt[propName];\n    var textStyle = isObject$3(labelOptSingle) && labelOptSingle.textStyle;\n    if (textStyle) {\n        for (var i = 0, len = TEXT_STYLE_OPTIONS.length; i < len; i++) {\n            var propName = TEXT_STYLE_OPTIONS[i];\n            if (textStyle.hasOwnProperty(propName)) {\n                labelOptSingle[propName] = textStyle[propName];\n            }\n        }\n    }\n}\n\nfunction compatLabelTextStyle(labelOpt) {\n    if (isObject$3(labelOpt)) {\n        compatTextStyle(labelOpt, 'normal');\n        compatTextStyle(labelOpt, 'emphasis');\n    }\n}\n\nfunction processSeries(seriesOpt) {\n    if (!isObject$3(seriesOpt)) {\n        return;\n    }\n\n    compatItemStyle(seriesOpt);\n    compatLabelTextStyle(seriesOpt.label);\n    // treemap\n    compatLabelTextStyle(seriesOpt.upperLabel);\n    // graph\n    compatLabelTextStyle(seriesOpt.edgeLabel);\n\n    var markPoint = seriesOpt.markPoint;\n    compatItemStyle(markPoint);\n    compatLabelTextStyle(markPoint && markPoint.label);\n\n    var markLine = seriesOpt.markLine;\n    compatItemStyle(seriesOpt.markLine);\n    compatLabelTextStyle(markLine && markLine.label);\n\n    var markArea = seriesOpt.markArea;\n    compatLabelTextStyle(markArea && markArea.label);\n\n    // For gauge\n    compatTextStyle(seriesOpt, 'axisLabel');\n    compatTextStyle(seriesOpt, 'title');\n    compatTextStyle(seriesOpt, 'detail');\n\n    var data = seriesOpt.data;\n    if (data) {\n        for (var i = 0; i < data.length; i++) {\n            compatItemStyle(data[i]);\n            compatLabelTextStyle(data[i] && data[i].label);\n        }\n    }\n\n    // mark point data\n    var markPoint = seriesOpt.markPoint;\n    if (markPoint && markPoint.data) {\n        var mpData = markPoint.data;\n        for (var i = 0; i < mpData.length; i++) {\n            compatItemStyle(mpData[i]);\n            compatLabelTextStyle(mpData[i] && mpData[i].label);\n        }\n    }\n    // mark line data\n    var markLine = seriesOpt.markLine;\n    if (markLine && markLine.data) {\n        var mlData = markLine.data;\n        for (var i = 0; i < mlData.length; i++) {\n            if (isArray(mlData[i])) {\n                compatItemStyle(mlData[i][0]);\n                compatLabelTextStyle(mlData[i][0] && mlData[i][0].label);\n                compatItemStyle(mlData[i][1]);\n                compatLabelTextStyle(mlData[i][1] && mlData[i][1].label);\n            }\n            else {\n                compatItemStyle(mlData[i]);\n                compatLabelTextStyle(mlData[i] && mlData[i].label);\n            }\n        }\n    }\n}\n\nfunction toArr(o) {\n    return isArray(o) ? o : o ? [o] : [];\n}\n\nfunction toObj(o) {\n    return (isArray(o) ? o[0] : o) || {};\n}\n\nvar compatStyle = function (option, isTheme) {\n    each$6(toArr(option.series), function (seriesOpt) {\n        isObject$3(seriesOpt) && processSeries(seriesOpt);\n    });\n\n    var axes = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar'];\n    isTheme && axes.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis');\n\n    each$6(\n        axes,\n        function (axisName) {\n            each$6(toArr(option[axisName]), function (axisOpt) {\n                if (axisOpt) {\n                    compatTextStyle(axisOpt, 'axisLabel');\n                    compatTextStyle(axisOpt.axisPointer, 'label');\n                }\n            });\n        }\n    );\n\n    each$6(toArr(option.parallel), function (parallelOpt) {\n        var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;\n        compatTextStyle(parallelAxisDefault, 'axisLabel');\n        compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, 'label');\n    });\n\n    each$6(toArr(option.calendar), function (calendarOpt) {\n        compatTextStyle(calendarOpt, 'dayLabel');\n        compatTextStyle(calendarOpt, 'monthLabel');\n        compatTextStyle(calendarOpt, 'yearLabel');\n    });\n\n    // radar.name.textStyle\n    each$6(toArr(option.radar), function (radarOpt) {\n        compatTextStyle(radarOpt, 'name');\n    });\n\n    each$6(toArr(option.geo), function (geoOpt) {\n        if (isObject$3(geoOpt)) {\n            compatLabelTextStyle(geoOpt.label);\n            each$6(toArr(geoOpt.regions), function (regionObj) {\n                compatLabelTextStyle(regionObj.label);\n            });\n        }\n    });\n\n    compatLabelTextStyle(toObj(option.timeline).label);\n    compatTextStyle(toObj(option.axisPointer), 'label');\n    compatTextStyle(toObj(option.tooltip).axisPointer, 'label');\n};\n\n// Compatitable with 2.0\n\nfunction get$1(opt, path) {\n    path = path.split(',');\n    var obj = opt;\n    for (var i = 0; i < path.length; i++) {\n        obj = obj && obj[path[i]];\n        if (obj == null) {\n            break;\n        }\n    }\n    return obj;\n}\n\nfunction set$2(opt, path, val, overwrite) {\n    path = path.split(',');\n    var obj = opt;\n    var key;\n    for (var i = 0; i < path.length - 1; i++) {\n        key = path[i];\n        if (obj[key] == null) {\n            obj[key] = {};\n        }\n        obj = obj[key];\n    }\n    if (overwrite || obj[path[i]] == null) {\n        obj[path[i]] = val;\n    }\n}\n\nfunction compatLayoutProperties(option) {\n    each$1(LAYOUT_PROPERTIES, function (prop) {\n        if (prop[0] in option && !(prop[1] in option)) {\n            option[prop[1]] = option[prop[0]];\n        }\n    });\n}\n\nvar LAYOUT_PROPERTIES = [\n    ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n];\n\nvar COMPATITABLE_COMPONENTS = [\n    'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n];\n\nvar COMPATITABLE_SERIES = [\n    'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n    'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n    'pie', 'radar', 'sankey', 'scatter', 'treemap'\n];\n\nvar backwardCompat = function (option, isTheme) {\n    compatStyle(option, isTheme);\n\n    // Make sure series array for model initialization.\n    option.series = normalizeToArray(option.series);\n\n    each$1(option.series, function (seriesOpt) {\n        if (!isObject(seriesOpt)) {\n            return;\n        }\n\n        var seriesType = seriesOpt.type;\n\n        if (seriesType === 'pie' || seriesType === 'gauge') {\n            if (seriesOpt.clockWise != null) {\n                seriesOpt.clockwise = seriesOpt.clockWise;\n            }\n        }\n        if (seriesType === 'gauge') {\n            var pointerColor = get$1(seriesOpt, 'pointer.color');\n            pointerColor != null\n                && set$2(seriesOpt, 'itemStyle.normal.color', pointerColor);\n        }\n\n        for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n            if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                compatLayoutProperties(seriesOpt);\n                break;\n            }\n        }\n    });\n\n    // dataRange has changed to visualMap\n    if (option.dataRange) {\n        option.visualMap = option.dataRange;\n    }\n\n    each$1(COMPATITABLE_COMPONENTS, function (componentName) {\n        var options = option[componentName];\n        if (options) {\n            if (!isArray(options)) {\n                options = [options];\n            }\n            each$1(options, function (option) {\n                compatLayoutProperties(option);\n            });\n        }\n    });\n};\n\nvar SeriesModel = ComponentModel.extend({\n\n    type: 'series.__base__',\n\n    /**\n     * @readOnly\n     */\n    seriesIndex: 0,\n\n    // coodinateSystem will be injected in the echarts/CoordinateSystem\n    coordinateSystem: null,\n\n    /**\n     * @type {Object}\n     * @protected\n     */\n    defaultOption: null,\n\n    /**\n     * Data provided for legend\n     * @type {Function}\n     */\n    // PENDING\n    legendDataProvider: null,\n\n    /**\n     * Access path of color for visual\n     */\n    visualColorAccessPath: 'itemStyle.normal.color',\n\n    /**\n     * Support merge layout params.\n     * Only support 'box' now (left/right/top/bottom/width/height).\n     * @type {string|Object} Object can be {ignoreSize: true}\n     * @readOnly\n     */\n    layoutMode: null,\n\n    init: function (option, parentModel, ecModel, extraOpt) {\n\n        /**\n         * @type {number}\n         * @readOnly\n         */\n        this.seriesIndex = this.componentIndex;\n\n        this.mergeDefaultAndTheme(option, ecModel);\n\n        var data = this.getInitialData(option, ecModel);\n        if (__DEV__) {\n            assert(data, 'getInitialData returned invalid data.');\n        }\n        /**\n         * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n         * @private\n         */\n        set$1(this, 'dataBeforeProcessed', data);\n\n        // If we reverse the order (make data firstly, and then make\n        // dataBeforeProcessed by cloneShallow), cloneShallow will\n        // cause data.graph.data !== data when using\n        // module:echarts/data/Graph or module:echarts/data/Tree.\n        // See module:echarts/data/helper/linkList\n        this.restoreData();\n    },\n\n    /**\n     * Util for merge default and theme to option\n     * @param  {Object} option\n     * @param  {module:echarts/model/Global} ecModel\n     */\n    mergeDefaultAndTheme: function (option, ecModel) {\n        var layoutMode = this.layoutMode;\n        var inputPositionParams = layoutMode\n            ? getLayoutParams(option) : {};\n\n        // Backward compat: using subType on theme.\n        // But if name duplicate between series subType\n        // (for example: parallel) add component mainType,\n        // add suffix 'Series'.\n        var themeSubType = this.subType;\n        if (ComponentModel.hasClass(themeSubType)) {\n            themeSubType += 'Series';\n        }\n        merge(\n            option,\n            ecModel.getTheme().get(this.subType)\n        );\n        merge(option, this.getDefaultOption());\n\n        // Default label emphasis `show`\n        defaultEmphasis(option.label, ['show']);\n\n        this.fillDataTextStyle(option.data);\n\n        if (layoutMode) {\n            mergeLayoutParam(option, inputPositionParams, layoutMode);\n        }\n    },\n\n    mergeOption: function (newSeriesOption, ecModel) {\n        newSeriesOption = merge(this.option, newSeriesOption, true);\n        this.fillDataTextStyle(newSeriesOption.data);\n\n        var layoutMode = this.layoutMode;\n        if (layoutMode) {\n            mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n        }\n\n        var data = this.getInitialData(newSeriesOption, ecModel);\n        // TODO Merge data?\n        if (data) {\n            set$1(this, 'data', data);\n            set$1(this, 'dataBeforeProcessed', data.cloneShallow());\n        }\n    },\n\n    fillDataTextStyle: function (data) {\n        // Default data label emphasis `show`\n        // FIXME Tree structure data ?\n        // FIXME Performance ?\n        if (data) {\n            var props = ['show'];\n            for (var i = 0; i < data.length; i++) {\n                if (data[i] && data[i].label) {\n                    defaultEmphasis(data[i].label, props);\n                }\n            }\n        }\n    },\n\n    /**\n     * Init a data structure from data related option in series\n     * Must be overwritten\n     */\n    getInitialData: function () {},\n\n    /**\n     * @param {string} [dataType]\n     * @return {module:echarts/data/List}\n     */\n    getData: function (dataType) {\n        var data = get(this, 'data');\n        return dataType == null ? data : data.getLinkedData(dataType);\n    },\n\n    /**\n     * @param {module:echarts/data/List} data\n     */\n    setData: function (data) {\n        set$1(this, 'data', data);\n    },\n\n    /**\n     * Get data before processed\n     * @return {module:echarts/data/List}\n     */\n    getRawData: function () {\n        return get(this, 'dataBeforeProcessed');\n    },\n\n    /**\n     * Coord dimension to data dimension.\n     *\n     * By default the result is the same as dimensions of series data.\n     * But in some series data dimensions are different from coord dimensions (i.e.\n     * candlestick and boxplot). Override this method to handle those cases.\n     *\n     * Coord dimension to data dimension can be one-to-many\n     *\n     * @param {string} coordDim\n     * @return {Array.<string>} dimensions on the axis.\n     */\n    coordDimToDataDim: function (coordDim) {\n        return coordDimToDataDim(this.getData(), coordDim);\n    },\n\n    /**\n     * Convert data dimension to coord dimension.\n     *\n     * @param {string|number} dataDim\n     * @return {string}\n     */\n    dataDimToCoordDim: function (dataDim) {\n        return dataDimToCoordDim(this.getData(), dataDim);\n    },\n\n    /**\n     * Get base axis if has coordinate system and has axis.\n     * By default use coordSys.getBaseAxis();\n     * Can be overrided for some chart.\n     * @return {type} description\n     */\n    getBaseAxis: function () {\n        var coordSys = this.coordinateSystem;\n        return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n    },\n\n    // FIXME\n    /**\n     * Default tooltip formatter\n     *\n     * @param {number} dataIndex\n     * @param {boolean} [multipleSeries=false]\n     * @param {number} [dataType]\n     */\n    formatTooltip: function (dataIndex, multipleSeries, dataType) {\n        function formatArrayValue(value) {\n            var vertially = reduce(value, function (vertially, val, idx) {\n                var dimItem = data.getDimensionInfo(idx);\n                return vertially |= dimItem && dimItem.tooltip !== false && dimItem.tooltipName != null;\n            }, 0);\n\n            var result = [];\n            var tooltipDims = otherDimToDataDim(data, 'tooltip');\n\n            tooltipDims.length\n                ? each$1(tooltipDims, function (dimIdx) {\n                    setEachItem(data.get(dimIdx, dataIndex), dimIdx);\n                })\n                // By default, all dims is used on tooltip.\n                : each$1(value, setEachItem);\n\n            function setEachItem(val, dimIdx) {\n                var dimInfo = data.getDimensionInfo(dimIdx);\n                // If `dimInfo.tooltip` is not set, show tooltip.\n                if (!dimInfo || dimInfo.otherDims.tooltip === false) {\n                    return;\n                }\n                var dimType = dimInfo.type;\n                var valStr = (vertially ? '- ' + (dimInfo.tooltipName || dimInfo.name) + ': ' : '')\n                    + (dimType === 'ordinal'\n                        ? val + ''\n                        : dimType === 'time'\n                        ? (multipleSeries ? '' : formatTime('yyyy/MM/dd hh:mm:ss', val))\n                        : addCommas(val)\n                    );\n                valStr && result.push(encodeHTML(valStr));\n            }\n\n            return (vertially ? '<br/>' : '') + result.join(vertially ? '<br/>' : ', ');\n        }\n\n        var data = get(this, 'data');\n\n        var value = this.getRawValue(dataIndex);\n        var formattedValue = isArray(value)\n            ? formatArrayValue(value) : encodeHTML(addCommas(value));\n        var name = data.getName(dataIndex);\n\n        var color = data.getItemVisual(dataIndex, 'color');\n        if (isObject(color) && color.colorStops) {\n            color = (color.colorStops[0] || {}).color;\n        }\n        color = color || 'transparent';\n\n        var colorEl = getTooltipMarker(color);\n\n        var seriesName = this.name;\n        // FIXME\n        if (seriesName === '\\0-') {\n            // Not show '-'\n            seriesName = '';\n        }\n        seriesName = seriesName\n            ? encodeHTML(seriesName) + (!multipleSeries ? '<br/>' : ': ')\n            : '';\n        return !multipleSeries\n            ? seriesName + colorEl\n                + (name\n                    ? encodeHTML(name) + ': ' + formattedValue\n                    : formattedValue\n                )\n            : colorEl + seriesName + formattedValue;\n    },\n\n    /**\n     * @return {boolean}\n     */\n    isAnimationEnabled: function () {\n        if (env$1.node) {\n            return false;\n        }\n\n        var animationEnabled = this.getShallow('animation');\n        if (animationEnabled) {\n            if (this.getData().count() > this.getShallow('animationThreshold')) {\n                animationEnabled = false;\n            }\n        }\n        return animationEnabled;\n    },\n\n    restoreData: function () {\n        set$1(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());\n    },\n\n    getColorFromPalette: function (name, scope) {\n        var ecModel = this.ecModel;\n        // PENDING\n        var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n        if (!color) {\n            color = ecModel.getColorFromPalette(name, scope);\n        }\n        return color;\n    },\n\n    /**\n     * Get data indices for show tooltip content. See tooltip.\n     * @abstract\n     * @param {Array.<string>|string} dim\n     * @param {Array.<number>} value\n     * @param {module:echarts/coord/single/SingleAxis} baseAxis\n     * @return {Object} {dataIndices, nestestValue}.\n     */\n    getAxisTooltipData: null,\n\n    /**\n     * See tooltip.\n     * @abstract\n     * @param {number} dataIndex\n     * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n     */\n    getTooltipPosition: null\n});\n\nmixin(SeriesModel, dataFormatMixin);\nmixin(SeriesModel, colorPaletteMixin);\n\nvar Component = function () {\n    /**\n     * @type {module:zrender/container/Group}\n     * @readOnly\n     */\n    this.group = new Group();\n\n    /**\n     * @type {string}\n     * @readOnly\n     */\n    this.uid = getUID('viewComponent');\n};\n\nComponent.prototype = {\n\n    constructor: Component,\n\n    init: function (ecModel, api) {},\n\n    render: function (componentModel, ecModel, api, payload) {},\n\n    dispose: function () {}\n\n};\n\nvar componentProto = Component.prototype;\ncomponentProto.updateView\n    = componentProto.updateLayout\n    = componentProto.updateVisual\n    = function (seriesModel, ecModel, api, payload) {\n        // Do nothing;\n    };\n// Enable Component.extend.\nenableClassExtend(Component);\n\n// Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\nenableClassManagement(Component, {registerWhenExtend: true});\n\nfunction Chart() {\n\n    /**\n     * @type {module:zrender/container/Group}\n     * @readOnly\n     */\n    this.group = new Group();\n\n    /**\n     * @type {string}\n     * @readOnly\n     */\n    this.uid = getUID('viewChart');\n}\n\nChart.prototype = {\n\n    type: 'chart',\n\n    /**\n     * Init the chart\n     * @param  {module:echarts/model/Global} ecModel\n     * @param  {module:echarts/ExtensionAPI} api\n     */\n    init: function (ecModel, api) {},\n\n    /**\n     * Render the chart\n     * @param  {module:echarts/model/Series} seriesModel\n     * @param  {module:echarts/model/Global} ecModel\n     * @param  {module:echarts/ExtensionAPI} api\n     * @param  {Object} payload\n     */\n    render: function (seriesModel, ecModel, api, payload) {},\n\n    /**\n     * Highlight series or specified data item\n     * @param  {module:echarts/model/Series} seriesModel\n     * @param  {module:echarts/model/Global} ecModel\n     * @param  {module:echarts/ExtensionAPI} api\n     * @param  {Object} payload\n     */\n    highlight: function (seriesModel, ecModel, api, payload) {\n        toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n    },\n\n    /**\n     * Downplay series or specified data item\n     * @param  {module:echarts/model/Series} seriesModel\n     * @param  {module:echarts/model/Global} ecModel\n     * @param  {module:echarts/ExtensionAPI} api\n     * @param  {Object} payload\n     */\n    downplay: function (seriesModel, ecModel, api, payload) {\n        toggleHighlight(seriesModel.getData(), payload, 'normal');\n    },\n\n    /**\n     * Remove self\n     * @param  {module:echarts/model/Global} ecModel\n     * @param  {module:echarts/ExtensionAPI} api\n     */\n    remove: function (ecModel, api) {\n        this.group.removeAll();\n    },\n\n    /**\n     * Dispose self\n     * @param  {module:echarts/model/Global} ecModel\n     * @param  {module:echarts/ExtensionAPI} api\n     */\n    dispose: function () {}\n\n    /**\n     * The view contains the given point.\n     * @interface\n     * @param {Array.<number>} point\n     * @return {boolean}\n     */\n    // containPoint: function () {}\n\n};\n\nvar chartProto = Chart.prototype;\nchartProto.updateView\n    = chartProto.updateLayout\n    = chartProto.updateVisual\n    = function (seriesModel, ecModel, api, payload) {\n        this.render(seriesModel, ecModel, api, payload);\n    };\n\n/**\n * Set state of single element\n * @param  {module:zrender/Element} el\n * @param  {string} state\n */\nfunction elSetState(el, state) {\n    if (el) {\n        el.trigger(state);\n        if (el.type === 'group') {\n            for (var i = 0; i < el.childCount(); i++) {\n                elSetState(el.childAt(i), state);\n            }\n        }\n    }\n}\n/**\n * @param  {module:echarts/data/List} data\n * @param  {Object} payload\n * @param  {string} state 'normal'|'emphasis'\n * @inner\n */\nfunction toggleHighlight(data, payload, state) {\n    var dataIndex = queryDataIndex(data, payload);\n\n    if (dataIndex != null) {\n        each$1(normalizeToArray(dataIndex), function (dataIdx) {\n            elSetState(data.getItemGraphicEl(dataIdx), state);\n        });\n    }\n    else {\n        data.eachItemGraphicEl(function (el) {\n            elSetState(el, state);\n        });\n    }\n}\n\n// Enable Chart.extend.\nenableClassExtend(Chart, ['dispose']);\n\n// Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\nenableClassManagement(Chart, {registerWhenExtend: true});\n\nvar ORIGIN_METHOD = '\\0__throttleOriginMethod';\nvar RATE = '\\0__throttleRate';\nvar THROTTLE_TYPE = '\\0__throttleType';\n\n/**\n * @public\n * @param {(Function)} fn\n * @param {number} [delay=0] Unit: ms.\n * @param {boolean} [debounce=false]\n *        true: If call interval less than `delay`, only the last call works.\n *        false: If call interval less than `delay, call works on fixed rate.\n * @return {(Function)} throttled fn.\n */\nfunction throttle(fn, delay, debounce) {\n\n    var currCall;\n    var lastCall = 0;\n    var lastExec = 0;\n    var timer = null;\n    var diff;\n    var scope;\n    var args;\n    var debounceNextCall;\n\n    delay = delay || 0;\n\n    function exec() {\n        lastExec = (new Date()).getTime();\n        timer = null;\n        fn.apply(scope, args || []);\n    }\n\n    var cb = function () {\n        currCall = (new Date()).getTime();\n        scope = this;\n        args = arguments;\n        var thisDelay = debounceNextCall || delay;\n        var thisDebounce = debounceNextCall || debounce;\n        debounceNextCall = null;\n        diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;\n\n        clearTimeout(timer);\n\n        if (thisDebounce) {\n            timer = setTimeout(exec, thisDelay);\n        }\n        else {\n            if (diff >= 0) {\n                exec();\n            }\n            else {\n                timer = setTimeout(exec, -diff);\n            }\n        }\n\n        lastCall = currCall;\n    };\n\n    /**\n     * Clear throttle.\n     * @public\n     */\n    cb.clear = function () {\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n        }\n    };\n\n    /**\n     * Enable debounce once.\n     */\n    cb.debounceNextCall = function (debounceDelay) {\n        debounceNextCall = debounceDelay;\n    };\n\n    return cb;\n}\n\n/**\n * Create throttle method or update throttle rate.\n *\n * @example\n * ComponentView.prototype.render = function () {\n *     ...\n *     throttle.createOrUpdate(\n *         this,\n *         '_dispatchAction',\n *         this.model.get('throttle'),\n *         'fixRate'\n *     );\n * };\n * ComponentView.prototype.remove = function () {\n *     throttle.clear(this, '_dispatchAction');\n * };\n * ComponentView.prototype.dispose = function () {\n *     throttle.clear(this, '_dispatchAction');\n * };\n *\n * @public\n * @param {Object} obj\n * @param {string} fnAttr\n * @param {number} [rate]\n * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n * @return {Function} throttled function.\n */\nfunction createOrUpdate(obj, fnAttr, rate, throttleType) {\n    var fn = obj[fnAttr];\n\n    if (!fn) {\n        return;\n    }\n\n    var originFn = fn[ORIGIN_METHOD] || fn;\n    var lastThrottleType = fn[THROTTLE_TYPE];\n    var lastRate = fn[RATE];\n\n    if (lastRate !== rate || lastThrottleType !== throttleType) {\n        if (rate == null || !throttleType) {\n            return (obj[fnAttr] = originFn);\n        }\n\n        fn = obj[fnAttr] = throttle(\n            originFn, rate, throttleType === 'debounce'\n        );\n        fn[ORIGIN_METHOD] = originFn;\n        fn[THROTTLE_TYPE] = throttleType;\n        fn[RATE] = rate;\n    }\n\n    return fn;\n}\n\n/**\n * Clear throttle. Example see throttle.createOrUpdate.\n *\n * @public\n * @param {Object} obj\n * @param {string} fnAttr\n */\nfunction clear(obj, fnAttr) {\n    var fn = obj[fnAttr];\n    if (fn && fn[ORIGIN_METHOD]) {\n        obj[fnAttr] = fn[ORIGIN_METHOD];\n    }\n}\n\nvar seriesColor = function (ecModel) {\n    function encodeColor(seriesModel) {\n        var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n        var data = seriesModel.getData();\n        var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n            || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\n        // FIXME Set color function or use the platte color\n        data.setVisual('color', color);\n\n        // Only visible series has each data be visual encoded\n        if (!ecModel.isSeriesFiltered(seriesModel)) {\n            if (typeof color === 'function' && !(color instanceof Gradient)) {\n                data.each(function (idx) {\n                    data.setItemVisual(\n                        idx, 'color', color(seriesModel.getDataParams(idx))\n                    );\n                });\n            }\n\n            // itemStyle in each data item\n            data.each(function (idx) {\n                var itemModel = data.getItemModel(idx);\n                var color = itemModel.get(colorAccessPath, true);\n                if (color != null) {\n                    data.setItemVisual(idx, 'color', color);\n                }\n            });\n        }\n    }\n    ecModel.eachRawSeries(encodeColor);\n};\n\nvar PI$1 = Math.PI;\n\n/**\n * @param {module:echarts/ExtensionAPI} api\n * @param {Object} [opts]\n * @param {string} [opts.text]\n * @param {string} [opts.color]\n * @param {string} [opts.textColor]\n * @return {module:zrender/Element}\n */\nvar loadingDefault = function (api, opts) {\n    opts = opts || {};\n    defaults(opts, {\n        text: 'loading',\n        color: '#c23531',\n        textColor: '#000',\n        maskColor: 'rgba(255, 255, 255, 0.8)',\n        zlevel: 0\n    });\n    var mask = new Rect({\n        style: {\n            fill: opts.maskColor\n        },\n        zlevel: opts.zlevel,\n        z: 10000\n    });\n    var arc = new Arc({\n        shape: {\n            startAngle: -PI$1 / 2,\n            endAngle: -PI$1 / 2 + 0.1,\n            r: 10\n        },\n        style: {\n            stroke: opts.color,\n            lineCap: 'round',\n            lineWidth: 5\n        },\n        zlevel: opts.zlevel,\n        z: 10001\n    });\n    var labelRect = new Rect({\n        style: {\n            fill: 'none',\n            text: opts.text,\n            textPosition: 'right',\n            textDistance: 10,\n            textFill: opts.textColor\n        },\n        zlevel: opts.zlevel,\n        z: 10001\n    });\n\n    arc.animateShape(true)\n        .when(1000, {\n            endAngle: PI$1 * 3 / 2\n        })\n        .start('circularInOut');\n    arc.animateShape(true)\n        .when(1000, {\n            startAngle: PI$1 * 3 / 2\n        })\n        .delay(300)\n        .start('circularInOut');\n\n    var group = new Group();\n    group.add(arc);\n    group.add(labelRect);\n    group.add(mask);\n    // Inject resize\n    group.resize = function () {\n        var cx = api.getWidth() / 2;\n        var cy = api.getHeight() / 2;\n        arc.setShape({\n            cx: cx,\n            cy: cy\n        });\n        var r = arc.shape.r;\n        labelRect.setShape({\n            x: cx - r,\n            y: cy - r,\n            width: r * 2,\n            height: r * 2\n        });\n\n        mask.setShape({\n            x: 0,\n            y: 0,\n            width: api.getWidth(),\n            height: api.getHeight()\n        });\n    };\n    group.resize();\n    return group;\n};\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\n\nvar each = each$1;\nvar parseClassType = ComponentModel.parseClassType;\n\nvar version = '3.8.4';\n\nvar dependencies = {\n    zrender: '3.7.3'\n};\n\nvar PRIORITY_PROCESSOR_FILTER = 1000;\nvar PRIORITY_PROCESSOR_STATISTIC = 5000;\n\nvar PRIORITY_VISUAL_LAYOUT = 1000;\nvar PRIORITY_VISUAL_GLOBAL = 2000;\nvar PRIORITY_VISUAL_CHART = 3000;\nvar PRIORITY_VISUAL_COMPONENT = 4000;\n// FIXME\n// necessary?\nvar PRIORITY_VISUAL_BRUSH = 5000;\n\nvar PRIORITY = {\n    PROCESSOR: {\n        FILTER: PRIORITY_PROCESSOR_FILTER,\n        STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n    },\n    VISUAL: {\n        LAYOUT: PRIORITY_VISUAL_LAYOUT,\n        GLOBAL: PRIORITY_VISUAL_GLOBAL,\n        CHART: PRIORITY_VISUAL_CHART,\n        COMPONENT: PRIORITY_VISUAL_COMPONENT,\n        BRUSH: PRIORITY_VISUAL_BRUSH\n    }\n};\n\n// Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n// where they must not be invoked nestedly, except the only case: invoke\n// dispatchAction with updateMethod \"none\" in main process.\n// This flag is used to carry out this rule.\n// All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\nvar IN_MAIN_PROCESS = '__flagInMainProcess';\nvar HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\nvar OPTION_UPDATED = '__optionUpdated';\nvar ACTION_REG = /^[a-zA-Z0-9_]+$/;\n\n\nfunction createRegisterEventWithLowercaseName(method) {\n    return function (eventName, handler, context) {\n        // Event name is all lowercase\n        eventName = eventName && eventName.toLowerCase();\n        Eventful.prototype[method].call(this, eventName, handler, context);\n    };\n}\n\n/**\n * @module echarts~MessageCenter\n */\nfunction MessageCenter() {\n    Eventful.call(this);\n}\nMessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\nMessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\nMessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\nmixin(MessageCenter, Eventful);\n\n/**\n * @module echarts~ECharts\n */\nfunction ECharts(dom, theme, opts) {\n    opts = opts || {};\n\n    // Get theme by name\n    if (typeof theme === 'string') {\n        theme = themeStorage[theme];\n    }\n\n    /**\n     * @type {string}\n     */\n    this.id;\n\n    /**\n     * Group id\n     * @type {string}\n     */\n    this.group;\n\n    /**\n     * @type {HTMLElement}\n     * @private\n     */\n    this._dom = dom;\n\n    var defaultRenderer = 'canvas';\n    if (__DEV__) {\n        defaultRenderer = (\n            typeof window === 'undefined' ? global : window\n        ).__ECHARTS__DEFAULT__RENDERER__ || defaultRenderer;\n    }\n\n    /**\n     * @type {module:zrender/ZRender}\n     * @private\n     */\n    var zr = this._zr = init$1(dom, {\n        renderer: opts.renderer || defaultRenderer,\n        devicePixelRatio: opts.devicePixelRatio,\n        width: opts.width,\n        height: opts.height\n    });\n\n    /**\n     * Expect 60 pfs.\n     * @type {Function}\n     * @private\n     */\n    this._throttledZrFlush = throttle(bind(zr.flush, zr), 17);\n\n    var theme = clone(theme);\n    theme && backwardCompat(theme, true);\n    /**\n     * @type {Object}\n     * @private\n     */\n    this._theme = theme;\n\n    /**\n     * @type {Array.<module:echarts/view/Chart>}\n     * @private\n     */\n    this._chartsViews = [];\n\n    /**\n     * @type {Object.<string, module:echarts/view/Chart>}\n     * @private\n     */\n    this._chartsMap = {};\n\n    /**\n     * @type {Array.<module:echarts/view/Component>}\n     * @private\n     */\n    this._componentsViews = [];\n\n    /**\n     * @type {Object.<string, module:echarts/view/Component>}\n     * @private\n     */\n    this._componentsMap = {};\n\n    /**\n     * @type {module:echarts/CoordinateSystem}\n     * @private\n     */\n    this._coordSysMgr = new CoordinateSystemManager();\n\n    /**\n     * @type {module:echarts/ExtensionAPI}\n     * @private\n     */\n    this._api = createExtensionAPI(this);\n\n    Eventful.call(this);\n\n    /**\n     * @type {module:echarts~MessageCenter}\n     * @private\n     */\n    this._messageCenter = new MessageCenter();\n\n    // Init mouse events\n    this._initEvents();\n\n    // In case some people write `window.onresize = chart.resize`\n    this.resize = bind(this.resize, this);\n\n    // Can't dispatch action during rendering procedure\n    this._pendingActions = [];\n    // Sort on demand\n    function prioritySortFunc(a, b) {\n        return a.prio - b.prio;\n    }\n    sort(visualFuncs, prioritySortFunc);\n    sort(dataProcessorFuncs, prioritySortFunc);\n\n    zr.animation.on('frame', this._onframe, this);\n\n    // ECharts instance can be used as value.\n    setAsPrimitive(this);\n}\n\nvar echartsProto = ECharts.prototype;\n\nechartsProto._onframe = function () {\n    // Lazy update\n    if (this[OPTION_UPDATED]) {\n        var silent = this[OPTION_UPDATED].silent;\n\n        this[IN_MAIN_PROCESS] = true;\n\n        updateMethods.prepareAndUpdate.call(this);\n\n        this[IN_MAIN_PROCESS] = false;\n\n        this[OPTION_UPDATED] = false;\n\n        flushPendingActions.call(this, silent);\n\n        triggerUpdatedEvent.call(this, silent);\n    }\n};\n/**\n * @return {HTMLElement}\n */\nechartsProto.getDom = function () {\n    return this._dom;\n};\n\n/**\n * @return {module:zrender~ZRender}\n */\nechartsProto.getZr = function () {\n    return this._zr;\n};\n\n/**\n * Usage:\n * chart.setOption(option, notMerge, lazyUpdate);\n * chart.setOption(option, {\n *     notMerge: ...,\n *     lazyUpdate: ...,\n *     silent: ...\n * });\n *\n * @param {Object} option\n * @param {Object|boolean} [opts] opts or notMerge.\n * @param {boolean} [opts.notMerge=false]\n * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.\n */\nechartsProto.setOption = function (option, notMerge, lazyUpdate) {\n    if (__DEV__) {\n        assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n    }\n\n    var silent;\n    if (isObject(notMerge)) {\n        lazyUpdate = notMerge.lazyUpdate;\n        silent = notMerge.silent;\n        notMerge = notMerge.notMerge;\n    }\n\n    this[IN_MAIN_PROCESS] = true;\n\n    if (!this._model || notMerge) {\n        var optionManager = new OptionManager(this._api);\n        var theme = this._theme;\n        var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n        ecModel.init(null, null, theme, optionManager);\n    }\n\n    this._model.setOption(option, optionPreprocessorFuncs);\n\n    if (lazyUpdate) {\n        this[OPTION_UPDATED] = {silent: silent};\n        this[IN_MAIN_PROCESS] = false;\n    }\n    else {\n        updateMethods.prepareAndUpdate.call(this);\n        // Ensure zr refresh sychronously, and then pixel in canvas can be\n        // fetched after `setOption`.\n        this._zr.flush();\n\n        this[OPTION_UPDATED] = false;\n        this[IN_MAIN_PROCESS] = false;\n\n        flushPendingActions.call(this, silent);\n        triggerUpdatedEvent.call(this, silent);\n    }\n};\n\n/**\n * @DEPRECATED\n */\nechartsProto.setTheme = function () {\n    console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n};\n\n/**\n * @return {module:echarts/model/Global}\n */\nechartsProto.getModel = function () {\n    return this._model;\n};\n\n/**\n * @return {Object}\n */\nechartsProto.getOption = function () {\n    return this._model && this._model.getOption();\n};\n\n/**\n * @return {number}\n */\nechartsProto.getWidth = function () {\n    return this._zr.getWidth();\n};\n\n/**\n * @return {number}\n */\nechartsProto.getHeight = function () {\n    return this._zr.getHeight();\n};\n\n/**\n * @return {number}\n */\nechartsProto.getDevicePixelRatio = function () {\n    return this._zr.painter.dpr || window.devicePixelRatio || 1;\n};\n\n/**\n * Get canvas which has all thing rendered\n * @param {Object} opts\n * @param {string} [opts.backgroundColor]\n * @return {string}\n */\nechartsProto.getRenderedCanvas = function (opts) {\n    if (!env$1.canvasSupported) {\n        return;\n    }\n    opts = opts || {};\n    opts.pixelRatio = opts.pixelRatio || 1;\n    opts.backgroundColor = opts.backgroundColor\n        || this._model.get('backgroundColor');\n    var zr = this._zr;\n    var list = zr.storage.getDisplayList();\n    // Stop animations\n    each$1(list, function (el) {\n        el.stopAnimation(true);\n    });\n    return zr.painter.getRenderedCanvas(opts);\n};\n\n/**\n * Get svg data url\n * @return {string}\n */\nechartsProto.getSvgDataUrl = function () {\n    if (!env$1.svgSupported) {\n        return;\n    }\n\n    var zr = this._zr;\n    var list = zr.storage.getDisplayList();\n    // Stop animations\n    each$1(list, function (el) {\n        el.stopAnimation(true);\n    });\n\n    return zr.painter.pathToSvg();\n};\n\n/**\n * @return {string}\n * @param {Object} opts\n * @param {string} [opts.type='png']\n * @param {string} [opts.pixelRatio=1]\n * @param {string} [opts.backgroundColor]\n * @param {string} [opts.excludeComponents]\n */\nechartsProto.getDataURL = function (opts) {\n    opts = opts || {};\n    var excludeComponents = opts.excludeComponents;\n    var ecModel = this._model;\n    var excludesComponentViews = [];\n    var self = this;\n\n    each(excludeComponents, function (componentType) {\n        ecModel.eachComponent({\n            mainType: componentType\n        }, function (component) {\n            var view = self._componentsMap[component.__viewId];\n            if (!view.group.ignore) {\n                excludesComponentViews.push(view);\n                view.group.ignore = true;\n            }\n        });\n    });\n\n    var url = this._zr.painter.getType() === 'svg'\n        ? this.getSvgDataUrl()\n        : this.getRenderedCanvas(opts).toDataURL(\n            'image/' + (opts && opts.type || 'png')\n        );\n\n    each(excludesComponentViews, function (view) {\n        view.group.ignore = false;\n    });\n\n    return url;\n};\n\n\n/**\n * @return {string}\n * @param {Object} opts\n * @param {string} [opts.type='png']\n * @param {string} [opts.pixelRatio=1]\n * @param {string} [opts.backgroundColor]\n */\nechartsProto.getConnectedDataURL = function (opts) {\n    if (!env$1.canvasSupported) {\n        return;\n    }\n    var groupId = this.group;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var MAX_NUMBER = Infinity;\n    if (connectedGroups[groupId]) {\n        var left = MAX_NUMBER;\n        var top = MAX_NUMBER;\n        var right = -MAX_NUMBER;\n        var bottom = -MAX_NUMBER;\n        var canvasList = [];\n        var dpr = (opts && opts.pixelRatio) || 1;\n\n        each$1(instances, function (chart, id) {\n            if (chart.group === groupId) {\n                var canvas = chart.getRenderedCanvas(\n                    clone(opts)\n                );\n                var boundingRect = chart.getDom().getBoundingClientRect();\n                left = mathMin(boundingRect.left, left);\n                top = mathMin(boundingRect.top, top);\n                right = mathMax(boundingRect.right, right);\n                bottom = mathMax(boundingRect.bottom, bottom);\n                canvasList.push({\n                    dom: canvas,\n                    left: boundingRect.left,\n                    top: boundingRect.top\n                });\n            }\n        });\n\n        left *= dpr;\n        top *= dpr;\n        right *= dpr;\n        bottom *= dpr;\n        var width = right - left;\n        var height = bottom - top;\n        var targetCanvas = createCanvas();\n        targetCanvas.width = width;\n        targetCanvas.height = height;\n        var zr = init$1(targetCanvas);\n\n        each(canvasList, function (item) {\n            var img = new ZImage({\n                style: {\n                    x: item.left * dpr - left,\n                    y: item.top * dpr - top,\n                    image: item.dom\n                }\n            });\n            zr.add(img);\n        });\n        zr.refreshImmediately();\n\n        return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n    }\n    else {\n        return this.getDataURL(opts);\n    }\n};\n\n/**\n * Convert from logical coordinate system to pixel coordinate system.\n * See CoordinateSystem#convertToPixel.\n * @param {string|Object} finder\n *        If string, e.g., 'geo', means {geoIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex / seriesId / seriesName,\n *            geoIndex / geoId, geoName,\n *            bmapIndex / bmapId / bmapName,\n *            xAxisIndex / xAxisId / xAxisName,\n *            yAxisIndex / yAxisId / yAxisName,\n *            gridIndex / gridId / gridName,\n *            ... (can be extended)\n *        }\n * @param {Array|number} value\n * @return {Array|number} result\n */\nechartsProto.convertToPixel = curry(doConvertPixel, 'convertToPixel');\n\n/**\n * Convert from pixel coordinate system to logical coordinate system.\n * See CoordinateSystem#convertFromPixel.\n * @param {string|Object} finder\n *        If string, e.g., 'geo', means {geoIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex / seriesId / seriesName,\n *            geoIndex / geoId / geoName,\n *            bmapIndex / bmapId / bmapName,\n *            xAxisIndex / xAxisId / xAxisName,\n *            yAxisIndex / yAxisId / yAxisName\n *            gridIndex / gridId / gridName,\n *            ... (can be extended)\n *        }\n * @param {Array|number} value\n * @return {Array|number} result\n */\nechartsProto.convertFromPixel = curry(doConvertPixel, 'convertFromPixel');\n\nfunction doConvertPixel(methodName, finder, value) {\n    var ecModel = this._model;\n    var coordSysList = this._coordSysMgr.getCoordinateSystems();\n    var result;\n\n    finder = parseFinder(ecModel, finder);\n\n    for (var i = 0; i < coordSysList.length; i++) {\n        var coordSys = coordSysList[i];\n        if (coordSys[methodName]\n            && (result = coordSys[methodName](ecModel, finder, value)) != null\n        ) {\n            return result;\n        }\n    }\n\n    if (__DEV__) {\n        console.warn(\n            'No coordinate system that supports ' + methodName + ' found by the given finder.'\n        );\n    }\n}\n\n/**\n * Is the specified coordinate systems or components contain the given pixel point.\n * @param {string|Object} finder\n *        If string, e.g., 'geo', means {geoIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex / seriesId / seriesName,\n *            geoIndex / geoId / geoName,\n *            bmapIndex / bmapId / bmapName,\n *            xAxisIndex / xAxisId / xAxisName,\n *            yAxisIndex / yAxisId / yAxisName,\n *            gridIndex / gridId / gridName,\n *            ... (can be extended)\n *        }\n * @param {Array|number} value\n * @return {boolean} result\n */\nechartsProto.containPixel = function (finder, value) {\n    var ecModel = this._model;\n    var result;\n\n    finder = parseFinder(ecModel, finder);\n\n    each$1(finder, function (models, key) {\n        key.indexOf('Models') >= 0 && each$1(models, function (model) {\n            var coordSys = model.coordinateSystem;\n            if (coordSys && coordSys.containPoint) {\n                result |= !!coordSys.containPoint(value);\n            }\n            else if (key === 'seriesModels') {\n                var view = this._chartsMap[model.__viewId];\n                if (view && view.containPoint) {\n                    result |= view.containPoint(value, model);\n                }\n                else {\n                    if (__DEV__) {\n                        console.warn(key + ': ' + (view\n                            ? 'The found component do not support containPoint.'\n                            : 'No view mapping to the found component.'\n                        ));\n                    }\n                }\n            }\n            else {\n                if (__DEV__) {\n                    console.warn(key + ': containPoint is not supported');\n                }\n            }\n        }, this);\n    }, this);\n\n    return !!result;\n};\n\n/**\n * Get visual from series or data.\n * @param {string|Object} finder\n *        If string, e.g., 'series', means {seriesIndex: 0}.\n *        If Object, could contain some of these properties below:\n *        {\n *            seriesIndex / seriesId / seriesName,\n *            dataIndex / dataIndexInside\n *        }\n *        If dataIndex is not specified, series visual will be fetched,\n *        but not data item visual.\n *        If all of seriesIndex, seriesId, seriesName are not specified,\n *        visual will be fetched from first series.\n * @param {string} visualType 'color', 'symbol', 'symbolSize'\n */\nechartsProto.getVisual = function (finder, visualType) {\n    var ecModel = this._model;\n\n    finder = parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\n    var seriesModel = finder.seriesModel;\n\n    if (__DEV__) {\n        if (!seriesModel) {\n            console.warn('There is no specified seires model');\n        }\n    }\n\n    var data = seriesModel.getData();\n\n    var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n        ? finder.dataIndexInside\n        : finder.hasOwnProperty('dataIndex')\n        ? data.indexOfRawIndex(finder.dataIndex)\n        : null;\n\n    return dataIndexInside != null\n        ? data.getItemVisual(dataIndexInside, visualType)\n        : data.getVisual(visualType);\n};\n\n/**\n * Get view of corresponding component model\n * @param  {module:echarts/model/Component} componentModel\n * @return {module:echarts/view/Component}\n */\nechartsProto.getViewOfComponentModel = function (componentModel) {\n    return this._componentsMap[componentModel.__viewId];\n};\n\n/**\n * Get view of corresponding series model\n * @param  {module:echarts/model/Series} seriesModel\n * @return {module:echarts/view/Chart}\n */\nechartsProto.getViewOfSeriesModel = function (seriesModel) {\n    return this._chartsMap[seriesModel.__viewId];\n};\n\n\nvar updateMethods = {\n\n    /**\n     * @param {Object} payload\n     * @private\n     */\n    update: function (payload) {\n        // console.profile && console.profile('update');\n\n        var ecModel = this._model;\n        var api = this._api;\n        var coordSysMgr = this._coordSysMgr;\n        var zr = this._zr;\n        // update before setOption\n        if (!ecModel) {\n            return;\n        }\n\n        // Fixme First time update ?\n        ecModel.restoreData();\n\n        // TODO\n        // Save total ecModel here for undo/redo (after restoring data and before processing data).\n        // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\n        // Create new coordinate system each update\n        // In LineView may save the old coordinate system and use it to get the orignal point\n        coordSysMgr.create(this._model, this._api);\n\n        processData.call(this, ecModel, api);\n\n        stackSeriesData.call(this, ecModel);\n\n        coordSysMgr.update(ecModel, api);\n\n        doVisualEncoding.call(this, ecModel, payload);\n\n        doRender.call(this, ecModel, payload);\n\n        // Set background\n        var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\n        var painter = zr.painter;\n        // TODO all use clearColor ?\n        if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n            zr.configLayer(0, {\n                clearColor: backgroundColor\n            });\n        }\n        else {\n            // In IE8\n            if (!env$1.canvasSupported) {\n                var colorArr = parse(backgroundColor);\n                backgroundColor = stringify(colorArr, 'rgb');\n                if (colorArr[3] === 0) {\n                    backgroundColor = 'transparent';\n                }\n            }\n            if (backgroundColor.colorStops || backgroundColor.image) {\n                // Gradient background\n                // FIXME Fixed layer\n                zr.configLayer(0, {\n                    clearColor: backgroundColor\n                });\n                this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\n                this._dom.style.background = 'transparent';\n            }\n            else {\n                if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                    zr.configLayer(0, {\n                        clearColor: null\n                    });\n                }\n                this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\n                this._dom.style.background = backgroundColor;\n            }\n        }\n\n        each(postUpdateFuncs, function (func) {\n            func(ecModel, api);\n        });\n\n        // console.profile && console.profileEnd('update');\n    },\n\n    /**\n     * @param {Object} payload\n     * @private\n     */\n    updateView: function (payload) {\n        var ecModel = this._model;\n\n        // update before setOption\n        if (!ecModel) {\n            return;\n        }\n\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.getData().clearAllVisual();\n        });\n\n        doVisualEncoding.call(this, ecModel, payload);\n\n        invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n    },\n\n    /**\n     * @param {Object} payload\n     * @private\n     */\n    updateVisual: function (payload) {\n        var ecModel = this._model;\n\n        // update before setOption\n        if (!ecModel) {\n            return;\n        }\n\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.getData().clearAllVisual();\n        });\n\n        doVisualEncoding.call(this, ecModel, payload, true);\n\n        invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n    },\n\n    /**\n     * @param {Object} payload\n     * @private\n     */\n    updateLayout: function (payload) {\n        var ecModel = this._model;\n\n        // update before setOption\n        if (!ecModel) {\n            return;\n        }\n\n        doLayout.call(this, ecModel, payload);\n\n        invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n    },\n\n    /**\n     * @param {Object} payload\n     * @private\n     */\n    prepareAndUpdate: function (payload) {\n        var ecModel = this._model;\n\n        prepareView.call(this, 'component', ecModel);\n\n        prepareView.call(this, 'chart', ecModel);\n\n        updateMethods.update.call(this, payload);\n    }\n};\n\n/**\n * @private\n */\nfunction updateDirectly(ecIns, method, payload, mainType, subType) {\n    var ecModel = ecIns._model;\n\n    // broadcast\n    if (!mainType) {\n        each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);\n        return;\n    }\n\n    var query = {};\n    query[mainType + 'Id'] = payload[mainType + 'Id'];\n    query[mainType + 'Index'] = payload[mainType + 'Index'];\n    query[mainType + 'Name'] = payload[mainType + 'Name'];\n\n    var condition = {mainType: mainType, query: query};\n    subType && (condition.subType = subType); // subType may be '' by parseClassType;\n\n    // If dispatchAction before setOption, do nothing.\n    ecModel && ecModel.eachComponent(condition, function (model, index) {\n        callView(ecIns[\n            mainType === 'series' ? '_chartsMap' : '_componentsMap'\n        ][model.__viewId]);\n    }, ecIns);\n\n    function callView(view) {\n        view && view.__alive && view[method] && view[method](\n            view.__model, ecModel, ecIns._api, payload\n        );\n    }\n}\n\n/**\n * Resize the chart\n * @param {Object} opts\n * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n * @param {boolean} [opts.silent=false]\n */\nechartsProto.resize = function (opts) {\n    if (__DEV__) {\n        assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n    }\n\n    this[IN_MAIN_PROCESS] = true;\n\n    this._zr.resize(opts);\n\n    var optionChanged = this._model && this._model.resetOption('media');\n    var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';\n\n    updateMethods[updateMethod].call(this);\n\n    // Resize loading effect\n    this._loadingFX && this._loadingFX.resize();\n\n    this[IN_MAIN_PROCESS] = false;\n\n    var silent = opts && opts.silent;\n\n    flushPendingActions.call(this, silent);\n\n    triggerUpdatedEvent.call(this, silent);\n};\n\n/**\n * Show loading effect\n * @param  {string} [name='default']\n * @param  {Object} [cfg]\n */\nechartsProto.showLoading = function (name, cfg) {\n    if (isObject(name)) {\n        cfg = name;\n        name = '';\n    }\n    name = name || 'default';\n\n    this.hideLoading();\n    if (!loadingEffects[name]) {\n        if (__DEV__) {\n            console.warn('Loading effects ' + name + ' not exists.');\n        }\n        return;\n    }\n    var el = loadingEffects[name](this._api, cfg);\n    var zr = this._zr;\n    this._loadingFX = el;\n\n    zr.add(el);\n};\n\n/**\n * Hide loading effect\n */\nechartsProto.hideLoading = function () {\n    this._loadingFX && this._zr.remove(this._loadingFX);\n    this._loadingFX = null;\n};\n\n/**\n * @param {Object} eventObj\n * @return {Object}\n */\nechartsProto.makeActionFromEvent = function (eventObj) {\n    var payload = extend({}, eventObj);\n    payload.type = eventActionMap[eventObj.type];\n    return payload;\n};\n\n/**\n * @pubilc\n * @param {Object} payload\n * @param {string} [payload.type] Action type\n * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n * @param {boolean} [opt.silent=false] Whether trigger events.\n * @param {boolean} [opt.flush=undefined]\n *                  true: Flush immediately, and then pixel in canvas can be fetched\n *                      immediately. Caution: it might affect performance.\n *                  false: Not not flush.\n *                  undefined: Auto decide whether perform flush.\n */\nechartsProto.dispatchAction = function (payload, opt) {\n    if (!isObject(opt)) {\n        opt = {silent: !!opt};\n    }\n\n    if (!actions[payload.type]) {\n        return;\n    }\n\n    // Avoid dispatch action before setOption. Especially in `connect`.\n    if (!this._model) {\n        return;\n    }\n\n    // May dispatchAction in rendering procedure\n    if (this[IN_MAIN_PROCESS]) {\n        this._pendingActions.push(payload);\n        return;\n    }\n\n    doDispatchAction.call(this, payload, opt.silent);\n\n    if (opt.flush) {\n        this._zr.flush(true);\n    }\n    else if (opt.flush !== false && env$1.browser.weChat) {\n        // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n        // hang when sliding page (on touch event), which cause that zr does not\n        // refresh util user interaction finished, which is not expected.\n        // But `dispatchAction` may be called too frequently when pan on touch\n        // screen, which impacts performance if do not throttle them.\n        this._throttledZrFlush();\n    }\n\n    flushPendingActions.call(this, opt.silent);\n\n    triggerUpdatedEvent.call(this, opt.silent);\n};\n\nfunction doDispatchAction(payload, silent) {\n    var payloadType = payload.type;\n    var escapeConnect = payload.escapeConnect;\n    var actionWrap = actions[payloadType];\n    var actionInfo = actionWrap.actionInfo;\n\n    var cptType = (actionInfo.update || 'update').split(':');\n    var updateMethod = cptType.pop();\n    cptType = cptType[0] != null && parseClassType(cptType[0]);\n\n    this[IN_MAIN_PROCESS] = true;\n\n    var payloads = [payload];\n    var batched = false;\n    // Batch action\n    if (payload.batch) {\n        batched = true;\n        payloads = map(payload.batch, function (item) {\n            item = defaults(extend({}, item), payload);\n            item.batch = null;\n            return item;\n        });\n    }\n\n    var eventObjBatch = [];\n    var eventObj;\n    var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';\n\n    each(payloads, function (batchItem) {\n        // Action can specify the event by return it.\n        eventObj = actionWrap.action(batchItem, this._model, this._api);\n        // Emit event outside\n        eventObj = eventObj || extend({}, batchItem);\n        // Convert type to eventType\n        eventObj.type = actionInfo.event || eventObj.type;\n        eventObjBatch.push(eventObj);\n\n        // light update does not perform data process, layout and visual.\n        if (isHighDown) {\n            // method, payload, mainType, subType\n            updateDirectly(this, updateMethod, batchItem, 'series');\n        }\n        else if (cptType) {\n            updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);\n        }\n    }, this);\n\n    if (updateMethod !== 'none' && !isHighDown && !cptType) {\n        // Still dirty\n        if (this[OPTION_UPDATED]) {\n            // FIXME Pass payload ?\n            updateMethods.prepareAndUpdate.call(this, payload);\n            this[OPTION_UPDATED] = false;\n        }\n        else {\n            updateMethods[updateMethod].call(this, payload);\n        }\n    }\n\n    // Follow the rule of action batch\n    if (batched) {\n        eventObj = {\n            type: actionInfo.event || payloadType,\n            escapeConnect: escapeConnect,\n            batch: eventObjBatch\n        };\n    }\n    else {\n        eventObj = eventObjBatch[0];\n    }\n\n    this[IN_MAIN_PROCESS] = false;\n\n    !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n}\n\nfunction flushPendingActions(silent) {\n    var pendingActions = this._pendingActions;\n    while (pendingActions.length) {\n        var payload = pendingActions.shift();\n        doDispatchAction.call(this, payload, silent);\n    }\n}\n\nfunction triggerUpdatedEvent(silent) {\n    !silent && this.trigger('updated');\n}\n\n/**\n * Register event\n * @method\n */\nechartsProto.on = createRegisterEventWithLowercaseName('on');\nechartsProto.off = createRegisterEventWithLowercaseName('off');\nechartsProto.one = createRegisterEventWithLowercaseName('one');\n\n/**\n * @param {string} methodName\n * @private\n */\nfunction invokeUpdateMethod(methodName, ecModel, payload) {\n    var api = this._api;\n\n    // Update all components\n    each(this._componentsViews, function (component) {\n        var componentModel = component.__model;\n        component[methodName](componentModel, ecModel, api, payload);\n\n        updateZ(componentModel, component);\n    }, this);\n\n    // Upate all charts\n    ecModel.eachSeries(function (seriesModel, idx) {\n        var chart = this._chartsMap[seriesModel.__viewId];\n        chart[methodName](seriesModel, ecModel, api, payload);\n\n        updateZ(seriesModel, chart);\n\n        updateProgressiveAndBlend(seriesModel, chart);\n    }, this);\n\n    // If use hover layer\n    updateHoverLayerStatus(this._zr, ecModel);\n\n    // Post render\n    each(postUpdateFuncs, function (func) {\n        func(ecModel, api);\n    });\n}\n\n/**\n * Prepare view instances of charts and components\n * @param  {module:echarts/model/Global} ecModel\n * @private\n */\nfunction prepareView(type, ecModel) {\n    var isComponent = type === 'component';\n    var viewList = isComponent ? this._componentsViews : this._chartsViews;\n    var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n    var zr = this._zr;\n\n    for (var i = 0; i < viewList.length; i++) {\n        viewList[i].__alive = false;\n    }\n\n    ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n        if (isComponent) {\n            if (componentType === 'series') {\n                return;\n            }\n        }\n        else {\n            model = componentType;\n        }\n\n        // Consider: id same and type changed.\n        var viewId = '_ec_' + model.id + '_' + model.type;\n        var view = viewMap[viewId];\n        if (!view) {\n            var classType = parseClassType(model.type);\n            var Clazz = isComponent\n                ? Component.getClass(classType.main, classType.sub)\n                : Chart.getClass(classType.sub);\n            if (Clazz) {\n                view = new Clazz();\n                view.init(ecModel, this._api);\n                viewMap[viewId] = view;\n                viewList.push(view);\n                zr.add(view.group);\n            }\n            else {\n                // Error\n                return;\n            }\n        }\n\n        model.__viewId = view.__id = viewId;\n        view.__alive = true;\n        view.__model = model;\n        view.group.__ecComponentInfo = {\n            mainType: model.mainType,\n            index: model.componentIndex\n        };\n    }, this);\n\n    for (var i = 0; i < viewList.length;) {\n        var view = viewList[i];\n        if (!view.__alive) {\n            zr.remove(view.group);\n            view.dispose(ecModel, this._api);\n            viewList.splice(i, 1);\n            delete viewMap[view.__id];\n            view.__id = view.group.__ecComponentInfo = null;\n        }\n        else {\n            i++;\n        }\n    }\n}\n\n/**\n * Processor data in each series\n *\n * @param {module:echarts/model/Global} ecModel\n * @private\n */\nfunction processData(ecModel, api) {\n    each(dataProcessorFuncs, function (process) {\n        process.func(ecModel, api);\n    });\n}\n\n/**\n * @private\n */\nfunction stackSeriesData(ecModel) {\n    var stackedDataMap = {};\n    ecModel.eachSeries(function (series) {\n        var stack = series.get('stack');\n        var data = series.getData();\n        if (stack && data.type === 'list') {\n            var previousStack = stackedDataMap[stack];\n            // Avoid conflict with Object.prototype\n            if (stackedDataMap.hasOwnProperty(stack) && previousStack) {\n                data.stackedOn = previousStack;\n            }\n            stackedDataMap[stack] = data;\n        }\n    });\n}\n\n/**\n * Layout before each chart render there series, special visual encoding stage\n *\n * @param {module:echarts/model/Global} ecModel\n * @private\n */\nfunction doLayout(ecModel, payload) {\n    var api = this._api;\n    each(visualFuncs, function (visual) {\n        if (visual.isLayout) {\n            visual.func(ecModel, api, payload);\n        }\n    });\n}\n\n/**\n * Encode visual infomation from data after data processing\n *\n * @param {module:echarts/model/Global} ecModel\n * @param {object} layout\n * @param {boolean} [excludesLayout]\n * @private\n */\nfunction doVisualEncoding(ecModel, payload, excludesLayout) {\n    var api = this._api;\n    ecModel.clearColorPalette();\n    ecModel.eachSeries(function (seriesModel) {\n        seriesModel.clearColorPalette();\n    });\n    each(visualFuncs, function (visual) {\n        (!excludesLayout || !visual.isLayout)\n            && visual.func(ecModel, api, payload);\n    });\n}\n\n/**\n * Render each chart and component\n * @private\n */\nfunction doRender(ecModel, payload) {\n    var api = this._api;\n    // Render all components\n    each(this._componentsViews, function (componentView) {\n        var componentModel = componentView.__model;\n        componentView.render(componentModel, ecModel, api, payload);\n\n        updateZ(componentModel, componentView);\n    }, this);\n\n    each(this._chartsViews, function (chart) {\n        chart.__alive = false;\n    }, this);\n\n    // Render all charts\n    ecModel.eachSeries(function (seriesModel, idx) {\n        var chartView = this._chartsMap[seriesModel.__viewId];\n        chartView.__alive = true;\n        chartView.render(seriesModel, ecModel, api, payload);\n\n        chartView.group.silent = !!seriesModel.get('silent');\n\n        updateZ(seriesModel, chartView);\n\n        updateProgressiveAndBlend(seriesModel, chartView);\n\n    }, this);\n\n    // If use hover layer\n    updateHoverLayerStatus(this._zr, ecModel);\n\n    // Remove groups of unrendered charts\n    each(this._chartsViews, function (chart) {\n        if (!chart.__alive) {\n            chart.remove(ecModel, api);\n        }\n    }, this);\n}\n\nvar MOUSE_EVENT_NAMES = [\n    'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n    'mousedown', 'mouseup', 'globalout', 'contextmenu'\n];\n/**\n * @private\n */\nechartsProto._initEvents = function () {\n    each(MOUSE_EVENT_NAMES, function (eveName) {\n        this._zr.on(eveName, function (e) {\n            var ecModel = this.getModel();\n            var el = e.target;\n            var params;\n\n            // no e.target when 'globalout'.\n            if (eveName === 'globalout') {\n                params = {};\n            }\n            else if (el && el.dataIndex != null) {\n                var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n            }\n            // If element has custom eventData of components\n            else if (el && el.eventData) {\n                params = extend({}, el.eventData);\n            }\n\n            if (params) {\n                params.event = e;\n                params.type = eveName;\n                this.trigger(eveName, params);\n            }\n\n        }, this);\n    }, this);\n\n    each(eventActionMap, function (actionType, eventType) {\n        this._messageCenter.on(eventType, function (event) {\n            this.trigger(eventType, event);\n        }, this);\n    }, this);\n};\n\n/**\n * @return {boolean}\n */\nechartsProto.isDisposed = function () {\n    return this._disposed;\n};\n\n/**\n * Clear\n */\nechartsProto.clear = function () {\n    this.setOption({ series: [] }, true);\n};\n\n/**\n * Dispose instance\n */\nechartsProto.dispose = function () {\n    if (this._disposed) {\n        if (__DEV__) {\n            console.warn('Instance ' + this.id + ' has been disposed');\n        }\n        return;\n    }\n    this._disposed = true;\n\n    var api = this._api;\n    var ecModel = this._model;\n\n    each(this._componentsViews, function (component) {\n        component.dispose(ecModel, api);\n    });\n    each(this._chartsViews, function (chart) {\n        chart.dispose(ecModel, api);\n    });\n\n    // Dispose after all views disposed\n    this._zr.dispose();\n\n    delete instances[this.id];\n};\n\nmixin(ECharts, Eventful);\n\nfunction updateHoverLayerStatus(zr, ecModel) {\n    var storage = zr.storage;\n    var elCount = 0;\n    storage.traverse(function (el) {\n        if (!el.isGroup) {\n            elCount++;\n        }\n    });\n    if (elCount > ecModel.get('hoverLayerThreshold') && !env$1.node) {\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                el.useHoverLayer = true;\n            }\n        });\n    }\n}\n\n/**\n * Update chart progressive and blend.\n * @param {module:echarts/model/Series|module:echarts/model/Component} model\n * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n */\nfunction updateProgressiveAndBlend(seriesModel, chartView) {\n    // Progressive configuration\n    var elCount = 0;\n    chartView.group.traverse(function (el) {\n        if (el.type !== 'group' && !el.ignore) {\n            elCount++;\n        }\n    });\n    var frameDrawNum = +seriesModel.get('progressive');\n    var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env$1.node;\n    if (needProgressive) {\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.progressive = needProgressive ?\n                    Math.floor(elCount++ / frameDrawNum) : -1;\n                if (needProgressive) {\n                    el.stopAnimation(true);\n                }\n            }\n        });\n    }\n\n    // Blend configration\n    var blendMode = seriesModel.get('blendMode') || null;\n    if (__DEV__) {\n        if (!env$1.canvasSupported && blendMode && blendMode !== 'source-over') {\n            console.warn('Only canvas support blendMode');\n        }\n    }\n    chartView.group.traverse(function (el) {\n        // FIXME marker and other components\n        if (!el.isGroup) {\n            el.setStyle('blend', blendMode);\n        }\n    });\n}\n\n/**\n * @param {module:echarts/model/Series|module:echarts/model/Component} model\n * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n */\nfunction updateZ(model, view) {\n    var z = model.get('z');\n    var zlevel = model.get('zlevel');\n    // Set z and zlevel\n    view.group.traverse(function (el) {\n        if (el.type !== 'group') {\n            z != null && (el.z = z);\n            zlevel != null && (el.zlevel = zlevel);\n        }\n    });\n}\n\nfunction createExtensionAPI(ecInstance) {\n    var coordSysMgr = ecInstance._coordSysMgr;\n    return extend(new ExtensionAPI(ecInstance), {\n        // Inject methods\n        getCoordinateSystems: bind(\n            coordSysMgr.getCoordinateSystems, coordSysMgr\n        ),\n        getComponentByElement: function (el) {\n            while (el) {\n                var modelInfo = el.__ecComponentInfo;\n                if (modelInfo != null) {\n                    return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);\n                }\n                el = el.parent;\n            }\n        }\n    });\n}\n\n/**\n * @type {Object} key: actionType.\n * @inner\n */\nvar actions = {};\n\n/**\n * Map eventType to actionType\n * @type {Object}\n */\nvar eventActionMap = {};\n\n/**\n * Data processor functions of each stage\n * @type {Array.<Object.<string, Function>>}\n * @inner\n */\nvar dataProcessorFuncs = [];\n\n/**\n * @type {Array.<Function>}\n * @inner\n */\nvar optionPreprocessorFuncs = [];\n\n/**\n * @type {Array.<Function>}\n * @inner\n */\nvar postUpdateFuncs = [];\n\n/**\n * Visual encoding functions of each stage\n * @type {Array.<Object.<string, Function>>}\n * @inner\n */\nvar visualFuncs = [];\n/**\n * Theme storage\n * @type {Object.<key, Object>}\n */\nvar themeStorage = {};\n/**\n * Loading effects\n */\nvar loadingEffects = {};\n\nvar instances = {};\nvar connectedGroups = {};\n\nvar idBase = new Date() - 0;\nvar groupIdBase = new Date() - 0;\nvar DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n\nvar mapDataStores = {};\n\nfunction enableConnect(chart) {\n    var STATUS_PENDING = 0;\n    var STATUS_UPDATING = 1;\n    var STATUS_UPDATED = 2;\n    var STATUS_KEY = '__connectUpdateStatus';\n\n    function updateConnectedChartsStatus(charts, status) {\n        for (var i = 0; i < charts.length; i++) {\n            var otherChart = charts[i];\n            otherChart[STATUS_KEY] = status;\n        }\n    }\n\n    each$1(eventActionMap, function (actionType, eventType) {\n        chart._messageCenter.on(eventType, function (event) {\n            if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                if (event && event.escapeConnect) {\n                    return;\n                }\n\n                var action = chart.makeActionFromEvent(event);\n                var otherCharts = [];\n\n                each$1(instances, function (otherChart) {\n                    if (otherChart !== chart && otherChart.group === chart.group) {\n                        otherCharts.push(otherChart);\n                    }\n                });\n\n                updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                each(otherCharts, function (otherChart) {\n                    if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                        otherChart.dispatchAction(action);\n                    }\n                });\n                updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n            }\n        });\n    });\n}\n\n/**\n * @param {HTMLElement} dom\n * @param {Object} [theme]\n * @param {Object} opts\n * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n *                              Can be 'auto' (the same as null/undefined)\n * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n *                               Can be 'auto' (the same as null/undefined)\n */\nfunction init(dom, theme, opts) {\n    if (__DEV__) {\n        // Check version\n        if ((version$1.replace('.', '') - 0) < (dependencies.zrender.replace('.', '') - 0)) {\n            throw new Error(\n                'zrender/src ' + version$1\n                + ' is too old for ECharts ' + version\n                + '. Current version need ZRender '\n                + dependencies.zrender + '+'\n            );\n        }\n\n        if (!dom) {\n            throw new Error('Initialize failed: invalid dom.');\n        }\n    }\n\n    var existInstance = getInstanceByDom(dom);\n    if (existInstance) {\n        if (__DEV__) {\n            console.warn('There is a chart instance already initialized on the dom.');\n        }\n        return existInstance;\n    }\n\n    if (__DEV__) {\n        if (isDom(dom)\n            && dom.nodeName.toUpperCase() !== 'CANVAS'\n            && (\n                (!dom.clientWidth && (!opts || opts.width == null))\n                || (!dom.clientHeight && (!opts || opts.height == null))\n            )\n        ) {\n            console.warn('Can\\'t get dom width or height');\n        }\n    }\n\n    var chart = new ECharts(dom, theme, opts);\n    chart.id = 'ec_' + idBase++;\n    instances[chart.id] = chart;\n\n    if (dom.setAttribute) {\n        dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n    }\n    else {\n        dom[DOM_ATTRIBUTE_KEY] = chart.id;\n    }\n\n    enableConnect(chart);\n\n    return chart;\n}\n\n/**\n * @return {string|Array.<module:echarts~ECharts>} groupId\n */\nfunction connect(groupId) {\n    // Is array of charts\n    if (isArray(groupId)) {\n        var charts = groupId;\n        groupId = null;\n        // If any chart has group\n        each$1(charts, function (chart) {\n            if (chart.group != null) {\n                groupId = chart.group;\n            }\n        });\n        groupId = groupId || ('g_' + groupIdBase++);\n        each$1(charts, function (chart) {\n            chart.group = groupId;\n        });\n    }\n    connectedGroups[groupId] = true;\n    return groupId;\n}\n\n/**\n * @DEPRECATED\n * @return {string} groupId\n */\nfunction disConnect(groupId) {\n    connectedGroups[groupId] = false;\n}\n\n/**\n * @return {string} groupId\n */\nvar disconnect = disConnect;\n\n/**\n * Dispose a chart instance\n * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n */\nfunction dispose(chart) {\n    if (typeof chart === 'string') {\n        chart = instances[chart];\n    }\n    else if (!(chart instanceof ECharts)){\n        // Try to treat as dom\n        chart = getInstanceByDom(chart);\n    }\n    if ((chart instanceof ECharts) && !chart.isDisposed()) {\n        chart.dispose();\n    }\n}\n\n/**\n * @param  {HTMLElement} dom\n * @return {echarts~ECharts}\n */\nfunction getInstanceByDom(dom) {\n    var key;\n    if (dom.getAttribute) {\n        key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n    }\n    else {\n        key = dom[DOM_ATTRIBUTE_KEY];\n    }\n    return instances[key];\n}\n\n/**\n * @param {string} key\n * @return {echarts~ECharts}\n */\nfunction getInstanceById(key) {\n    return instances[key];\n}\n\n/**\n * Register theme\n */\nfunction registerTheme(name, theme) {\n    themeStorage[name] = theme;\n}\n\n/**\n * Register option preprocessor\n * @param {Function} preprocessorFunc\n */\nfunction registerPreprocessor(preprocessorFunc) {\n    optionPreprocessorFuncs.push(preprocessorFunc);\n}\n\n/**\n * @param {number} [priority=1000]\n * @param {Function} processorFunc\n */\nfunction registerProcessor(priority, processorFunc) {\n    if (typeof priority === 'function') {\n        processorFunc = priority;\n        priority = PRIORITY_PROCESSOR_FILTER;\n    }\n    if (__DEV__) {\n        if (isNaN(priority)) {\n            throw new Error('Unkown processor priority');\n        }\n    }\n    dataProcessorFuncs.push({\n        prio: priority,\n        func: processorFunc\n    });\n}\n\n/**\n * Register postUpdater\n * @param {Function} postUpdateFunc\n */\nfunction registerPostUpdate(postUpdateFunc) {\n    postUpdateFuncs.push(postUpdateFunc);\n}\n\n/**\n * Usage:\n * registerAction('someAction', 'someEvent', function () { ... });\n * registerAction('someAction', function () { ... });\n * registerAction(\n *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n *     function () { ... }\n * );\n *\n * @param {(string|Object)} actionInfo\n * @param {string} actionInfo.type\n * @param {string} [actionInfo.event]\n * @param {string} [actionInfo.update]\n * @param {string} [eventName]\n * @param {Function} action\n */\nfunction registerAction(actionInfo, eventName, action) {\n    if (typeof eventName === 'function') {\n        action = eventName;\n        eventName = '';\n    }\n    var actionType = isObject(actionInfo)\n        ? actionInfo.type\n        : ([actionInfo, actionInfo = {\n            event: eventName\n        }][0]);\n\n    // Event name is all lowercase\n    actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n    eventName = actionInfo.event;\n\n    // Validate action type and event name.\n    assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n\n    if (!actions[actionType]) {\n        actions[actionType] = {action: action, actionInfo: actionInfo};\n    }\n    eventActionMap[eventName] = actionType;\n}\n\n/**\n * @param {string} type\n * @param {*} CoordinateSystem\n */\nfunction registerCoordinateSystem(type, CoordinateSystem$$1) {\n    CoordinateSystemManager.register(type, CoordinateSystem$$1);\n}\n\n/**\n * Get dimensions of specified coordinate system.\n * @param {string} type\n * @return {Array.<string|Object>}\n */\nfunction getCoordinateSystemDimensions(type) {\n    var coordSysCreator = CoordinateSystemManager.get(type);\n    if (coordSysCreator) {\n        return coordSysCreator.getDimensionsInfo\n                ? coordSysCreator.getDimensionsInfo()\n                : coordSysCreator.dimensions.slice();\n    }\n}\n\n/**\n * Layout is a special stage of visual encoding\n * Most visual encoding like color are common for different chart\n * But each chart has it's own layout algorithm\n *\n * @param {number} [priority=1000]\n * @param {Function} layoutFunc\n */\nfunction registerLayout(priority, layoutFunc) {\n    if (typeof priority === 'function') {\n        layoutFunc = priority;\n        priority = PRIORITY_VISUAL_LAYOUT;\n    }\n    if (__DEV__) {\n        if (isNaN(priority)) {\n            throw new Error('Unkown layout priority');\n        }\n    }\n    visualFuncs.push({\n        prio: priority,\n        func: layoutFunc,\n        isLayout: true\n    });\n}\n\n/**\n * @param {number} [priority=3000]\n * @param {Function} visualFunc\n */\nfunction registerVisual(priority, visualFunc) {\n    if (typeof priority === 'function') {\n        visualFunc = priority;\n        priority = PRIORITY_VISUAL_CHART;\n    }\n    if (__DEV__) {\n        if (isNaN(priority)) {\n            throw new Error('Unkown visual priority');\n        }\n    }\n    visualFuncs.push({\n        prio: priority,\n        func: visualFunc\n    });\n}\n\n/**\n * @param {string} name\n */\nfunction registerLoading(name, loadingFx) {\n    loadingEffects[name] = loadingFx;\n}\n\n/**\n * @param {Object} opts\n * @param {string} [superClass]\n */\nfunction extendComponentModel(opts/*, superClass*/) {\n    // var Clazz = ComponentModel;\n    // if (superClass) {\n    //     var classType = parseClassType(superClass);\n    //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n    // }\n    return ComponentModel.extend(opts);\n}\n\n/**\n * @param {Object} opts\n * @param {string} [superClass]\n */\nfunction extendComponentView(opts/*, superClass*/) {\n    // var Clazz = ComponentView;\n    // if (superClass) {\n    //     var classType = parseClassType(superClass);\n    //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n    // }\n    return Component.extend(opts);\n}\n\n/**\n * @param {Object} opts\n * @param {string} [superClass]\n */\nfunction extendSeriesModel(opts/*, superClass*/) {\n    // var Clazz = SeriesModel;\n    // if (superClass) {\n    //     superClass = 'series.' + superClass.replace('series.', '');\n    //     var classType = parseClassType(superClass);\n    //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n    // }\n    return SeriesModel.extend(opts);\n}\n\n/**\n * @param {Object} opts\n * @param {string} [superClass]\n */\nfunction extendChartView(opts/*, superClass*/) {\n    // var Clazz = ChartView;\n    // if (superClass) {\n    //     superClass = superClass.replace('series.', '');\n    //     var classType = parseClassType(superClass);\n    //     Clazz = ChartView.getClass(classType.main, true);\n    // }\n    return Chart.extend(opts);\n}\n\n/**\n * ZRender need a canvas context to do measureText.\n * But in node environment canvas may be created by node-canvas.\n * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n *\n * Be careful of using it in the browser.\n *\n * @param {Function} creator\n * @example\n *     var Canvas = require('canvas');\n *     var echarts = require('echarts');\n *     echarts.setCanvasCreator(function () {\n *         // Small size is enough.\n *         return new Canvas(32, 32);\n *     });\n */\nfunction setCanvasCreator(creator) {\n    $override('createCanvas', creator);\n}\n\n/**\n * @param {string} mapName\n * @param {Object|string} geoJson\n * @param {Object} [specialAreas]\n *\n * @example\n *     $.get('USA.json', function (geoJson) {\n *         echarts.registerMap('USA', geoJson);\n *         // Or\n *         echarts.registerMap('USA', {\n *             geoJson: geoJson,\n *             specialAreas: {}\n *         })\n *     });\n */\nfunction registerMap(mapName, geoJson, specialAreas) {\n    if (geoJson.geoJson && !geoJson.features) {\n        specialAreas = geoJson.specialAreas;\n        geoJson = geoJson.geoJson;\n    }\n    if (typeof geoJson === 'string') {\n        geoJson = (typeof JSON !== 'undefined' && JSON.parse)\n            ? JSON.parse(geoJson) : (new Function('return (' + geoJson + ');'))();\n    }\n    mapDataStores[mapName] = {\n        geoJson: geoJson,\n        specialAreas: specialAreas\n    };\n}\n\n/**\n * @param {string} mapName\n * @return {Object}\n */\nfunction getMap(mapName) {\n    return mapDataStores[mapName];\n}\n\nregisterVisual(PRIORITY_VISUAL_GLOBAL, seriesColor);\nregisterPreprocessor(backwardCompat);\nregisterLoading('default', loadingDefault);\n\n// Default actions\n\nregisterAction({\n    type: 'highlight',\n    event: 'highlight',\n    update: 'highlight'\n}, noop);\n\nregisterAction({\n    type: 'downplay',\n    event: 'downplay',\n    update: 'downplay'\n}, noop);\n\n\n// For backward compatibility, where the namespace `dataTool` will\n// be mounted on `echarts` is the extension `dataTool` is imported.\nvar dataTool = {};\n\nfunction defaultKeyGetter(item) {\n    return item;\n}\n\n/**\n * @param {Array} oldArr\n * @param {Array} newArr\n * @param {Function} oldKeyGetter\n * @param {Function} newKeyGetter\n * @param {Object} [context] Can be visited by this.context in callback.\n */\nfunction DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context) {\n    this._old = oldArr;\n    this._new = newArr;\n\n    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n    this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n\n    this.context = context;\n}\n\nDataDiffer.prototype = {\n\n    constructor: DataDiffer,\n\n    /**\n     * Callback function when add a data\n     */\n    add: function (func) {\n        this._add = func;\n        return this;\n    },\n\n    /**\n     * Callback function when update a data\n     */\n    update: function (func) {\n        this._update = func;\n        return this;\n    },\n\n    /**\n     * Callback function when remove a data\n     */\n    remove: function (func) {\n        this._remove = func;\n        return this;\n    },\n\n    execute: function () {\n        var oldArr = this._old;\n        var newArr = this._new;\n\n        var oldDataIndexMap = {};\n        var newDataIndexMap = {};\n        var oldDataKeyArr = [];\n        var newDataKeyArr = [];\n        var i;\n\n        initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter', this);\n        initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter', this);\n\n        // Travel by inverted order to make sure order consistency\n        // when duplicate keys exists (consider newDataIndex.pop() below).\n        // For performance consideration, these code below do not look neat.\n        for (i = 0; i < oldArr.length; i++) {\n            var key = oldDataKeyArr[i];\n            var idx = newDataIndexMap[key];\n\n            // idx can never be empty array here. see 'set null' logic below.\n            if (idx != null) {\n                // Consider there is duplicate key (for example, use dataItem.name as key).\n                // We should make sure every item in newArr and oldArr can be visited.\n                var len = idx.length;\n                if (len) {\n                    len === 1 && (newDataIndexMap[key] = null);\n                    idx = idx.unshift();\n                }\n                else {\n                    newDataIndexMap[key] = null;\n                }\n                this._update && this._update(idx, i);\n            }\n            else {\n                this._remove && this._remove(i);\n            }\n        }\n\n        for (var i = 0; i < newDataKeyArr.length; i++) {\n            var key = newDataKeyArr[i];\n            if (newDataIndexMap.hasOwnProperty(key)) {\n                var idx = newDataIndexMap[key];\n                if (idx == null) {\n                    continue;\n                }\n                // idx can never be empty array here. see 'set null' logic above.\n                if (!idx.length) {\n                    this._add && this._add(idx);\n                }\n                else {\n                    for (var j = 0, len = idx.length; j < len; j++) {\n                        this._add && this._add(idx[j]);\n                    }\n                }\n            }\n        }\n    }\n};\n\nfunction initIndexMap(arr, map, keyArr, keyGetterName, dataDiffer) {\n    for (var i = 0; i < arr.length; i++) {\n        // Add prefix to avoid conflict with Object.prototype.\n        var key = '_ec_' + dataDiffer[keyGetterName](arr[i], i);\n        var existence = map[key];\n        if (existence == null) {\n            keyArr.push(key);\n            map[key] = i;\n        }\n        else {\n            if (!existence.length) {\n                map[key] = existence = [existence];\n            }\n            existence.push(i);\n        }\n    }\n}\n\n/**\n * List for data storage\n * @module echarts/data/List\n */\n\nvar isObject$4 = isObject;\n\nvar UNDEFINED = 'undefined';\nvar globalObj = typeof window === UNDEFINED ? global : window;\n\nvar dataCtors = {\n    'float': typeof globalObj.Float64Array === UNDEFINED\n        ? Array : globalObj.Float64Array,\n    'int': typeof globalObj.Int32Array === UNDEFINED\n        ? Array : globalObj.Int32Array,\n    // Ordinal data type can be string or int\n    'ordinal': Array,\n    'number': Array,\n    'time': Array\n};\n\nvar TRANSFERABLE_PROPERTIES = [\n    'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n];\n\nfunction transferProperties(a, b) {\n    each$1(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n        if (b.hasOwnProperty(propName)) {\n            a[propName] = b[propName];\n        }\n    });\n\n    a.__wrappedMethods = b.__wrappedMethods;\n}\n\nfunction DefaultDataProvider(dataArray) {\n    this._array = dataArray || [];\n}\n\nDefaultDataProvider.prototype.pure = false;\n\nDefaultDataProvider.prototype.count = function () {\n    return this._array.length;\n};\nDefaultDataProvider.prototype.getItem = function (idx) {\n    return this._array[idx];\n};\n\n/**\n * @constructor\n * @alias module:echarts/data/List\n *\n * @param {Array.<string|Object>} dimensions\n *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n * @param {module:echarts/model/Model} hostModel\n */\nvar List = function (dimensions, hostModel) {\n\n    dimensions = dimensions || ['x', 'y'];\n\n    var dimensionInfos = {};\n    var dimensionNames = [];\n    for (var i = 0; i < dimensions.length; i++) {\n        var dimensionName;\n        var dimensionInfo = {};\n        if (typeof dimensions[i] === 'string') {\n            dimensionName = dimensions[i];\n            dimensionInfo = {\n                name: dimensionName,\n                coordDim: dimensionName,\n                coordDimIndex: 0,\n                stackable: false,\n                // Type can be 'float', 'int', 'number'\n                // Default is number, Precision of float may not enough\n                type: 'number'\n            };\n        }\n        else {\n            dimensionInfo = dimensions[i];\n            dimensionName = dimensionInfo.name;\n            dimensionInfo.type = dimensionInfo.type || 'number';\n            if (!dimensionInfo.coordDim) {\n                dimensionInfo.coordDim = dimensionName;\n                dimensionInfo.coordDimIndex = 0;\n            }\n        }\n        dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n        dimensionNames.push(dimensionName);\n        dimensionInfos[dimensionName] = dimensionInfo;\n    }\n\n    /**\n     * @readOnly\n     * @type {Array.<string>}\n     */\n    this.dimensions = dimensionNames;\n\n    /**\n     * Infomation of each data dimension, like data type.\n     * @type {Object}\n     */\n    this._dimensionInfos = dimensionInfos;\n\n    /**\n     * @type {module:echarts/model/Model}\n     */\n    this.hostModel = hostModel;\n\n    /**\n     * @type {module:echarts/model/Model}\n     */\n    this.dataType;\n\n    /**\n     * Indices stores the indices of data subset after filtered.\n     * This data subset will be used in chart.\n     * @type {Array.<number>}\n     * @readOnly\n     */\n    this.indices = [];\n\n    /**\n     * Data storage\n     * @type {Object.<key, TypedArray|Array>}\n     * @private\n     */\n    this._storage = {};\n\n    /**\n     * @type {Array.<string>}\n     */\n    this._nameList = [];\n    /**\n     * @type {Array.<string>}\n     */\n    this._idList = [];\n\n    /**\n     * Models of data option is stored sparse for optimizing memory cost\n     * @type {Array.<module:echarts/model/Model>}\n     * @private\n     */\n    this._optionModels = [];\n\n    /**\n     * @param {module:echarts/data/List}\n     */\n    this.stackedOn = null;\n\n    /**\n     * Global visual properties after visual coding\n     * @type {Object}\n     * @private\n     */\n    this._visual = {};\n\n    /**\n     * Globel layout properties.\n     * @type {Object}\n     * @private\n     */\n    this._layout = {};\n\n    /**\n     * Item visual properties after visual coding\n     * @type {Array.<Object>}\n     * @private\n     */\n    this._itemVisuals = [];\n\n    /**\n     * Item layout properties after layout\n     * @type {Array.<Object>}\n     * @private\n     */\n    this._itemLayouts = [];\n\n    /**\n     * Graphic elemnents\n     * @type {Array.<module:zrender/Element>}\n     * @private\n     */\n    this._graphicEls = [];\n\n    /**\n     * @type {Array.<Array|Object>}\n     * @private\n     */\n    this._rawData;\n\n    /**\n     * @type {Object}\n     * @private\n     */\n    this._extent;\n};\n\nvar listProto = List.prototype;\n\nlistProto.type = 'list';\n\n/**\n * If each data item has it's own option\n * @type {boolean}\n */\nlistProto.hasItemOption = true;\n\n/**\n * Get dimension name\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n * @return {string} Concrete dim name.\n */\nlistProto.getDimension = function (dim) {\n    if (!isNaN(dim)) {\n        dim = this.dimensions[dim] || dim;\n    }\n    return dim;\n};\n\n/**\n * Get type and stackable info of particular dimension\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n */\nlistProto.getDimensionInfo = function (dim) {\n    return clone(this._dimensionInfos[this.getDimension(dim)]);\n};\n\n/**\n * Initialize from data\n * @param {Array.<Object|number|Array>} data\n * @param {Array.<string>} [nameList]\n * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n */\nlistProto.initData = function (data, nameList, dimValueGetter) {\n    data = data || [];\n\n    var isDataArray = isArray(data);\n    if (isDataArray) {\n        data = new DefaultDataProvider(data);\n    }\n    if (__DEV__) {\n        if (!isDataArray && (typeof data.getItem != 'function' || typeof data.count != 'function')) {\n            throw new Error('Inavlid data provider.');\n        }\n    }\n\n    this._rawData = data;\n\n    // Clear\n    var storage = this._storage = {};\n    var indices = this.indices = [];\n\n    var dimensions = this.dimensions;\n    var dimensionInfoMap = this._dimensionInfos;\n\n    var size = data.count();\n\n    var idList = [];\n    var nameRepeatCount = {};\n    var nameDimIdx;\n\n    nameList = nameList || [];\n\n    // Init storage\n    for (var i = 0; i < dimensions.length; i++) {\n        var dimInfo = dimensionInfoMap[dimensions[i]];\n        dimInfo.otherDims.itemName === 0 && (nameDimIdx = i);\n        var DataCtor = dataCtors[dimInfo.type];\n        storage[dimensions[i]] = new DataCtor(size);\n    }\n\n    var self = this;\n    if (!dimValueGetter) {\n        self.hasItemOption = false;\n    }\n    // Default dim value getter\n    dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n        var value = getDataItemValue(dataItem);\n        // If any dataItem is like { value: 10 }\n        if (isDataItemOption(dataItem)) {\n            self.hasItemOption = true;\n        }\n        return converDataValue(\n            (value instanceof Array)\n                ? value[dimIndex]\n                // If value is a single number or something else not array.\n                : value,\n            dimensionInfoMap[dimName]\n        );\n    };\n\n    for (var i = 0; i < size; i++) {\n        // NOTICE: Try not to write things into dataItem\n        var dataItem = data.getItem(i);\n        // Each data item is value\n        // [1, 2]\n        // 2\n        // Bar chart, line chart which uses category axis\n        // only gives the 'y' value. 'x' value is the indices of cateogry\n        // Use a tempValue to normalize the value to be a (x, y) value\n\n        // Store the data by dimensions\n        for (var k = 0; k < dimensions.length; k++) {\n            var dim = dimensions[k];\n            var dimStorage = storage[dim];\n            // PENDING NULL is empty or zero\n            dimStorage[i] = dimValueGetter(dataItem, dim, i, k);\n        }\n\n        indices.push(i);\n    }\n\n    // Use the name in option and create id\n    for (var i = 0; i < size; i++) {\n        var dataItem = data.getItem(i);\n        if (!nameList[i] && dataItem) {\n            if (dataItem.name != null) {\n                nameList[i] = dataItem.name;\n            }\n            else if (nameDimIdx != null) {\n                nameList[i] = storage[dimensions[nameDimIdx]][i];\n            }\n        }\n        var name = nameList[i] || '';\n        // Try using the id in option\n        var id = dataItem && dataItem.id;\n\n        if (!id && name) {\n            // Use name as id and add counter to avoid same name\n            nameRepeatCount[name] = nameRepeatCount[name] || 0;\n            id = name;\n            if (nameRepeatCount[name] > 0) {\n                id += '__ec__' + nameRepeatCount[name];\n            }\n            nameRepeatCount[name]++;\n        }\n        id && (idList[i] = id);\n    }\n\n    this._nameList = nameList;\n    this._idList = idList;\n};\n\n/**\n * @return {number}\n */\nlistProto.count = function () {\n    return this.indices.length;\n};\n\n/**\n * Get value. Return NaN if idx is out of range.\n * @param {string} dim Dim must be concrete name.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\nlistProto.get = function (dim, idx, stack) {\n    var storage = this._storage;\n    var dataIndex = this.indices[idx];\n\n    // If value not exists\n    if (dataIndex == null || !storage[dim]) {\n        return NaN;\n    }\n\n    var value = storage[dim][dataIndex];\n    // FIXME ordinal data type is not stackable\n    if (stack) {\n        var dimensionInfo = this._dimensionInfos[dim];\n        if (dimensionInfo && dimensionInfo.stackable) {\n            var stackedOn = this.stackedOn;\n            while (stackedOn) {\n                // Get no stacked data of stacked on\n                var stackedValue = stackedOn.get(dim, idx);\n                // Considering positive stack, negative stack and empty data\n                if ((value >= 0 && stackedValue > 0)  // Positive stack\n                    || (value <= 0 && stackedValue < 0) // Negative stack\n                ) {\n                    value += stackedValue;\n                }\n                stackedOn = stackedOn.stackedOn;\n            }\n        }\n    }\n    return value;\n};\n\n/**\n * Get value for multi dimensions.\n * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\nlistProto.getValues = function (dimensions, idx, stack) {\n    var values = [];\n\n    if (!isArray(dimensions)) {\n        stack = idx;\n        idx = dimensions;\n        dimensions = this.dimensions;\n    }\n\n    for (var i = 0, len = dimensions.length; i < len; i++) {\n        values.push(this.get(dimensions[i], idx, stack));\n    }\n\n    return values;\n};\n\n/**\n * If value is NaN. Inlcuding '-'\n * @param {string} dim\n * @param {number} idx\n * @return {number}\n */\nlistProto.hasValue = function (idx) {\n    var dimensions = this.dimensions;\n    var dimensionInfos = this._dimensionInfos;\n    for (var i = 0, len = dimensions.length; i < len; i++) {\n        if (\n            // Ordinal type can be string or number\n            dimensionInfos[dimensions[i]].type !== 'ordinal'\n            && isNaN(this.get(dimensions[i], idx))\n        ) {\n            return false;\n        }\n    }\n    return true;\n};\n\n/**\n * Get extent of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n * @param {Function} filter\n */\nlistProto.getDataExtent = function (dim, stack, filter$$1) {\n    dim = this.getDimension(dim);\n    var dimData = this._storage[dim];\n    var dimInfo = this.getDimensionInfo(dim);\n    stack = (dimInfo && dimInfo.stackable) && stack;\n    var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n    var value;\n    if (dimExtent) {\n        return dimExtent;\n    }\n    // var dimInfo = this._dimensionInfos[dim];\n    if (dimData) {\n        var min = Infinity;\n        var max = -Infinity;\n        // var isOrdinal = dimInfo.type === 'ordinal';\n        for (var i = 0, len = this.count(); i < len; i++) {\n            value = this.get(dim, i, stack);\n            // FIXME\n            // if (isOrdinal && typeof value === 'string') {\n            //     value = zrUtil.indexOf(dimData, value);\n            // }\n            if (!filter$$1 || filter$$1(value, dim, i)) {\n                value < min && (min = value);\n                value > max && (max = value);\n            }\n        }\n        return (this._extent[dim + !!stack] = [min, max]);\n    }\n    else {\n        return [Infinity, -Infinity];\n    }\n};\n\n/**\n * Get sum of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n */\nlistProto.getSum = function (dim, stack) {\n    var dimData = this._storage[dim];\n    var sum = 0;\n    if (dimData) {\n        for (var i = 0, len = this.count(); i < len; i++) {\n            var value = this.get(dim, i, stack);\n            if (!isNaN(value)) {\n                sum += value;\n            }\n        }\n    }\n    return sum;\n};\n\n/**\n * Retreive the index with given value\n * @param {number} idx\n * @param {number} value\n * @return {number}\n */\n// FIXME Precision of float value\nlistProto.indexOf = function (dim, value) {\n    var storage = this._storage;\n    var dimData = storage[dim];\n    var indices = this.indices;\n\n    if (dimData) {\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (dimData[rawIndex] === value) {\n                return i;\n            }\n        }\n    }\n    return -1;\n};\n\n/**\n * Retreive the index with given name\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\nlistProto.indexOfName = function (name) {\n    var indices = this.indices;\n    var nameList = this._nameList;\n\n    for (var i = 0, len = indices.length; i < len; i++) {\n        var rawIndex = indices[i];\n        if (nameList[rawIndex] === name) {\n            return i;\n        }\n    }\n\n    return -1;\n};\n\n/**\n * Retreive the index with given raw data index\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\nlistProto.indexOfRawIndex = function (rawIndex) {\n    // Indices are ascending\n    var indices = this.indices;\n\n    // If rawIndex === dataIndex\n    var rawDataIndex = indices[rawIndex];\n    if (rawDataIndex != null && rawDataIndex === rawIndex) {\n        return rawIndex;\n    }\n\n    var left = 0;\n    var right = indices.length - 1;\n    while (left <= right) {\n        var mid = (left + right) / 2 | 0;\n        if (indices[mid] < rawIndex) {\n            left = mid + 1;\n        }\n        else if (indices[mid] > rawIndex) {\n            right = mid - 1;\n        }\n        else {\n            return mid;\n        }\n    }\n    return -1;\n};\n\n/**\n * Retreive the index of nearest value\n * @param {string} dim\n * @param {number} value\n * @param {boolean} stack If given value is after stacked\n * @param {number} [maxDistance=Infinity]\n * @return {Array.<number>} Considere multiple points has the same value.\n */\nlistProto.indicesOfNearest = function (dim, value, stack, maxDistance) {\n    var storage = this._storage;\n    var dimData = storage[dim];\n    var nearestIndices = [];\n\n    if (!dimData) {\n        return nearestIndices;\n    }\n\n    if (maxDistance == null) {\n        maxDistance = Infinity;\n    }\n\n    var minDist = Number.MAX_VALUE;\n    var minDiff = -1;\n    for (var i = 0, len = this.count(); i < len; i++) {\n        var diff = value - this.get(dim, i, stack);\n        var dist = Math.abs(diff);\n        if (diff <= maxDistance && dist <= minDist) {\n            // For the case of two data are same on xAxis, which has sequence data.\n            // Show the nearest index\n            // https://github.com/ecomfe/echarts/issues/2869\n            if (dist < minDist || (diff >= 0 && minDiff < 0)) {\n                minDist = dist;\n                minDiff = diff;\n                nearestIndices.length = 0;\n            }\n            nearestIndices.push(i);\n        }\n    }\n    return nearestIndices;\n};\n\n/**\n * Get raw data index\n * @param {number} idx\n * @return {number}\n */\nlistProto.getRawIndex = function (idx) {\n    var rawIdx = this.indices[idx];\n    return rawIdx == null ? -1 : rawIdx;\n};\n\n/**\n * Get raw data item\n * @param {number} idx\n * @return {number}\n */\nlistProto.getRawDataItem = function (idx) {\n    return this._rawData.getItem(this.getRawIndex(idx));\n};\n\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\nlistProto.getName = function (idx) {\n    return this._nameList[this.indices[idx]] || '';\n};\n\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\nlistProto.getId = function (idx) {\n    return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n};\n\n\nfunction normalizeDimensions(dimensions) {\n    if (!isArray(dimensions)) {\n        dimensions = [dimensions];\n    }\n    return dimensions;\n}\n\n/**\n * Data iteration\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n *\n * @example\n *  list.each('x', function (x, idx) {});\n *  list.each(['x', 'y'], function (x, y, idx) {});\n *  list.each(function (idx) {})\n */\nlistProto.each = function (dims, cb, stack, context) {\n    if (typeof dims === 'function') {\n        context = stack;\n        stack = cb;\n        cb = dims;\n        dims = [];\n    }\n\n    dims = map(normalizeDimensions(dims), this.getDimension, this);\n\n    var value = [];\n    var dimSize = dims.length;\n    var indices = this.indices;\n\n    context = context || this;\n\n    for (var i = 0; i < indices.length; i++) {\n        // Simple optimization\n        switch (dimSize) {\n            case 0:\n                cb.call(context, i);\n                break;\n            case 1:\n                cb.call(context, this.get(dims[0], i, stack), i);\n                break;\n            case 2:\n                cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                break;\n            default:\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dims[k], i, stack);\n                }\n                // Index\n                value[k] = i;\n                cb.apply(context, value);\n        }\n    }\n};\n\n/**\n * Data filter\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n */\nlistProto.filterSelf = function (dimensions, cb, stack, context) {\n    if (typeof dimensions === 'function') {\n        context = stack;\n        stack = cb;\n        cb = dimensions;\n        dimensions = [];\n    }\n\n    dimensions = map(\n        normalizeDimensions(dimensions), this.getDimension, this\n    );\n\n    var newIndices = [];\n    var value = [];\n    var dimSize = dimensions.length;\n    var indices = this.indices;\n\n    context = context || this;\n\n    for (var i = 0; i < indices.length; i++) {\n        var keep;\n        // Simple optimization\n        if (!dimSize) {\n            keep = cb.call(context, i);\n        }\n        else if (dimSize === 1) {\n            keep = cb.call(\n                context, this.get(dimensions[0], i, stack), i\n            );\n        }\n        else {\n            for (var k = 0; k < dimSize; k++) {\n                value[k] = this.get(dimensions[k], i, stack);\n            }\n            value[k] = i;\n            keep = cb.apply(context, value);\n        }\n        if (keep) {\n            newIndices.push(indices[i]);\n        }\n    }\n\n    this.indices = newIndices;\n\n    // Reset data extent\n    this._extent = {};\n\n    return this;\n};\n\n/**\n * Data mapping to a plain array\n * @param {string|Array.<string>} [dimensions]\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n * @return {Array}\n */\nlistProto.mapArray = function (dimensions, cb, stack, context) {\n    if (typeof dimensions === 'function') {\n        context = stack;\n        stack = cb;\n        cb = dimensions;\n        dimensions = [];\n    }\n\n    var result = [];\n    this.each(dimensions, function () {\n        result.push(cb && cb.apply(this, arguments));\n    }, stack, context);\n    return result;\n};\n\nfunction cloneListForMapAndSample(original, excludeDimensions) {\n    var allDimensions = original.dimensions;\n    var list = new List(\n        map(allDimensions, original.getDimensionInfo, original),\n        original.hostModel\n    );\n    // FIXME If needs stackedOn, value may already been stacked\n    transferProperties(list, original);\n\n    var storage = list._storage = {};\n    var originalStorage = original._storage;\n    // Init storage\n    for (var i = 0; i < allDimensions.length; i++) {\n        var dim = allDimensions[i];\n        var dimStore = originalStorage[dim];\n        if (indexOf(excludeDimensions, dim) >= 0) {\n            storage[dim] = new dimStore.constructor(\n                originalStorage[dim].length\n            );\n        }\n        else {\n            // Direct reference for other dimensions\n            storage[dim] = originalStorage[dim];\n        }\n    }\n    return list;\n}\n\n/**\n * Data mapping to a new List with given dimensions\n * @param {string|Array.<string>} dimensions\n * @param {Function} cb\n * @param {boolean} [stack=false]\n * @param {*} [context=this]\n * @return {Array}\n */\nlistProto.map = function (dimensions, cb, stack, context) {\n    dimensions = map(\n        normalizeDimensions(dimensions), this.getDimension, this\n    );\n\n    var list = cloneListForMapAndSample(this, dimensions);\n    // Following properties are all immutable.\n    // So we can reference to the same value\n    var indices = list.indices = this.indices;\n\n    var storage = list._storage;\n\n    var tmpRetValue = [];\n    this.each(dimensions, function () {\n        var idx = arguments[arguments.length - 1];\n        var retValue = cb && cb.apply(this, arguments);\n        if (retValue != null) {\n            // a number\n            if (typeof retValue === 'number') {\n                tmpRetValue[0] = retValue;\n                retValue = tmpRetValue;\n            }\n            for (var i = 0; i < retValue.length; i++) {\n                var dim = dimensions[i];\n                var dimStore = storage[dim];\n                var rawIdx = indices[idx];\n                if (dimStore) {\n                    dimStore[rawIdx] = retValue[i];\n                }\n            }\n        }\n    }, stack, context);\n\n    return list;\n};\n\n/**\n * Large data down sampling on given dimension\n * @param {string} dimension\n * @param {number} rate\n * @param {Function} sampleValue\n * @param {Function} sampleIndex Sample index for name and id\n */\nlistProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var list = cloneListForMapAndSample(this, [dimension]);\n    var storage = this._storage;\n    var targetStorage = list._storage;\n\n    var originalIndices = this.indices;\n    var indices = list.indices = [];\n\n    var frameValues = [];\n    var frameIndices = [];\n    var frameSize = Math.floor(1 / rate);\n\n    var dimStore = targetStorage[dimension];\n    var len = this.count();\n    // Copy data from original data\n    for (var i = 0; i < storage[dimension].length; i++) {\n        targetStorage[dimension][i] = storage[dimension][i];\n    }\n    for (var i = 0; i < len; i += frameSize) {\n        // Last frame\n        if (frameSize > len - i) {\n            frameSize = len - i;\n            frameValues.length = frameSize;\n        }\n        for (var k = 0; k < frameSize; k++) {\n            var idx = originalIndices[i + k];\n            frameValues[k] = dimStore[idx];\n            frameIndices[k] = idx;\n        }\n        var value = sampleValue(frameValues);\n        var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n        // Only write value on the filtered data\n        dimStore[idx] = value;\n        indices.push(idx);\n    }\n\n    return list;\n};\n\n/**\n * Get model of one data item.\n *\n * @param {number} idx\n */\n// FIXME Model proxy ?\nlistProto.getItemModel = function (idx) {\n    var hostModel = this.hostModel;\n    idx = this.indices[idx];\n    return new Model(this._rawData.getItem(idx), hostModel, hostModel && hostModel.ecModel);\n};\n\n/**\n * Create a data differ\n * @param {module:echarts/data/List} otherList\n * @return {module:echarts/data/DataDiffer}\n */\nlistProto.diff = function (otherList) {\n    var idList = this._idList;\n    var otherIdList = otherList && otherList._idList;\n    var val;\n    // Use prefix to avoid index to be the same as otherIdList[idx],\n    // which will cause weird udpate animation.\n    var prefix = 'e\\0\\0';\n\n    return new DataDiffer(\n        otherList ? otherList.indices : [],\n        this.indices,\n        function (idx) {\n            return (val = otherIdList[idx]) != null ? val : prefix + idx;\n        },\n        function (idx) {\n            return (val = idList[idx]) != null ? val : prefix + idx;\n        }\n    );\n};\n/**\n * Get visual property.\n * @param {string} key\n */\nlistProto.getVisual = function (key) {\n    var visual = this._visual;\n    return visual && visual[key];\n};\n\n/**\n * Set visual property\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setVisual('color', color);\n *  setVisual({\n *      'color': color\n *  });\n */\nlistProto.setVisual = function (key, val) {\n    if (isObject$4(key)) {\n        for (var name in key) {\n            if (key.hasOwnProperty(name)) {\n                this.setVisual(name, key[name]);\n            }\n        }\n        return;\n    }\n    this._visual = this._visual || {};\n    this._visual[key] = val;\n};\n\n/**\n * Set layout property.\n * @param {string|Object} key\n * @param {*} [val]\n */\nlistProto.setLayout = function (key, val) {\n    if (isObject$4(key)) {\n        for (var name in key) {\n            if (key.hasOwnProperty(name)) {\n                this.setLayout(name, key[name]);\n            }\n        }\n        return;\n    }\n    this._layout[key] = val;\n};\n\n/**\n * Get layout property.\n * @param  {string} key.\n * @return {*}\n */\nlistProto.getLayout = function (key) {\n    return this._layout[key];\n};\n\n/**\n * Get layout of single data item\n * @param {number} idx\n */\nlistProto.getItemLayout = function (idx) {\n    return this._itemLayouts[idx];\n};\n\n/**\n * Set layout of single data item\n * @param {number} idx\n * @param {Object} layout\n * @param {boolean=} [merge=false]\n */\nlistProto.setItemLayout = function (idx, layout, merge$$1) {\n    this._itemLayouts[idx] = merge$$1\n        ? extend(this._itemLayouts[idx] || {}, layout)\n        : layout;\n};\n\n/**\n * Clear all layout of single data item\n */\nlistProto.clearItemLayouts = function () {\n    this._itemLayouts.length = 0;\n};\n\n/**\n * Get visual property of single data item\n * @param {number} idx\n * @param {string} key\n * @param {boolean} [ignoreParent=false]\n */\nlistProto.getItemVisual = function (idx, key, ignoreParent) {\n    var itemVisual = this._itemVisuals[idx];\n    var val = itemVisual && itemVisual[key];\n    if (val == null && !ignoreParent) {\n        // Use global visual property\n        return this.getVisual(key);\n    }\n    return val;\n};\n\n/**\n * Set visual property of single data item\n *\n * @param {number} idx\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setItemVisual(0, 'color', color);\n *  setItemVisual(0, {\n *      'color': color\n *  });\n */\nlistProto.setItemVisual = function (idx, key, value) {\n    var itemVisual = this._itemVisuals[idx] || {};\n    this._itemVisuals[idx] = itemVisual;\n\n    if (isObject$4(key)) {\n        for (var name in key) {\n            if (key.hasOwnProperty(name)) {\n                itemVisual[name] = key[name];\n            }\n        }\n        return;\n    }\n    itemVisual[key] = value;\n};\n\n/**\n * Clear itemVisuals and list visual.\n */\nlistProto.clearAllVisual = function () {\n    this._visual = {};\n    this._itemVisuals = [];\n};\n\nvar setItemDataAndSeriesIndex = function (child) {\n    child.seriesIndex = this.seriesIndex;\n    child.dataIndex = this.dataIndex;\n    child.dataType = this.dataType;\n};\n/**\n * Set graphic element relative to data. It can be set as null\n * @param {number} idx\n * @param {module:zrender/Element} [el]\n */\nlistProto.setItemGraphicEl = function (idx, el) {\n    var hostModel = this.hostModel;\n\n    if (el) {\n        // Add data index and series index for indexing the data by element\n        // Useful in tooltip\n        el.dataIndex = idx;\n        el.dataType = this.dataType;\n        el.seriesIndex = hostModel && hostModel.seriesIndex;\n        if (el.type === 'group') {\n            el.traverse(setItemDataAndSeriesIndex, el);\n        }\n    }\n\n    this._graphicEls[idx] = el;\n};\n\n/**\n * @param {number} idx\n * @return {module:zrender/Element}\n */\nlistProto.getItemGraphicEl = function (idx) {\n    return this._graphicEls[idx];\n};\n\n/**\n * @param {Function} cb\n * @param {*} context\n */\nlistProto.eachItemGraphicEl = function (cb, context) {\n    each$1(this._graphicEls, function (el, idx) {\n        if (el) {\n            cb && cb.call(context, el, idx);\n        }\n    });\n};\n\n/**\n * Shallow clone a new list except visual and layout properties, and graph elements.\n * New list only change the indices.\n */\nlistProto.cloneShallow = function () {\n    var dimensionInfoList = map(this.dimensions, this.getDimensionInfo, this);\n    var list = new List(dimensionInfoList, this.hostModel);\n\n    // FIXME\n    list._storage = this._storage;\n\n    transferProperties(list, this);\n\n\n    // Clone will not change the data extent and indices\n    list.indices = this.indices.slice();\n\n    if (this._extent) {\n        list._extent = extend({}, this._extent);\n    }\n\n    return list;\n};\n\n/**\n * Wrap some method to add more feature\n * @param {string} methodName\n * @param {Function} injectFunction\n */\nlistProto.wrapMethod = function (methodName, injectFunction) {\n    var originalMethod = this[methodName];\n    if (typeof originalMethod !== 'function') {\n        return;\n    }\n    this.__wrappedMethods = this.__wrappedMethods || [];\n    this.__wrappedMethods.push(methodName);\n    this[methodName] = function () {\n        var res = originalMethod.apply(this, arguments);\n        return injectFunction.apply(this, [res].concat(slice(arguments)));\n    };\n};\n\n// Methods that create a new list based on this list should be listed here.\n// Notice that those method should `RETURN` the new list.\nlistProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n// Methods that change indices of this list should be listed here.\nlistProto.CHANGABLE_METHODS = ['filterSelf'];\n\n/**\n * Complete dimensions by data (guess dimension).\n */\n\nvar each$7 = each$1;\nvar isString$1 = isString;\nvar defaults$1 = defaults;\n\nvar OTHER_DIMS = {tooltip: 1, label: 1, itemName: 1};\n\n/**\n * Complete the dimensions array, by user defined `dimension` and `encode`,\n * and guessing from the data structure.\n * If no 'value' dimension specified, the first no-named dimension will be\n * named as 'value'.\n *\n * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which\n *      provides not only dim template, but also default order.\n *      `name` of each item provides default coord name.\n *      [{dimsDef: []}, ...] can be specified to give names.\n * @param {Array} data Data list. [[1, 2, 3], [2, 3, 4]].\n * @param {Object} [opt]\n * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions\n *      For example: ['asdf', {name, type}, ...].\n * @param {Object} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}\n * @param {string} [opt.extraPrefix] Prefix of name when filling the left dimensions.\n * @param {string} [opt.extraFromZero] If specified, extra dim names will be:\n *                      extraPrefix + 0, extraPrefix + extraBaseIndex + 1 ...\n *                      If not specified, extra dim names will be:\n *                      extraPrefix, extraPrefix + 0, extraPrefix + 1 ...\n * @param {number} [opt.dimCount] If not specified, guess by the first data item.\n * @return {Array.<Object>} [{\n *      name: string mandatory,\n *      coordDim: string mandatory,\n *      coordDimIndex: number mandatory,\n *      type: string optional,\n *      tooltipName: string optional,\n *      otherDims: {\n *          tooltip: number optional,\n *          label: number optional\n *      },\n *      isExtraCoord: boolean true or undefined.\n *      other props ...\n * }]\n */\nfunction completeDimensions(sysDims, data, opt) {\n    data = data || [];\n    opt = opt || {};\n    sysDims = (sysDims || []).slice();\n    var dimsDef = (opt.dimsDef || []).slice();\n    var encodeDef = createHashMap(opt.encodeDef);\n    var dataDimNameMap = createHashMap();\n    var coordDimNameMap = createHashMap();\n    // var valueCandidate;\n    var result = [];\n\n    var dimCount = opt.dimCount;\n    if (dimCount == null) {\n        var value0 = retrieveValue(data[0]);\n        dimCount = Math.max(\n            isArray(value0) && value0.length || 1,\n            sysDims.length,\n            dimsDef.length\n        );\n        each$7(sysDims, function (sysDimItem) {\n            var sysDimItemDimsDef = sysDimItem.dimsDef;\n            sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));\n        });\n    }\n\n    // Apply user defined dims (`name` and `type`) and init result.\n    for (var i = 0; i < dimCount; i++) {\n        var dimDefItem = isString$1(dimsDef[i]) ? {name: dimsDef[i]} : (dimsDef[i] || {});\n        var userDimName = dimDefItem.name;\n        var resultItem = result[i] = {otherDims: {}};\n        // Name will be applied later for avoiding duplication.\n        if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n            // Only if `series.dimensions` is defined in option, tooltipName\n            // will be set, and dimension will be diplayed vertically in\n            // tooltip by default.\n            resultItem.name = resultItem.tooltipName = userDimName;\n            dataDimNameMap.set(userDimName, i);\n        }\n        dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n    }\n\n    // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.\n    encodeDef.each(function (dataDims, coordDim) {\n        dataDims = encodeDef.set(coordDim, normalizeToArray(dataDims).slice());\n        each$7(dataDims, function (resultDimIdx, coordDimIndex) {\n            // The input resultDimIdx can be dim name or index.\n            isString$1(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));\n            if (resultDimIdx != null && resultDimIdx < dimCount) {\n                dataDims[coordDimIndex] = resultDimIdx;\n                applyDim(result[resultDimIdx], coordDim, coordDimIndex);\n            }\n        });\n    });\n\n    // Apply templetes and default order from `sysDims`.\n    var availDimIdx = 0;\n    each$7(sysDims, function (sysDimItem, sysDimIndex) {\n        var coordDim;\n        var sysDimItem;\n        var sysDimItemDimsDef;\n        var sysDimItemOtherDims;\n        if (isString$1(sysDimItem)) {\n            coordDim = sysDimItem;\n            sysDimItem = {};\n        }\n        else {\n            coordDim = sysDimItem.name;\n            sysDimItem = clone(sysDimItem);\n            // `coordDimIndex` should not be set directly.\n            sysDimItemDimsDef = sysDimItem.dimsDef;\n            sysDimItemOtherDims = sysDimItem.otherDims;\n            sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex\n                = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n        }\n\n        var dataDims = normalizeToArray(encodeDef.get(coordDim));\n        // dimensions provides default dim sequences.\n        if (!dataDims.length) {\n            for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n                while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {\n                    availDimIdx++;\n                }\n                availDimIdx < result.length && dataDims.push(availDimIdx++);\n            }\n        }\n        // Apply templates.\n        each$7(dataDims, function (resultDimIdx, coordDimIndex) {\n            var resultItem = result[resultDimIdx];\n            applyDim(defaults$1(resultItem, sysDimItem), coordDim, coordDimIndex);\n            if (resultItem.name == null && sysDimItemDimsDef) {\n                resultItem.name = resultItem.tooltipName = sysDimItemDimsDef[coordDimIndex];\n            }\n            sysDimItemOtherDims && defaults$1(resultItem.otherDims, sysDimItemOtherDims);\n        });\n    });\n\n    // Make sure the first extra dim is 'value'.\n    var extra = opt.extraPrefix || 'value';\n\n    // Set dim `name` and other `coordDim` and other props.\n    for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n        var resultItem = result[resultDimIdx] = result[resultDimIdx] || {};\n        var coordDim = resultItem.coordDim;\n\n        coordDim == null && (\n            resultItem.coordDim = genName(extra, coordDimNameMap, opt.extraFromZero),\n            resultItem.coordDimIndex = 0,\n            resultItem.isExtraCoord = true\n        );\n\n        resultItem.name == null && (resultItem.name = genName(\n            resultItem.coordDim,\n            dataDimNameMap\n        ));\n\n        resultItem.type == null && guessOrdinal(data, resultDimIdx)\n            && (resultItem.type = 'ordinal');\n    }\n\n    return result;\n\n    function applyDim(resultItem, coordDim, coordDimIndex) {\n        if (OTHER_DIMS[coordDim]) {\n            resultItem.otherDims[coordDim] = coordDimIndex;\n        }\n        else {\n            resultItem.coordDim = coordDim;\n            resultItem.coordDimIndex = coordDimIndex;\n            coordDimNameMap.set(coordDim, true);\n        }\n    }\n\n    function genName(name, map$$1, fromZero) {\n        if (fromZero || map$$1.get(name) != null) {\n            var i = 0;\n            while (map$$1.get(name + i) != null) {\n                i++;\n            }\n            name += i;\n        }\n        map$$1.set(name, true);\n        return name;\n    }\n}\n\n// The rule should not be complex, otherwise user might not\n// be able to known where the data is wrong.\nvar guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n    for (var i = 0, len = data.length; i < len; i++) {\n        var value = retrieveValue(data[i]);\n\n        if (!isArray(value)) {\n            return false;\n        }\n\n        var value = value[dimIndex];\n        // Consider usage convenience, '1', '2' will be treated as \"number\".\n        // `isFinit('')` get `true`.\n        if (value != null && isFinite(value) && value !== '') {\n            return false;\n        }\n        else if (isString$1(value) && value !== '-') {\n            return true;\n        }\n    }\n    return false;\n};\n\nfunction retrieveValue(o) {\n    return isArray(o) ? o : isObject(o) ? o.value: o;\n}\n\nfunction firstDataNotNull(data) {\n    var i = 0;\n    while (i < data.length && data[i] == null) {\n        i++;\n    }\n    return data[i];\n}\nfunction ifNeedCompleteOrdinalData(data) {\n    var sampleItem = firstDataNotNull(data);\n    return sampleItem != null\n        && !isArray(getDataItemValue(sampleItem));\n}\n\n/**\n * Helper function to create a list from option data\n */\nfunction createListFromArray(data, seriesModel, ecModel) {\n    // If data is undefined\n    data = data || [];\n\n    if (__DEV__) {\n        if (!isArray(data)) {\n            throw new Error('Invalid data.');\n        }\n    }\n\n    var coordSysName = seriesModel.get('coordinateSystem');\n    var creator = creators[coordSysName];\n    var registeredCoordSys = CoordinateSystemManager.get(coordSysName);\n    var completeDimOpt = {\n        encodeDef: seriesModel.get('encode'),\n        dimsDef: seriesModel.get('dimensions')\n    };\n\n    // FIXME\n    var axesInfo = creator && creator(data, seriesModel, ecModel, completeDimOpt);\n    var dimensions = axesInfo && axesInfo.dimensions;\n    if (!dimensions) {\n        // Get dimensions from registered coordinate system\n        dimensions = (registeredCoordSys && (\n            registeredCoordSys.getDimensionsInfo\n                ? registeredCoordSys.getDimensionsInfo()\n                : registeredCoordSys.dimensions.slice()\n        )) || ['x', 'y'];\n        dimensions = completeDimensions(dimensions, data, completeDimOpt);\n    }\n\n    var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\n    var list = new List(dimensions, seriesModel);\n\n    var nameList = createNameList(axesInfo, data);\n\n    var categories = {};\n    var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n        ? function (itemOpt, dimName, dataIndex, dimIndex) {\n            // If any dataItem is like { value: 10 }\n            if (isDataItemOption(itemOpt)) {\n                list.hasItemOption = true;\n            }\n\n            // Use dataIndex as ordinal value in categoryAxis\n            return dimIndex === categoryIndex\n                ? dataIndex\n                : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n        }\n        : function (itemOpt, dimName, dataIndex, dimIndex) {\n            var value = getDataItemValue(itemOpt);\n            var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n            // If any dataItem is like { value: 10 }\n            if (isDataItemOption(itemOpt)) {\n                list.hasItemOption = true;\n            }\n\n            var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n            if (categoryAxesModels && categoryAxesModels[dimName]) {\n                // If given value is a category string\n                if (typeof val === 'string') {\n                    // Lazy get categories\n                    categories[dimName] = categories[dimName]\n                        || categoryAxesModels[dimName].getCategories();\n                    val = indexOf(categories[dimName], val);\n                    if (val < 0 && !isNaN(val)) {\n                        // In case some one write '1', '2' istead of 1, 2\n                        val = +val;\n                    }\n                }\n            }\n            return val;\n        };\n\n    list.hasItemOption = false;\n    list.initData(data, nameList, dimValueGetter);\n\n    return list;\n}\n\nfunction isStackable(axisType) {\n    return axisType !== 'category' && axisType !== 'time';\n}\n\nfunction getDimTypeByAxis(axisType) {\n    return axisType === 'category'\n        ? 'ordinal'\n        : axisType === 'time'\n        ? 'time'\n        : 'float';\n}\n\n/**\n * Creaters for each coord system.\n */\nvar creators = {\n\n    cartesian2d: function (data, seriesModel, ecModel, completeDimOpt) {\n\n        var axesModels = map(['xAxis', 'yAxis'], function (name) {\n            return ecModel.queryComponents({\n                mainType: name,\n                index: seriesModel.get(name + 'Index'),\n                id: seriesModel.get(name + 'Id')\n            })[0];\n        });\n        var xAxisModel = axesModels[0];\n        var yAxisModel = axesModels[1];\n\n        if (__DEV__) {\n            if (!xAxisModel) {\n                throw new Error('xAxis \"' + retrieve(\n                    seriesModel.get('xAxisIndex'),\n                    seriesModel.get('xAxisId'),\n                    0\n                ) + '\" not found');\n            }\n            if (!yAxisModel) {\n                throw new Error('yAxis \"' + retrieve(\n                    seriesModel.get('xAxisIndex'),\n                    seriesModel.get('yAxisId'),\n                    0\n                ) + '\" not found');\n            }\n        }\n\n        var xAxisType = xAxisModel.get('type');\n        var yAxisType = yAxisModel.get('type');\n\n        var dimensions = [\n            {\n                name: 'x',\n                type: getDimTypeByAxis(xAxisType),\n                stackable: isStackable(xAxisType)\n            },\n            {\n                name: 'y',\n                // If two category axes\n                type: getDimTypeByAxis(yAxisType),\n                stackable: isStackable(yAxisType)\n            }\n        ];\n\n        var isXAxisCateogry = xAxisType === 'category';\n        var isYAxisCategory = yAxisType === 'category';\n\n        dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n        var categoryAxesModels = {};\n        if (isXAxisCateogry) {\n            categoryAxesModels.x = xAxisModel;\n        }\n        if (isYAxisCategory) {\n            categoryAxesModels.y = yAxisModel;\n        }\n        return {\n            dimensions: dimensions,\n            categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n            categoryAxesModels: categoryAxesModels\n        };\n    },\n\n    singleAxis: function (data, seriesModel, ecModel, completeDimOpt) {\n\n        var singleAxisModel = ecModel.queryComponents({\n            mainType: 'singleAxis',\n            index: seriesModel.get('singleAxisIndex'),\n            id: seriesModel.get('singleAxisId')\n        })[0];\n\n        if (__DEV__) {\n            if (!singleAxisModel) {\n                throw new Error('singleAxis should be specified.');\n            }\n        }\n\n        var singleAxisType = singleAxisModel.get('type');\n        var isCategory = singleAxisType === 'category';\n\n        var dimensions = [{\n            name: 'single',\n            type: getDimTypeByAxis(singleAxisType),\n            stackable: isStackable(singleAxisType)\n        }];\n\n        dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n        var categoryAxesModels = {};\n        if (isCategory) {\n            categoryAxesModels.single = singleAxisModel;\n        }\n\n        return {\n            dimensions: dimensions,\n            categoryIndex: isCategory ? 0 : -1,\n            categoryAxesModels: categoryAxesModels\n        };\n    },\n\n    polar: function (data, seriesModel, ecModel, completeDimOpt) {\n        var polarModel = ecModel.queryComponents({\n            mainType: 'polar',\n            index: seriesModel.get('polarIndex'),\n            id: seriesModel.get('polarId')\n        })[0];\n\n        var angleAxisModel = polarModel.findAxisModel('angleAxis');\n        var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\n        if (__DEV__) {\n            if (!angleAxisModel) {\n                throw new Error('angleAxis option not found');\n            }\n            if (!radiusAxisModel) {\n                throw new Error('radiusAxis option not found');\n            }\n        }\n\n        var radiusAxisType = radiusAxisModel.get('type');\n        var angleAxisType = angleAxisModel.get('type');\n\n        var dimensions = [\n            {\n                name: 'radius',\n                type: getDimTypeByAxis(radiusAxisType),\n                stackable: isStackable(radiusAxisType)\n            },\n            {\n                name: 'angle',\n                type: getDimTypeByAxis(angleAxisType),\n                stackable: isStackable(angleAxisType)\n            }\n        ];\n        var isAngleAxisCateogry = angleAxisType === 'category';\n        var isRadiusAxisCateogry = radiusAxisType === 'category';\n\n        dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n        var categoryAxesModels = {};\n        if (isRadiusAxisCateogry) {\n            categoryAxesModels.radius = radiusAxisModel;\n        }\n        if (isAngleAxisCateogry) {\n            categoryAxesModels.angle = angleAxisModel;\n        }\n        return {\n            dimensions: dimensions,\n            categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n            categoryAxesModels: categoryAxesModels\n        };\n    },\n\n    geo: function (data, seriesModel, ecModel, completeDimOpt) {\n        // TODO Region\n        // \n        return {\n            dimensions: completeDimensions([\n                {name: 'lng'},\n                {name: 'lat'}\n            ], data, completeDimOpt)\n        };\n    }\n};\n\nfunction createNameList(result, data) {\n    var nameList = [];\n\n    var categoryDim = result && result.dimensions[result.categoryIndex];\n    var categoryAxisModel;\n    if (categoryDim) {\n        categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n    }\n\n    if (categoryAxisModel) {\n        // FIXME Two category axis\n        var categories = categoryAxisModel.getCategories();\n        if (categories) {\n            var dataLen = data.length;\n            // Ordered data is given explicitly like\n            // [[3, 0.2], [1, 0.3], [2, 0.15]]\n            // or given scatter data,\n            // pick the category\n            if (isArray(data[0]) && data[0].length > 1) {\n                nameList = [];\n                for (var i = 0; i < dataLen; i++) {\n                    nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                }\n            }\n            else {\n                nameList = categories.slice(0);\n            }\n        }\n    }\n\n    return nameList;\n}\n\n/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n/**\n * @param {Object} [setting]\n */\nfunction Scale(setting) {\n    this._setting = setting || {};\n\n    /**\n     * Extent\n     * @type {Array.<number>}\n     * @protected\n     */\n    this._extent = [Infinity, -Infinity];\n\n    /**\n     * Step is calculated in adjustExtent\n     * @type {Array.<number>}\n     * @protected\n     */\n    this._interval = 0;\n\n    this.init && this.init.apply(this, arguments);\n}\n\n/**\n * Parse input val to valid inner number.\n * @param {*} val\n * @return {number}\n */\nScale.prototype.parse = function (val) {\n    // Notice: This would be a trap here, If the implementation\n    // of this method depends on extent, and this method is used\n    // before extent set (like in dataZoom), it would be wrong.\n    // Nevertheless, parse does not depend on extent generally.\n    return val;\n};\n\nScale.prototype.getSetting = function (name) {\n    return this._setting[name];\n};\n\nScale.prototype.contain = function (val) {\n    var extent = this._extent;\n    return val >= extent[0] && val <= extent[1];\n};\n\n/**\n * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n * @param {number} val\n * @return {number}\n */\nScale.prototype.normalize = function (val) {\n    var extent = this._extent;\n    if (extent[1] === extent[0]) {\n        return 0.5;\n    }\n    return (val - extent[0]) / (extent[1] - extent[0]);\n};\n\n/**\n * Scale normalized value\n * @param {number} val\n * @return {number}\n */\nScale.prototype.scale = function (val) {\n    var extent = this._extent;\n    return val * (extent[1] - extent[0]) + extent[0];\n};\n\n/**\n * Set extent from data\n * @param {Array.<number>} other\n */\nScale.prototype.unionExtent = function (other) {\n    var extent = this._extent;\n    other[0] < extent[0] && (extent[0] = other[0]);\n    other[1] > extent[1] && (extent[1] = other[1]);\n    // not setExtent because in log axis it may transformed to power\n    // this.setExtent(extent[0], extent[1]);\n};\n\n/**\n * Set extent from data\n * @param {module:echarts/data/List} data\n * @param {string} dim\n */\nScale.prototype.unionExtentFromData = function (data, dim) {\n    this.unionExtent(data.getDataExtent(dim, true));\n};\n\n/**\n * Get extent\n * @return {Array.<number>}\n */\nScale.prototype.getExtent = function () {\n    return this._extent.slice();\n};\n\n/**\n * Set extent\n * @param {number} start\n * @param {number} end\n */\nScale.prototype.setExtent = function (start, end) {\n    var thisExtent = this._extent;\n    if (!isNaN(start)) {\n        thisExtent[0] = start;\n    }\n    if (!isNaN(end)) {\n        thisExtent[1] = end;\n    }\n};\n\n/**\n * @return {Array.<string>}\n */\nScale.prototype.getTicksLabels = function () {\n    var labels = [];\n    var ticks = this.getTicks();\n    for (var i = 0; i < ticks.length; i++) {\n        labels.push(this.getLabel(ticks[i]));\n    }\n    return labels;\n};\n\n/**\n * When axis extent depends on data and no data exists,\n * axis ticks should not be drawn, which is named 'blank'.\n */\nScale.prototype.isBlank = function () {\n    return this._isBlank;\n},\n\n/**\n * When axis extent depends on data and no data exists,\n * axis ticks should not be drawn, which is named 'blank'.\n */\nScale.prototype.setBlank = function (isBlank) {\n    this._isBlank = isBlank;\n};\n\n\nenableClassExtend(Scale);\nenableClassManagement(Scale, {\n    registerWhenExtend: true\n});\n\n/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n\n// FIXME only one data\n\nvar scaleProto = Scale.prototype;\n\nvar OrdinalScale = Scale.extend({\n\n    type: 'ordinal',\n\n    init: function (data, extent) {\n        this._data = data;\n        this._extent = extent || [0, data.length - 1];\n    },\n\n    parse: function (val) {\n        return typeof val === 'string'\n            ? indexOf(this._data, val)\n            // val might be float.\n            : Math.round(val);\n    },\n\n    contain: function (rank) {\n        rank = this.parse(rank);\n        return scaleProto.contain.call(this, rank)\n            && this._data[rank] != null;\n    },\n\n    /**\n     * Normalize given rank or name to linear [0, 1]\n     * @param {number|string} [val]\n     * @return {number}\n     */\n    normalize: function (val) {\n        return scaleProto.normalize.call(this, this.parse(val));\n    },\n\n    scale: function (val) {\n        return Math.round(scaleProto.scale.call(this, val));\n    },\n\n    /**\n     * @return {Array}\n     */\n    getTicks: function () {\n        var ticks = [];\n        var extent = this._extent;\n        var rank = extent[0];\n\n        while (rank <= extent[1]) {\n            ticks.push(rank);\n            rank++;\n        }\n\n        return ticks;\n    },\n\n    /**\n     * Get item on rank n\n     * @param {number} n\n     * @return {string}\n     */\n    getLabel: function (n) {\n        return this._data[n];\n    },\n\n    /**\n     * @return {number}\n     */\n    count: function () {\n        return this._extent[1] - this._extent[0] + 1;\n    },\n\n    /**\n     * @override\n     */\n    unionExtentFromData: function (data, dim) {\n        this.unionExtent(data.getDataExtent(dim, false));\n    },\n\n    niceTicks: noop,\n    niceExtent: noop\n});\n\n/**\n * @return {module:echarts/scale/Time}\n */\nOrdinalScale.create = function () {\n    return new OrdinalScale();\n};\n\n/**\n * For testable.\n */\n\nvar roundNumber$1 = round;\n\n/**\n * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.\n *                                Should be extent[0] < extent[1].\n * @param {number} splitNumber splitNumber should be >= 1.\n * @param {number} [minInterval]\n * @param {number} [maxInterval]\n * @return {Object} {interval, intervalPrecision, niceTickExtent}\n */\nfunction intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {\n    var result = {};\n    var span = extent[1] - extent[0];\n\n    var interval = result.interval = nice(span / splitNumber, true);\n    if (minInterval != null && interval < minInterval) {\n        interval = result.interval = minInterval;\n    }\n    if (maxInterval != null && interval > maxInterval) {\n        interval = result.interval = maxInterval;\n    }\n    // Tow more digital for tick.\n    var precision = result.intervalPrecision = getIntervalPrecision(interval);\n    // Niced extent inside original extent\n    var niceTickExtent = result.niceTickExtent = [\n        roundNumber$1(Math.ceil(extent[0] / interval) * interval, precision),\n        roundNumber$1(Math.floor(extent[1] / interval) * interval, precision)\n    ];\n\n    fixExtent(niceTickExtent, extent);\n\n    return result;\n}\n\n/**\n * @param {number} interval\n * @return {number} interval precision\n */\nfunction getIntervalPrecision(interval) {\n    // Tow more digital for tick.\n    return getPrecisionSafe(interval) + 2;\n}\n\nfunction clamp(niceTickExtent, idx, extent) {\n    niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n}\n\n// In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.\nfunction fixExtent(niceTickExtent, extent) {\n    !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n    !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n    clamp(niceTickExtent, 0, extent);\n    clamp(niceTickExtent, 1, extent);\n    if (niceTickExtent[0] > niceTickExtent[1]) {\n        niceTickExtent[0] = niceTickExtent[1];\n    }\n}\n\nfunction intervalScaleGetTicks(interval, extent, niceTickExtent, intervalPrecision) {\n    var ticks = [];\n\n    // If interval is 0, return [];\n    if (!interval) {\n        return ticks;\n    }\n\n    // Consider this case: using dataZoom toolbox, zoom and zoom.\n    var safeLimit = 10000;\n\n    if (extent[0] < niceTickExtent[0]) {\n        ticks.push(extent[0]);\n    }\n    var tick = niceTickExtent[0];\n\n    while (tick <= niceTickExtent[1]) {\n        ticks.push(tick);\n        // Avoid rounding error\n        tick = roundNumber$1(tick + interval, intervalPrecision);\n        if (tick === ticks[ticks.length - 1]) {\n            // Consider out of safe float point, e.g.,\n            // -3711126.9907707 + 2e-10 === -3711126.9907707\n            break;\n        }\n        if (ticks.length > safeLimit) {\n            return [];\n        }\n    }\n    // Consider this case: the last item of ticks is smaller\n    // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n    if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) {\n        ticks.push(extent[1]);\n    }\n\n    return ticks;\n}\n\n/**\n * Interval scale\n * @module echarts/scale/Interval\n */\n\n\nvar roundNumber = round;\n\n/**\n * @alias module:echarts/coord/scale/Interval\n * @constructor\n */\nvar IntervalScale = Scale.extend({\n\n    type: 'interval',\n\n    _interval: 0,\n\n    _intervalPrecision: 2,\n\n    setExtent: function (start, end) {\n        var thisExtent = this._extent;\n        //start,end may be a Number like '25',so...\n        if (!isNaN(start)) {\n            thisExtent[0] = parseFloat(start);\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = parseFloat(end);\n        }\n    },\n\n    unionExtent: function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);\n\n        // unionExtent may called by it's sub classes\n        IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n    },\n    /**\n     * Get interval\n     */\n    getInterval: function () {\n        return this._interval;\n    },\n\n    /**\n     * Set interval\n     */\n    setInterval: function (interval) {\n        this._interval = interval;\n        // Dropped auto calculated niceExtent and use user setted extent\n        // We assume user wan't to set both interval, min, max to get a better result\n        this._niceExtent = this._extent.slice();\n\n        this._intervalPrecision = getIntervalPrecision(interval);\n    },\n\n    /**\n     * @return {Array.<number>}\n     */\n    getTicks: function () {\n        return intervalScaleGetTicks(\n            this._interval, this._extent, this._niceExtent, this._intervalPrecision\n        );\n    },\n\n    /**\n     * @return {Array.<string>}\n     */\n    getTicksLabels: function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    },\n\n    /**\n     * @param {number} data\n     * @param {Object} [opt]\n     * @param {number|string} [opt.precision] If 'auto', use nice presision.\n     * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.\n     * @return {string}\n     */\n    getLabel: function (data, opt) {\n        if (data == null) {\n            return '';\n        }\n\n        var precision = opt && opt.precision;\n\n        if (precision == null) {\n            precision = getPrecisionSafe(data) || 0;\n        }\n        else if (precision === 'auto') {\n            // Should be more precise then tick.\n            precision = this._intervalPrecision;\n        }\n\n        // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n        // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n        data = roundNumber(data, precision, true);\n\n        return addCommas(data);\n    },\n\n    /**\n     * Update interval and extent of intervals for nice ticks\n     *\n     * @param {number} [splitNumber = 5] Desired number of ticks\n     * @param {number} [minInterval]\n     * @param {number} [maxInterval]\n     */\n    niceTicks: function (splitNumber, minInterval, maxInterval) {\n        splitNumber = splitNumber || 5;\n        var extent = this._extent;\n        var span = extent[1] - extent[0];\n        if (!isFinite(span)) {\n            return;\n        }\n        // User may set axis min 0 and data are all negative\n        // FIXME If it needs to reverse ?\n        if (span < 0) {\n            span = -span;\n            extent.reverse();\n        }\n\n        var result = intervalScaleNiceTicks(\n            extent, splitNumber, minInterval, maxInterval\n        );\n\n        this._intervalPrecision = result.intervalPrecision;\n        this._interval = result.interval;\n        this._niceExtent = result.niceTickExtent;\n    },\n\n    /**\n     * Nice extent.\n     * @param {Object} opt\n     * @param {number} [opt.splitNumber = 5] Given approx tick number\n     * @param {boolean} [opt.fixMin=false]\n     * @param {boolean} [opt.fixMax=false]\n     * @param {boolean} [opt.minInterval]\n     * @param {boolean} [opt.maxInterval]\n     */\n    niceExtent: function (opt) {\n        var extent = this._extent;\n        // If extent start and end are same, expand them\n        if (extent[0] === extent[1]) {\n            if (extent[0] !== 0) {\n                // Expand extent\n                var expandSize = extent[0];\n                // In the fowllowing case\n                //      Axis has been fixed max 100\n                //      Plus data are all 100 and axis extent are [100, 100].\n                // Extend to the both side will cause expanded max is larger than fixed max.\n                // So only expand to the smaller side.\n                if (!opt.fixMax) {\n                    extent[1] += expandSize / 2;\n                    extent[0] -= expandSize / 2;\n                }\n                else {\n                    extent[0] -= expandSize / 2;\n                }\n            }\n            else {\n                extent[1] = 1;\n            }\n        }\n        var span = extent[1] - extent[0];\n        // If there are no data and extent are [Infinity, -Infinity]\n        if (!isFinite(span)) {\n            extent[0] = 0;\n            extent[1] = 1;\n        }\n\n        this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);\n\n        // var extent = this._extent;\n        var interval = this._interval;\n\n        if (!opt.fixMin) {\n            extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n        }\n        if (!opt.fixMax) {\n            extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n        }\n    }\n});\n\n/**\n * @return {module:echarts/scale/Time}\n */\nIntervalScale.create = function () {\n    return new IntervalScale();\n};\n\n// [About UTC and local time zone]:\n// In most cases, `number.parseDate` will treat input data string as local time\n// (except time zone is specified in time string). And `format.formateTime` returns\n// local time by default. option.useUTC is false by default. This design have\n// concidered these common case:\n// (1) Time that is persistent in server is in UTC, but it is needed to be diplayed\n// in local time by default.\n// (2) By default, the input data string (e.g., '2011-01-02') should be displayed\n// as its original time, without any time difference.\n\nvar intervalScaleProto = IntervalScale.prototype;\n\nvar mathCeil = Math.ceil;\nvar mathFloor = Math.floor;\nvar ONE_SECOND = 1000;\nvar ONE_MINUTE = ONE_SECOND * 60;\nvar ONE_HOUR = ONE_MINUTE * 60;\nvar ONE_DAY = ONE_HOUR * 24;\n\n// FIXME \nvar bisect = function (a, x, lo, hi) {\n    while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (a[mid][1] < x) {\n            lo = mid + 1;\n        }\n        else {\n            hi  = mid;\n        }\n    }\n    return lo;\n};\n\n/**\n * @alias module:echarts/coord/scale/Time\n * @constructor\n */\nvar TimeScale = IntervalScale.extend({\n    type: 'time',\n\n    /**\n     * @override\n     */\n    getLabel: function (val) {\n        var stepLvl = this._stepLvl;\n\n        var date = new Date(val);\n\n        return formatTime(stepLvl[0], date, this.getSetting('useUTC'));\n    },\n\n    /**\n     * @override\n     */\n    niceExtent: function (opt) {\n        var extent = this._extent;\n        // If extent start and end are same, expand them\n        if (extent[0] === extent[1]) {\n            // Expand extent\n            extent[0] -= ONE_DAY;\n            extent[1] += ONE_DAY;\n        }\n        // If there are no data and extent are [Infinity, -Infinity]\n        if (extent[1] === -Infinity && extent[0] === Infinity) {\n            var d = new Date();\n            extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());\n            extent[0] = extent[1] - ONE_DAY;\n        }\n\n        this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);\n\n        // var extent = this._extent;\n        var interval = this._interval;\n\n        if (!opt.fixMin) {\n            extent[0] = round(mathFloor(extent[0] / interval) * interval);\n        }\n        if (!opt.fixMax) {\n            extent[1] = round(mathCeil(extent[1] / interval) * interval);\n        }\n    },\n\n    /**\n     * @override\n     */\n    niceTicks: function (approxTickNum, minInterval, maxInterval) {\n        approxTickNum = approxTickNum || 10;\n\n        var extent = this._extent;\n        var span = extent[1] - extent[0];\n        var approxInterval = span / approxTickNum;\n\n        if (minInterval != null && approxInterval < minInterval) {\n            approxInterval = minInterval;\n        }\n        if (maxInterval != null && approxInterval > maxInterval) {\n            approxInterval = maxInterval;\n        }\n\n        var scaleLevelsLen = scaleLevels.length;\n        var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\n        var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n        var interval = level[1];\n        // Same with interval scale if span is much larger than 1 year\n        if (level[0] === 'year') {\n            var yearSpan = span / interval;\n\n            // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n            // var niceYearSpan = numberUtil.nice(yearSpan, false);\n            var yearStep = nice(yearSpan / approxTickNum, true);\n\n            interval *= yearStep;\n        }\n\n        var timezoneOffset = this.getSetting('useUTC')\n            ? 0 : (new Date(+extent[0] || +extent[1])).getTimezoneOffset() * 60 * 1000;\n        var niceExtent = [\n            Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset),\n            Math.round(mathFloor((extent[1] - timezoneOffset) / interval) * interval + timezoneOffset)\n        ];\n\n        fixExtent(niceExtent, extent);\n\n        this._stepLvl = level;\n        // Interval will be used in getTicks\n        this._interval = interval;\n        this._niceExtent = niceExtent;\n    },\n\n    parse: function (val) {\n        // val might be float.\n        return +parseDate(val);\n    }\n});\n\neach$1(['contain', 'normalize'], function (methodName) {\n    TimeScale.prototype[methodName] = function (val) {\n        return intervalScaleProto[methodName].call(this, this.parse(val));\n    };\n});\n\n// Steps from d3\nvar scaleLevels = [\n    // Format              interval\n    ['hh:mm:ss', ONE_SECOND],          // 1s\n    ['hh:mm:ss', ONE_SECOND * 5],      // 5s\n    ['hh:mm:ss', ONE_SECOND * 10],     // 10s\n    ['hh:mm:ss', ONE_SECOND * 15],     // 15s\n    ['hh:mm:ss', ONE_SECOND * 30],     // 30s\n    ['hh:mm\\nMM-dd', ONE_MINUTE],      // 1m\n    ['hh:mm\\nMM-dd', ONE_MINUTE * 5],  // 5m\n    ['hh:mm\\nMM-dd', ONE_MINUTE * 10], // 10m\n    ['hh:mm\\nMM-dd', ONE_MINUTE * 15], // 15m\n    ['hh:mm\\nMM-dd', ONE_MINUTE * 30], // 30m\n    ['hh:mm\\nMM-dd', ONE_HOUR],        // 1h\n    ['hh:mm\\nMM-dd', ONE_HOUR * 2],    // 2h\n    ['hh:mm\\nMM-dd', ONE_HOUR * 6],    // 6h\n    ['hh:mm\\nMM-dd', ONE_HOUR * 12],   // 12h\n    ['MM-dd\\nyyyy', ONE_DAY],          // 1d\n    ['MM-dd\\nyyyy', ONE_DAY * 2],      // 2d\n    ['MM-dd\\nyyyy', ONE_DAY * 3],      // 3d\n    ['MM-dd\\nyyyy', ONE_DAY * 4],      // 4d\n    ['MM-dd\\nyyyy', ONE_DAY * 5],      // 5d\n    ['MM-dd\\nyyyy', ONE_DAY * 6],      // 6d\n    ['week', ONE_DAY * 7],             // 7d\n    ['MM-dd\\nyyyy', ONE_DAY * 10],     // 10d\n    ['week', ONE_DAY * 14],            // 2w\n    ['week', ONE_DAY * 21],            // 3w\n    ['month', ONE_DAY * 31],           // 1M\n    ['week', ONE_DAY * 42],            // 6w\n    ['month', ONE_DAY * 62],           // 2M\n    ['week', ONE_DAY * 42],            // 10w\n    ['quarter', ONE_DAY * 380 / 4],    // 3M\n    ['month', ONE_DAY * 31 * 4],       // 4M\n    ['month', ONE_DAY * 31 * 5],       // 5M\n    ['half-year', ONE_DAY * 380 / 2],  // 6M\n    ['month', ONE_DAY * 31 * 8],       // 8M\n    ['month', ONE_DAY * 31 * 10],      // 10M\n    ['year', ONE_DAY * 380]            // 1Y\n];\n\n/**\n * @param {module:echarts/model/Model}\n * @return {module:echarts/scale/Time}\n */\nTimeScale.create = function (model) {\n    return new TimeScale({useUTC: model.ecModel.get('useUTC')});\n};\n\n/**\n * Log scale\n * @module echarts/scale/Log\n */\n\n// Use some method of IntervalScale\nvar scaleProto$1 = Scale.prototype;\nvar intervalScaleProto$1 = IntervalScale.prototype;\n\nvar getPrecisionSafe$1 = getPrecisionSafe;\nvar roundingErrorFix = round;\n\nvar mathFloor$1 = Math.floor;\nvar mathCeil$1 = Math.ceil;\nvar mathPow$1 = Math.pow;\n\nvar mathLog = Math.log;\n\nvar LogScale = Scale.extend({\n\n    type: 'log',\n\n    base: 10,\n\n    $constructor: function () {\n        Scale.apply(this, arguments);\n        this._originalScale = new IntervalScale();\n    },\n\n    /**\n     * @return {Array.<number>}\n     */\n    getTicks: function () {\n        var originalScale = this._originalScale;\n        var extent = this._extent;\n        var originalExtent = originalScale.getExtent();\n\n        return map(intervalScaleProto$1.getTicks.call(this), function (val) {\n            var powVal = round(mathPow$1(this.base, val));\n\n            // Fix #4158\n            powVal = (val === extent[0] && originalScale.__fixMin)\n                ? fixRoundingError(powVal, originalExtent[0])\n                : powVal;\n            powVal = (val === extent[1] && originalScale.__fixMax)\n                ? fixRoundingError(powVal, originalExtent[1])\n                : powVal;\n\n            return powVal;\n        }, this);\n    },\n\n    /**\n     * @param {number} val\n     * @return {string}\n     */\n    getLabel: intervalScaleProto$1.getLabel,\n\n    /**\n     * @param  {number} val\n     * @return {number}\n     */\n    scale: function (val) {\n        val = scaleProto$1.scale.call(this, val);\n        return mathPow$1(this.base, val);\n    },\n\n    /**\n     * @param {number} start\n     * @param {number} end\n     */\n    setExtent: function (start, end) {\n        var base = this.base;\n        start = mathLog(start) / mathLog(base);\n        end = mathLog(end) / mathLog(base);\n        intervalScaleProto$1.setExtent.call(this, start, end);\n    },\n\n    /**\n     * @return {number} end\n     */\n    getExtent: function () {\n        var base = this.base;\n        var extent = scaleProto$1.getExtent.call(this);\n        extent[0] = mathPow$1(base, extent[0]);\n        extent[1] = mathPow$1(base, extent[1]);\n\n        // Fix #4158\n        var originalScale = this._originalScale;\n        var originalExtent = originalScale.getExtent();\n        originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n        originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\n        return extent;\n    },\n\n    /**\n     * @param  {Array.<number>} extent\n     */\n    unionExtent: function (extent) {\n        this._originalScale.unionExtent(extent);\n\n        var base = this.base;\n        extent[0] = mathLog(extent[0]) / mathLog(base);\n        extent[1] = mathLog(extent[1]) / mathLog(base);\n        scaleProto$1.unionExtent.call(this, extent);\n    },\n\n    /**\n     * @override\n     */\n    unionExtentFromData: function (data, dim) {\n        this.unionExtent(data.getDataExtent(dim, true, function (val) {\n            return val > 0;\n        }));\n    },\n\n    /**\n     * Update interval and extent of intervals for nice ticks\n     * @param  {number} [approxTickNum = 10] Given approx tick number\n     */\n    niceTicks: function (approxTickNum) {\n        approxTickNum = approxTickNum || 10;\n        var extent = this._extent;\n        var span = extent[1] - extent[0];\n        if (span === Infinity || span <= 0) {\n            return;\n        }\n\n        var interval = quantity(span);\n        var err = approxTickNum / span * interval;\n\n        // Filter ticks to get closer to the desired count.\n        if (err <= 0.5) {\n            interval *= 10;\n        }\n\n        // Interval should be integer\n        while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n            interval *= 10;\n        }\n\n        var niceExtent = [\n            round(mathCeil$1(extent[0] / interval) * interval),\n            round(mathFloor$1(extent[1] / interval) * interval)\n        ];\n\n        this._interval = interval;\n        this._niceExtent = niceExtent;\n    },\n\n    /**\n     * Nice extent.\n     * @override\n     */\n    niceExtent: function (opt) {\n        intervalScaleProto$1.niceExtent.call(this, opt);\n\n        var originalScale = this._originalScale;\n        originalScale.__fixMin = opt.fixMin;\n        originalScale.__fixMax = opt.fixMax;\n    }\n\n});\n\neach$1(['contain', 'normalize'], function (methodName) {\n    LogScale.prototype[methodName] = function (val) {\n        val = mathLog(val) / mathLog(this.base);\n        return scaleProto$1[methodName].call(this, val);\n    };\n});\n\nLogScale.create = function () {\n    return new LogScale();\n};\n\nfunction fixRoundingError(val, originalVal) {\n    return roundingErrorFix(val, getPrecisionSafe$1(originalVal));\n}\n\n/**\n * Get axis scale extent before niced.\n * Item of returned array can only be number (including Infinity and NaN).\n */\nfunction getScaleExtent(scale, model) {\n    var scaleType = scale.type;\n\n    var min = model.getMin();\n    var max = model.getMax();\n    var fixMin = min != null;\n    var fixMax = max != null;\n    var originalExtent = scale.getExtent();\n\n    var axisDataLen;\n    var boundaryGap;\n    var span;\n    if (scaleType === 'ordinal') {\n        axisDataLen = (model.get('data') || []).length;\n    }\n    else {\n        boundaryGap = model.get('boundaryGap');\n        if (!isArray(boundaryGap)) {\n            boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n        }\n        if (typeof boundaryGap[0] === 'boolean') {\n            if (__DEV__) {\n                console.warn('Boolean type for boundaryGap is only '\n                    + 'allowed for ordinal axis. Please use string in '\n                    + 'percentage instead, e.g., \"20%\". Currently, '\n                    + 'boundaryGap is set to be 0.');\n            }\n            boundaryGap = [0, 0];\n        }\n        boundaryGap[0] = parsePercent$1(boundaryGap[0], 1);\n        boundaryGap[1] = parsePercent$1(boundaryGap[1], 1);\n        span = (originalExtent[1] - originalExtent[0])\n            || Math.abs(originalExtent[0]);\n    }\n\n    // Notice: When min/max is not set (that is, when there are null/undefined,\n    // which is the most common case), these cases should be ensured:\n    // (1) For 'ordinal', show all axis.data.\n    // (2) For others:\n    //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n    //      disabled).\n    //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n    //      be the result that originalExtent enlarged by boundaryGap.\n    // (3) If no data, it should be ensured that `scale.setBlank` is set.\n\n    // FIXME\n    // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?\n    // (2) When `needCrossZero` and all data is positive/negative, should it be ensured\n    // that the results processed by boundaryGap are positive/negative?\n\n    if (min == null) {\n        min = scaleType === 'ordinal'\n            ? (axisDataLen ? 0 : NaN)\n            : originalExtent[0] - boundaryGap[0] * span;\n    }\n    if (max == null) {\n        max = scaleType === 'ordinal'\n            ? (axisDataLen ? axisDataLen - 1 : NaN)\n            : originalExtent[1] + boundaryGap[1] * span;\n    }\n\n    if (min === 'dataMin') {\n        min = originalExtent[0];\n    }\n    else if (typeof min === 'function') {\n        min = min({\n            min: originalExtent[0],\n            max: originalExtent[1]\n        });\n    }\n\n    if (max === 'dataMax') {\n        max = originalExtent[1];\n    }\n    else if (typeof max === 'function') {\n        max = max({\n            min: originalExtent[0],\n            max: originalExtent[1]\n        });\n    }\n\n    (min == null || !isFinite(min)) && (min = NaN);\n    (max == null || !isFinite(max)) && (max = NaN);\n\n    scale.setBlank(eqNaN(min) || eqNaN(max));\n\n    // Evaluate if axis needs cross zero\n    if (model.getNeedCrossZero()) {\n        // Axis is over zero and min is not set\n        if (min > 0 && max > 0 && !fixMin) {\n            min = 0;\n        }\n        // Axis is under zero and max is not set\n        if (min < 0 && max < 0 && !fixMax) {\n            max = 0;\n        }\n    }\n\n    return [min, max];\n}\n\nfunction niceScaleExtent(scale, model) {\n    var extent = getScaleExtent(scale, model);\n    var fixMin = model.getMin() != null;\n    var fixMax = model.getMax() != null;\n    var splitNumber = model.get('splitNumber');\n\n    if (scale.type === 'log') {\n        scale.base = model.get('logBase');\n    }\n\n    var scaleType = scale.type;\n    scale.setExtent(extent[0], extent[1]);\n    scale.niceExtent({\n        splitNumber: splitNumber,\n        fixMin: fixMin,\n        fixMax: fixMax,\n        minInterval: (scaleType === 'interval' || scaleType === 'time')\n            ? model.get('minInterval') : null,\n        maxInterval: (scaleType === 'interval' || scaleType === 'time')\n            ? model.get('maxInterval') : null\n    });\n\n    // If some one specified the min, max. And the default calculated interval\n    // is not good enough. He can specify the interval. It is often appeared\n    // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n    // to be 60.\n    // FIXME\n    var interval = model.get('interval');\n    if (interval != null) {\n        scale.setInterval && scale.setInterval(interval);\n    }\n}\n\n/**\n * @param {module:echarts/model/Model} model\n * @param {string} [axisType] Default retrieve from model.type\n * @return {module:echarts/scale/*}\n */\nfunction createScaleByModel(model, axisType) {\n    axisType = axisType || model.get('type');\n    if (axisType) {\n        switch (axisType) {\n            // Buildin scale\n            case 'category':\n                return new OrdinalScale(\n                    model.getCategories(), [Infinity, -Infinity]\n                );\n            case 'value':\n                return new IntervalScale();\n            // Extended scale, like time and log\n            default:\n                return (Scale.getClass(axisType) || IntervalScale).create(model);\n        }\n    }\n}\n\n/**\n * Check if the axis corss 0\n */\nfunction ifAxisCrossZero(axis) {\n    var dataExtent = axis.scale.getExtent();\n    var min = dataExtent[0];\n    var max = dataExtent[1];\n    return !((min > 0 && max > 0) || (min < 0 && max < 0));\n}\n\n/**\n * @param {Array.<number>} tickCoords In axis self coordinate.\n * @param {Array.<string>} labels\n * @param {string} font\n * @param {number} axisRotate 0: towards right horizontally, clock-wise is negative.\n * @param {number} [labelRotate=0] 0: towards right horizontally, clock-wise is negative.\n * @return {number}\n */\nfunction getAxisLabelInterval(tickCoords, labels, font, axisRotate, labelRotate) {\n    var textSpaceTakenRect;\n    var autoLabelInterval = 0;\n    var accumulatedLabelInterval = 0;\n    var rotation = (axisRotate - labelRotate) / 180 * Math.PI;\n\n    var step = 1;\n    if (labels.length > 40) {\n        // Simple optimization for large amount of labels\n        step = Math.floor(labels.length / 40);\n    }\n\n    for (var i = 0; i < tickCoords.length; i += step) {\n        var tickCoord = tickCoords[i];\n\n        // Not precise, do not consider align and vertical align\n        // and each distance from axis line yet.\n        var rect = getBoundingRect(\n            labels[i], font, 'center', 'top'\n        );\n        rect.x += tickCoord * Math.cos(rotation);\n        rect.y += tickCoord * Math.sin(rotation);\n\n        // Magic number\n        rect.width *= 1.3;\n        rect.height *= 1.3;\n\n        if (!textSpaceTakenRect) {\n            textSpaceTakenRect = rect.clone();\n        }\n        // There is no space for current label;\n        else if (textSpaceTakenRect.intersect(rect)) {\n            accumulatedLabelInterval++;\n            autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n        }\n        else {\n            textSpaceTakenRect.union(rect);\n            // Reset\n            accumulatedLabelInterval = 0;\n        }\n    }\n    if (autoLabelInterval === 0 && step > 1) {\n        return step;\n    }\n    return (autoLabelInterval + 1) * step - 1;\n}\n\n/**\n * @param {Object} axis\n * @param {Function} labelFormatter\n * @return {Array.<string>}\n */\nfunction getFormattedLabels(axis, labelFormatter) {\n    var scale = axis.scale;\n    var labels = scale.getTicksLabels();\n    var ticks = scale.getTicks();\n    if (typeof labelFormatter === 'string') {\n        labelFormatter = (function (tpl) {\n            return function (val) {\n                return tpl.replace('{value}', val != null ? val : '');\n            };\n        })(labelFormatter);\n        // Consider empty array\n        return map(labels, labelFormatter);\n    }\n    else if (typeof labelFormatter === 'function') {\n        return map(ticks, function (tick, idx) {\n            return labelFormatter(\n                getAxisRawValue(axis, tick),\n                idx\n            );\n        }, this);\n    }\n    else {\n        return labels;\n    }\n}\n\nfunction getAxisRawValue(axis, value) {\n    // In category axis with data zoom, tick is not the original\n    // index of axis.data. So tick should not be exposed to user\n    // in category axis.\n    return axis.type === 'category' ? axis.scale.getLabel(value) : value;\n}\n\nfunction getName(obj) {\n    if (isObject(obj) && obj.value != null) {\n        return obj.value;\n    }\n    else {\n        return obj + '';\n    }\n}\n\nvar axisModelCommonMixin = {\n\n    /**\n     * Format labels\n     * @return {Array.<string>}\n     */\n    getFormattedLabels: function () {\n        return getFormattedLabels(\n            this.axis,\n            this.get('axisLabel.formatter')\n        );\n    },\n\n    /**\n     * Get categories\n     */\n    getCategories: function () {\n        return this.get('type') === 'category'\n            && map(this.get('data'), getName);\n    },\n\n    /**\n     * @param {boolean} origin\n     * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n     */\n    getMin: function (origin) {\n        var option = this.option;\n        var min = (!origin && option.rangeStart != null)\n            ? option.rangeStart : option.min;\n\n        if (this.axis\n            && min != null\n            && min !== 'dataMin'\n            && typeof min !== 'function'\n            && !eqNaN(min)\n        ) {\n            min = this.axis.scale.parse(min);\n        }\n        return min;\n    },\n\n    /**\n     * @param {boolean} origin\n     * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n     */\n    getMax: function (origin) {\n        var option = this.option;\n        var max = (!origin && option.rangeEnd != null)\n            ? option.rangeEnd : option.max;\n\n        if (this.axis\n            && max != null\n            && max !== 'dataMax'\n            && typeof max !== 'function'\n            && !eqNaN(max)\n        ) {\n            max = this.axis.scale.parse(max);\n        }\n        return max;\n    },\n\n    /**\n     * @return {boolean}\n     */\n    getNeedCrossZero: function () {\n        var option = this.option;\n        return (option.rangeStart != null || option.rangeEnd != null)\n            ? false : !option.scale;\n    },\n\n    /**\n     * Should be implemented by each axis model if necessary.\n     * @return {module:echarts/model/Component} coordinate system model\n     */\n    getCoordSysModel: noop,\n\n    /**\n     * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n     * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n     */\n    setRange: function (rangeStart, rangeEnd) {\n        this.option.rangeStart = rangeStart;\n        this.option.rangeEnd = rangeEnd;\n    },\n\n    /**\n     * Reset range\n     */\n    resetRange: function () {\n        // rangeStart and rangeEnd is readonly.\n        this.option.rangeStart = this.option.rangeEnd = null;\n    }\n};\n\n// Symbol factory\n\n/**\n * Triangle shape\n * @inner\n */\nvar Triangle = extendShape({\n    type: 'triangle',\n    shape: {\n        cx: 0,\n        cy: 0,\n        width: 0,\n        height: 0\n    },\n    buildPath: function (path, shape) {\n        var cx = shape.cx;\n        var cy = shape.cy;\n        var width = shape.width / 2;\n        var height = shape.height / 2;\n        path.moveTo(cx, cy - height);\n        path.lineTo(cx + width, cy + height);\n        path.lineTo(cx - width, cy + height);\n        path.closePath();\n    }\n});\n\n/**\n * Diamond shape\n * @inner\n */\nvar Diamond = extendShape({\n    type: 'diamond',\n    shape: {\n        cx: 0,\n        cy: 0,\n        width: 0,\n        height: 0\n    },\n    buildPath: function (path, shape) {\n        var cx = shape.cx;\n        var cy = shape.cy;\n        var width = shape.width / 2;\n        var height = shape.height / 2;\n        path.moveTo(cx, cy - height);\n        path.lineTo(cx + width, cy);\n        path.lineTo(cx, cy + height);\n        path.lineTo(cx - width, cy);\n        path.closePath();\n    }\n});\n\n/**\n * Pin shape\n * @inner\n */\nvar Pin = extendShape({\n    type: 'pin',\n    shape: {\n        // x, y on the cusp\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n    },\n\n    buildPath: function (path, shape) {\n        var x = shape.x;\n        var y = shape.y;\n        var w = shape.width / 5 * 3;\n        // Height must be larger than width\n        var h = Math.max(w, shape.height);\n        var r = w / 2;\n\n        // Dist on y with tangent point and circle center\n        var dy = r * r / (h - r);\n        var cy = y - h + r + dy;\n        var angle = Math.asin(dy / r);\n        // Dist on x with tangent point and circle center\n        var dx = Math.cos(angle) * r;\n\n        var tanX = Math.sin(angle);\n        var tanY = Math.cos(angle);\n\n        var cpLen = r * 0.6;\n        var cpLen2 = r * 0.7;\n\n        path.moveTo(x - dx, cy + dy);\n\n        path.arc(\n            x, cy, r,\n            Math.PI - angle,\n            Math.PI * 2 + angle\n        );\n        path.bezierCurveTo(\n            x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n            x, y - cpLen2,\n            x, y\n        );\n        path.bezierCurveTo(\n            x, y - cpLen2,\n            x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n            x - dx, cy + dy\n        );\n        path.closePath();\n    }\n});\n\n/**\n * Arrow shape\n * @inner\n */\nvar Arrow = extendShape({\n\n    type: 'arrow',\n\n    shape: {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n    },\n\n    buildPath: function (ctx, shape) {\n        var height = shape.height;\n        var width = shape.width;\n        var x = shape.x;\n        var y = shape.y;\n        var dx = width / 3 * 2;\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + dx, y + height);\n        ctx.lineTo(x, y + height / 4 * 3);\n        ctx.lineTo(x - dx, y + height);\n        ctx.lineTo(x, y);\n        ctx.closePath();\n    }\n});\n\n/**\n * Map of path contructors\n * @type {Object.<string, module:zrender/graphic/Path>}\n */\nvar symbolCtors = {\n\n    line: Line,\n\n    rect: Rect,\n\n    roundRect: Rect,\n\n    square: Rect,\n\n    circle: Circle,\n\n    diamond: Diamond,\n\n    pin: Pin,\n\n    arrow: Arrow,\n\n    triangle: Triangle\n};\n\nvar symbolShapeMakers = {\n\n    line: function (x, y, w, h, shape) {\n        // FIXME\n        shape.x1 = x;\n        shape.y1 = y + h / 2;\n        shape.x2 = x + w;\n        shape.y2 = y + h / 2;\n    },\n\n    rect: function (x, y, w, h, shape) {\n        shape.x = x;\n        shape.y = y;\n        shape.width = w;\n        shape.height = h;\n    },\n\n    roundRect: function (x, y, w, h, shape) {\n        shape.x = x;\n        shape.y = y;\n        shape.width = w;\n        shape.height = h;\n        shape.r = Math.min(w, h) / 4;\n    },\n\n    square: function (x, y, w, h, shape) {\n        var size = Math.min(w, h);\n        shape.x = x;\n        shape.y = y;\n        shape.width = size;\n        shape.height = size;\n    },\n\n    circle: function (x, y, w, h, shape) {\n        // Put circle in the center of square\n        shape.cx = x + w / 2;\n        shape.cy = y + h / 2;\n        shape.r = Math.min(w, h) / 2;\n    },\n\n    diamond: function (x, y, w, h, shape) {\n        shape.cx = x + w / 2;\n        shape.cy = y + h / 2;\n        shape.width = w;\n        shape.height = h;\n    },\n\n    pin: function (x, y, w, h, shape) {\n        shape.x = x + w / 2;\n        shape.y = y + h / 2;\n        shape.width = w;\n        shape.height = h;\n    },\n\n    arrow: function (x, y, w, h, shape) {\n        shape.x = x + w / 2;\n        shape.y = y + h / 2;\n        shape.width = w;\n        shape.height = h;\n    },\n\n    triangle: function (x, y, w, h, shape) {\n        shape.cx = x + w / 2;\n        shape.cy = y + h / 2;\n        shape.width = w;\n        shape.height = h;\n    }\n};\n\nvar symbolBuildProxies = {};\neach$1(symbolCtors, function (Ctor, name) {\n    symbolBuildProxies[name] = new Ctor();\n});\n\nvar SymbolClz = extendShape({\n\n    type: 'symbol',\n\n    shape: {\n        symbolType: '',\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n    },\n\n    beforeBrush: function () {\n        var style = this.style;\n        var shape = this.shape;\n        // FIXME\n        if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n            style.textPosition = ['50%', '40%'];\n            style.textAlign = 'center';\n            style.textVerticalAlign = 'middle';\n        }\n    },\n\n    buildPath: function (ctx, shape, inBundle) {\n        var symbolType = shape.symbolType;\n        var proxySymbol = symbolBuildProxies[symbolType];\n        if (shape.symbolType !== 'none') {\n            if (!proxySymbol) {\n                // Default rect\n                symbolType = 'rect';\n                proxySymbol = symbolBuildProxies[symbolType];\n            }\n            symbolShapeMakers[symbolType](\n                shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n            );\n            proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n        }\n    }\n});\n\n// Provide setColor helper method to avoid determine if set the fill or stroke outside\nfunction symbolPathSetColor(color, innerColor) {\n    if (this.type !== 'image') {\n        var symbolStyle = this.style;\n        var symbolShape = this.shape;\n        if (symbolShape && symbolShape.symbolType === 'line') {\n            symbolStyle.stroke = color;\n        }\n        else if (this.__isEmptyBrush) {\n            symbolStyle.stroke = color;\n            symbolStyle.fill = innerColor || '#fff';\n        }\n        else {\n            // FIXME  onlyStroke ?\n            symbolStyle.fill && (symbolStyle.fill = color);\n            symbolStyle.stroke && (symbolStyle.stroke = color);\n        }\n        this.dirty(false);\n    }\n}\n\n/**\n * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n * @param {string} symbolType\n * @param {number} x\n * @param {number} y\n * @param {number} w\n * @param {number} h\n * @param {string} color\n * @param {boolean} [keepAspect=false] whether to keep the ratio of w/h,\n *                            for path and image only.\n */\nfunction createSymbol(symbolType, x, y, w, h, color, keepAspect) {\n    // TODO Support image object, DynamicImage.\n\n    var isEmpty = symbolType.indexOf('empty') === 0;\n    if (isEmpty) {\n        symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n    }\n    var symbolPath;\n\n    if (symbolType.indexOf('image://') === 0) {\n        symbolPath = makeImage(\n            symbolType.slice(8),\n            new BoundingRect(x, y, w, h),\n            keepAspect ? 'center' : 'cover'\n        );\n    }\n    else if (symbolType.indexOf('path://') === 0) {\n        symbolPath = makePath(\n            symbolType.slice(7),\n            {},\n            new BoundingRect(x, y, w, h),\n            keepAspect ? 'center' : 'cover'\n        );\n    }\n    else {\n        symbolPath = new SymbolClz({\n            shape: {\n                symbolType: symbolType,\n                x: x,\n                y: y,\n                width: w,\n                height: h\n            }\n        });\n    }\n\n    symbolPath.__isEmptyBrush = isEmpty;\n\n    symbolPath.setColor = symbolPathSetColor;\n\n    symbolPath.setColor(color);\n\n    return symbolPath;\n}\n\n/**\n * Create a muti dimension List structure from seriesModel.\n * @param  {module:echarts/model/Model} seriesModel\n * @return {module:echarts/data/List} list\n */\nfunction createList(seriesModel) {\n    var data = seriesModel.get('data');\n    return createListFromArray(data, seriesModel, seriesModel.ecModel);\n}\n\n/**\n * Create scale\n * @param {Array.<number>} dataExtent\n * @param {Object|module:echarts/Model} option\n */\nfunction createScale(dataExtent, option) {\n    var axisModel = option;\n    if (!(option instanceof Model)) {\n        axisModel = new Model(option);\n        mixin(axisModel, axisModelCommonMixin);\n    }\n\n    var scale = createScaleByModel(axisModel);\n    scale.setExtent(dataExtent[0], dataExtent[1]);\n\n    niceScaleExtent(scale, axisModel);\n    return scale;\n}\n\n/**\n * Mixin common methods to axis model,\n *\n * Inlcude methods\n * `getFormattedLabels() => Array.<string>`\n * `getCategories() => Array.<string>`\n * `getMin(origin: boolean) => number`\n * `getMax(origin: boolean) => number`\n * `getNeedCrossZero() => boolean`\n * `setRange(start: number, end: number)`\n * `resetRange()`\n */\nfunction mixinAxisModelCommonMethods(Model$$1) {\n    mixin(Model$$1, axisModelCommonMixin);\n}\n\nvar helper = (Object.freeze || Object)({\n\tcreateList: createList,\n\tcreateScale: createScale,\n\tmixinAxisModelCommonMethods: mixinAxisModelCommonMethods,\n\tcompleteDimensions: completeDimensions,\n\tcreateSymbol: createSymbol\n});\n\nvar linearMap$1 = linearMap;\n\nfunction fixExtentWithBands(extent, nTick) {\n    var size = extent[1] - extent[0];\n    var len = nTick;\n    var margin = size / len / 2;\n    extent[0] += margin;\n    extent[1] -= margin;\n}\n\nvar normalizedExtent = [0, 1];\n/**\n * @name module:echarts/coord/CartesianAxis\n * @constructor\n */\nvar Axis = function (dim, scale, extent) {\n\n    /**\n     * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n     * @type {string}\n     */\n    this.dim = dim;\n\n    /**\n     * Axis scale\n     * @type {module:echarts/coord/scale/*}\n     */\n    this.scale = scale;\n\n    /**\n     * @type {Array.<number>}\n     * @private\n     */\n    this._extent = extent || [0, 0];\n\n    /**\n     * @type {boolean}\n     */\n    this.inverse = false;\n\n    /**\n     * Usually true when axis has a ordinal scale\n     * @type {boolean}\n     */\n    this.onBand = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this._labelInterval;\n};\n\nAxis.prototype = {\n\n    constructor: Axis,\n\n    /**\n     * If axis extent contain given coord\n     * @param {number} coord\n     * @return {boolean}\n     */\n    contain: function (coord) {\n        var extent = this._extent;\n        var min = Math.min(extent[0], extent[1]);\n        var max = Math.max(extent[0], extent[1]);\n        return coord >= min && coord <= max;\n    },\n\n    /**\n     * If axis extent contain given data\n     * @param {number} data\n     * @return {boolean}\n     */\n    containData: function (data) {\n        return this.contain(this.dataToCoord(data));\n    },\n\n    /**\n     * Get coord extent.\n     * @return {Array.<number>}\n     */\n    getExtent: function () {\n        return this._extent.slice();\n    },\n\n    /**\n     * Get precision used for formatting\n     * @param {Array.<number>} [dataExtent]\n     * @return {number}\n     */\n    getPixelPrecision: function (dataExtent) {\n        return getPixelPrecision(\n            dataExtent || this.scale.getExtent(),\n            this._extent\n        );\n    },\n\n    /**\n     * Set coord extent\n     * @param {number} start\n     * @param {number} end\n     */\n    setExtent: function (start, end) {\n        var extent = this._extent;\n        extent[0] = start;\n        extent[1] = end;\n    },\n\n    /**\n     * Convert data to coord. Data is the rank if it has a ordinal scale\n     * @param {number} data\n     * @param  {boolean} clamp\n     * @return {number}\n     */\n    dataToCoord: function (data, clamp) {\n        var extent = this._extent;\n        var scale = this.scale;\n        data = scale.normalize(data);\n\n        if (this.onBand && scale.type === 'ordinal') {\n            extent = extent.slice();\n            fixExtentWithBands(extent, scale.count());\n        }\n\n        return linearMap$1(data, normalizedExtent, extent, clamp);\n    },\n\n    /**\n     * Convert coord to data. Data is the rank if it has a ordinal scale\n     * @param {number} coord\n     * @param  {boolean} clamp\n     * @return {number}\n     */\n    coordToData: function (coord, clamp) {\n        var extent = this._extent;\n        var scale = this.scale;\n\n        if (this.onBand && scale.type === 'ordinal') {\n            extent = extent.slice();\n            fixExtentWithBands(extent, scale.count());\n        }\n\n        var t = linearMap$1(coord, extent, normalizedExtent, clamp);\n\n        return this.scale.scale(t);\n    },\n\n    /**\n     * Convert pixel point to data in axis\n     * @param {Array.<number>} point\n     * @param  {boolean} clamp\n     * @return {number} data\n     */\n    pointToData: function (point, clamp) {\n        // Should be implemented in derived class if necessary.\n    },\n\n    /**\n     * @return {Array.<number>}\n     */\n    getTicksCoords: function (alignWithLabel) {\n        if (this.onBand && !alignWithLabel) {\n            var bands = this.getBands();\n            var coords = [];\n            for (var i = 0; i < bands.length; i++) {\n                coords.push(bands[i][0]);\n            }\n            if (bands[i - 1]) {\n                coords.push(bands[i - 1][1]);\n            }\n            return coords;\n        }\n        else {\n            return map(this.scale.getTicks(), this.dataToCoord, this);\n        }\n    },\n\n    /**\n     * Coords of labels are on the ticks or on the middle of bands\n     * @return {Array.<number>}\n     */\n    getLabelsCoords: function () {\n        return map(this.scale.getTicks(), this.dataToCoord, this);\n    },\n\n    /**\n     * Get bands.\n     *\n     * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n     * |---1---|---2---|---3---|---4---|.\n     *\n     * @return {Array}\n     */\n        // FIXME Situation when labels is on ticks\n    getBands: function () {\n        var extent = this.getExtent();\n        var bands = [];\n        var len = this.scale.count();\n        var start = extent[0];\n        var end = extent[1];\n        var span = end - start;\n\n        for (var i = 0; i < len; i++) {\n            bands.push([\n                span * i / len + start,\n                span * (i + 1) / len + start\n            ]);\n        }\n        return bands;\n    },\n\n    /**\n     * Get width of band\n     * @return {number}\n     */\n    getBandWidth: function () {\n        var axisExtent = this._extent;\n        var dataExtent = this.scale.getExtent();\n\n        var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n        // Fix #2728, avoid NaN when only one data.\n        len === 0 && (len = 1);\n\n        var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\n        return Math.abs(size) / len;\n    },\n\n    /**\n     * @abstract\n     * @return {boolean} Is horizontal\n     */\n    isHorizontal: null,\n\n    /**\n     * @abstract\n     * @return {number} Get axis rotate, by degree.\n     */\n    getRotate: null,\n\n    /**\n     * Get interval of the axis label.\n     * To get precise result, at least one of `getRotate` and `isHorizontal`\n     * should be implemented.\n     * @return {number}\n     */\n    getLabelInterval: function () {\n        var labelInterval = this._labelInterval;\n        if (!labelInterval) {\n            var axisModel = this.model;\n            var labelModel = axisModel.getModel('axisLabel');\n            labelInterval = labelModel.get('interval');\n\n            if (this.type === 'category'\n                && (labelInterval == null || labelInterval === 'auto')\n            ) {\n                labelInterval = getAxisLabelInterval(\n                    map(this.scale.getTicks(), this.dataToCoord, this),\n                    axisModel.getFormattedLabels(),\n                    labelModel.getFont(),\n                    this.getRotate\n                        ? this.getRotate()\n                        : (this.isHorizontal && !this.isHorizontal())\n                        ? 90\n                        : 0,\n                    labelModel.get('rotate')\n                );\n            }\n\n            this._labelInterval = labelInterval;\n        }\n        return labelInterval;\n    }\n\n};\n\nvar EPSILON$3 = 1e-8;\n\nfunction isAroundEqual$1(a, b) {\n    return Math.abs(a - b) < EPSILON$3;\n}\n\nfunction contain$1(points, x, y) {\n    var w = 0;\n    var p = points[0];\n\n    if (!p) {\n        return false;\n    }\n\n    for (var i = 1; i < points.length; i++) {\n        var p2 = points[i];\n        w += windingLine(p[0], p[1], p2[0], p2[1], x, y);\n        p = p2;\n    }\n\n    // Close polygon\n    var p0 = points[0];\n    if (!isAroundEqual$1(p[0], p0[0]) || !isAroundEqual$1(p[1], p0[1])) {\n        w += windingLine(p[0], p[1], p0[0], p0[1], x, y);\n    }\n\n    return w !== 0;\n}\n\n/**\n * @module echarts/coord/geo/Region\n */\n\n/**\n * @param {string} name\n * @param {Array} geometries\n * @param {Array.<number>} cp\n */\nfunction Region(name, geometries, cp) {\n\n    /**\n     * @type {string}\n     * @readOnly\n     */\n    this.name = name;\n\n    /**\n     * @type {Array.<Array>}\n     * @readOnly\n     */\n    this.geometries = geometries;\n\n    if (!cp) {\n        var rect = this.getBoundingRect();\n        cp = [\n            rect.x + rect.width / 2,\n            rect.y + rect.height / 2\n        ];\n    }\n    else {\n        cp = [cp[0], cp[1]];\n    }\n    /**\n     * @type {Array.<number>}\n     */\n    this.center = cp;\n}\n\nRegion.prototype = {\n\n    constructor: Region,\n\n    properties: null,\n\n    /**\n     * @return {module:zrender/core/BoundingRect}\n     */\n    getBoundingRect: function () {\n        var rect = this._rect;\n        if (rect) {\n            return rect;\n        }\n\n        var MAX_NUMBER = Number.MAX_VALUE;\n        var min$$1 = [MAX_NUMBER, MAX_NUMBER];\n        var max$$1 = [-MAX_NUMBER, -MAX_NUMBER];\n        var min2 = [];\n        var max2 = [];\n        var geometries = this.geometries;\n        for (var i = 0; i < geometries.length; i++) {\n            // Only support polygon\n            if (geometries[i].type !== 'polygon') {\n                continue;\n            }\n            // Doesn't consider hole\n            var exterior = geometries[i].exterior;\n            fromPoints(exterior, min2, max2);\n            min(min$$1, min$$1, min2);\n            max(max$$1, max$$1, max2);\n        }\n        // No data\n        if (i === 0) {\n            min$$1[0] = min$$1[1] = max$$1[0] = max$$1[1] = 0;\n        }\n\n        return (this._rect = new BoundingRect(\n            min$$1[0], min$$1[1], max$$1[0] - min$$1[0], max$$1[1] - min$$1[1]\n        ));\n    },\n\n    /**\n     * @param {<Array.<number>} coord\n     * @return {boolean}\n     */\n    contain: function (coord) {\n        var rect = this.getBoundingRect();\n        var geometries = this.geometries;\n        if (!rect.contain(coord[0], coord[1])) {\n            return false;\n        }\n        loopGeo: for (var i = 0, len$$1 = geometries.length; i < len$$1; i++) {\n            // Only support polygon.\n            if (geometries[i].type !== 'polygon') {\n                continue;\n            }\n            var exterior = geometries[i].exterior;\n            var interiors = geometries[i].interiors;\n            if (contain$1(exterior, coord[0], coord[1])) {\n                // Not in the region if point is in the hole.\n                for (var k = 0; k < (interiors ? interiors.length : 0); k++) {\n                    if (contain$1(interiors[k])) {\n                        continue loopGeo;\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    },\n\n    transformTo: function (x, y, width, height) {\n        var rect = this.getBoundingRect();\n        var aspect = rect.width / rect.height;\n        if (!width) {\n            width = aspect * height;\n        }\n        else if (!height) {\n            height = width / aspect ;\n        }\n        var target = new BoundingRect(x, y, width, height);\n        var transform = rect.calculateTransform(target);\n        var geometries = this.geometries;\n        for (var i = 0; i < geometries.length; i++) {\n            // Only support polygon.\n            if (geometries[i].type !== 'polygon') {\n                continue;\n            }\n            var exterior = geometries[i].exterior;\n            var interiors = geometries[i].interiors;\n            for (var p = 0; p < exterior.length; p++) {\n                applyTransform(exterior[p], exterior[p], transform);\n            }\n            for (var h = 0; h < (interiors ? interiors.length : 0); h++) {\n                for (var p = 0; p < interiors[h].length; p++) {\n                    applyTransform(interiors[h][p], interiors[h][p], transform);\n                }\n            }\n        }\n        rect = this._rect;\n        rect.copy(target);\n        // Update center\n        this.center = [\n            rect.x + rect.width / 2,\n            rect.y + rect.height / 2\n        ];\n    }\n};\n\n/**\n * Parse and decode geo json\n * @module echarts/coord/geo/parseGeoJson\n */\n\nfunction decode(json) {\n    if (!json.UTF8Encoding) {\n        return json;\n    }\n    var encodeScale = json.UTF8Scale;\n    if (encodeScale == null) {\n        encodeScale = 1024;\n    }\n\n    var features = json.features;\n\n    for (var f = 0; f < features.length; f++) {\n        var feature = features[f];\n        var geometry = feature.geometry;\n        var coordinates = geometry.coordinates;\n        var encodeOffsets = geometry.encodeOffsets;\n\n        for (var c = 0; c < coordinates.length; c++) {\n            var coordinate = coordinates[c];\n\n            if (geometry.type === 'Polygon') {\n                coordinates[c] = decodePolygon(\n                    coordinate,\n                    encodeOffsets[c],\n                    encodeScale\n                );\n            }\n            else if (geometry.type === 'MultiPolygon') {\n                for (var c2 = 0; c2 < coordinate.length; c2++) {\n                    var polygon = coordinate[c2];\n                    coordinate[c2] = decodePolygon(\n                        polygon,\n                        encodeOffsets[c][c2],\n                        encodeScale\n                    );\n                }\n            }\n        }\n    }\n    // Has been decoded\n    json.UTF8Encoding = false;\n    return json;\n}\n\nfunction decodePolygon(coordinate, encodeOffsets, encodeScale) {\n    var result = [];\n    var prevX = encodeOffsets[0];\n    var prevY = encodeOffsets[1];\n\n    for (var i = 0; i < coordinate.length; i += 2) {\n        var x = coordinate.charCodeAt(i) - 64;\n        var y = coordinate.charCodeAt(i + 1) - 64;\n        // ZigZag decoding\n        x = (x >> 1) ^ (-(x & 1));\n        y = (y >> 1) ^ (-(y & 1));\n        // Delta deocding\n        x += prevX;\n        y += prevY;\n\n        prevX = x;\n        prevY = y;\n        // Dequantize\n        result.push([x / encodeScale, y / encodeScale]);\n    }\n\n    return result;\n}\n\n/**\n * @alias module:echarts/coord/geo/parseGeoJson\n * @param {Object} geoJson\n * @return {module:zrender/container/Group}\n */\nvar parseGeoJson = function (geoJson) {\n\n    decode(geoJson);\n\n    return map(filter(geoJson.features, function (featureObj) {\n        // Output of mapshaper may have geometry null\n        return featureObj.geometry\n            && featureObj.properties\n            && featureObj.geometry.coordinates.length > 0;\n    }), function (featureObj) {\n        var properties = featureObj.properties;\n        var geo = featureObj.geometry;\n\n        var coordinates = geo.coordinates;\n\n        var geometries = [];\n        if (geo.type === 'Polygon') {\n            geometries.push({\n                type: 'polygon',\n                // According to the GeoJSON specification.\n                // First must be exterior, and the rest are all interior(holes).\n                exterior: coordinates[0],\n                interiors: coordinates.slice(1)\n            });\n        }\n        if (geo.type === 'MultiPolygon') {\n            each$1(coordinates, function (item) {\n                if (item[0]) {\n                    geometries.push({\n                        type: 'polygon',\n                        exterior: item[0],\n                        interiors: item.slice(1)\n                    });\n                }\n            });\n        }\n\n        var region = new Region(\n            properties.name,\n            geometries,\n            properties.cp\n        );\n        region.properties = properties;\n        return region;\n    });\n};\n\n/**\n * Do not mount those modules on 'src/echarts' for better tree shaking.\n */\n\nvar ecUtil = {};\neach$1([\n        'map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter',\n        'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction',\n        'extend', 'defaults', 'clone', 'merge'\n    ],\n    function (name) {\n        ecUtil[name] = zrUtil[name];\n    }\n);\n\nSeriesModel.extend({\n\n    type: 'series.line',\n\n    dependencies: ['grid', 'polar'],\n\n    getInitialData: function (option, ecModel) {\n        if (__DEV__) {\n            var coordSys = option.coordinateSystem;\n            if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {\n                throw new Error('Line not support coordinateSystem besides cartesian and polar');\n            }\n        }\n        return createListFromArray(option.data, this, ecModel);\n    },\n\n    defaultOption: {\n        zlevel: 0,                  // \n        z: 2,                       // \n        coordinateSystem: 'cartesian2d',\n        legendHoverLink: true,\n\n        hoverAnimation: true,\n        // stack: null\n        // xAxisIndex: 0,\n        // yAxisIndex: 0,\n\n        // polarIndex: 0,\n\n        // If clip the overflow value\n        clipOverflow: true,\n        // cursor: null,\n\n        label: {\n            normal: {\n                position: 'top'\n            }\n        },\n        // itemStyle: {\n        //     normal: {},\n        //     emphasis: {}\n        // },\n        lineStyle: {\n            normal: {\n                width: 2,\n                type: 'solid'\n            }\n        },\n        // areaStyle: {},\n        // false, 'start', 'end', 'middle'\n        step: false,\n\n        // Disabled if step is true\n        smooth: false,\n        smoothMonotone: null,\n        // \n        symbol: 'emptyCircle',\n        // \n        symbolSize: 4,\n        // \n        symbolRotate: null,\n\n        //  symbol,  tooltip hover \n        showSymbol: true,\n        // \n        showAllSymbol: false,\n\n        // \n        connectNulls: false,\n\n        // 'average', 'max', 'min', 'sum'\n        sampling: 'none',\n\n        animationEasing: 'linear',\n\n        // Disable progressive\n        progressive: 0,\n        hoverLayerThreshold: Infinity\n    }\n});\n\n/**\n * @module echarts/chart/helper/Symbol\n */\n\nfunction findLabelValueDim(data) {\n    var valueDim;\n    var labelDims = otherDimToDataDim(data, 'label');\n\n    if (labelDims.length) {\n        valueDim = labelDims[0];\n    }\n    else {\n        // Get last value dim\n        var dimensions = data.dimensions.slice();\n        var dataType;\n        while (dimensions.length && (\n            valueDim = dimensions.pop(),\n            dataType = data.getDimensionInfo(valueDim).type,\n            dataType === 'ordinal' || dataType === 'time'\n        )) {} // jshint ignore:line\n    }\n\n    return valueDim;\n}\n\n/**\n * @module echarts/chart/helper/Symbol\n */\n\nfunction getSymbolSize(data, idx) {\n    var symbolSize = data.getItemVisual(idx, 'symbolSize');\n    return symbolSize instanceof Array\n        ? symbolSize.slice()\n        : [+symbolSize, +symbolSize];\n}\n\nfunction getScale(symbolSize) {\n    return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\nfunction SymbolClz$1(data, idx, seriesScope) {\n    Group.call(this);\n\n    this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz$1.prototype;\n\nfunction driftSymbol(dx, dy) {\n    this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n    // Remove paths created before\n    this.removeAll();\n\n    var color = data.getItemVisual(idx, 'color');\n\n    // var symbolPath = createSymbol(\n    //     symbolType, -0.5, -0.5, 1, 1, color\n    // );\n    // If width/height are set too small (e.g., set to 1) on ios10\n    // and macOS Sierra, a circle stroke become a rect, no matter what\n    // the scale is set. So we set width/height as 2. See #4150.\n    var symbolPath = createSymbol(\n        symbolType, -1, -1, 2, 2, color\n    );\n\n    symbolPath.attr({\n        z2: 100,\n        culling: true,\n        scale: getScale(symbolSize)\n    });\n    // Rewrite drift method\n    symbolPath.drift = driftSymbol;\n\n    this._symbolType = symbolType;\n\n    this.add(symbolPath);\n};\n\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n    this.childAt(0).stopAnimation(toLastFrame);\n};\n\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\nsymbolProto.getSymbolPath = function () {\n    return this.childAt(0);\n};\n\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\nsymbolProto.getScale = function () {\n    return this.childAt(0).scale;\n};\n\n/**\n * Highlight symbol\n */\nsymbolProto.highlight = function () {\n    this.childAt(0).trigger('emphasis');\n};\n\n/**\n * Downplay symbol\n */\nsymbolProto.downplay = function () {\n    this.childAt(0).trigger('normal');\n};\n\n/**\n * @param {number} zlevel\n * @param {number} z\n */\nsymbolProto.setZ = function (zlevel, z) {\n    var symbolPath = this.childAt(0);\n    symbolPath.zlevel = zlevel;\n    symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n    var symbolPath = this.childAt(0);\n    symbolPath.draggable = draggable;\n    symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\nsymbolProto.updateData = function (data, idx, seriesScope) {\n    this.silent = false;\n\n    var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n    var seriesModel = data.hostModel;\n    var symbolSize = getSymbolSize(data, idx);\n    var isInit = symbolType !== this._symbolType;\n\n    if (isInit) {\n        this._createSymbol(symbolType, data, idx, symbolSize);\n    }\n    else {\n        var symbolPath = this.childAt(0);\n        symbolPath.silent = false;\n        updateProps(symbolPath, {\n            scale: getScale(symbolSize)\n        }, seriesModel, idx);\n    }\n\n    this._updateCommon(data, idx, symbolSize, seriesScope);\n\n    if (isInit) {\n        var symbolPath = this.childAt(0);\n        var fadeIn = seriesScope && seriesScope.fadeIn;\n\n        var target = {scale: symbolPath.scale.slice()};\n        fadeIn && (target.style = {opacity: symbolPath.style.opacity});\n\n        symbolPath.scale = [0, 0];\n        fadeIn && (symbolPath.style.opacity = 0);\n\n        initProps(symbolPath, target, seriesModel, idx);\n    }\n\n    this._seriesModel = seriesModel;\n};\n\n// Update common properties\nvar normalStyleAccessPath = ['itemStyle', 'normal'];\nvar emphasisStyleAccessPath = ['itemStyle', 'emphasis'];\nvar normalLabelAccessPath = ['label', 'normal'];\nvar emphasisLabelAccessPath = ['label', 'emphasis'];\n\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n    var symbolPath = this.childAt(0);\n    var seriesModel = data.hostModel;\n    var color = data.getItemVisual(idx, 'color');\n\n    // Reset style\n    if (symbolPath.type !== 'image') {\n        symbolPath.useStyle({\n            strokeNoScale: true\n        });\n    }\n\n    var itemStyle = seriesScope && seriesScope.itemStyle;\n    var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n    var symbolRotate = seriesScope && seriesScope.symbolRotate;\n    var symbolOffset = seriesScope && seriesScope.symbolOffset;\n    var labelModel = seriesScope && seriesScope.labelModel;\n    var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n    var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n    var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n    if (!seriesScope || data.hasItemOption) {\n        var itemModel = (seriesScope && seriesScope.itemModel)\n            ? seriesScope.itemModel : data.getItemModel(idx);\n\n        // Color must be excluded.\n        // Because symbol provide setColor individually to set fill and stroke\n        itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n        hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n\n        symbolRotate = itemModel.getShallow('symbolRotate');\n        symbolOffset = itemModel.getShallow('symbolOffset');\n\n        labelModel = itemModel.getModel(normalLabelAccessPath);\n        hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n        hoverAnimation = itemModel.getShallow('hoverAnimation');\n        cursorStyle = itemModel.getShallow('cursor');\n    }\n    else {\n        hoverItemStyle = extend({}, hoverItemStyle);\n    }\n\n    var elStyle = symbolPath.style;\n\n    symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n    if (symbolOffset) {\n        symbolPath.attr('position', [\n            parsePercent$1(symbolOffset[0], symbolSize[0]),\n            parsePercent$1(symbolOffset[1], symbolSize[1])\n        ]);\n    }\n\n    cursorStyle && symbolPath.attr('cursor', cursorStyle);\n\n    // PENDING setColor before setStyle!!!\n    symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n\n    symbolPath.setStyle(itemStyle);\n\n    var opacity = data.getItemVisual(idx, 'opacity');\n    if (opacity != null) {\n        elStyle.opacity = opacity;\n    }\n\n    var useNameLabel = seriesScope && seriesScope.useNameLabel;\n    var valueDim = !useNameLabel && findLabelValueDim(data);\n\n    if (useNameLabel || valueDim != null) {\n        setLabelStyle(\n            elStyle, hoverItemStyle, labelModel, hoverLabelModel,\n            {\n                labelFetcher: seriesModel,\n                labelDataIndex: idx,\n                defaultText: useNameLabel ? data.getName(idx) : data.get(valueDim, idx),\n                isRectText: true,\n                autoColor: color\n            }\n        );\n    }\n\n    symbolPath.off('mouseover')\n        .off('mouseout')\n        .off('emphasis')\n        .off('normal');\n\n    symbolPath.hoverStyle = hoverItemStyle;\n\n    // FIXME\n    // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n    setHoverStyle(symbolPath);\n\n    var scale = getScale(symbolSize);\n\n    if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n        var onEmphasis = function() {\n            var ratio = scale[1] / scale[0];\n            this.animateTo({\n                scale: [\n                    Math.max(scale[0] * 1.1, scale[0] + 3),\n                    Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)\n                ]\n            }, 400, 'elasticOut');\n        };\n        var onNormal = function() {\n            this.animateTo({\n                scale: scale\n            }, 400, 'elasticOut');\n        };\n        symbolPath.on('mouseover', onEmphasis)\n            .on('mouseout', onNormal)\n            .on('emphasis', onEmphasis)\n            .on('normal', onNormal);\n    }\n};\n\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\nsymbolProto.fadeOut = function (cb, opt) {\n    var symbolPath = this.childAt(0);\n    // Avoid mistaken hover when fading out\n    this.silent = symbolPath.silent = true;\n    // Not show text when animating\n    !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n\n    updateProps(\n        symbolPath,\n        {\n            style: {opacity: 0},\n            scale: [0, 0]\n        },\n        this._seriesModel,\n        this.dataIndex,\n        cb\n    );\n};\n\ninherits(SymbolClz$1, Group);\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n    this.group = new Group();\n\n    this._symbolCtor = symbolCtor || SymbolClz$1;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, idx, isIgnore) {\n    var point = data.getItemLayout(idx);\n    // Is an object\n    // if (point && point.hasOwnProperty('point')) {\n    //     point = point.point;\n    // }\n    return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx))\n                && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Array.<boolean>} [isIgnore]\n */\nsymbolDrawProto.updateData = function (data, isIgnore) {\n    var group = this.group;\n    var seriesModel = data.hostModel;\n    var oldData = this._data;\n\n    var SymbolCtor = this._symbolCtor;\n\n    var seriesScope = {\n        itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),\n        hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),\n        symbolRotate: seriesModel.get('symbolRotate'),\n        symbolOffset: seriesModel.get('symbolOffset'),\n        hoverAnimation: seriesModel.get('hoverAnimation'),\n\n        labelModel: seriesModel.getModel('label.normal'),\n        hoverLabelModel: seriesModel.getModel('label.emphasis'),\n        cursorStyle: seriesModel.get('cursor')\n    };\n\n    data.diff(oldData)\n        .add(function (newIdx) {\n            var point = data.getItemLayout(newIdx);\n            if (symbolNeedsDraw(data, newIdx, isIgnore)) {\n                var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n                symbolEl.attr('position', point);\n                data.setItemGraphicEl(newIdx, symbolEl);\n                group.add(symbolEl);\n            }\n        })\n        .update(function (newIdx, oldIdx) {\n            var symbolEl = oldData.getItemGraphicEl(oldIdx);\n            var point = data.getItemLayout(newIdx);\n            if (!symbolNeedsDraw(data, newIdx, isIgnore)) {\n                group.remove(symbolEl);\n                return;\n            }\n            if (!symbolEl) {\n                symbolEl = new SymbolCtor(data, newIdx);\n                symbolEl.attr('position', point);\n            }\n            else {\n                symbolEl.updateData(data, newIdx, seriesScope);\n                updateProps(symbolEl, {\n                    position: point\n                }, seriesModel);\n            }\n\n            // Add back\n            group.add(symbolEl);\n\n            data.setItemGraphicEl(newIdx, symbolEl);\n        })\n        .remove(function (oldIdx) {\n            var el = oldData.getItemGraphicEl(oldIdx);\n            el && el.fadeOut(function () {\n                group.remove(el);\n            });\n        })\n        .execute();\n\n    this._data = data;\n};\n\nsymbolDrawProto.updateLayout = function () {\n    var data = this._data;\n    if (data) {\n        // Not use animation\n        data.eachItemGraphicEl(function (el, idx) {\n            var point = data.getItemLayout(idx);\n            el.attr('position', point);\n        });\n    }\n};\n\nsymbolDrawProto.remove = function (enableAnimation) {\n    var group = this.group;\n    var data = this._data;\n    if (data) {\n        if (enableAnimation) {\n            data.eachItemGraphicEl(function (el) {\n                el.fadeOut(function () {\n                    group.remove(el);\n                });\n            });\n        }\n        else {\n            group.removeAll();\n        }\n    }\n};\n\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n\nfunction sign$1(val) {\n    return val >= 0 ? 1 : -1;\n}\n\nfunction getStackedOnPoint(coordSys, data, idx) {\n    var baseAxis = coordSys.getBaseAxis();\n    var valueAxis = coordSys.getOtherAxis(baseAxis);\n    var valueStart = baseAxis.onZero\n        ? 0 : valueAxis.scale.getExtent()[0];\n\n    var valueDim = valueAxis.dim;\n    var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n    var stackedOnSameSign;\n    var stackedOn = data.stackedOn;\n    var val = data.get(valueDim, idx);\n    // Find first stacked value with same sign\n    while (stackedOn &&\n        sign$1(stackedOn.get(valueDim, idx)) === sign$1(val)\n    ) {\n        stackedOnSameSign = stackedOn;\n        break;\n    }\n    var stackedData = [];\n    stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n    stackedData[1 - baseDataOffset] = stackedOnSameSign\n        ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n    return coordSys.dataToPoint(stackedData);\n}\n\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\n\nfunction diffData(oldData, newData) {\n    var diffResult = [];\n\n    newData.diff(oldData)\n        .add(function (idx) {\n            diffResult.push({cmd: '+', idx: idx});\n        })\n        .update(function (newIdx, oldIdx) {\n            diffResult.push({cmd: '=', idx: oldIdx, idx1: newIdx});\n        })\n        .remove(function (idx) {\n            diffResult.push({cmd: '-', idx: idx});\n        })\n        .execute();\n\n    return diffResult;\n}\n\nvar lineAnimationDiff = function (\n    oldData, newData,\n    oldStackedOnPoints, newStackedOnPoints,\n    oldCoordSys, newCoordSys\n) {\n    var diff = diffData(oldData, newData);\n\n    // var newIdList = newData.mapArray(newData.getId);\n    // var oldIdList = oldData.mapArray(oldData.getId);\n\n    // convertToIntId(newIdList, oldIdList);\n\n    // // FIXME One data ?\n    // diff = arrayDiff(oldIdList, newIdList);\n\n    var currPoints = [];\n    var nextPoints = [];\n    // Points for stacking base line\n    var currStackedPoints = [];\n    var nextStackedPoints = [];\n\n    var status = [];\n    var sortedIndices = [];\n    var rawIndices = [];\n    var dims = newCoordSys.dimensions;\n    for (var i = 0; i < diff.length; i++) {\n        var diffItem = diff[i];\n        var pointAdded = true;\n\n        // FIXME, animation is not so perfect when dataZoom window moves fast\n        // Which is in case remvoing or add more than one data in the tail or head\n        switch (diffItem.cmd) {\n            case '=':\n                var currentPt = oldData.getItemLayout(diffItem.idx);\n                var nextPt = newData.getItemLayout(diffItem.idx1);\n                // If previous data is NaN, use next point directly\n                if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n                    currentPt = nextPt.slice();\n                }\n                currPoints.push(currentPt);\n                nextPoints.push(nextPt);\n\n                currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n                nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n\n                rawIndices.push(newData.getRawIndex(diffItem.idx1));\n                break;\n            case '+':\n                var idx = diffItem.idx;\n                currPoints.push(\n                    oldCoordSys.dataToPoint([\n                        newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)\n                    ])\n                );\n\n                nextPoints.push(newData.getItemLayout(idx).slice());\n\n                currStackedPoints.push(\n                    getStackedOnPoint(oldCoordSys, newData, idx)\n                );\n                nextStackedPoints.push(newStackedOnPoints[idx]);\n\n                rawIndices.push(newData.getRawIndex(idx));\n                break;\n            case '-':\n                var idx = diffItem.idx;\n                var rawIndex = oldData.getRawIndex(idx);\n                // Data is replaced. In the case of dynamic data queue\n                // FIXME FIXME FIXME\n                if (rawIndex !== idx) {\n                    currPoints.push(oldData.getItemLayout(idx));\n                    nextPoints.push(newCoordSys.dataToPoint([\n                        oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)\n                    ]));\n\n                    currStackedPoints.push(oldStackedOnPoints[idx]);\n                    nextStackedPoints.push(\n                        getStackedOnPoint(\n                            newCoordSys, oldData, idx\n                        )\n                    );\n\n                    rawIndices.push(rawIndex);\n                }\n                else {\n                    pointAdded = false;\n                }\n        }\n\n        // Original indices\n        if (pointAdded) {\n            status.push(diffItem);\n            sortedIndices.push(sortedIndices.length);\n        }\n    }\n\n    // Diff result may be crossed if all items are changed\n    // Sort by data index\n    sortedIndices.sort(function (a, b) {\n        return rawIndices[a] - rawIndices[b];\n    });\n\n    var sortedCurrPoints = [];\n    var sortedNextPoints = [];\n\n    var sortedCurrStackedPoints = [];\n    var sortedNextStackedPoints = [];\n\n    var sortedStatus = [];\n    for (var i = 0; i < sortedIndices.length; i++) {\n        var idx = sortedIndices[i];\n        sortedCurrPoints[i] = currPoints[idx];\n        sortedNextPoints[i] = nextPoints[idx];\n\n        sortedCurrStackedPoints[i] = currStackedPoints[idx];\n        sortedNextStackedPoints[i] = nextStackedPoints[idx];\n\n        sortedStatus[i] = status[idx];\n    }\n\n    return {\n        current: sortedCurrPoints,\n        next: sortedNextPoints,\n\n        stackedOnCurrent: sortedCurrStackedPoints,\n        stackedOnNext: sortedNextStackedPoints,\n\n        status: sortedStatus\n    };\n};\n\n// Poly path support NaN point\n\nvar vec2Min = min;\nvar vec2Max = max;\n\nvar scaleAndAdd$1 = scaleAndAdd;\nvar v2Copy = copy;\n\n// Temporary variable\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n    return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(\n    ctx, points, start, segLen, allLen,\n    dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls\n) {\n    var prevIdx = 0;\n    var idx = start;\n    for (var k = 0; k < segLen; k++) {\n        var p = points[idx];\n        if (idx >= allLen || idx < 0) {\n            break;\n        }\n        if (isPointNull(p)) {\n            if (connectNulls) {\n                idx += dir;\n                continue;\n            }\n            break;\n        }\n\n        if (idx === start) {\n            ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n            v2Copy(cp0, p);\n        }\n        else {\n            if (smooth > 0) {\n                var nextIdx = idx + dir;\n                var nextP = points[nextIdx];\n                if (connectNulls) {\n                    // Find next point not null\n                    while (nextP && isPointNull(points[nextIdx])) {\n                        nextIdx += dir;\n                        nextP = points[nextIdx];\n                    }\n                }\n\n                var ratioNextSeg = 0.5;\n                var prevP = points[prevIdx];\n                var nextP = points[nextIdx];\n                // Last point\n                if (!nextP || isPointNull(nextP)) {\n                    v2Copy(cp1, p);\n                }\n                else {\n                    // If next data is null in not connect case\n                    if (isPointNull(nextP) && !connectNulls) {\n                        nextP = p;\n                    }\n\n                    sub(v, nextP, prevP);\n\n                    var lenPrevSeg;\n                    var lenNextSeg;\n                    if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n                        var dim = smoothMonotone === 'x' ? 0 : 1;\n                        lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n                        lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n                    }\n                    else {\n                        lenPrevSeg = dist(p, prevP);\n                        lenNextSeg = dist(p, nextP);\n                    }\n\n                    // Use ratio of seg length\n                    ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n\n                    scaleAndAdd$1(cp1, p, v, -smooth * (1 - ratioNextSeg));\n                }\n                // Smooth constraint\n                vec2Min(cp0, cp0, smoothMax);\n                vec2Max(cp0, cp0, smoothMin);\n                vec2Min(cp1, cp1, smoothMax);\n                vec2Max(cp1, cp1, smoothMin);\n\n                ctx.bezierCurveTo(\n                    cp0[0], cp0[1],\n                    cp1[0], cp1[1],\n                    p[0], p[1]\n                );\n                // cp0 of next segment\n                scaleAndAdd$1(cp0, p, v, smooth * ratioNextSeg);\n            }\n            else {\n                ctx.lineTo(p[0], p[1]);\n            }\n        }\n\n        prevIdx = idx;\n        idx += dir;\n    }\n\n    return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n    var ptMin = [Infinity, Infinity];\n    var ptMax = [-Infinity, -Infinity];\n    if (smoothConstraint) {\n        for (var i = 0; i < points.length; i++) {\n            var pt = points[i];\n            if (pt[0] < ptMin[0]) { ptMin[0] = pt[0]; }\n            if (pt[1] < ptMin[1]) { ptMin[1] = pt[1]; }\n            if (pt[0] > ptMax[0]) { ptMax[0] = pt[0]; }\n            if (pt[1] > ptMax[1]) { ptMax[1] = pt[1]; }\n        }\n    }\n    return {\n        min: smoothConstraint ? ptMin : ptMax,\n        max: smoothConstraint ? ptMax : ptMin\n    };\n}\n\nvar Polyline$1 = Path.extend({\n\n    type: 'ec-polyline',\n\n    shape: {\n        points: [],\n\n        smooth: 0,\n\n        smoothConstraint: true,\n\n        smoothMonotone: null,\n\n        connectNulls: false\n    },\n\n    style: {\n        fill: null,\n\n        stroke: '#000'\n    },\n\n    brush: fixClipWithShadow(Path.prototype.brush),\n\n    buildPath: function (ctx, shape) {\n        var points = shape.points;\n\n        var i = 0;\n        var len$$1 = points.length;\n\n        var result = getBoundingBox(points, shape.smoothConstraint);\n\n        if (shape.connectNulls) {\n            // Must remove first and last null values avoid draw error in polygon\n            for (; len$$1 > 0; len$$1--) {\n                if (!isPointNull(points[len$$1 - 1])) {\n                    break;\n                }\n            }\n            for (; i < len$$1; i++) {\n                if (!isPointNull(points[i])) {\n                    break;\n                }\n            }\n        }\n        while (i < len$$1) {\n            i += drawSegment(\n                ctx, points, i, len$$1, len$$1,\n                1, result.min, result.max, shape.smooth,\n                shape.smoothMonotone, shape.connectNulls\n            ) + 1;\n        }\n    }\n});\n\nvar Polygon$1 = Path.extend({\n\n    type: 'ec-polygon',\n\n    shape: {\n        points: [],\n\n        // Offset between stacked base points and points\n        stackedOnPoints: [],\n\n        smooth: 0,\n\n        stackedOnSmooth: 0,\n\n        smoothConstraint: true,\n\n        smoothMonotone: null,\n\n        connectNulls: false\n    },\n\n    brush: fixClipWithShadow(Path.prototype.brush),\n\n    buildPath: function (ctx, shape) {\n        var points = shape.points;\n        var stackedOnPoints = shape.stackedOnPoints;\n\n        var i = 0;\n        var len$$1 = points.length;\n        var smoothMonotone = shape.smoothMonotone;\n        var bbox = getBoundingBox(points, shape.smoothConstraint);\n        var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n        if (shape.connectNulls) {\n            // Must remove first and last null values avoid draw error in polygon\n            for (; len$$1 > 0; len$$1--) {\n                if (!isPointNull(points[len$$1 - 1])) {\n                    break;\n                }\n            }\n            for (; i < len$$1; i++) {\n                if (!isPointNull(points[i])) {\n                    break;\n                }\n            }\n        }\n        while (i < len$$1) {\n            var k = drawSegment(\n                ctx, points, i, len$$1, len$$1,\n                1, bbox.min, bbox.max, shape.smooth,\n                smoothMonotone, shape.connectNulls\n            );\n            drawSegment(\n                ctx, stackedOnPoints, i + k - 1, k, len$$1,\n                -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth,\n                smoothMonotone, shape.connectNulls\n            );\n            i += k + 1;\n\n            ctx.closePath();\n        }\n    }\n});\n\n// FIXME step not support polar\n\nfunction isPointsSame(points1, points2) {\n    if (points1.length !== points2.length) {\n        return;\n    }\n    for (var i = 0; i < points1.length; i++) {\n        var p1 = points1[i];\n        var p2 = points2[i];\n        if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n            return;\n        }\n    }\n    return true;\n}\n\nfunction getSmooth(smooth) {\n    return typeof (smooth) === 'number' ? smooth : (smooth ? 0.3 : 0);\n}\n\nfunction getAxisExtentWithGap(axis) {\n    var extent = axis.getGlobalExtent();\n    if (axis.onBand) {\n        // Remove extra 1px to avoid line miter in clipped edge\n        var halfBandWidth = axis.getBandWidth() / 2 - 1;\n        var dir = extent[1] > extent[0] ? 1 : -1;\n        extent[0] += dir * halfBandWidth;\n        extent[1] -= dir * halfBandWidth;\n    }\n    return extent;\n}\n\nfunction sign(val) {\n    return val >= 0 ? 1 : -1;\n}\n\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Array.<Array.<number>>} points\n * @private\n */\nfunction getStackedOnPoints(coordSys, data) {\n    var baseAxis = coordSys.getBaseAxis();\n    var valueAxis = coordSys.getOtherAxis(baseAxis);\n\n    var valueStart = 0;\n    if (!baseAxis.onZero) {\n        var extent = valueAxis.scale.getExtent();\n        if (extent[0] > 0) {\n            // Both positive\n            valueStart = extent[0];\n        }\n        else if (extent[1] < 0) {\n            // Both negative\n            valueStart = extent[1];\n        }\n        // If is one positive, and one negative, onZero shall be true\n    }\n\n    var valueDim = valueAxis.dim;\n\n    var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n    return data.mapArray([valueDim], function (val, idx) {\n        var stackedOnSameSign;\n        var stackedOn = data.stackedOn;\n        // Find first stacked value with same sign\n        while (stackedOn &&\n            sign(stackedOn.get(valueDim, idx)) === sign(val)\n        ) {\n            stackedOnSameSign = stackedOn;\n            break;\n        }\n        var stackedData = [];\n        stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n        stackedData[1 - baseDataOffset] = stackedOnSameSign\n            ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n        return coordSys.dataToPoint(stackedData);\n    }, true);\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, seriesModel) {\n    var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n    var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n    var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n\n    var x = Math.min(xExtent[0], xExtent[1]);\n    var y = Math.min(yExtent[0], yExtent[1]);\n    var width = Math.max(xExtent[0], xExtent[1]) - x;\n    var height = Math.max(yExtent[0], yExtent[1]) - y;\n    var lineWidth = seriesModel.get('lineStyle.normal.width') || 2;\n    // Expand clip shape to avoid clipping when line value exceeds axis\n    var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n    if (isHorizontal) {\n        y -= expandSize;\n        height += expandSize * 2;\n    }\n    else {\n        x -= expandSize;\n        width += expandSize * 2;\n    }\n\n    var clipPath = new Rect({\n        shape: {\n            x: x,\n            y: y,\n            width: width,\n            height: height\n        }\n    });\n\n    if (hasAnimation) {\n        clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n        initProps(clipPath, {\n            shape: {\n                width: width,\n                height: height\n            }\n        }, seriesModel);\n    }\n\n    return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, seriesModel) {\n    var angleAxis = polar.getAngleAxis();\n    var radiusAxis = polar.getRadiusAxis();\n\n    var radiusExtent = radiusAxis.getExtent();\n    var angleExtent = angleAxis.getExtent();\n\n    var RADIAN = Math.PI / 180;\n\n    var clipPath = new Sector({\n        shape: {\n            cx: polar.cx,\n            cy: polar.cy,\n            r0: radiusExtent[0],\n            r: radiusExtent[1],\n            startAngle: -angleExtent[0] * RADIAN,\n            endAngle: -angleExtent[1] * RADIAN,\n            clockwise: angleAxis.inverse\n        }\n    });\n\n    if (hasAnimation) {\n        clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n        initProps(clipPath, {\n            shape: {\n                endAngle: -angleExtent[1] * RADIAN\n            }\n        }, seriesModel);\n    }\n\n    return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, seriesModel) {\n    return coordSys.type === 'polar'\n        ? createPolarClipShape(coordSys, hasAnimation, seriesModel)\n        : createGridClipShape(coordSys, hasAnimation, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n    var baseAxis = coordSys.getBaseAxis();\n    var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n\n    var stepPoints = [];\n    for (var i = 0; i < points.length - 1; i++) {\n        var nextPt = points[i + 1];\n        var pt = points[i];\n        stepPoints.push(pt);\n\n        var stepPt = [];\n        switch (stepTurnAt) {\n            case 'end':\n                stepPt[baseIndex] = nextPt[baseIndex];\n                stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                // default is start\n                stepPoints.push(stepPt);\n                break;\n            case 'middle':\n                // default is start\n                var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n                var stepPt2 = [];\n                stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n                stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n                stepPoints.push(stepPt);\n                stepPoints.push(stepPt2);\n                break;\n            default:\n                stepPt[baseIndex] = pt[baseIndex];\n                stepPt[1 - baseIndex] = nextPt[1 - baseIndex];\n                // default is start\n                stepPoints.push(stepPt);\n        }\n    }\n    // Last points\n    points[i] && stepPoints.push(points[i]);\n    return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n    var visualMetaList = data.getVisual('visualMeta');\n    if (!visualMetaList || !visualMetaList.length || !data.count()) {\n        // When data.count() is 0, gradient range can not be calculated.\n        return;\n    }\n\n    var visualMeta;\n    for (var i = visualMetaList.length - 1; i >= 0; i--) {\n        // Can only be x or y\n        if (visualMetaList[i].dimension < 2) {\n            visualMeta = visualMetaList[i];\n            break;\n        }\n    }\n    if (!visualMeta || coordSys.type !== 'cartesian2d') {\n        if (__DEV__) {\n            console.warn('Visual map on line style only support x or y dimension.');\n        }\n        return;\n    }\n\n    // If the area to be rendered is bigger than area defined by LinearGradient,\n    // the canvas spec prescribes that the color of the first stop and the last\n    // stop should be used. But if two stops are added at offset 0, in effect\n    // browsers use the color of the second stop to render area outside\n    // LinearGradient. So we can only infinitesimally extend area defined in\n    // LinearGradient to render `outerColors`.\n\n    var dimension = visualMeta.dimension;\n    var dimName = data.dimensions[dimension];\n    var axis = coordSys.getAxis(dimName);\n\n    // dataToCoor mapping may not be linear, but must be monotonic.\n    var colorStops = map(visualMeta.stops, function (stop) {\n        return {\n            coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n            color: stop.color\n        };\n    });\n    var stopLen = colorStops.length;\n    var outerColors = visualMeta.outerColors.slice();\n\n    if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n        colorStops.reverse();\n        outerColors.reverse();\n    }\n\n    var tinyExtent = 10; // Arbitrary value: 10px\n    var minCoord = colorStops[0].coord - tinyExtent;\n    var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n    var coordSpan = maxCoord - minCoord;\n\n    if (coordSpan < 1e-3) {\n        return 'transparent';\n    }\n\n    each$1(colorStops, function (stop) {\n        stop.offset = (stop.coord - minCoord) / coordSpan;\n    });\n    colorStops.push({\n        offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n        color: outerColors[1] || 'transparent'\n    });\n    colorStops.unshift({ // notice colorStops.length have been changed.\n        offset: stopLen ? colorStops[0].offset : 0.5,\n        color: outerColors[0] || 'transparent'\n    });\n\n    // zrUtil.each(colorStops, function (colorStop) {\n    //     // Make sure each offset has rounded px to avoid not sharp edge\n    //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n    // });\n\n    var gradient = new LinearGradient(0, 0, 0, 0, colorStops, true);\n    gradient[dimName] = minCoord;\n    gradient[dimName + '2'] = maxCoord;\n\n    return gradient;\n}\n\nChart.extend({\n\n    type: 'line',\n\n    init: function () {\n        var lineGroup = new Group();\n\n        var symbolDraw = new SymbolDraw();\n        this.group.add(symbolDraw.group);\n\n        this._symbolDraw = symbolDraw;\n        this._lineGroup = lineGroup;\n    },\n\n    render: function (seriesModel, ecModel, api) {\n        var coordSys = seriesModel.coordinateSystem;\n        var group = this.group;\n        var data = seriesModel.getData();\n        var lineStyleModel = seriesModel.getModel('lineStyle.normal');\n        var areaStyleModel = seriesModel.getModel('areaStyle.normal');\n\n        var points = data.mapArray(data.getItemLayout, true);\n\n        var isCoordSysPolar = coordSys.type === 'polar';\n        var prevCoordSys = this._coordSys;\n\n        var symbolDraw = this._symbolDraw;\n        var polyline = this._polyline;\n        var polygon = this._polygon;\n\n        var lineGroup = this._lineGroup;\n\n        var hasAnimation = seriesModel.get('animation');\n\n        var isAreaChart = !areaStyleModel.isEmpty();\n        var stackedOnPoints = getStackedOnPoints(coordSys, data);\n\n        var showSymbol = seriesModel.get('showSymbol');\n\n        var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol')\n            && this._getSymbolIgnoreFunc(data, coordSys);\n\n        // Remove temporary symbols\n        var oldData = this._data;\n        oldData && oldData.eachItemGraphicEl(function (el, idx) {\n            if (el.__temp) {\n                group.remove(el);\n                oldData.setItemGraphicEl(idx, null);\n            }\n        });\n\n        // Remove previous created symbols if showSymbol changed to false\n        if (!showSymbol) {\n            symbolDraw.remove();\n        }\n\n        group.add(lineGroup);\n\n        // FIXME step not support polar\n        var step = !isCoordSysPolar && seriesModel.get('step');\n        // Initialization animation or coordinate system changed\n        if (\n            !(polyline && prevCoordSys.type === coordSys.type && step === this._step)\n        ) {\n            showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n            if (step) {\n                // TODO If stacked series is not step\n                points = turnPointsIntoStep(points, coordSys, step);\n                stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n            }\n\n            polyline = this._newPolyline(points, coordSys, hasAnimation);\n            if (isAreaChart) {\n                polygon = this._newPolygon(\n                    points, stackedOnPoints,\n                    coordSys, hasAnimation\n                );\n            }\n            lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n        }\n        else {\n            if (isAreaChart && !polygon) {\n                // If areaStyle is added\n                polygon = this._newPolygon(\n                    points, stackedOnPoints,\n                    coordSys, hasAnimation\n                );\n            }\n            else if (polygon && !isAreaChart) {\n                // If areaStyle is removed\n                lineGroup.remove(polygon);\n                polygon = this._polygon = null;\n            }\n\n            // Update clipPath\n            lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel));\n\n            // Always update, or it is wrong in the case turning on legend\n            // because points are not changed\n            showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n            // Stop symbol animation and sync with line points\n            // FIXME performance?\n            data.eachItemGraphicEl(function (el) {\n                el.stopAnimation(true);\n            });\n\n            // In the case data zoom triggerred refreshing frequently\n            // Data may not change if line has a category axis. So it should animate nothing\n            if (!isPointsSame(this._stackedOnPoints, stackedOnPoints)\n                || !isPointsSame(this._points, points)\n            ) {\n                if (hasAnimation) {\n                    this._updateAnimation(\n                        data, stackedOnPoints, coordSys, api, step\n                    );\n                }\n                else {\n                    // Not do it in update with animation\n                    if (step) {\n                        // TODO If stacked series is not step\n                        points = turnPointsIntoStep(points, coordSys, step);\n                        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                    }\n\n                    polyline.setShape({\n                        points: points\n                    });\n                    polygon && polygon.setShape({\n                        points: points,\n                        stackedOnPoints: stackedOnPoints\n                    });\n                }\n            }\n        }\n\n        var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n\n        polyline.useStyle(defaults(\n            // Use color in lineStyle first\n            lineStyleModel.getLineStyle(),\n            {\n                fill: 'none',\n                stroke: visualColor,\n                lineJoin: 'bevel'\n            }\n        ));\n\n        var smooth = seriesModel.get('smooth');\n        smooth = getSmooth(seriesModel.get('smooth'));\n        polyline.setShape({\n            smooth: smooth,\n            smoothMonotone: seriesModel.get('smoothMonotone'),\n            connectNulls: seriesModel.get('connectNulls')\n        });\n\n        if (polygon) {\n            var stackedOn = data.stackedOn;\n            var stackedOnSmooth = 0;\n\n            polygon.useStyle(defaults(\n                areaStyleModel.getAreaStyle(),\n                {\n                    fill: visualColor,\n                    opacity: 0.7,\n                    lineJoin: 'bevel'\n                }\n            ));\n\n            if (stackedOn) {\n                var stackedOnSeries = stackedOn.hostModel;\n                stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n            }\n\n            polygon.setShape({\n                smooth: smooth,\n                stackedOnSmooth: stackedOnSmooth,\n                smoothMonotone: seriesModel.get('smoothMonotone'),\n                connectNulls: seriesModel.get('connectNulls')\n            });\n        }\n\n        this._data = data;\n        // Save the coordinate system for transition animation when data changed\n        this._coordSys = coordSys;\n        this._stackedOnPoints = stackedOnPoints;\n        this._points = points;\n        this._step = step;\n    },\n\n    dispose: function () {},\n\n    highlight: function (seriesModel, ecModel, api, payload) {\n        var data = seriesModel.getData();\n        var dataIndex = queryDataIndex(data, payload);\n\n        if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n            var symbol = data.getItemGraphicEl(dataIndex);\n            if (!symbol) {\n                // Create a temporary symbol if it is not exists\n                var pt = data.getItemLayout(dataIndex);\n                if (!pt) {\n                    // Null data\n                    return;\n                }\n                symbol = new SymbolClz$1(data, dataIndex);\n                symbol.position = pt;\n                symbol.setZ(\n                    seriesModel.get('zlevel'),\n                    seriesModel.get('z')\n                );\n                symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n                symbol.__temp = true;\n                data.setItemGraphicEl(dataIndex, symbol);\n\n                // Stop scale animation\n                symbol.stopSymbolAnimation(true);\n\n                this.group.add(symbol);\n            }\n            symbol.highlight();\n        }\n        else {\n            // Highlight whole series\n            Chart.prototype.highlight.call(\n                this, seriesModel, ecModel, api, payload\n            );\n        }\n    },\n\n    downplay: function (seriesModel, ecModel, api, payload) {\n        var data = seriesModel.getData();\n        var dataIndex = queryDataIndex(data, payload);\n        if (dataIndex != null && dataIndex >= 0) {\n            var symbol = data.getItemGraphicEl(dataIndex);\n            if (symbol) {\n                if (symbol.__temp) {\n                    data.setItemGraphicEl(dataIndex, null);\n                    this.group.remove(symbol);\n                }\n                else {\n                    symbol.downplay();\n                }\n            }\n        }\n        else {\n            // FIXME\n            // can not downplay completely.\n            // Downplay whole series\n            Chart.prototype.downplay.call(\n                this, seriesModel, ecModel, api, payload\n            );\n        }\n    },\n\n    /**\n     * @param {module:zrender/container/Group} group\n     * @param {Array.<Array.<number>>} points\n     * @private\n     */\n    _newPolyline: function (points) {\n        var polyline = this._polyline;\n        // Remove previous created polyline\n        if (polyline) {\n            this._lineGroup.remove(polyline);\n        }\n\n        polyline = new Polyline$1({\n            shape: {\n                points: points\n            },\n            silent: true,\n            z2: 10\n        });\n\n        this._lineGroup.add(polyline);\n\n        this._polyline = polyline;\n\n        return polyline;\n    },\n\n    /**\n     * @param {module:zrender/container/Group} group\n     * @param {Array.<Array.<number>>} stackedOnPoints\n     * @param {Array.<Array.<number>>} points\n     * @private\n     */\n    _newPolygon: function (points, stackedOnPoints) {\n        var polygon = this._polygon;\n        // Remove previous created polygon\n        if (polygon) {\n            this._lineGroup.remove(polygon);\n        }\n\n        polygon = new Polygon$1({\n            shape: {\n                points: points,\n                stackedOnPoints: stackedOnPoints\n            },\n            silent: true\n        });\n\n        this._lineGroup.add(polygon);\n\n        this._polygon = polygon;\n        return polygon;\n    },\n    /**\n     * @private\n     */\n    _getSymbolIgnoreFunc: function (data, coordSys) {\n        var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n        // `getLabelInterval` is provided by echarts/component/axis\n        if (categoryAxis && categoryAxis.isLabelIgnored) {\n            return bind(categoryAxis.isLabelIgnored, categoryAxis);\n        }\n    },\n\n    /**\n     * @private\n     */\n    // FIXME Two value axis\n    _updateAnimation: function (data, stackedOnPoints, coordSys, api, step) {\n        var polyline = this._polyline;\n        var polygon = this._polygon;\n        var seriesModel = data.hostModel;\n\n        var diff = lineAnimationDiff(\n            this._data, data,\n            this._stackedOnPoints, stackedOnPoints,\n            this._coordSys, coordSys\n        );\n\n        var current = diff.current;\n        var stackedOnCurrent = diff.stackedOnCurrent;\n        var next = diff.next;\n        var stackedOnNext = diff.stackedOnNext;\n        if (step) {\n            // TODO If stacked series is not step\n            current = turnPointsIntoStep(diff.current, coordSys, step);\n            stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n            next = turnPointsIntoStep(diff.next, coordSys, step);\n            stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n        }\n        // `diff.current` is subset of `current` (which should be ensured by\n        // turnPointsIntoStep), so points in `__points` can be updated when\n        // points in `current` are update during animation.\n        polyline.shape.__points = diff.current;\n        polyline.shape.points = current;\n\n        updateProps(polyline, {\n            shape: {\n                points: next\n            }\n        }, seriesModel);\n\n        if (polygon) {\n            polygon.setShape({\n                points: current,\n                stackedOnPoints: stackedOnCurrent\n            });\n            updateProps(polygon, {\n                shape: {\n                    points: next,\n                    stackedOnPoints: stackedOnNext\n                }\n            }, seriesModel);\n        }\n\n        var updatedDataInfo = [];\n        var diffStatus = diff.status;\n\n        for (var i = 0; i < diffStatus.length; i++) {\n            var cmd = diffStatus[i].cmd;\n            if (cmd === '=') {\n                var el = data.getItemGraphicEl(diffStatus[i].idx1);\n                if (el) {\n                    updatedDataInfo.push({\n                        el: el,\n                        ptIdx: i    // Index of points\n                    });\n                }\n            }\n        }\n\n        if (polyline.animators && polyline.animators.length) {\n            polyline.animators[0].during(function () {\n                for (var i = 0; i < updatedDataInfo.length; i++) {\n                    var el = updatedDataInfo[i].el;\n                    el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n                }\n            });\n        }\n    },\n\n    remove: function (ecModel) {\n        var group = this.group;\n        var oldData = this._data;\n        this._lineGroup.removeAll();\n        this._symbolDraw.remove(true);\n        // Remove temporary created elements when highlighting\n        oldData && oldData.eachItemGraphicEl(function (el, idx) {\n            if (el.__temp) {\n                group.remove(el);\n                oldData.setItemGraphicEl(idx, null);\n            }\n        });\n\n        this._polyline =\n        this._polygon =\n        this._coordSys =\n        this._points =\n        this._stackedOnPoints =\n        this._data = null;\n    }\n});\n\nvar visualSymbol = function (seriesType, defaultSymbolType, legendSymbol, ecModel, api) {\n\n    // Encoding visual for all series include which is filtered for legend drawing\n    ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n        var data = seriesModel.getData();\n\n        var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n        var symbolSize = seriesModel.get('symbolSize');\n\n        data.setVisual({\n            legendSymbol: legendSymbol || symbolType,\n            symbol: symbolType,\n            symbolSize: symbolSize\n        });\n\n        // Only visible series has each data be visual encoded\n        if (!ecModel.isSeriesFiltered(seriesModel)) {\n            if (typeof symbolSize === 'function') {\n                data.each(function (idx) {\n                    var rawValue = seriesModel.getRawValue(idx);\n                    // FIXME\n                    var params = seriesModel.getDataParams(idx);\n                    data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n                });\n            }\n            data.each(function (idx) {\n                var itemModel = data.getItemModel(idx);\n                var itemSymbolType = itemModel.getShallow('symbol', true);\n                var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n                // If has item symbol\n                if (itemSymbolType != null) {\n                    data.setItemVisual(idx, 'symbol', itemSymbolType);\n                }\n                if (itemSymbolSize != null) {\n                    // PENDING Transform symbolSize ?\n                    data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n                }\n            });\n        }\n    });\n};\n\nvar layoutPoints = function (seriesType, ecModel) {\n    ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        var data = seriesModel.getData();\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (!coordSys) {\n            return;\n        }\n\n        var dims = [];\n        var coordDims = coordSys.dimensions;\n        for (var i = 0; i < coordDims.length; i++) {\n            dims.push(seriesModel.coordDimToDataDim(coordSys.dimensions[i])[0]);\n        }\n\n        if (dims.length === 1) {\n            data.each(dims[0], function (x, idx) {\n                // Also {Array.<number>}, not undefined to avoid if...else... statement\n                data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));\n            });\n        }\n        else if (dims.length === 2) {\n            data.each(dims, function (x, y, idx) {\n                // Also {Array.<number>}, not undefined to avoid if...else... statement\n                data.setItemLayout(\n                    idx, (isNaN(x) || isNaN(y)) ? [NaN, NaN] : coordSys.dataToPoint([x, y])\n                );\n            }, true);\n        }\n    });\n};\n\nvar samplers = {\n    average: function (frame) {\n        var sum = 0;\n        var count = 0;\n        for (var i = 0; i < frame.length; i++) {\n            if (!isNaN(frame[i])) {\n                sum += frame[i];\n                count++;\n            }\n        }\n        // Return NaN if count is 0\n        return count === 0 ? NaN : sum / count;\n    },\n    sum: function (frame) {\n        var sum = 0;\n        for (var i = 0; i < frame.length; i++) {\n            // Ignore NaN\n            sum += frame[i] || 0;\n        }\n        return sum;\n    },\n    max: function (frame) {\n        var max = -Infinity;\n        for (var i = 0; i < frame.length; i++) {\n            frame[i] > max && (max = frame[i]);\n        }\n        return max;\n    },\n    min: function (frame) {\n        var min = Infinity;\n        for (var i = 0; i < frame.length; i++) {\n            frame[i] < min && (min = frame[i]);\n        }\n        return min;\n    },\n    // TODO\n    // Median\n    nearest: function (frame) {\n        return frame[0];\n    }\n};\n\nvar indexSampler = function (frame, value) {\n    return Math.round(frame.length / 2);\n};\n\nvar dataSample = function (seriesType, ecModel, api) {\n    ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        var data = seriesModel.getData();\n        var sampling = seriesModel.get('sampling');\n        var coordSys = seriesModel.coordinateSystem;\n        // Only cartesian2d support down sampling\n        if (coordSys.type === 'cartesian2d' && sampling) {\n            var baseAxis = coordSys.getBaseAxis();\n            var valueAxis = coordSys.getOtherAxis(baseAxis);\n            var extent = baseAxis.getExtent();\n            // Coordinste system has been resized\n            var size = extent[1] - extent[0];\n            var rate = Math.round(data.count() / size);\n            if (rate > 1) {\n                var sampler;\n                if (typeof sampling === 'string') {\n                    sampler = samplers[sampling];\n                }\n                else if (typeof sampling === 'function') {\n                    sampler = sampling;\n                }\n                if (sampler) {\n                    data = data.downSample(\n                        valueAxis.dim, 1 / rate, sampler, indexSampler\n                    );\n                    seriesModel.setData(data);\n                }\n            }\n        }\n    }, this);\n};\n\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\n\nfunction dimAxisMapper(dim) {\n    return this._axes[dim];\n}\n\n/**\n * @alias module:echarts/coord/Cartesian\n * @constructor\n */\nvar Cartesian = function (name) {\n    this._axes = {};\n\n    this._dimList = [];\n\n    /**\n     * @type {string}\n     */\n    this.name = name || '';\n};\n\nCartesian.prototype = {\n\n    constructor: Cartesian,\n\n    type: 'cartesian',\n\n    /**\n     * Get axis\n     * @param  {number|string} dim\n     * @return {module:echarts/coord/Cartesian~Axis}\n     */\n    getAxis: function (dim) {\n        return this._axes[dim];\n    },\n\n    /**\n     * Get axes list\n     * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n     */\n    getAxes: function () {\n        return map(this._dimList, dimAxisMapper, this);\n    },\n\n    /**\n     * Get axes list by given scale type\n     */\n    getAxesByScale: function (scaleType) {\n        scaleType = scaleType.toLowerCase();\n        return filter(\n            this.getAxes(),\n            function (axis) {\n                return axis.scale.type === scaleType;\n            }\n        );\n    },\n\n    /**\n     * Add axis\n     * @param {module:echarts/coord/Cartesian.Axis}\n     */\n    addAxis: function (axis) {\n        var dim = axis.dim;\n\n        this._axes[dim] = axis;\n\n        this._dimList.push(dim);\n    },\n\n    /**\n     * Convert data to coord in nd space\n     * @param {Array.<number>|Object.<string, number>} val\n     * @return {Array.<number>|Object.<string, number>}\n     */\n    dataToCoord: function (val) {\n        return this._dataCoordConvert(val, 'dataToCoord');\n    },\n\n    /**\n     * Convert coord in nd space to data\n     * @param  {Array.<number>|Object.<string, number>} val\n     * @return {Array.<number>|Object.<string, number>}\n     */\n    coordToData: function (val) {\n        return this._dataCoordConvert(val, 'coordToData');\n    },\n\n    _dataCoordConvert: function (input, method) {\n        var dimList = this._dimList;\n\n        var output = input instanceof Array ? [] : {};\n\n        for (var i = 0; i < dimList.length; i++) {\n            var dim = dimList[i];\n            var axis = this._axes[dim];\n\n            output[dim] = axis[method](input[dim]);\n        }\n\n        return output;\n    }\n};\n\nfunction Cartesian2D(name) {\n\n    Cartesian.call(this, name);\n}\n\nCartesian2D.prototype = {\n\n    constructor: Cartesian2D,\n\n    type: 'cartesian2d',\n\n    /**\n     * @type {Array.<string>}\n     * @readOnly\n     */\n    dimensions: ['x', 'y'],\n\n    /**\n     * Base axis will be used on stacking.\n     *\n     * @return {module:echarts/coord/cartesian/Axis2D}\n     */\n    getBaseAxis: function () {\n        return this.getAxesByScale('ordinal')[0]\n            || this.getAxesByScale('time')[0]\n            || this.getAxis('x');\n    },\n\n    /**\n     * If contain point\n     * @param {Array.<number>} point\n     * @return {boolean}\n     */\n    containPoint: function (point) {\n        var axisX = this.getAxis('x');\n        var axisY = this.getAxis('y');\n        return axisX.contain(axisX.toLocalCoord(point[0]))\n            && axisY.contain(axisY.toLocalCoord(point[1]));\n    },\n\n    /**\n     * If contain data\n     * @param {Array.<number>} data\n     * @return {boolean}\n     */\n    containData: function (data) {\n        return this.getAxis('x').containData(data[0])\n            && this.getAxis('y').containData(data[1]);\n    },\n\n    /**\n     * @param {Array.<number>} data\n     * @param {boolean} [clamp=false]\n     * @return {Array.<number>}\n     */\n    dataToPoint: function (data, clamp) {\n        var xAxis = this.getAxis('x');\n        var yAxis = this.getAxis('y');\n        return [\n            xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n            yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n        ];\n    },\n\n    /**\n     * @param {Array.<number>} point\n     * @param {boolean} [clamp=false]\n     * @return {Array.<number>}\n     */\n    pointToData: function (point, clamp) {\n        var xAxis = this.getAxis('x');\n        var yAxis = this.getAxis('y');\n        return [\n            xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n            yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n        ];\n    },\n\n    /**\n     * Get other axis\n     * @param {module:echarts/coord/cartesian/Axis2D} axis\n     */\n    getOtherAxis: function (axis) {\n        return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n    }\n\n};\n\ninherits(Cartesian2D, Cartesian);\n\n/**\n * Extend axis 2d\n * @constructor module:echarts/coord/cartesian/Axis2D\n * @extends {module:echarts/coord/cartesian/Axis}\n * @param {string} dim\n * @param {*} scale\n * @param {Array.<number>} coordExtent\n * @param {string} axisType\n * @param {string} position\n */\nvar Axis2D = function (dim, scale, coordExtent, axisType, position) {\n    Axis.call(this, dim, scale, coordExtent);\n    /**\n     * Axis type\n     *  - 'category'\n     *  - 'value'\n     *  - 'time'\n     *  - 'log'\n     * @type {string}\n     */\n    this.type = axisType || 'value';\n\n    /**\n     * Axis position\n     *  - 'top'\n     *  - 'bottom'\n     *  - 'left'\n     *  - 'right'\n     */\n    this.position = position || 'bottom';\n};\n\nAxis2D.prototype = {\n\n    constructor: Axis2D,\n\n    /**\n     * Index of axis, can be used as key\n     */\n    index: 0,\n    /**\n     * If axis is on the zero position of the other axis\n     * @type {boolean}\n     */\n    onZero: false,\n\n    /**\n     * Axis model\n     * @param {module:echarts/coord/cartesian/AxisModel}\n     */\n    model: null,\n\n    isHorizontal: function () {\n        var position = this.position;\n        return position === 'top' || position === 'bottom';\n    },\n\n    /**\n     * Each item cooresponds to this.getExtent(), which\n     * means globalExtent[0] may greater than globalExtent[1],\n     * unless `asc` is input.\n     *\n     * @param {boolean} [asc]\n     * @return {Array.<number>}\n     */\n    getGlobalExtent: function (asc) {\n        var ret = this.getExtent();\n        ret[0] = this.toGlobalCoord(ret[0]);\n        ret[1] = this.toGlobalCoord(ret[1]);\n        asc && ret[0] > ret[1] && ret.reverse();\n        return ret;\n    },\n\n    getOtherAxis: function () {\n        this.grid.getOtherAxis();\n    },\n\n    /**\n     * If label is ignored.\n     * Automatically used when axis is category and label can not be all shown\n     * @param  {number}  idx\n     * @return {boolean}\n     */\n    isLabelIgnored: function (idx) {\n        if (this.type === 'category') {\n            var labelInterval = this.getLabelInterval();\n            return ((typeof labelInterval === 'function')\n                && !labelInterval(idx, this.scale.getLabel(idx)))\n                || idx % (labelInterval + 1);\n        }\n    },\n\n    /**\n     * @override\n     */\n    pointToData: function (point, clamp) {\n        return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n    },\n\n    /**\n     * Transform global coord to local coord,\n     * i.e. var localCoord = axis.toLocalCoord(80);\n     * designate by module:echarts/coord/cartesian/Grid.\n     * @type {Function}\n     */\n    toLocalCoord: null,\n\n    /**\n     * Transform global coord to local coord,\n     * i.e. var globalCoord = axis.toLocalCoord(40);\n     * designate by module:echarts/coord/cartesian/Grid.\n     * @type {Function}\n     */\n    toGlobalCoord: null\n\n};\n\ninherits(Axis2D, Axis);\n\nvar defaultOption = {\n    show: true,\n    zlevel: 0,                  // \n    z: 0,                       // \n    // \n    inverse: false,\n\n    // \n    name: '',\n    // 'start' | 'middle' | 'end'\n    nameLocation: 'end',\n    // degree\n    nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.\n    nameTruncate: {\n        maxWidth: null,\n        ellipsis: '...',\n        placeholder: '.'\n    },\n    // \n    nameTextStyle: {},\n    // \n    nameGap: 15,\n\n    silent: false, // Default false to support tooltip.\n    triggerEvent: false, // Default false to avoid legacy user event listener fail.\n\n    tooltip: {\n        show: false\n    },\n\n    axisPointer: {},\n\n    // \n    axisLine: {\n        // show\n        show: true,\n        onZero: true,\n        onZeroAxisIndex: null,\n        // lineStyle\n        lineStyle: {\n            color: '#333',\n            width: 1,\n            type: 'solid'\n        },\n        // \n        symbol: ['none', 'none'],\n        symbolSize: [10, 15]\n    },\n    // \n    axisTick: {\n        // show\n        show: true,\n        // grid\n        inside: false,\n        // length\n        length: 5,\n        // lineStyle\n        lineStyle: {\n            width: 1\n        }\n    },\n    // axis.axisLabel\n    axisLabel: {\n        show: true,\n        // grid\n        inside: false,\n        rotate: 0,\n        showMinLabel: null, // true | false | null (auto)\n        showMaxLabel: null, // true | false | null (auto)\n        margin: 8,\n        // formatter: null,\n        // TEXTSTYLE\n        fontSize: 12\n    },\n    // \n    splitLine: {\n        // show\n        show: true,\n        // lineStylelineStyle\n        lineStyle: {\n            color: ['#ccc'],\n            width: 1,\n            type: 'solid'\n        }\n    },\n    // \n    splitArea: {\n        // show\n        show: false,\n        // areaStyleareaStyle\n        areaStyle: {\n            color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n        }\n    }\n};\n\nvar axisDefault = {};\n\naxisDefault.categoryAxis = merge({\n    // \n    boundaryGap: true,\n    // splitArea: {\n        // show: false\n    // },\n    splitLine: {\n        show: false\n    },\n    // \n    axisTick: {\n        // If tick is align with label when boundaryGap is true\n        alignWithLabel: false,\n        interval: 'auto'\n    },\n    // axis.axisLabel\n    axisLabel: {\n        interval: 'auto'\n    }\n}, defaultOption);\n\naxisDefault.valueAxis = merge({\n    // \n    boundaryGap: [0, 0],\n    // ,  'dataMin' \n    // min: null,\n    //  'dataMax' \n    // max: null,\n    // Readonly prop, specifies start value of the range when using data zoom.\n    // rangeStart: null\n    // Readonly prop, specifies end value of the range when using data zoom.\n    // rangeEnd: null\n    // 0_min_max\n    // scale: false,\n    // 5\n    splitNumber: 5\n    // Minimum interval\n    // minInterval: null\n    // maxInterval: null\n}, defaultOption);\n\n// FIXME\naxisDefault.timeAxis = defaults({\n    scale: true,\n    min: 'dataMin',\n    max: 'dataMax'\n}, axisDefault.valueAxis);\n\naxisDefault.logAxis = defaults({\n    scale: true,\n    logBase: 10\n}, axisDefault.valueAxis);\n\n// FIXME axisType is fixed ?\nvar AXIS_TYPES = ['value', 'category', 'time', 'log'];\n\n/**\n * Generate sub axis model class\n * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n * @param {module:echarts/model/Component} BaseAxisModelClass\n * @param {Function} axisTypeDefaulter\n * @param {Object} [extraDefaultOption]\n */\nvar axisModelCreator = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\n    each$1(AXIS_TYPES, function (axisType) {\n\n        BaseAxisModelClass.extend({\n\n            type: axisName + 'Axis.' + axisType,\n\n            mergeDefaultAndTheme: function (option, ecModel) {\n                var layoutMode = this.layoutMode;\n                var inputPositionParams = layoutMode\n                    ? getLayoutParams(option) : {};\n\n                var themeModel = ecModel.getTheme();\n                merge(option, themeModel.get(axisType + 'Axis'));\n                merge(option, this.getDefaultOption());\n\n                option.type = axisTypeDefaulter(axisName, option);\n\n                if (layoutMode) {\n                    mergeLayoutParam(option, inputPositionParams, layoutMode);\n                }\n            },\n\n            defaultOption: mergeAll(\n                [\n                    {},\n                    axisDefault[axisType + 'Axis'],\n                    extraDefaultOption\n                ],\n                true\n            )\n        });\n    });\n\n    ComponentModel.registerSubTypeDefaulter(\n        axisName + 'Axis',\n        curry(axisTypeDefaulter, axisName)\n    );\n};\n\nvar AxisModel = ComponentModel.extend({\n\n    type: 'cartesian2dAxis',\n\n    /**\n     * @type {module:echarts/coord/cartesian/Axis2D}\n     */\n    axis: null,\n\n    /**\n     * @override\n     */\n    init: function () {\n        AxisModel.superApply(this, 'init', arguments);\n        this.resetRange();\n    },\n\n    /**\n     * @override\n     */\n    mergeOption: function () {\n        AxisModel.superApply(this, 'mergeOption', arguments);\n        this.resetRange();\n    },\n\n    /**\n     * @override\n     */\n    restoreData: function () {\n        AxisModel.superApply(this, 'restoreData', arguments);\n        this.resetRange();\n    },\n\n    /**\n     * @override\n     * @return {module:echarts/model/Component}\n     */\n    getCoordSysModel: function () {\n        return this.ecModel.queryComponents({\n            mainType: 'grid',\n            index: this.option.gridIndex,\n            id: this.option.gridId\n        })[0];\n    }\n\n});\n\nfunction getAxisType(axisDim, option) {\n    // Default axis with data is category axis\n    return option.type || (option.data ? 'category' : 'value');\n}\n\nmerge(AxisModel.prototype, axisModelCommonMixin);\n\nvar extraOption = {\n    // gridIndex: 0,\n    // gridId: '',\n\n    // Offset is for multiple axis on the same position\n    offset: 0\n};\n\naxisModelCreator('x', AxisModel, getAxisType, extraOption);\naxisModelCreator('y', AxisModel, getAxisType, extraOption);\n\n// Grid \n//  Cartesian2D \n\nComponentModel.extend({\n\n    type: 'grid',\n\n    dependencies: ['xAxis', 'yAxis'],\n\n    layoutMode: 'box',\n\n    /**\n     * @type {module:echarts/coord/cartesian/Grid}\n     */\n    coordinateSystem: null,\n\n    defaultOption: {\n        show: false,\n        zlevel: 0,\n        z: 0,\n        left: '10%',\n        top: 60,\n        right: '10%',\n        bottom: 60,\n        // If grid size contain label\n        containLabel: false,\n        // width: {totalWidth} - left - right,\n        // height: {totalHeight} - top - bottom,\n        backgroundColor: 'rgba(0,0,0,0)',\n        borderWidth: 1,\n        borderColor: '#ccc'\n    }\n});\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n\n// Depends on GridModel, AxisModel, which performs preprocess.\nvar each$8 = each$1;\nvar ifAxisCrossZero$1 = ifAxisCrossZero;\nvar niceScaleExtent$1 = niceScaleExtent;\n\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n    return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var boundingBox = textRect.plain();\n  var beforeWidth = boundingBox.width;\n  var beforeHeight = boundingBox.height;\n  var afterWidth = beforeWidth * Math.cos(rotateRadians) + beforeHeight * Math.sin(rotateRadians);\n  var afterHeight = beforeWidth * Math.sin(rotateRadians) + beforeHeight * Math.cos(rotateRadians);\n  var rotatedRect = new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);\n\n  return rotatedRect;\n}\n\nfunction getLabelUnionRect(axis) {\n    var axisModel = axis.model;\n    var labels = axisModel.getFormattedLabels();\n    var axisLabelModel = axisModel.getModel('axisLabel');\n    var rect;\n    var step = 1;\n    var labelCount = labels.length;\n    if (labelCount > 40) {\n        // Simple optimization for large amount of labels\n        step = Math.ceil(labelCount / 40);\n    }\n    for (var i = 0; i < labelCount; i += step) {\n        if (!axis.isLabelIgnored(i)) {\n            var unrotatedSingleRect = axisLabelModel.getTextRect(labels[i]);\n            var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n\n            rect ? rect.union(singleRect) : (rect = singleRect);\n        }\n    }\n    return rect;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n    /**\n     * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n     * @private\n     */\n    this._coordsMap = {};\n\n    /**\n     * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n     * @private\n     */\n    this._coordsList = [];\n\n    /**\n     * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n     * @private\n     */\n    this._axesMap = {};\n\n    /**\n     * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n     * @private\n     */\n    this._axesList = [];\n\n    this._initCartesian(gridModel, ecModel, api);\n\n    this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\n\ngridProto.type = 'grid';\n\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n    return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n\n    var axesMap = this._axesMap;\n\n    this._updateScale(ecModel, this.model);\n\n    each$8(axesMap.x, function (xAxis) {\n        niceScaleExtent$1(xAxis.scale, xAxis.model);\n    });\n    each$8(axesMap.y, function (yAxis) {\n        niceScaleExtent$1(yAxis.scale, yAxis.model);\n    });\n    each$8(axesMap.x, function (xAxis) {\n        fixAxisOnZero(axesMap, 'y', xAxis);\n    });\n    each$8(axesMap.y, function (yAxis) {\n        fixAxisOnZero(axesMap, 'x', yAxis);\n    });\n\n    // Resize again if containLabel is enabled\n    // FIXME It may cause getting wrong grid size in data processing stage\n    this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis) {\n    // onZero can not be enabled in these two situations:\n    // 1. When any other axis is a category axis.\n    // 2. When no axis is cross 0 point.\n    var axes = axesMap[otherAxisDim];\n\n    if (!axis.onZero) {\n        return;\n    }\n\n    var onZeroAxisIndex = axis.onZeroAxisIndex;\n\n    // If target axis is specified.\n    if (onZeroAxisIndex != null) {\n        var otherAxis = axes[onZeroAxisIndex];\n        if (otherAxis && canNotOnZeroToAxis(otherAxis)) {\n            axis.onZero = false;\n        }\n        return;\n    }\n\n    for (var idx in axes) {\n        if (axes.hasOwnProperty(idx)) {\n            var otherAxis = axes[idx];\n            if (otherAxis && !canNotOnZeroToAxis(otherAxis)) {\n                onZeroAxisIndex = +idx;\n                break;\n            }\n        }\n    }\n\n    if (onZeroAxisIndex == null) {\n        axis.onZero = false;\n    }\n    axis.onZeroAxisIndex = onZeroAxisIndex;\n}\n\nfunction canNotOnZeroToAxis(axis) {\n    return axis.type === 'category' || axis.type === 'time' || !ifAxisCrossZero$1(axis);\n}\n\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n\n    var gridRect = getLayoutRect(\n        gridModel.getBoxLayoutParams(), {\n            width: api.getWidth(),\n            height: api.getHeight()\n        });\n\n    this._rect = gridRect;\n\n    var axesList = this._axesList;\n\n    adjustAxes();\n\n    // Minus label size\n    if (!ignoreContainLabel && gridModel.get('containLabel')) {\n        each$8(axesList, function (axis) {\n            if (!axis.model.get('axisLabel.inside')) {\n                var labelUnionRect = getLabelUnionRect(axis);\n                if (labelUnionRect) {\n                    var dim = axis.isHorizontal() ? 'height' : 'width';\n                    var margin = axis.model.get('axisLabel.margin');\n                    gridRect[dim] -= labelUnionRect[dim] + margin;\n                    if (axis.position === 'top') {\n                        gridRect.y += labelUnionRect.height + margin;\n                    }\n                    else if (axis.position === 'left')  {\n                        gridRect.x += labelUnionRect.width + margin;\n                    }\n                }\n            }\n        });\n\n        adjustAxes();\n    }\n\n    function adjustAxes() {\n        each$8(axesList, function (axis) {\n            var isHorizontal = axis.isHorizontal();\n            var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n            var idx = axis.inverse ? 1 : 0;\n            axis.setExtent(extent[idx], extent[1 - idx]);\n            updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n        });\n    }\n};\n\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\ngridProto.getAxis = function (axisType, axisIndex) {\n    var axesMapOnDim = this._axesMap[axisType];\n    if (axesMapOnDim != null) {\n        if (axisIndex == null) {\n            // Find first axis\n            for (var name in axesMapOnDim) {\n                if (axesMapOnDim.hasOwnProperty(name)) {\n                    return axesMapOnDim[name];\n                }\n            }\n        }\n        return axesMapOnDim[axisIndex];\n    }\n};\n\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\ngridProto.getAxes = function () {\n    return this._axesList.slice();\n};\n\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n    if (xAxisIndex != null && yAxisIndex != null) {\n        var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n        return this._coordsMap[key];\n    }\n\n    if (isObject(xAxisIndex)) {\n        yAxisIndex = xAxisIndex.yAxisIndex;\n        xAxisIndex = xAxisIndex.xAxisIndex;\n    }\n    // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n        if (coordList[i].getAxis('x').index === xAxisIndex\n            || coordList[i].getAxis('y').index === yAxisIndex\n        ) {\n            return coordList[i];\n        }\n    }\n};\n\ngridProto.getCartesians = function () {\n    return this._coordsList.slice();\n};\n\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\ngridProto.convertToPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(ecModel, finder);\n\n    return target.cartesian\n        ? target.cartesian.dataToPoint(value)\n        : target.axis\n        ? target.axis.toGlobalCoord(target.axis.dataToCoord(value))\n        : null;\n};\n\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(ecModel, finder);\n\n    return target.cartesian\n        ? target.cartesian.pointToData(value)\n        : target.axis\n        ? target.axis.coordToData(target.axis.toLocalCoord(value))\n        : null;\n};\n\n/**\n * @inner\n */\ngridProto._findConvertTarget = function (ecModel, finder) {\n    var seriesModel = finder.seriesModel;\n    var xAxisModel = finder.xAxisModel\n        || (seriesModel && seriesModel.getReferringComponents('xAxis')[0]);\n    var yAxisModel = finder.yAxisModel\n        || (seriesModel && seriesModel.getReferringComponents('yAxis')[0]);\n    var gridModel = finder.gridModel;\n    var coordsList = this._coordsList;\n    var cartesian;\n    var axis;\n\n    if (seriesModel) {\n        cartesian = seriesModel.coordinateSystem;\n        indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n    }\n    else if (xAxisModel && yAxisModel) {\n        cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n    }\n    else if (xAxisModel) {\n        axis = this.getAxis('x', xAxisModel.componentIndex);\n    }\n    else if (yAxisModel) {\n        axis = this.getAxis('y', yAxisModel.componentIndex);\n    }\n    // Lowest priority.\n    else if (gridModel) {\n        var grid = gridModel.coordinateSystem;\n        if (grid === this) {\n            cartesian = this._coordsList[0];\n        }\n    }\n\n    return {cartesian: cartesian, axis: axis};\n};\n\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\ngridProto.containPoint = function (point) {\n    var coord = this._coordsList[0];\n    if (coord) {\n        return coord.containPoint(point);\n    }\n};\n\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n    var axisPositionUsed = {\n        left: false,\n        right: false,\n        top: false,\n        bottom: false\n    };\n\n    var axesMap = {\n        x: {},\n        y: {}\n    };\n    var axesCount = {\n        x: 0,\n        y: 0\n    };\n\n    /// Create axis\n    ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n    ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n    if (!axesCount.x || !axesCount.y) {\n        // Roll back when there no either x or y axis\n        this._axesMap = {};\n        this._axesList = [];\n        return;\n    }\n\n    this._axesMap = axesMap;\n\n    /// Create cartesian2d\n    each$8(axesMap.x, function (xAxis, xAxisIndex) {\n        each$8(axesMap.y, function (yAxis, yAxisIndex) {\n            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n            var cartesian = new Cartesian2D(key);\n\n            cartesian.grid = this;\n            cartesian.model = gridModel;\n\n            this._coordsMap[key] = cartesian;\n            this._coordsList.push(cartesian);\n\n            cartesian.addAxis(xAxis);\n            cartesian.addAxis(yAxis);\n        }, this);\n    }, this);\n\n    function createAxisCreator(axisType) {\n        return function (axisModel, idx) {\n            if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n                return;\n            }\n\n            var axisPosition = axisModel.get('position');\n            if (axisType === 'x') {\n                // Fix position\n                if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n                    // Default bottom of X\n                    axisPosition = 'bottom';\n                    if (axisPositionUsed[axisPosition]) {\n                        axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n                    }\n                }\n            }\n            else {\n                // Fix position\n                if (axisPosition !== 'left' && axisPosition !== 'right') {\n                    // Default left of Y\n                    axisPosition = 'left';\n                    if (axisPositionUsed[axisPosition]) {\n                        axisPosition = axisPosition === 'left' ? 'right' : 'left';\n                    }\n                }\n            }\n            axisPositionUsed[axisPosition] = true;\n\n            var axis = new Axis2D(\n                axisType, createScaleByModel(axisModel),\n                [0, 0],\n                axisModel.get('type'),\n                axisPosition\n            );\n\n            var isCategory = axis.type === 'category';\n            axis.onBand = isCategory && axisModel.get('boundaryGap');\n            axis.inverse = axisModel.get('inverse');\n\n            axis.onZero = axisModel.get('axisLine.onZero');\n            axis.onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex');\n\n            // Inject axis into axisModel\n            axisModel.axis = axis;\n\n            // Inject axisModel into axis\n            axis.model = axisModel;\n\n            // Inject grid info axis\n            axis.grid = this;\n\n            // Index of axis, can be used as key\n            axis.index = idx;\n\n            this._axesList.push(axis);\n\n            axesMap[axisType][idx] = axis;\n            axesCount[axisType]++;\n        };\n    }\n};\n\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\ngridProto._updateScale = function (ecModel, gridModel) {\n    // Reset scale\n    each$1(this._axesList, function (axis) {\n        axis.scale.setExtent(Infinity, -Infinity);\n    });\n    ecModel.eachSeries(function (seriesModel) {\n        if (isCartesian2D(seriesModel)) {\n            var axesModels = findAxesModels(seriesModel, ecModel);\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel)\n                || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)\n                ) {\n                return;\n            }\n\n            var cartesian = this.getCartesian(\n                xAxisModel.componentIndex, yAxisModel.componentIndex\n            );\n            var data = seriesModel.getData();\n            var xAxis = cartesian.getAxis('x');\n            var yAxis = cartesian.getAxis('y');\n\n            if (data.type === 'list') {\n                unionExtent(data, xAxis, seriesModel);\n                unionExtent(data, yAxis, seriesModel);\n            }\n        }\n    }, this);\n\n    function unionExtent(data, axis, seriesModel) {\n        each$8(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n            axis.scale.unionExtentFromData(data, dim);\n        });\n    }\n};\n\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\ngridProto.getTooltipAxes = function (dim) {\n    var baseAxes = [];\n    var otherAxes = [];\n\n    each$8(this.getCartesians(), function (cartesian) {\n        var baseAxis = (dim != null && dim !== 'auto')\n            ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n        var otherAxis = cartesian.getOtherAxis(baseAxis);\n        indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n        indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n    });\n\n    return {baseAxes: baseAxes, otherAxes: otherAxes};\n};\n\n/**\n * @inner\n */\nfunction updateAxisTransfrom(axis, coordBase) {\n    var axisExtent = axis.getExtent();\n    var axisExtentSum = axisExtent[0] + axisExtent[1];\n\n    // Fast transform\n    axis.toGlobalCoord = axis.dim === 'x'\n        ? function (coord) {\n            return coord + coordBase;\n        }\n        : function (coord) {\n            return axisExtentSum - coord + coordBase;\n        };\n    axis.toLocalCoord = axis.dim === 'x'\n        ? function (coord) {\n            return coord - coordBase;\n        }\n        : function (coord) {\n            return axisExtentSum - coord + coordBase;\n        };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\nfunction findAxesModels(seriesModel, ecModel) {\n    return map(axesTypes, function (axisType) {\n        var axisModel = seriesModel.getReferringComponents(axisType)[0];\n\n        if (__DEV__) {\n            if (!axisModel) {\n                throw new Error(axisType + ' \"' + retrieve(\n                    seriesModel.get(axisType + 'Index'),\n                    seriesModel.get(axisType + 'Id'),\n                    0\n                ) + '\" not found');\n            }\n        }\n        return axisModel;\n    });\n}\n\n/**\n * @inner\n */\nfunction isCartesian2D(seriesModel) {\n    return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n    var grids = [];\n    ecModel.eachComponent('grid', function (gridModel, idx) {\n        var grid = new Grid(gridModel, ecModel, api);\n        grid.name = 'grid_' + idx;\n        // dataSampling requires axis extent, so resize\n        // should be performed in create stage.\n        grid.resize(gridModel, api, true);\n\n        gridModel.coordinateSystem = grid;\n\n        grids.push(grid);\n    });\n\n    // Inject the coordinateSystems into seriesModel\n    ecModel.eachSeries(function (seriesModel) {\n        if (!isCartesian2D(seriesModel)) {\n            return;\n        }\n\n        var axesModels = findAxesModels(seriesModel, ecModel);\n        var xAxisModel = axesModels[0];\n        var yAxisModel = axesModels[1];\n\n        var gridModel = xAxisModel.getCoordSysModel();\n\n        if (__DEV__) {\n            if (!gridModel) {\n                throw new Error(\n                    'Grid \"' + retrieve(\n                        xAxisModel.get('gridIndex'),\n                        xAxisModel.get('gridId'),\n                        0\n                    ) + '\" not found'\n                );\n            }\n            if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {\n                throw new Error('xAxis and yAxis must use the same grid');\n            }\n        }\n\n        var grid = gridModel.coordinateSystem;\n\n        seriesModel.coordinateSystem = grid.getCartesian(\n            xAxisModel.componentIndex, yAxisModel.componentIndex\n        );\n    });\n\n    return grids;\n};\n\n// For deciding which dimensions to use when creating list data\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\n\nCoordinateSystemManager.register('cartesian2d', Grid);\n\nvar PI$2 = Math.PI;\n\nfunction makeAxisEventDataBase(axisModel) {\n    var eventData = {\n        componentType: axisModel.mainType\n    };\n    eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n    return eventData;\n}\n\n/**\n * A final axis is translated and rotated from a \"standard axis\".\n * So opt.position and opt.rotation is required.\n *\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n * for example: (0, 0) ------------> (0, 50)\n *\n * nameDirection or tickDirection or labelDirection is 1 means tick\n * or label is below the standard axis, whereas is -1 means above\n * the standard axis. labelOffset means offset between label and axis,\n * which is useful when 'onZero', where axisLabel is in the grid and\n * label in outside grid.\n *\n * Tips: like always,\n * positive rotation represents anticlockwise, and negative rotation\n * represents clockwise.\n * The direction of position coordinate is the same as the direction\n * of screen coordinate.\n *\n * Do not need to consider axis 'inverse', which is auto processed by\n * axis extent.\n *\n * @param {module:zrender/container/Group} group\n * @param {Object} axisModel\n * @param {Object} opt Standard axis parameters.\n * @param {Array.<number>} opt.position [x, y]\n * @param {number} opt.rotation by radian\n * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.\n * @param {number} [opt.tickDirection=1] 1 or -1\n * @param {number} [opt.labelDirection=1] 1 or -1\n * @param {number} [opt.labelOffset=0] Usefull when onZero.\n * @param {string} [opt.axisLabelShow] default get from axisModel.\n * @param {string} [opt.axisName] default get from axisModel.\n * @param {number} [opt.axisNameAvailableWidth]\n * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n * @param {number} [opt.labelInterval] Default label interval when label\n *                                     interval from model is null or 'auto'.\n * @param {number} [opt.strokeContainThreshold] Default label interval when label\n * @param {number} [opt.nameTruncateMaxWidth]\n */\nvar AxisBuilder = function (axisModel, opt) {\n\n    /**\n     * @readOnly\n     */\n    this.opt = opt;\n\n    /**\n     * @readOnly\n     */\n    this.axisModel = axisModel;\n\n    // Default value\n    defaults(\n        opt,\n        {\n            labelOffset: 0,\n            nameDirection: 1,\n            tickDirection: 1,\n            labelDirection: 1,\n            silent: true\n        }\n    );\n\n    /**\n     * @readOnly\n     */\n    this.group = new Group();\n\n    // FIXME Not use a seperate text group?\n    var dumbGroup = new Group({\n        position: opt.position.slice(),\n        rotation: opt.rotation\n    });\n\n    // this.group.add(dumbGroup);\n    // this._dumbGroup = dumbGroup;\n\n    dumbGroup.updateTransform();\n    this._transform = dumbGroup.transform;\n\n    this._dumbGroup = dumbGroup;\n};\n\nAxisBuilder.prototype = {\n\n    constructor: AxisBuilder,\n\n    hasBuilder: function (name) {\n        return !!builders[name];\n    },\n\n    add: function (name) {\n        builders[name].call(this);\n    },\n\n    getGroup: function () {\n        return this.group;\n    }\n\n};\n\nvar builders = {\n\n    /**\n     * @private\n     */\n    axisLine: function () {\n        var opt = this.opt;\n        var axisModel = this.axisModel;\n\n        if (!axisModel.get('axisLine.show')) {\n            return;\n        }\n\n        var extent = this.axisModel.axis.getExtent();\n\n        var matrix = this._transform;\n        var pt1 = [extent[0], 0];\n        var pt2 = [extent[1], 0];\n        if (matrix) {\n            applyTransform(pt1, pt1, matrix);\n            applyTransform(pt2, pt2, matrix);\n        }\n\n        var lineStyle = extend(\n            {\n                lineCap: 'round'\n            },\n            axisModel.getModel('axisLine.lineStyle').getLineStyle()\n        );\n\n        this.group.add(new Line(subPixelOptimizeLine({\n            // Id for animation\n            anid: 'line',\n\n            shape: {\n                x1: pt1[0],\n                y1: pt1[1],\n                x2: pt2[0],\n                y2: pt2[1]\n            },\n            style: lineStyle,\n            strokeContainThreshold: opt.strokeContainThreshold || 5,\n            silent: true,\n            z2: 1\n        })));\n\n        var arrows = axisModel.get('axisLine.symbol');\n        var arrowSize = axisModel.get('axisLine.symbolSize');\n\n        if (arrows != null) {\n            if (typeof arrows === 'string') {\n                // Use the same arrow for start and end point\n                arrows = [arrows, arrows];\n            }\n            if (typeof arrowSize === 'string'\n                || typeof arrowSize === 'number'\n            ) {\n                // Use the same size for width and height\n                arrowSize = [arrowSize, arrowSize];\n            }\n\n            var symbolWidth = arrowSize[0];\n            var symbolHeight = arrowSize[1];\n\n            each$1([\n                [opt.rotation + Math.PI / 2, pt1],\n                [opt.rotation - Math.PI / 2, pt2]\n            ], function (item, index) {\n                if (arrows[index] !== 'none' && arrows[index] != null) {\n                    var symbol = createSymbol(\n                        arrows[index],\n                        -symbolWidth / 2,\n                        -symbolHeight / 2,\n                        symbolWidth,\n                        symbolHeight,\n                        lineStyle.stroke,\n                        true\n                    );\n                    symbol.attr({\n                        rotation: item[0],\n                        position: item[1],\n                        silent: true\n                    });\n                    this.group.add(symbol);\n                }\n            }, this);\n        }\n    },\n\n    /**\n     * @private\n     */\n    axisTickLabel: function () {\n        var axisModel = this.axisModel;\n        var opt = this.opt;\n\n        var tickEls = buildAxisTick(this, axisModel, opt);\n        var labelEls = buildAxisLabel(this, axisModel, opt);\n\n        fixMinMaxLabelShow(axisModel, labelEls, tickEls);\n    },\n\n    /**\n     * @private\n     */\n    axisName: function () {\n        var opt = this.opt;\n        var axisModel = this.axisModel;\n        var name = retrieve(opt.axisName, axisModel.get('name'));\n\n        if (!name) {\n            return;\n        }\n\n        var nameLocation = axisModel.get('nameLocation');\n        var nameDirection = opt.nameDirection;\n        var textStyleModel = axisModel.getModel('nameTextStyle');\n        var gap = axisModel.get('nameGap') || 0;\n\n        var extent = this.axisModel.axis.getExtent();\n        var gapSignal = extent[0] > extent[1] ? -1 : 1;\n        var pos = [\n            nameLocation === 'start'\n                ? extent[0] - gapSignal * gap\n                : nameLocation === 'end'\n                ? extent[1] + gapSignal * gap\n                : (extent[0] + extent[1]) / 2, // 'middle'\n            // Reuse labelOffset.\n            isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0\n        ];\n\n        var labelLayout;\n\n        var nameRotation = axisModel.get('nameRotate');\n        if (nameRotation != null) {\n            nameRotation = nameRotation * PI$2 / 180; // To radian.\n        }\n\n        var axisNameAvailableWidth;\n\n        if (isNameLocationCenter(nameLocation)) {\n            labelLayout = innerTextLayout(\n                opt.rotation,\n                nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n                nameDirection\n            );\n        }\n        else {\n            labelLayout = endTextLayout(\n                opt, nameLocation, nameRotation || 0, extent\n            );\n\n            axisNameAvailableWidth = opt.axisNameAvailableWidth;\n            if (axisNameAvailableWidth != null) {\n                axisNameAvailableWidth = Math.abs(\n                    axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n                );\n                !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n            }\n        }\n\n        var textFont = textStyleModel.getFont();\n\n        var truncateOpt = axisModel.get('nameTruncate', true) || {};\n        var ellipsis = truncateOpt.ellipsis;\n        var maxWidth = retrieve(\n            opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth\n        );\n        // FIXME\n        // truncate rich text? (consider performance)\n        var truncatedText = (ellipsis != null && maxWidth != null)\n            ? truncateText$1(\n                name, maxWidth, textFont, ellipsis,\n                {minChar: 2, placeholder: truncateOpt.placeholder}\n            )\n            : name;\n\n        var tooltipOpt = axisModel.get('tooltip', true);\n\n        var mainType = axisModel.mainType;\n        var formatterParams = {\n            componentType: mainType,\n            name: name,\n            $vars: ['name']\n        };\n        formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\n        var textEl = new Text({\n            // Id for animation\n            anid: 'name',\n\n            __fullText: name,\n            __truncatedText: truncatedText,\n\n            position: pos,\n            rotation: labelLayout.rotation,\n            silent: isSilent(axisModel),\n            z2: 1,\n            tooltip: (tooltipOpt && tooltipOpt.show)\n                ? extend({\n                    content: name,\n                    formatter: function () {\n                        return name;\n                    },\n                    formatterParams: formatterParams\n                }, tooltipOpt)\n                : null\n        });\n\n        setTextStyle(textEl.style, textStyleModel, {\n            text: truncatedText,\n            textFont: textFont,\n            textFill: textStyleModel.getTextColor()\n                || axisModel.get('axisLine.lineStyle.color'),\n            textAlign: labelLayout.textAlign,\n            textVerticalAlign: labelLayout.textVerticalAlign\n        });\n\n        if (axisModel.get('triggerEvent')) {\n            textEl.eventData = makeAxisEventDataBase(axisModel);\n            textEl.eventData.targetType = 'axisName';\n            textEl.eventData.name = name;\n        }\n\n        // FIXME\n        this._dumbGroup.add(textEl);\n        textEl.updateTransform();\n\n        this.group.add(textEl);\n\n        textEl.decomposeTransform();\n    }\n\n};\n\n/**\n * @public\n * @static\n * @param {Object} opt\n * @param {number} axisRotation in radian\n * @param {number} textRotation in radian\n * @param {number} direction\n * @return {Object} {\n *  rotation, // according to axis\n *  textAlign,\n *  textVerticalAlign\n * }\n */\nvar innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n    var rotationDiff = remRadian(textRotation - axisRotation);\n    var textAlign;\n    var textVerticalAlign;\n\n    if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n        textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n        textAlign = 'center';\n    }\n    else if (isRadianAroundZero(rotationDiff - PI$2)) { // Label is inverse parallel with axis line.\n        textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n        textAlign = 'center';\n    }\n    else {\n        textVerticalAlign = 'middle';\n\n        if (rotationDiff > 0 && rotationDiff < PI$2) {\n            textAlign = direction > 0 ? 'right' : 'left';\n        }\n        else {\n            textAlign = direction > 0 ? 'left' : 'right';\n        }\n    }\n\n    return {\n        rotation: rotationDiff,\n        textAlign: textAlign,\n        textVerticalAlign: textVerticalAlign\n    };\n};\n\nfunction endTextLayout(opt, textPosition, textRotate, extent) {\n    var rotationDiff = remRadian(textRotate - opt.rotation);\n    var textAlign;\n    var textVerticalAlign;\n    var inverse = extent[0] > extent[1];\n    var onLeft = (textPosition === 'start' && !inverse)\n        || (textPosition !== 'start' && inverse);\n\n    if (isRadianAroundZero(rotationDiff - PI$2 / 2)) {\n        textVerticalAlign = onLeft ? 'bottom' : 'top';\n        textAlign = 'center';\n    }\n    else if (isRadianAroundZero(rotationDiff - PI$2 * 1.5)) {\n        textVerticalAlign = onLeft ? 'top' : 'bottom';\n        textAlign = 'center';\n    }\n    else {\n        textVerticalAlign = 'middle';\n        if (rotationDiff < PI$2 * 1.5 && rotationDiff > PI$2 / 2) {\n            textAlign = onLeft ? 'left' : 'right';\n        }\n        else {\n            textAlign = onLeft ? 'right' : 'left';\n        }\n    }\n\n    return {\n        rotation: rotationDiff,\n        textAlign: textAlign,\n        textVerticalAlign: textVerticalAlign\n    };\n}\n\nfunction isSilent(axisModel) {\n    var tooltipOpt = axisModel.get('tooltip');\n    return axisModel.get('silent')\n        // Consider mouse cursor, add these restrictions.\n        || !(\n            axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n        );\n}\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n    // If min or max are user set, we need to check\n    // If the tick on min(max) are overlap on their neighbour tick\n    // If they are overlapped, we need to hide the min(max) tick label\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n    // FIXME\n    // Have not consider onBand yet, where tick els is more than label els.\n\n    labelEls = labelEls || [];\n    tickEls = tickEls || [];\n\n    var firstLabel = labelEls[0];\n    var nextLabel = labelEls[1];\n    var lastLabel = labelEls[labelEls.length - 1];\n    var prevLabel = labelEls[labelEls.length - 2];\n\n    var firstTick = tickEls[0];\n    var nextTick = tickEls[1];\n    var lastTick = tickEls[tickEls.length - 1];\n    var prevTick = tickEls[tickEls.length - 2];\n\n    if (showMinLabel === false) {\n        ignoreEl(firstLabel);\n        ignoreEl(firstTick);\n    }\n    else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n        if (showMinLabel) {\n            ignoreEl(nextLabel);\n            ignoreEl(nextTick);\n        }\n        else {\n            ignoreEl(firstLabel);\n            ignoreEl(firstTick);\n        }\n    }\n\n    if (showMaxLabel === false) {\n        ignoreEl(lastLabel);\n        ignoreEl(lastTick);\n    }\n    else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n        if (showMaxLabel) {\n            ignoreEl(prevLabel);\n            ignoreEl(prevTick);\n        }\n        else {\n            ignoreEl(lastLabel);\n            ignoreEl(lastTick);\n        }\n    }\n}\n\nfunction ignoreEl(el) {\n    el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next, labelLayout) {\n    // current and next has the same rotation.\n    var firstRect = current && current.getBoundingRect().clone();\n    var nextRect = next && next.getBoundingRect().clone();\n\n    if (!firstRect || !nextRect) {\n        return;\n    }\n\n    // When checking intersect of two rotated labels, we use mRotationBack\n    // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n    var mRotationBack = identity([]);\n    rotate(mRotationBack, mRotationBack, -current.rotation);\n\n    firstRect.applyTransform(mul$1([], mRotationBack, current.getLocalTransform()));\n    nextRect.applyTransform(mul$1([], mRotationBack, next.getLocalTransform()));\n\n    return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n    return nameLocation === 'middle' || nameLocation === 'center';\n}\n\n/**\n * @static\n */\nvar ifIgnoreOnTick$1 = AxisBuilder.ifIgnoreOnTick = function (\n    axis,\n    i,\n    interval,\n    ticksCnt,\n    showMinLabel,\n    showMaxLabel\n) {\n    if (i === 0 && showMinLabel || i === ticksCnt - 1 && showMaxLabel) {\n        return false;\n    }\n\n    // FIXME\n    // Have not consider label overlap (if label is too long) yet.\n\n    var rawTick;\n    var scale$$1 = axis.scale;\n    return scale$$1.type === 'ordinal'\n        && (\n            typeof interval === 'function'\n                ? (\n                    rawTick = scale$$1.getTicks()[i],\n                    !interval(rawTick, scale$$1.getLabel(rawTick))\n                )\n                : i % (interval + 1)\n        );\n};\n\n/**\n * @static\n */\nvar getInterval$1 = AxisBuilder.getInterval = function (model, labelInterval) {\n    var interval = model.get('interval');\n    if (interval == null || interval == 'auto') {\n        interval = labelInterval;\n    }\n    return interval;\n};\n\nfunction buildAxisTick(axisBuilder, axisModel, opt) {\n    var axis = axisModel.axis;\n\n    if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n        return;\n    }\n\n    var tickModel = axisModel.getModel('axisTick');\n\n    var lineStyleModel = tickModel.getModel('lineStyle');\n    var tickLen = tickModel.get('length');\n\n    var tickInterval = getInterval$1(tickModel, opt.labelInterval);\n    var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n    // FIXME\n    // Corresponds to ticksCoords ?\n    var ticks = axis.scale.getTicks();\n\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n    var pt1 = [];\n    var pt2 = [];\n    var matrix = axisBuilder._transform;\n\n    var tickEls = [];\n\n    var ticksCnt = ticksCoords.length;\n    for (var i = 0; i < ticksCnt; i++) {\n        // Only ordinal scale support tick interval\n        if (ifIgnoreOnTick$1(\n            axis, i, tickInterval, ticksCnt,\n            showMinLabel, showMaxLabel\n        )) {\n            continue;\n        }\n\n        var tickCoord = ticksCoords[i];\n\n        pt1[0] = tickCoord;\n        pt1[1] = 0;\n        pt2[0] = tickCoord;\n        pt2[1] = opt.tickDirection * tickLen;\n\n        if (matrix) {\n            applyTransform(pt1, pt1, matrix);\n            applyTransform(pt2, pt2, matrix);\n        }\n        // Tick line, Not use group transform to have better line draw\n        var tickEl = new Line(subPixelOptimizeLine({\n            // Id for animation\n            anid: 'tick_' + ticks[i],\n\n            shape: {\n                x1: pt1[0],\n                y1: pt1[1],\n                x2: pt2[0],\n                y2: pt2[1]\n            },\n            style: defaults(\n                lineStyleModel.getLineStyle(),\n                {\n                    stroke: axisModel.get('axisLine.lineStyle.color')\n                }\n            ),\n            z2: 2,\n            silent: true\n        }));\n        axisBuilder.group.add(tickEl);\n        tickEls.push(tickEl);\n    }\n\n    return tickEls;\n}\n\nfunction buildAxisLabel(axisBuilder, axisModel, opt) {\n    var axis = axisModel.axis;\n    var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n    if (!show || axis.scale.isBlank()) {\n        return;\n    }\n\n    var labelModel = axisModel.getModel('axisLabel');\n    var labelMargin = labelModel.get('margin');\n    var ticks = axis.scale.getTicks();\n    var labels = axisModel.getFormattedLabels();\n\n    // Special label rotate.\n    var labelRotation = (\n        retrieve(opt.labelRotate, labelModel.get('rotate')) || 0\n    ) * PI$2 / 180;\n\n    var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n    var categoryData = axisModel.get('data');\n\n    var labelEls = [];\n    var silent = isSilent(axisModel);\n    var triggerEvent = axisModel.get('triggerEvent');\n\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n    each$1(ticks, function (tickVal, index) {\n        if (ifIgnoreOnTick$1(\n            axis, index, opt.labelInterval, ticks.length,\n            showMinLabel, showMaxLabel\n        )) {\n                return;\n        }\n\n        var itemLabelModel = labelModel;\n        if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n            itemLabelModel = new Model(\n                categoryData[tickVal].textStyle, labelModel, axisModel.ecModel\n            );\n        }\n\n        var textColor = itemLabelModel.getTextColor()\n            || axisModel.get('axisLine.lineStyle.color');\n\n        var tickCoord = axis.dataToCoord(tickVal);\n        var pos = [\n            tickCoord,\n            opt.labelOffset + opt.labelDirection * labelMargin\n        ];\n        var labelStr = axis.scale.getLabel(tickVal);\n\n        var textEl = new Text({\n            // Id for animation\n            anid: 'label_' + tickVal,\n            position: pos,\n            rotation: labelLayout.rotation,\n            silent: silent,\n            z2: 10\n        });\n\n        setTextStyle(textEl.style, itemLabelModel, {\n            text: labels[index],\n            textAlign: itemLabelModel.getShallow('align', true)\n                || labelLayout.textAlign,\n            textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true)\n                || itemLabelModel.getShallow('baseline', true)\n                || labelLayout.textVerticalAlign,\n            textFill: typeof textColor === 'function'\n                ? textColor(\n                    // (1) In category axis with data zoom, tick is not the original\n                    // index of axis.data. So tick should not be exposed to user\n                    // in category axis.\n                    // (2) Compatible with previous version, which always returns labelStr.\n                    // But in interval scale labelStr is like '223,445', which maked\n                    // user repalce ','. So we modify it to return original val but remain\n                    // it as 'string' to avoid error in replacing.\n                    axis.type === 'category' ? labelStr : axis.type === 'value' ? tickVal + '' : tickVal,\n                    index\n                )\n                : textColor\n        });\n\n        // Pack data for mouse event\n        if (triggerEvent) {\n            textEl.eventData = makeAxisEventDataBase(axisModel);\n            textEl.eventData.targetType = 'axisLabel';\n            textEl.eventData.value = labelStr;\n        }\n\n        // FIXME\n        axisBuilder._dumbGroup.add(textEl);\n        textEl.updateTransform();\n\n        labelEls.push(textEl);\n        axisBuilder.group.add(textEl);\n\n        textEl.decomposeTransform();\n\n    });\n\n    return labelEls;\n}\n\nvar each$9 = each$1;\nvar curry$1 = curry;\n\n// Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n// allAxesInfo should be updated when setOption performed.\nfunction collect(ecModel, api) {\n    var result = {\n        /**\n         * key: makeKey(axis.model)\n         * value: {\n         *      axis,\n         *      coordSys,\n         *      axisPointerModel,\n         *      triggerTooltip,\n         *      involveSeries,\n         *      snap,\n         *      seriesModels,\n         *      seriesDataCount\n         * }\n         */\n        axesInfo: {},\n        seriesInvolved: false,\n        /**\n         * key: makeKey(coordSys.model)\n         * value: Object: key makeKey(axis.model), value: axisInfo\n         */\n        coordSysAxesInfo: {},\n        coordSysMap: {}\n    };\n\n    collectAxesInfo(result, ecModel, api);\n\n    // Check seriesInvolved for performance, in case too many series in some chart.\n    result.seriesInvolved && collectSeriesInfo(result, ecModel);\n\n    return result;\n}\n\nfunction collectAxesInfo(result, ecModel, api) {\n    var globalTooltipModel = ecModel.getComponent('tooltip');\n    var globalAxisPointerModel = ecModel.getComponent('axisPointer');\n    // links can only be set on global.\n    var linksOption = globalAxisPointerModel.get('link', true) || [];\n    var linkGroups = [];\n\n    // Collect axes info.\n    each$9(api.getCoordinateSystems(), function (coordSys) {\n        // Some coordinate system do not support axes, like geo.\n        if (!coordSys.axisPointerEnabled) {\n            return;\n        }\n\n        var coordSysKey = makeKey(coordSys.model);\n        var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};\n        result.coordSysMap[coordSysKey] = coordSys;\n\n        // Set tooltip (like 'cross') is a convienent way to show axisPointer\n        // for user. So we enable seting tooltip on coordSys model.\n        var coordSysModel = coordSys.model;\n        var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);\n\n        each$9(coordSys.getAxes(), curry$1(saveTooltipAxisInfo, false, null));\n\n        // If axis tooltip used, choose tooltip axis for each coordSys.\n        // Notice this case: coordSys is `grid` but not `cartesian2D` here.\n        if (coordSys.getTooltipAxes\n            && globalTooltipModel\n            // If tooltip.showContent is set as false, tooltip will not\n            // show but axisPointer will show as normal.\n            && baseTooltipModel.get('show')\n        ) {\n            // Compatible with previous logic. But series.tooltip.trigger: 'axis'\n            // or series.data[n].tooltip.trigger: 'axis' are not support any more.\n            var triggerAxis = baseTooltipModel.get('trigger') === 'axis';\n            var cross = baseTooltipModel.get('axisPointer.type') === 'cross';\n            var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));\n            if (triggerAxis || cross) {\n                each$9(tooltipAxes.baseAxes, curry$1(\n                    saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis\n                ));\n            }\n            if (cross) {\n                each$9(tooltipAxes.otherAxes, curry$1(saveTooltipAxisInfo, 'cross', false));\n            }\n        }\n\n        // fromTooltip: true | false | 'cross'\n        // triggerTooltip: true | false | null\n        function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {\n            var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);\n\n            var axisPointerShow = axisPointerModel.get('show');\n            if (!axisPointerShow || (\n                axisPointerShow === 'auto'\n                && !fromTooltip\n                && !isHandleTrigger(axisPointerModel)\n            )) {\n                return;\n            }\n\n            if (triggerTooltip == null) {\n                triggerTooltip = axisPointerModel.get('triggerTooltip');\n            }\n\n            axisPointerModel = fromTooltip\n                ? makeAxisPointerModel(\n                    axis, baseTooltipModel, globalAxisPointerModel, ecModel,\n                    fromTooltip, triggerTooltip\n                )\n                : axisPointerModel;\n\n            var snap = axisPointerModel.get('snap');\n            var key = makeKey(axis.model);\n            var involveSeries = triggerTooltip || snap || axis.type === 'category';\n\n            // If result.axesInfo[key] exist, override it (tooltip has higher priority).\n            var axisInfo = result.axesInfo[key] = {\n                key: key,\n                axis: axis,\n                coordSys: coordSys,\n                axisPointerModel: axisPointerModel,\n                triggerTooltip: triggerTooltip,\n                involveSeries: involveSeries,\n                snap: snap,\n                useHandle: isHandleTrigger(axisPointerModel),\n                seriesModels: []\n            };\n            axesInfoInCoordSys[key] = axisInfo;\n            result.seriesInvolved |= involveSeries;\n\n            var groupIndex = getLinkGroupIndex(linksOption, axis);\n            if (groupIndex != null) {\n                var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {axesInfo: {}});\n                linkGroup.axesInfo[key] = axisInfo;\n                linkGroup.mapper = linksOption[groupIndex].mapper;\n                axisInfo.linkGroup = linkGroup;\n            }\n        }\n    });\n}\n\nfunction makeAxisPointerModel(\n    axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip\n) {\n    var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');\n    var volatileOption = {};\n\n    each$9(\n        [\n            'type', 'snap', 'lineStyle', 'shadowStyle', 'label',\n            'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'\n        ],\n        function (field) {\n            volatileOption[field] = clone(tooltipAxisPointerModel.get(field));\n        }\n    );\n\n    // category axis do not auto snap, otherwise some tick that do not\n    // has value can not be hovered. value/time/log axis default snap if\n    // triggered from tooltip and trigger tooltip.\n    volatileOption.snap = axis.type !== 'category' && !!triggerTooltip;\n\n    // Compatibel with previous behavior, tooltip axis do not show label by default.\n    // Only these properties can be overrided from tooltip to axisPointer.\n    if (tooltipAxisPointerModel.get('type') === 'cross') {\n        volatileOption.type = 'line';\n    }\n    var labelOption = volatileOption.label || (volatileOption.label = {});\n    // Follow the convention, do not show label when triggered by tooltip by default.\n    labelOption.show == null && (labelOption.show = false);\n\n    if (fromTooltip === 'cross') {\n        // When 'cross', both axes show labels.\n        labelOption.show = true;\n        // If triggerTooltip, this is a base axis, which should better not use cross style\n        // (cross style is dashed by default)\n        if (!triggerTooltip) {\n            var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');\n            crossStyle && defaults(labelOption, crossStyle.textStyle);\n        }\n    }\n\n    return axis.model.getModel(\n        'axisPointer',\n        new Model(volatileOption, globalAxisPointerModel, ecModel)\n    );\n}\n\nfunction collectSeriesInfo(result, ecModel) {\n    // Prepare data for axis trigger\n    ecModel.eachSeries(function (seriesModel) {\n\n        // Notice this case: this coordSys is `cartesian2D` but not `grid`.\n        var coordSys = seriesModel.coordinateSystem;\n        var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);\n        var seriesTooltipShow = seriesModel.get('tooltip.show', true);\n        if (!coordSys\n            || seriesTooltipTrigger === 'none'\n            || seriesTooltipTrigger === false\n            || seriesTooltipTrigger === 'item'\n            || seriesTooltipShow === false\n            || seriesModel.get('axisPointer.show', true) === false\n        ) {\n            return;\n        }\n\n        each$9(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {\n            var axis = axisInfo.axis;\n            if (coordSys.getAxis(axis.dim) === axis) {\n                axisInfo.seriesModels.push(seriesModel);\n                axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);\n                axisInfo.seriesDataCount += seriesModel.getData().count();\n            }\n        });\n\n    }, this);\n}\n\n/**\n * For example:\n * {\n *     axisPointer: {\n *         links: [{\n *             xAxisIndex: [2, 4],\n *             yAxisIndex: 'all'\n *         }, {\n *             xAxisId: ['a5', 'a7'],\n *             xAxisName: 'xxx'\n *         }]\n *     }\n * }\n */\nfunction getLinkGroupIndex(linksOption, axis) {\n    var axisModel = axis.model;\n    var dim = axis.dim;\n    for (var i = 0; i < linksOption.length; i++) {\n        var linkOption = linksOption[i] || {};\n        if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id)\n            || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex)\n            || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)\n        ) {\n            return i;\n        }\n    }\n}\n\nfunction checkPropInLink(linkPropValue, axisPropValue) {\n    return linkPropValue === 'all'\n        || (isArray(linkPropValue) && indexOf(linkPropValue, axisPropValue) >= 0)\n        || linkPropValue === axisPropValue;\n}\n\nfunction fixValue(axisModel) {\n    var axisInfo = getAxisInfo(axisModel);\n    if (!axisInfo) {\n        return;\n    }\n\n    var axisPointerModel = axisInfo.axisPointerModel;\n    var scale = axisInfo.axis.scale;\n    var option = axisPointerModel.option;\n    var status = axisPointerModel.get('status');\n    var value = axisPointerModel.get('value');\n\n    // Parse init value for category and time axis.\n    if (value != null) {\n        value = scale.parse(value);\n    }\n\n    var useHandle = isHandleTrigger(axisPointerModel);\n    // If `handle` used, `axisPointer` will always be displayed, so value\n    // and status should be initialized.\n    if (status == null) {\n        option.status = useHandle ? 'show' : 'hide';\n    }\n\n    var extent = scale.getExtent().slice();\n    extent[0] > extent[1] && extent.reverse();\n\n    if (// Pick a value on axis when initializing.\n        value == null\n        // If both `handle` and `dataZoom` are used, value may be out of axis extent,\n        // where we should re-pick a value to keep `handle` displaying normally.\n        || value > extent[1]\n    ) {\n        // Make handle displayed on the end of the axis when init, which looks better.\n        value = extent[1];\n    }\n    if (value < extent[0]) {\n        value = extent[0];\n    }\n\n    option.value = value;\n\n    if (useHandle) {\n        option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';\n    }\n}\n\nfunction getAxisInfo(axisModel) {\n    var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;\n    return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];\n}\n\nfunction getAxisPointerModel(axisModel) {\n    var axisInfo = getAxisInfo(axisModel);\n    return axisInfo && axisInfo.axisPointerModel;\n}\n\nfunction isHandleTrigger(axisPointerModel) {\n    return !!axisPointerModel.get('handle.show');\n}\n\n/**\n * @param {module:echarts/model/Model} model\n * @return {string} unique key\n */\nfunction makeKey(model) {\n    return model.type + '||' + model.id;\n}\n\n/**\n * Base class of AxisView.\n */\nvar AxisView = extendComponentView({\n\n    type: 'axis',\n\n    /**\n     * @private\n     */\n    _axisPointer: null,\n\n    /**\n     * @protected\n     * @type {string}\n     */\n    axisPointerClass: null,\n\n    /**\n     * @override\n     */\n    render: function (axisModel, ecModel, api, payload) {\n        // FIXME\n        // This process should proformed after coordinate systems updated\n        // (axis scale updated), and should be performed each time update.\n        // So put it here temporarily, although it is not appropriate to\n        // put a model-writing procedure in `view`.\n        this.axisPointerClass && fixValue(axisModel);\n\n        AxisView.superApply(this, 'render', arguments);\n\n        updateAxisPointer(this, axisModel, ecModel, api, payload, true);\n    },\n\n    /**\n     * Action handler.\n     * @public\n     * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} payload\n     */\n    updateAxisPointer: function (axisModel, ecModel, api, payload, force) {\n        updateAxisPointer(this, axisModel, ecModel, api, payload, false);\n    },\n\n    /**\n     * @override\n     */\n    remove: function (ecModel, api) {\n        var axisPointer = this._axisPointer;\n        axisPointer && axisPointer.remove(api);\n        AxisView.superApply(this, 'remove', arguments);\n    },\n\n    /**\n     * @override\n     */\n    dispose: function (ecModel, api) {\n        disposeAxisPointer(this, api);\n        AxisView.superApply(this, 'dispose', arguments);\n    }\n\n});\n\nfunction updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {\n    var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);\n    if (!Clazz) {\n        return;\n    }\n    var axisPointerModel = getAxisPointerModel(axisModel);\n    axisPointerModel\n        ? (axisView._axisPointer || (axisView._axisPointer = new Clazz()))\n            .render(axisModel, axisPointerModel, api, forceRender)\n        : disposeAxisPointer(axisView, api);\n}\n\nfunction disposeAxisPointer(axisView, ecModel, api) {\n    var axisPointer = axisView._axisPointer;\n    axisPointer && axisPointer.dispose(ecModel, api);\n    axisView._axisPointer = null;\n}\n\nvar axisPointerClazz = [];\n\nAxisView.registerAxisPointerClass = function (type, clazz) {\n    if (__DEV__) {\n        if (axisPointerClazz[type]) {\n            throw new Error('axisPointer ' + type + ' exists');\n        }\n    }\n    axisPointerClazz[type] = clazz;\n};\n\nAxisView.getAxisPointerClass = function (type) {\n    return type && axisPointerClazz[type];\n};\n\n/**\n * @param {Object} opt {labelInside}\n * @return {Object} {\n *  position, rotation, labelDirection, labelOffset,\n *  tickDirection, labelRotate, labelInterval, z2\n * }\n */\nfunction layout(gridModel, axisModel, opt) {\n    opt = opt || {};\n    var grid = gridModel.coordinateSystem;\n    var axis = axisModel.axis;\n    var layout = {};\n\n    var rawAxisPosition = axis.position;\n    var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n    var axisDim = axis.dim;\n\n    var rect = grid.getRect();\n    var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n    var idx = {left: 0, right: 1, top: 0, bottom: 1, onZero: 2};\n    var axisOffset = axisModel.get('offset') || 0;\n\n    var posBound = axisDim === 'x'\n        ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset]\n        : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];\n\n    if (axis.onZero) {\n        var otherAxis = grid.getAxis(axisDim === 'x' ? 'y' : 'x', axis.onZeroAxisIndex);\n        var onZeroCoord = otherAxis.toGlobalCoord(otherAxis.dataToCoord(0));\n        posBound[idx['onZero']] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);\n    }\n\n    // Axis position\n    layout.position = [\n        axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0],\n        axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]\n    ];\n\n    // Axis rotation\n    layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\n    // Tick and label direction, x y is axisDim\n    var dirMap = {top: -1, bottom: 1, left: -1, right: 1};\n\n    layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n    layout.labelOffset = axis.onZero ? posBound[idx[rawAxisPosition]] - posBound[idx['onZero']] : 0;\n\n    if (axisModel.get('axisTick.inside')) {\n        layout.tickDirection = -layout.tickDirection;\n    }\n    if (retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {\n        layout.labelDirection = -layout.labelDirection;\n    }\n\n    // Special label rotation\n    var labelRotate = axisModel.get('axisLabel.rotate');\n    layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate;\n\n    // label interval when auto mode.\n    layout.labelInterval = axis.getLabelInterval();\n\n    // Over splitLine and splitArea\n    layout.z2 = 1;\n\n    return layout;\n}\n\nvar ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\nvar getInterval = AxisBuilder.getInterval;\n\nvar axisBuilderAttrs = [\n    'axisLine', 'axisTickLabel', 'axisName'\n];\nvar selfBuilderAttrs = [\n    'splitArea', 'splitLine'\n];\n\n// function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n\n    type: 'cartesianAxis',\n\n    axisPointerClass: 'CartesianAxisPointer',\n\n    /**\n     * @override\n     */\n    render: function (axisModel, ecModel, api, payload) {\n\n        this.group.removeAll();\n\n        var oldAxisGroup = this._axisGroup;\n        this._axisGroup = new Group();\n\n        this.group.add(this._axisGroup);\n\n        if (!axisModel.get('show')) {\n            return;\n        }\n\n        var gridModel = axisModel.getCoordSysModel();\n\n        var layout$$1 = layout(gridModel, axisModel);\n\n        var axisBuilder = new AxisBuilder(axisModel, layout$$1);\n\n        each$1(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n        this._axisGroup.add(axisBuilder.getGroup());\n\n        each$1(selfBuilderAttrs, function (name) {\n            if (axisModel.get(name + '.show')) {\n                this['_' + name](axisModel, gridModel, layout$$1.labelInterval);\n            }\n        }, this);\n\n        groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n\n        CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n    },\n\n    /**\n     * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n     * @param {number|Function} labelInterval\n     * @private\n     */\n    _splitLine: function (axisModel, gridModel, labelInterval) {\n        var axis = axisModel.axis;\n\n        if (axis.scale.isBlank()) {\n            return;\n        }\n\n        var splitLineModel = axisModel.getModel('splitLine');\n        var lineStyleModel = splitLineModel.getModel('lineStyle');\n        var lineColors = lineStyleModel.get('color');\n\n        var lineInterval = getInterval(splitLineModel, labelInterval);\n\n        lineColors = isArray(lineColors) ? lineColors : [lineColors];\n\n        var gridRect = gridModel.coordinateSystem.getRect();\n        var isHorizontal = axis.isHorizontal();\n\n        var lineCount = 0;\n\n        var ticksCoords = axis.getTicksCoords(\n            // splitLineModel.get('alignWithLabel')\n        );\n        var ticks = axis.scale.getTicks();\n\n        var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n        var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n        var p1 = [];\n        var p2 = [];\n        // Simple optimization\n        // Batching the lines if color are the same\n        var lineStyle = lineStyleModel.getLineStyle();\n        for (var i = 0; i < ticksCoords.length; i++) {\n            if (ifIgnoreOnTick(\n                axis, i, lineInterval, ticksCoords.length,\n                showMinLabel, showMaxLabel\n            )) {\n                continue;\n            }\n\n            var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n            if (isHorizontal) {\n                p1[0] = tickCoord;\n                p1[1] = gridRect.y;\n                p2[0] = tickCoord;\n                p2[1] = gridRect.y + gridRect.height;\n            }\n            else {\n                p1[0] = gridRect.x;\n                p1[1] = tickCoord;\n                p2[0] = gridRect.x + gridRect.width;\n                p2[1] = tickCoord;\n            }\n\n            var colorIndex = (lineCount++) % lineColors.length;\n            this._axisGroup.add(new Line(subPixelOptimizeLine({\n                anid: 'line_' + ticks[i],\n\n                shape: {\n                    x1: p1[0],\n                    y1: p1[1],\n                    x2: p2[0],\n                    y2: p2[1]\n                },\n                style: defaults({\n                    stroke: lineColors[colorIndex]\n                }, lineStyle),\n                silent: true\n            })));\n        }\n    },\n\n    /**\n     * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n     * @param {number|Function} labelInterval\n     * @private\n     */\n    _splitArea: function (axisModel, gridModel, labelInterval) {\n        var axis = axisModel.axis;\n\n        if (axis.scale.isBlank()) {\n            return;\n        }\n\n        var splitAreaModel = axisModel.getModel('splitArea');\n        var areaStyleModel = splitAreaModel.getModel('areaStyle');\n        var areaColors = areaStyleModel.get('color');\n\n        var gridRect = gridModel.coordinateSystem.getRect();\n\n        var ticksCoords = axis.getTicksCoords(\n            // splitAreaModel.get('alignWithLabel')\n        );\n        var ticks = axis.scale.getTicks();\n\n        var prevX = axis.toGlobalCoord(ticksCoords[0]);\n        var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\n        var count = 0;\n\n        var areaInterval = getInterval(splitAreaModel, labelInterval);\n\n        var areaStyle = areaStyleModel.getAreaStyle();\n        areaColors = isArray(areaColors) ? areaColors : [areaColors];\n\n        var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n        var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n        for (var i = 1; i < ticksCoords.length; i++) {\n            if (ifIgnoreOnTick(\n                axis, i, areaInterval, ticksCoords.length,\n                showMinLabel, showMaxLabel\n            )) {\n                continue;\n            }\n\n            var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n            var x;\n            var y;\n            var width;\n            var height;\n            if (axis.isHorizontal()) {\n                x = prevX;\n                y = gridRect.y;\n                width = tickCoord - x;\n                height = gridRect.height;\n            }\n            else {\n                x = gridRect.x;\n                y = prevY;\n                width = gridRect.width;\n                height = tickCoord - y;\n            }\n\n            var colorIndex = (count++) % areaColors.length;\n            this._axisGroup.add(new Rect({\n                anid: 'area_' + ticks[i],\n\n                shape: {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                },\n                style: defaults({\n                    fill: areaColors[colorIndex]\n                }, areaStyle),\n                silent: true\n            }));\n\n            prevX = x + width;\n            prevY = y + height;\n        }\n    }\n});\n\nCartesianAxisView.extend({\n    type: 'xAxis'\n});\nCartesianAxisView.extend({\n    type: 'yAxis'\n});\n\n// Grid view\nextendComponentView({\n\n    type: 'grid',\n\n    render: function (gridModel, ecModel) {\n        this.group.removeAll();\n        if (gridModel.get('show')) {\n            this.group.add(new Rect({\n                shape: gridModel.coordinateSystem.getRect(),\n                style: defaults({\n                    fill: gridModel.get('backgroundColor')\n                }, gridModel.getItemStyle()),\n                silent: true,\n                z2: -1\n            }));\n        }\n    }\n\n});\n\nregisterPreprocessor(function (option) {\n    // Only create grid when need\n    if (option.xAxis && option.yAxis && !option.grid) {\n        option.grid = {};\n    }\n});\n\n// In case developer forget to include grid component\nregisterVisual(curry(\n    visualSymbol, 'line', 'circle', 'line'\n));\nregisterLayout(curry(\n    layoutPoints, 'line'\n));\n\n// Down sample after filter\nregisterProcessor(PRIORITY.PROCESSOR.STATISTIC, curry(\n    dataSample, 'line'\n));\n\nvar STACK_PREFIX = '__ec_stack_';\n\nfunction getSeriesStackId(seriesModel) {\n    return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n    return axis.dim + axis.index;\n}\n\n/**\n * @param {Object} opt\n * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n * @param {number} opt.count Positive interger.\n * @param {number} [opt.barWidth]\n * @param {number} [opt.barMaxWidth]\n * @param {number} [opt.barGap]\n * @param {number} [opt.barCategoryGap]\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n */\nfunction getLayoutOnAxis(opt, api) {\n    var params = [];\n    var baseAxis = opt.axis;\n    var axisKey = 'axis0';\n\n    if (baseAxis.type !== 'category') {\n        return;\n    }\n    var bandWidth = baseAxis.getBandWidth();\n\n    for (var i = 0; i < opt.count || 0; i++) {\n        params.push(defaults({\n            bandWidth: bandWidth,\n            axisKey: axisKey,\n            stackId: STACK_PREFIX + i\n        }, opt));\n    }\n    var widthAndOffsets = doCalBarWidthAndOffset(params, api);\n\n    var result = [];\n    for (var i = 0; i < opt.count; i++) {\n        var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n        item.offsetCenter = item.offset + item.width / 2;\n        result.push(item);\n    }\n\n    return result;\n}\n\nfunction calBarWidthAndOffset(barSeries, api) {\n    var seriesInfoList = map(barSeries, function (seriesModel) {\n        var data = seriesModel.getData();\n        var cartesian = seriesModel.coordinateSystem;\n        var baseAxis = cartesian.getBaseAxis();\n        var axisExtent = baseAxis.getExtent();\n        var bandWidth = baseAxis.type === 'category'\n            ? baseAxis.getBandWidth()\n            : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count());\n\n        var barWidth = parsePercent$1(\n            seriesModel.get('barWidth'), bandWidth\n        );\n        var barMaxWidth = parsePercent$1(\n            seriesModel.get('barMaxWidth'), bandWidth\n        );\n        var barGap = seriesModel.get('barGap');\n        var barCategoryGap = seriesModel.get('barCategoryGap');\n\n        return {\n            bandWidth: bandWidth,\n            barWidth: barWidth,\n            barMaxWidth: barMaxWidth,\n            barGap: barGap,\n            barCategoryGap: barCategoryGap,\n            axisKey: getAxisKey(baseAxis),\n            stackId: getSeriesStackId(seriesModel)\n        };\n    });\n\n    return doCalBarWidthAndOffset(seriesInfoList, api);\n}\n\nfunction doCalBarWidthAndOffset(seriesInfoList, api) {\n    // Columns info on each category axis. Key is cartesian name\n    var columnsMap = {};\n\n    each$1(seriesInfoList, function (seriesInfo, idx) {\n        var axisKey = seriesInfo.axisKey;\n        var bandWidth = seriesInfo.bandWidth;\n        var columnsOnAxis = columnsMap[axisKey] || {\n            bandWidth: bandWidth,\n            remainedWidth: bandWidth,\n            autoWidthCount: 0,\n            categoryGap: '20%',\n            gap: '30%',\n            stacks: {}\n        };\n        var stacks = columnsOnAxis.stacks;\n        columnsMap[axisKey] = columnsOnAxis;\n\n        var stackId = seriesInfo.stackId;\n\n        if (!stacks[stackId]) {\n            columnsOnAxis.autoWidthCount++;\n        }\n        stacks[stackId] = stacks[stackId] || {\n            width: 0,\n            maxWidth: 0\n        };\n\n        // Caution: In a single coordinate system, these barGrid attributes\n        // will be shared by series. Consider that they have default values,\n        // only the attributes set on the last series will work.\n        // Do not change this fact unless there will be a break change.\n\n        // TODO\n        var barWidth = seriesInfo.barWidth;\n        if (barWidth && !stacks[stackId].width) {\n            // See #6312, do not restrict width.\n            stacks[stackId].width = barWidth;\n            barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n            columnsOnAxis.remainedWidth -= barWidth;\n        }\n\n        var barMaxWidth = seriesInfo.barMaxWidth;\n        barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n        var barGap = seriesInfo.barGap;\n        (barGap != null) && (columnsOnAxis.gap = barGap);\n        var barCategoryGap = seriesInfo.barCategoryGap;\n        (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap);\n    });\n\n    var result = {};\n\n    each$1(columnsMap, function (columnsOnAxis, coordSysName) {\n\n        result[coordSysName] = {};\n\n        var stacks = columnsOnAxis.stacks;\n        var bandWidth = columnsOnAxis.bandWidth;\n        var categoryGap = parsePercent$1(columnsOnAxis.categoryGap, bandWidth);\n        var barGapPercent = parsePercent$1(columnsOnAxis.gap, 1);\n\n        var remainedWidth = columnsOnAxis.remainedWidth;\n        var autoWidthCount = columnsOnAxis.autoWidthCount;\n        var autoWidth = (remainedWidth - categoryGap)\n            / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n        autoWidth = Math.max(autoWidth, 0);\n\n        // Find if any auto calculated bar exceeded maxBarWidth\n        each$1(stacks, function (column, stack) {\n            var maxWidth = column.maxWidth;\n            if (maxWidth && maxWidth < autoWidth) {\n                maxWidth = Math.min(maxWidth, remainedWidth);\n                if (column.width) {\n                    maxWidth = Math.min(maxWidth, column.width);\n                }\n                remainedWidth -= maxWidth;\n                column.width = maxWidth;\n                autoWidthCount--;\n            }\n        });\n\n        // Recalculate width again\n        autoWidth = (remainedWidth - categoryGap)\n            / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n        autoWidth = Math.max(autoWidth, 0);\n\n        var widthSum = 0;\n        var lastColumn;\n        each$1(stacks, function (column, idx) {\n            if (!column.width) {\n                column.width = autoWidth;\n            }\n            lastColumn = column;\n            widthSum += column.width * (1 + barGapPercent);\n        });\n        if (lastColumn) {\n            widthSum -= lastColumn.width * barGapPercent;\n        }\n\n        var offset = -widthSum / 2;\n        each$1(stacks, function (column, stackId) {\n            result[coordSysName][stackId] = result[coordSysName][stackId] || {\n                offset: offset,\n                width: column.width\n            };\n\n            offset += column.width * (1 + barGapPercent);\n        });\n    });\n\n    return result;\n}\n\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n */\nfunction barLayoutGrid(seriesType, ecModel, api) {\n\n    var barWidthAndOffset = calBarWidthAndOffset(\n        filter(\n            ecModel.getSeriesByType(seriesType),\n            function (seriesModel) {\n                return !ecModel.isSeriesFiltered(seriesModel)\n                    && seriesModel.coordinateSystem\n                    && seriesModel.coordinateSystem.type === 'cartesian2d';\n            }\n        )\n    );\n\n    var lastStackCoords = {};\n    var lastStackCoordsOrigin = {};\n\n    ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\n        // Check series coordinate, do layout for cartesian2d only\n        if (seriesModel.coordinateSystem.type !== 'cartesian2d') {\n            return;\n        }\n\n        var data = seriesModel.getData();\n        var cartesian = seriesModel.coordinateSystem;\n        var baseAxis = cartesian.getBaseAxis();\n\n        var stackId = getSeriesStackId(seriesModel);\n        var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n        var columnOffset = columnLayoutInfo.offset;\n        var columnWidth = columnLayoutInfo.width;\n        var valueAxis = cartesian.getOtherAxis(baseAxis);\n\n        var barMinHeight = seriesModel.get('barMinHeight') || 0;\n\n        var valueAxisStart = baseAxis.onZero\n            ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0))\n            : valueAxis.getGlobalExtent()[0];\n\n        var coordDims = [\n            seriesModel.coordDimToDataDim('x')[0],\n            seriesModel.coordDimToDataDim('y')[0]\n        ];\n        var coords = data.mapArray(coordDims, function (x, y) {\n            return cartesian.dataToPoint([x, y]);\n        }, true);\n\n        lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n        lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n        data.setLayout({\n            offset: columnOffset,\n            size: columnWidth\n        });\n\n        data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0], function (value, idx) {\n            if (isNaN(value)) {\n                return;\n            }\n\n            if (!lastStackCoords[stackId][idx]) {\n                lastStackCoords[stackId][idx] = {\n                    p: valueAxisStart, // Positive stack\n                    n: valueAxisStart  // Negative stack\n                };\n                lastStackCoordsOrigin[stackId][idx] = {\n                    p: valueAxisStart, // Positive stack\n                    n: valueAxisStart  // Negative stack\n                };\n            }\n            var sign = value >= 0 ? 'p' : 'n';\n            var coord = coords[idx];\n            var lastCoord = lastStackCoords[stackId][idx][sign];\n            var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n            var x;\n            var y;\n            var width;\n            var height;\n\n            if (valueAxis.isHorizontal()) {\n                x = lastCoord;\n                y = coord[1] + columnOffset;\n                width = coord[0] - lastCoordOrigin;\n                height = columnWidth;\n\n                lastStackCoordsOrigin[stackId][idx][sign] += width;\n                if (Math.abs(width) < barMinHeight) {\n                    width = (width < 0 ? -1 : 1) * barMinHeight;\n                }\n                lastStackCoords[stackId][idx][sign] += width;\n            }\n            else {\n                x = coord[0] + columnOffset;\n                y = lastCoord;\n                width = columnWidth;\n                height = coord[1] - lastCoordOrigin;\n\n                lastStackCoordsOrigin[stackId][idx][sign] += height;\n                if (Math.abs(height) < barMinHeight) {\n                    // Include zero to has a positive bar\n                    height = (height <= 0 ? -1 : 1) * barMinHeight;\n                }\n                lastStackCoords[stackId][idx][sign] += height;\n            }\n\n            data.setItemLayout(idx, {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            });\n        }, true);\n\n    }, this);\n}\n\nbarLayoutGrid.getLayoutOnAxis = getLayoutOnAxis;\n\nvar BaseBarSeries = SeriesModel.extend({\n\n    type: 'series.__base_bar__',\n\n    getInitialData: function (option, ecModel) {\n        return createListFromArray(option.data, this, ecModel);\n    },\n\n    getMarkerPosition: function (value) {\n        var coordSys = this.coordinateSystem;\n        if (coordSys) {\n            // PENDING if clamp ?\n            var pt = coordSys.dataToPoint(value, true);\n            var data = this.getData();\n            var offset = data.getLayout('offset');\n            var size = data.getLayout('size');\n            var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n            pt[offsetIndex] += offset + size / 2;\n            return pt;\n        }\n        return [NaN, NaN];\n    },\n\n    defaultOption: {\n        zlevel: 0,                  // \n        z: 2,                       // \n        coordinateSystem: 'cartesian2d',\n        legendHoverLink: true,\n        // stack: null\n\n        // Cartesian coordinate system\n        // xAxisIndex: 0,\n        // yAxisIndex: 0,\n\n        // 0\n        barMinHeight: 0,\n        // 0\n        barMinAngle: 0,\n        // cursor: null,\n\n        // barMaxWidth: null,\n        // \n        // barWidth: null,\n        // 30%\n        // barGap: '30%',\n        // 20%\n        // barCategoryGap: '20%',\n        // label: {\n        //     normal: {\n        //         show: false\n        //     }\n        // },\n        itemStyle: {\n            // normal: {\n                // color: ''\n            // },\n            // emphasis: {}\n        }\n    }\n});\n\nBaseBarSeries.extend({\n\n    type: 'series.bar',\n\n    dependencies: ['grid', 'polar'],\n\n    brushSelector: 'rect'\n});\n\nfunction setLabel(\n    normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside\n) {\n    var labelModel = itemModel.getModel('label.normal');\n    var hoverLabelModel = itemModel.getModel('label.emphasis');\n\n    setLabelStyle(\n        normalStyle, hoverStyle, labelModel, hoverLabelModel,\n        {\n            labelFetcher: seriesModel,\n            labelDataIndex: dataIndex,\n            defaultText: seriesModel.getRawValue(dataIndex),\n            isRectText: true,\n            autoColor: color\n        }\n    );\n\n    fixPosition(normalStyle);\n    fixPosition(hoverStyle);\n}\n\nfunction fixPosition(style, labelPositionOutside) {\n    if (style.textPosition === 'outside') {\n        style.textPosition = labelPositionOutside;\n    }\n}\n\nvar getBarItemStyle = makeStyleMapper(\n    [\n        ['fill', 'color'],\n        ['stroke', 'borderColor'],\n        ['lineWidth', 'borderWidth'],\n        // Compatitable with 2\n        ['stroke', 'barBorderColor'],\n        ['lineWidth', 'barBorderWidth'],\n        ['opacity'],\n        ['shadowBlur'],\n        ['shadowOffsetX'],\n        ['shadowOffsetY'],\n        ['shadowColor']\n    ]\n);\n\nvar barItemStyle = {\n    getBarItemStyle: function (excludes) {\n        var style = getBarItemStyle(this, excludes);\n        if (this.getBorderLineDash) {\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n        }\n        return style;\n    }\n};\n\nvar BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth'];\n\n// FIXME\n// Just for compatible with ec2.\nextend(Model.prototype, barItemStyle);\n\nextendChartView({\n\n    type: 'bar',\n\n    render: function (seriesModel, ecModel, api) {\n        var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n        if (coordinateSystemType === 'cartesian2d'\n            || coordinateSystemType === 'polar'\n        ) {\n            this._render(seriesModel, ecModel, api);\n        }\n        else if (__DEV__) {\n            console.warn('Only cartesian2d and polar supported for bar.');\n        }\n\n        return this.group;\n    },\n\n    dispose: noop,\n\n    _render: function (seriesModel, ecModel, api) {\n        var group = this.group;\n        var data = seriesModel.getData();\n        var oldData = this._data;\n\n        var coord = seriesModel.coordinateSystem;\n        var baseAxis = coord.getBaseAxis();\n        var isHorizontalOrRadial;\n\n        if (coord.type === 'cartesian2d') {\n            isHorizontalOrRadial = baseAxis.isHorizontal();\n        }\n        else if (coord.type === 'polar') {\n            isHorizontalOrRadial = baseAxis.dim === 'angle';\n        }\n\n        var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n\n        data.diff(oldData)\n            .add(function (dataIndex) {\n                if (!data.hasValue(dataIndex)) {\n                    return;\n                }\n\n                var itemModel = data.getItemModel(dataIndex);\n                var layout = getLayout[coord.type](data, dataIndex, itemModel);\n                var el = elementCreator[coord.type](\n                    data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel\n                );\n                data.setItemGraphicEl(dataIndex, el);\n                group.add(el);\n\n                updateStyle(\n                    el, data, dataIndex, itemModel, layout,\n                    seriesModel, isHorizontalOrRadial, coord.type === 'polar'\n                );\n            })\n            .update(function (newIndex, oldIndex) {\n                var el = oldData.getItemGraphicEl(oldIndex);\n\n                if (!data.hasValue(newIndex)) {\n                    group.remove(el);\n                    return;\n                }\n\n                var itemModel = data.getItemModel(newIndex);\n                var layout = getLayout[coord.type](data, newIndex, itemModel);\n\n                if (el) {\n                    updateProps(el, {shape: layout}, animationModel, newIndex);\n                }\n                else {\n                    el = elementCreator[coord.type](\n                        data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true\n                    );\n                }\n\n                data.setItemGraphicEl(newIndex, el);\n                // Add back\n                group.add(el);\n\n                updateStyle(\n                    el, data, newIndex, itemModel, layout,\n                    seriesModel, isHorizontalOrRadial, coord.type === 'polar'\n                );\n            })\n            .remove(function (dataIndex) {\n                var el = oldData.getItemGraphicEl(dataIndex);\n                if (coord.type === 'cartesian2d') {\n                    el && removeRect(dataIndex, animationModel, el);\n                }\n                else {\n                    el && removeSector(dataIndex, animationModel, el);\n                }\n            })\n            .execute();\n\n        this._data = data;\n    },\n\n    remove: function (ecModel, api) {\n        var group = this.group;\n        var data = this._data;\n        if (ecModel.get('animation')) {\n            if (data) {\n                data.eachItemGraphicEl(function (el) {\n                    if (el.type === 'sector') {\n                        removeSector(el.dataIndex, ecModel, el);\n                    }\n                    else {\n                        removeRect(el.dataIndex, ecModel, el);\n                    }\n                });\n            }\n        }\n        else {\n            group.removeAll();\n        }\n    }\n});\n\nvar elementCreator = {\n\n    cartesian2d: function (\n        data, dataIndex, itemModel, layout, isHorizontal,\n        animationModel, isUpdate\n    ) {\n        var rect = new Rect({shape: extend({}, layout)});\n\n        // Animation\n        if (animationModel) {\n            var rectShape = rect.shape;\n            var animateProperty = isHorizontal ? 'height' : 'width';\n            var animateTarget = {};\n            rectShape[animateProperty] = 0;\n            animateTarget[animateProperty] = layout[animateProperty];\n            graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n                shape: animateTarget\n            }, animationModel, dataIndex);\n        }\n\n        return rect;\n    },\n\n    polar: function (\n        data, dataIndex, itemModel, layout, isRadial,\n        animationModel, isUpdate\n    ) {\n        var sector = new Sector({shape: extend({}, layout)});\n\n        // Animation\n        if (animationModel) {\n            var sectorShape = sector.shape;\n            var animateProperty = isRadial ? 'r' : 'endAngle';\n            var animateTarget = {};\n            sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;\n            animateTarget[animateProperty] = layout[animateProperty];\n            graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {\n                shape: animateTarget\n            }, animationModel, dataIndex);\n        }\n\n        return sector;\n    }\n};\n\nfunction removeRect(dataIndex, animationModel, el) {\n    // Not show text when animating\n    el.style.text = null;\n    updateProps(el, {\n        shape: {\n            width: 0\n        }\n    }, animationModel, dataIndex, function () {\n        el.parent && el.parent.remove(el);\n    });\n}\n\nfunction removeSector(dataIndex, animationModel, el) {\n    // Not show text when animating\n    el.style.text = null;\n    updateProps(el, {\n        shape: {\n            r: el.shape.r0\n        }\n    }, animationModel, dataIndex, function () {\n        el.parent && el.parent.remove(el);\n    });\n}\n\nvar getLayout = {\n    cartesian2d: function (data, dataIndex, itemModel) {\n        var layout = data.getItemLayout(dataIndex);\n        var fixedLineWidth = getLineWidth(itemModel, layout);\n\n        // fix layout with lineWidth\n        var signX = layout.width > 0 ? 1 : -1;\n        var signY = layout.height > 0 ? 1 : -1;\n        return {\n            x: layout.x + signX * fixedLineWidth / 2,\n            y: layout.y + signY * fixedLineWidth / 2,\n            width: layout.width - signX * fixedLineWidth,\n            height: layout.height - signY * fixedLineWidth\n        };\n    },\n\n    polar: function (data, dataIndex, itemModel) {\n        var layout = data.getItemLayout(dataIndex);\n        return {\n            cx: layout.cx,\n            cy: layout.cy,\n            r0: layout.r0,\n            r: layout.r,\n            startAngle: layout.startAngle,\n            endAngle: layout.endAngle\n        };\n    }\n};\n\nfunction updateStyle(\n    el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar\n) {\n    var color = data.getItemVisual(dataIndex, 'color');\n    var opacity = data.getItemVisual(dataIndex, 'opacity');\n    var itemStyleModel = itemModel.getModel('itemStyle.normal');\n    var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n    if (!isPolar) {\n        el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n    }\n\n    el.useStyle(defaults(\n        {\n            fill: color,\n            opacity: opacity\n        },\n        itemStyleModel.getBarItemStyle()\n    ));\n\n    var cursorStyle = itemModel.getShallow('cursor');\n    cursorStyle && el.attr('cursor', cursorStyle);\n\n    var labelPositionOutside = isHorizontal\n        ? (layout.height > 0 ? 'bottom' : 'top')\n        : (layout.width > 0 ? 'left' : 'right');\n\n    if (!isPolar) {\n        setLabel(\n            el.style, hoverStyle, itemModel, color,\n            seriesModel, dataIndex, labelPositionOutside\n        );\n    }\n\n    setHoverStyle(el, hoverStyle);\n}\n\n// In case width or height are too small.\nfunction getLineWidth(itemModel, rawLayout) {\n    var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n    return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n}\n\n// In case developer forget to include grid component\nregisterLayout(curry(barLayoutGrid, 'bar'));\n\n// Visual coding for legend\nregisterVisual(function (ecModel) {\n    ecModel.eachSeriesByType('bar', function (seriesModel) {\n        var data = seriesModel.getData();\n        data.setVisual('legendSymbol', 'roundRect');\n    });\n});\n\n/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n */\n\nvar selectableMixin = {\n\n    updateSelectedMap: function (targetList) {\n        this._targetList = targetList.slice();\n        this._selectTargetMap = reduce(targetList || [], function (targetMap, target) {\n            targetMap.set(target.name, target);\n            return targetMap;\n        }, createHashMap());\n    },\n\n    /**\n     * Either name or id should be passed as input here.\n     * If both of them are defined, id is used.\n     *\n     * @param {string|undefined} name name of data\n     * @param {number|undefined} id dataIndex of data\n     */\n    // PENGING If selectedMode is null ?\n    select: function (name, id) {\n        var target = id != null\n            ? this._targetList[id]\n            : this._selectTargetMap.get(name);\n        var selectedMode = this.get('selectedMode');\n        if (selectedMode === 'single') {\n            this._selectTargetMap.each(function (target) {\n                target.selected = false;\n            });\n        }\n        target && (target.selected = true);\n    },\n\n    /**\n     * Either name or id should be passed as input here.\n     * If both of them are defined, id is used.\n     *\n     * @param {string|undefined} name name of data\n     * @param {number|undefined} id dataIndex of data\n     */\n    unSelect: function (name, id) {\n        var target = id != null\n            ? this._targetList[id]\n            : this._selectTargetMap.get(name);\n        // var selectedMode = this.get('selectedMode');\n        // selectedMode !== 'single' && target && (target.selected = false);\n        target && (target.selected = false);\n    },\n\n    /**\n     * Either name or id should be passed as input here.\n     * If both of them are defined, id is used.\n     *\n     * @param {string|undefined} name name of data\n     * @param {number|undefined} id dataIndex of data\n     */\n    toggleSelected: function (name, id) {\n        var target = id != null\n            ? this._targetList[id]\n            : this._selectTargetMap.get(name);\n        if (target != null) {\n            this[target.selected ? 'unSelect' : 'select'](name, id);\n            return target.selected;\n        }\n    },\n\n    /**\n     * Either name or id should be passed as input here.\n     * If both of them are defined, id is used.\n     *\n     * @param {string|undefined} name name of data\n     * @param {number|undefined} id dataIndex of data\n     */\n    isSelected: function (name, id) {\n        var target = id != null\n            ? this._targetList[id]\n            : this._selectTargetMap.get(name);\n        return target && target.selected;\n    }\n};\n\nvar PieSeries = extendSeriesModel({\n\n    type: 'series.pie',\n\n    // Overwrite\n    init: function (option) {\n        PieSeries.superApply(this, 'init', arguments);\n\n        // Enable legend selection for each data item\n        // Use a function instead of direct access because data reference may changed\n        this.legendDataProvider = function () {\n            return this.getRawData();\n        };\n\n        this.updateSelectedMap(option.data);\n\n        this._defaultLabelLine(option);\n    },\n\n    // Overwrite\n    mergeOption: function (newOption) {\n        PieSeries.superCall(this, 'mergeOption', newOption);\n        this.updateSelectedMap(this.option.data);\n    },\n\n    getInitialData: function (option, ecModel) {\n        var dimensions = completeDimensions(['value'], option.data);\n        var list = new List(dimensions, this);\n        list.initData(option.data);\n        return list;\n    },\n\n    // Overwrite\n    getDataParams: function (dataIndex) {\n        var data = this.getData();\n        var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n        // FIXME toFixed?\n\n        var valueList = [];\n        data.each('value', function (value) {\n            valueList.push(value);\n        });\n\n        params.percent = getPercentWithPrecision(\n            valueList,\n            dataIndex,\n            data.hostModel.get('percentPrecision')\n        );\n\n        params.$vars.push('percent');\n        return params;\n    },\n\n    _defaultLabelLine: function (option) {\n        // Extend labelLine emphasis\n        defaultEmphasis(option.labelLine, ['show']);\n\n        var labelLineNormalOpt = option.labelLine.normal;\n        var labelLineEmphasisOpt = option.labelLine.emphasis;\n        // Not show label line if `label.normal.show = false`\n        labelLineNormalOpt.show = labelLineNormalOpt.show\n            && option.label.normal.show;\n        labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n            && option.label.emphasis.show;\n    },\n\n    defaultOption: {\n        zlevel: 0,\n        z: 2,\n        legendHoverLink: true,\n\n        hoverAnimation: true,\n        // \n        center: ['50%', '50%'],\n        radius: [0, '75%'],\n        // \n        clockwise: true,\n        startAngle: 90,\n        // 0\n        minAngle: 0,\n        // \n        selectedOffset: 10,\n        // \n        hoverOffset: 10,\n\n        // If use strategy to avoid label overlapping\n        avoidLabelOverlap: true,\n        // singlemultiple\n        // selectedMode: false,\n        // 'radius' | 'area'\n        // roseType: null,\n\n        percentPrecision: 2,\n\n        // If still show when all data zero.\n        stillShowZeroSum: true,\n\n        // cursor: null,\n\n        label: {\n            normal: {\n                // If rotate around circle\n                rotate: false,\n                show: true,\n                // 'outer', 'inside', 'center'\n                position: 'outer'\n                // formatter: Tooltip.formatter\n                // TEXTSTYLE\n                // distance: positioninnerlabel()\n            },\n            emphasis: {}\n        },\n        // Enabled when label.normal.position is 'outer'\n        labelLine: {\n            normal: {\n                show: true,\n                // \n                length: 15,\n                // \n                length2: 15,\n                smooth: false,\n                lineStyle: {\n                    // color: ,\n                    width: 1,\n                    type: 'solid'\n                }\n            }\n        },\n        itemStyle: {\n            normal: {\n                borderWidth: 1\n            },\n            emphasis: {}\n        },\n\n        // Animation type canbe expansion, scale\n        animationType: 'expansion',\n\n        animationEasing: 'cubicOut',\n\n        data: []\n    }\n});\n\nmixin(PieSeries, selectableMixin);\n\n/**\n * @param {module:echarts/model/Series} seriesModel\n * @param {boolean} hasAnimation\n * @inner\n */\nfunction updateDataSelected(uid, seriesModel, hasAnimation, api) {\n    var data = seriesModel.getData();\n    var dataIndex = this.dataIndex;\n    var name = data.getName(dataIndex);\n    var selectedOffset = seriesModel.get('selectedOffset');\n\n    api.dispatchAction({\n        type: 'pieToggleSelect',\n        from: uid,\n        name: name,\n        seriesId: seriesModel.id\n    });\n\n    data.each(function (idx) {\n        toggleItemSelected(\n            data.getItemGraphicEl(idx),\n            data.getItemLayout(idx),\n            seriesModel.isSelected(data.getName(idx)),\n            selectedOffset,\n            hasAnimation\n        );\n    });\n}\n\n/**\n * @param {module:zrender/graphic/Sector} el\n * @param {Object} layout\n * @param {boolean} isSelected\n * @param {number} selectedOffset\n * @param {boolean} hasAnimation\n * @inner\n */\nfunction toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n    var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\n    var dx = Math.cos(midAngle);\n    var dy = Math.sin(midAngle);\n\n    var offset = isSelected ? selectedOffset : 0;\n    var position = [dx * offset, dy * offset];\n\n    hasAnimation\n        // animateTo will stop revious animation like update transition\n        ? el.animate()\n            .when(200, {\n                position: position\n            })\n            .start('bounceOut')\n        : el.attr('position', position);\n}\n\n/**\n * Piece of pie including Sector, Label, LabelLine\n * @constructor\n * @extends {module:zrender/graphic/Group}\n */\nfunction PiePiece(data, idx) {\n\n    Group.call(this);\n\n    var sector = new Sector({\n        z2: 2\n    });\n    var polyline = new Polyline();\n    var text = new Text();\n    this.add(sector);\n    this.add(polyline);\n    this.add(text);\n\n    this.updateData(data, idx, true);\n\n    // Hover to change label and labelLine\n    function onEmphasis() {\n        polyline.ignore = polyline.hoverIgnore;\n        text.ignore = text.hoverIgnore;\n    }\n    function onNormal() {\n        polyline.ignore = polyline.normalIgnore;\n        text.ignore = text.normalIgnore;\n    }\n    this.on('emphasis', onEmphasis)\n        .on('normal', onNormal)\n        .on('mouseover', onEmphasis)\n        .on('mouseout', onNormal);\n}\n\nvar piePieceProto = PiePiece.prototype;\n\npiePieceProto.updateData = function (data, idx, firstCreate) {\n\n    var sector = this.childAt(0);\n\n    var seriesModel = data.hostModel;\n    var itemModel = data.getItemModel(idx);\n    var layout = data.getItemLayout(idx);\n    var sectorShape = extend({}, layout);\n    sectorShape.label = null;\n\n    if (firstCreate) {\n        sector.setShape(sectorShape);\n\n        var animationType = seriesModel.getShallow('animationType');\n        if (animationType === 'scale') {\n            sector.shape.r = layout.r0;\n            initProps(sector, {\n                shape: {\n                    r: layout.r\n                }\n            }, seriesModel, idx);\n        }\n        // Expansion\n        else {\n            sector.shape.endAngle = layout.startAngle;\n            updateProps(sector, {\n                shape: {\n                    endAngle: layout.endAngle\n                }\n            }, seriesModel, idx);\n        }\n\n    }\n    else {\n        updateProps(sector, {\n            shape: sectorShape\n        }, seriesModel, idx);\n    }\n\n    // Update common style\n    var itemStyleModel = itemModel.getModel('itemStyle');\n    var visualColor = data.getItemVisual(idx, 'color');\n\n    sector.useStyle(\n        defaults(\n            {\n                lineJoin: 'bevel',\n                fill: visualColor\n            },\n            itemStyleModel.getModel('normal').getItemStyle()\n        )\n    );\n    sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\n    var cursorStyle = itemModel.getShallow('cursor');\n    cursorStyle && sector.attr('cursor', cursorStyle);\n\n    // Toggle selected\n    toggleItemSelected(\n        this,\n        data.getItemLayout(idx),\n        itemModel.get('selected'),\n        seriesModel.get('selectedOffset'),\n        seriesModel.get('animation')\n    );\n\n    function onEmphasis() {\n        // Sector may has animation of updating data. Force to move to the last frame\n        // Or it may stopped on the wrong shape\n        sector.stopAnimation(true);\n        sector.animateTo({\n            shape: {\n                r: layout.r + seriesModel.get('hoverOffset')\n            }\n        }, 300, 'elasticOut');\n    }\n    function onNormal() {\n        sector.stopAnimation(true);\n        sector.animateTo({\n            shape: {\n                r: layout.r\n            }\n        }, 300, 'elasticOut');\n    }\n    sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n    if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n        sector\n            .on('mouseover', onEmphasis)\n            .on('mouseout', onNormal)\n            .on('emphasis', onEmphasis)\n            .on('normal', onNormal);\n    }\n\n    this._updateLabel(data, idx);\n\n    setHoverStyle(this);\n};\n\npiePieceProto._updateLabel = function (data, idx) {\n\n    var labelLine = this.childAt(1);\n    var labelText = this.childAt(2);\n\n    var seriesModel = data.hostModel;\n    var itemModel = data.getItemModel(idx);\n    var layout = data.getItemLayout(idx);\n    var labelLayout = layout.label;\n    var visualColor = data.getItemVisual(idx, 'color');\n\n    updateProps(labelLine, {\n        shape: {\n            points: labelLayout.linePoints || [\n                [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]\n            ]\n        }\n    }, seriesModel, idx);\n\n    updateProps(labelText, {\n        style: {\n            x: labelLayout.x,\n            y: labelLayout.y\n        }\n    }, seriesModel, idx);\n    labelText.attr({\n        rotation: labelLayout.rotation,\n        origin: [labelLayout.x, labelLayout.y],\n        z2: 10\n    });\n\n    var labelModel = itemModel.getModel('label.normal');\n    var labelHoverModel = itemModel.getModel('label.emphasis');\n    var labelLineModel = itemModel.getModel('labelLine.normal');\n    var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n    var visualColor = data.getItemVisual(idx, 'color');\n\n    setLabelStyle(\n        labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel,\n        {\n            labelFetcher: data.hostModel,\n            labelDataIndex: idx,\n            defaultText: data.getName(idx),\n            autoColor: visualColor,\n            useInsideStyle: !!labelLayout.inside\n        },\n        {\n            textAlign: labelLayout.textAlign,\n            textVerticalAlign: labelLayout.verticalAlign,\n            opacity: data.getItemVisual(idx, 'opacity')\n        }\n    );\n\n    labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n    labelText.hoverIgnore = !labelHoverModel.get('show');\n\n    labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n    labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\n    // Default use item visual color\n    labelLine.setStyle({\n        stroke: visualColor,\n        opacity: data.getItemVisual(idx, 'opacity')\n    });\n    labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\n    labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\n    var smooth = labelLineModel.get('smooth');\n    if (smooth && smooth === true) {\n        smooth = 0.4;\n    }\n    labelLine.setShape({\n        smooth: smooth\n    });\n};\n\ninherits(PiePiece, Group);\n\n\n// Pie view\nvar PieView = Chart.extend({\n\n    type: 'pie',\n\n    init: function () {\n        var sectorGroup = new Group();\n        this._sectorGroup = sectorGroup;\n    },\n\n    render: function (seriesModel, ecModel, api, payload) {\n        if (payload && (payload.from === this.uid)) {\n            return;\n        }\n\n        var data = seriesModel.getData();\n        var oldData = this._data;\n        var group = this.group;\n\n        var hasAnimation = ecModel.get('animation');\n        var isFirstRender = !oldData;\n        var animationType = seriesModel.get('animationType');\n\n        var onSectorClick = curry(\n            updateDataSelected, this.uid, seriesModel, hasAnimation, api\n        );\n\n        var selectedMode = seriesModel.get('selectedMode');\n\n        data.diff(oldData)\n            .add(function (idx) {\n                var piePiece = new PiePiece(data, idx);\n                // Default expansion animation\n                if (isFirstRender && animationType !== 'scale') {\n                    piePiece.eachChild(function (child) {\n                        child.stopAnimation(true);\n                    });\n                }\n\n                selectedMode && piePiece.on('click', onSectorClick);\n\n                data.setItemGraphicEl(idx, piePiece);\n\n                group.add(piePiece);\n            })\n            .update(function (newIdx, oldIdx) {\n                var piePiece = oldData.getItemGraphicEl(oldIdx);\n\n                piePiece.updateData(data, newIdx);\n\n                piePiece.off('click');\n                selectedMode && piePiece.on('click', onSectorClick);\n                group.add(piePiece);\n                data.setItemGraphicEl(newIdx, piePiece);\n            })\n            .remove(function (idx) {\n                var piePiece = oldData.getItemGraphicEl(idx);\n                group.remove(piePiece);\n            })\n            .execute();\n\n        if (\n            hasAnimation && isFirstRender && data.count() > 0\n            // Default expansion animation\n            && animationType !== 'scale'\n        ) {\n            var shape = data.getItemLayout(0);\n            var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\n            var removeClipPath = bind(group.removeClipPath, group);\n            group.setClipPath(this._createClipPath(\n                shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel\n            ));\n        }\n\n        this._data = data;\n    },\n\n    dispose: function () {},\n\n    _createClipPath: function (\n        cx, cy, r, startAngle, clockwise, cb, seriesModel\n    ) {\n        var clipPath = new Sector({\n            shape: {\n                cx: cx,\n                cy: cy,\n                r0: 0,\n                r: r,\n                startAngle: startAngle,\n                endAngle: startAngle,\n                clockwise: clockwise\n            }\n        });\n\n        initProps(clipPath, {\n            shape: {\n                endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n            }\n        }, seriesModel, cb);\n\n        return clipPath;\n    },\n\n    /**\n     * @implement\n     */\n    containPoint: function (point, seriesModel) {\n        var data = seriesModel.getData();\n        var itemLayout = data.getItemLayout(0);\n        if (itemLayout) {\n            var dx = point[0] - itemLayout.cx;\n            var dy = point[1] - itemLayout.cy;\n            var radius = Math.sqrt(dx * dx + dy * dy);\n            return radius <= itemLayout.r && radius >= itemLayout.r0;\n        }\n    }\n\n});\n\nvar createDataSelectAction = function (seriesType, actionInfos) {\n    each$1(actionInfos, function (actionInfo) {\n        actionInfo.update = 'updateView';\n        /**\n         * @payload\n         * @property {string} seriesName\n         * @property {string} name\n         */\n        registerAction(actionInfo, function (payload, ecModel) {\n            var selected = {};\n            ecModel.eachComponent(\n                {mainType: 'series', subType: seriesType, query: payload},\n                function (seriesModel) {\n                    if (seriesModel[actionInfo.method]) {\n                        seriesModel[actionInfo.method](\n                            payload.name,\n                            payload.dataIndex\n                        );\n                    }\n                    var data = seriesModel.getData();\n                    // Create selected map\n                    data.each(function (idx) {\n                        var name = data.getName(idx);\n                        selected[name] = seriesModel.isSelected(name)\n                            || false;\n                    });\n                }\n            );\n            return {\n                name: payload.name,\n                selected: selected\n            };\n        });\n    });\n};\n\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\n\nvar dataColor = function (seriesType, ecModel) {\n    // Pie and funnel may use diferrent scope\n    var paletteScope = {};\n    ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n        var dataAll = seriesModel.getRawData();\n        var idxMap = {};\n        if (!ecModel.isSeriesFiltered(seriesModel)) {\n            var data = seriesModel.getData();\n            data.each(function (idx) {\n                var rawIdx = data.getRawIndex(idx);\n                idxMap[rawIdx] = idx;\n            });\n            dataAll.each(function (rawIdx) {\n                var filteredIdx = idxMap[rawIdx];\n\n                // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n                var singleDataColor = filteredIdx != null\n                    && data.getItemVisual(filteredIdx, 'color', true);\n\n                if (!singleDataColor) {\n                    // FIXME Performance\n                    var itemModel = dataAll.getItemModel(rawIdx);\n                    var color = itemModel.get('itemStyle.normal.color')\n                        || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n                    // Legend may use the visual info in data before processed\n                    dataAll.setItemVisual(rawIdx, 'color', color);\n\n                    // Data is not filtered\n                    if (filteredIdx != null) {\n                        data.setItemVisual(filteredIdx, 'color', color);\n                    }\n                }\n                else {\n                    // Set data all color for legend\n                    dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n                }\n            });\n        }\n    });\n};\n\n// FIXME emphasis label position is not same with normal label position\n\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n    list.sort(function (a, b) {\n        return a.y - b.y;\n    });\n\n    // \n    function shiftDown(start, end, delta, dir) {\n        for (var j = start; j < end; j++) {\n            list[j].y += delta;\n            if (j > start\n                && j + 1 < end\n                && list[j + 1].y > list[j].y + list[j].height\n            ) {\n                shiftUp(j, delta / 2);\n                return;\n            }\n        }\n\n        shiftUp(end - 1, delta / 2);\n    }\n\n    // \n    function shiftUp(end, delta) {\n        for (var j = end; j >= 0; j--) {\n            list[j].y -= delta;\n            if (j > 0\n                && list[j].y > list[j - 1].y + list[j - 1].height\n            ) {\n                break;\n            }\n        }\n    }\n\n    function changeX(list, isDownList, cx, cy, r, dir) {\n        var lastDeltaX = dir > 0\n            ? isDownList                // \n                ? Number.MAX_VALUE      // \n                : 0                     // \n            : isDownList                // \n                ? Number.MAX_VALUE      // \n                : 0;                    // \n\n        for (var i = 0, l = list.length; i < l; i++) {\n            // Not change x for center label\n            if (list[i].position === 'center') {\n                continue;\n            }\n            var deltaY = Math.abs(list[i].y - cy);\n            var length = list[i].len;\n            var length2 = list[i].len2;\n            var deltaX = (deltaY < r + length)\n                ? Math.sqrt(\n                        (r + length + length2) * (r + length + length2)\n                        - deltaY * deltaY\n                    )\n                : Math.abs(list[i].x - cx);\n            if (isDownList && deltaX >= lastDeltaX) {\n                // \n                deltaX = lastDeltaX - 10;\n            }\n            if (!isDownList && deltaX <= lastDeltaX) {\n                // \n                deltaX = lastDeltaX + 10;\n            }\n\n            list[i].x = cx + deltaX * dir;\n            lastDeltaX = deltaX;\n        }\n    }\n\n    var lastY = 0;\n    var delta;\n    var len = list.length;\n    var upList = [];\n    var downList = [];\n    for (var i = 0; i < len; i++) {\n        delta = list[i].y - lastY;\n        if (delta < 0) {\n            shiftDown(i, len, -delta, dir);\n        }\n        lastY = list[i].y + list[i].height;\n    }\n    if (viewHeight - lastY < 0) {\n        shiftUp(len - 1, lastY - viewHeight);\n    }\n    for (var i = 0; i < len; i++) {\n        if (list[i].y >= cy) {\n            downList.push(list[i]);\n        }\n        else {\n            upList.push(list[i]);\n        }\n    }\n    changeX(upList, false, cx, cy, r, dir);\n    changeX(downList, true, cx, cy, r, dir);\n}\n\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n    var leftList = [];\n    var rightList = [];\n    for (var i = 0; i < labelLayoutList.length; i++) {\n        if (labelLayoutList[i].x < cx) {\n            leftList.push(labelLayoutList[i]);\n        }\n        else {\n            rightList.push(labelLayoutList[i]);\n        }\n    }\n\n    adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n    adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n    for (var i = 0; i < labelLayoutList.length; i++) {\n        var linePoints = labelLayoutList[i].linePoints;\n        if (linePoints) {\n            var dist = linePoints[1][0] - linePoints[2][0];\n            if (labelLayoutList[i].x < cx) {\n                linePoints[2][0] = labelLayoutList[i].x + 3;\n            }\n            else {\n                linePoints[2][0] = labelLayoutList[i].x - 3;\n            }\n            linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n            linePoints[1][0] = linePoints[2][0] + dist;\n        }\n    }\n}\n\nvar labelLayout = function (seriesModel, r, viewWidth, viewHeight) {\n    var data = seriesModel.getData();\n    var labelLayoutList = [];\n    var cx;\n    var cy;\n    var hasLabelRotate = false;\n\n    data.each(function (idx) {\n        var layout = data.getItemLayout(idx);\n\n        var itemModel = data.getItemModel(idx);\n        var labelModel = itemModel.getModel('label.normal');\n        // Use position in normal or emphasis\n        var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineLen = labelLineModel.get('length');\n        var labelLineLen2 = labelLineModel.get('length2');\n\n        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n        var dx = Math.cos(midAngle);\n        var dy = Math.sin(midAngle);\n\n        var textX;\n        var textY;\n        var linePoints;\n        var textAlign;\n\n        cx = layout.cx;\n        cy = layout.cy;\n\n        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n        if (labelPosition === 'center') {\n            textX = layout.cx;\n            textY = layout.cy;\n            textAlign = 'center';\n        }\n        else {\n            var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n            var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\n            textX = x1 + dx * 3;\n            textY = y1 + dy * 3;\n\n            if (!isLabelInside) {\n                // For roseType\n                var x2 = x1 + dx * (labelLineLen + r - layout.r);\n                var y2 = y1 + dy * (labelLineLen + r - layout.r);\n                var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);\n                var y3 = y2;\n\n                textX = x3 + (dx < 0 ? -5 : 5);\n                textY = y3;\n                linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n            }\n\n            textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');\n        }\n        var font = labelModel.getFont();\n\n        var labelRotate = labelModel.get('rotate')\n            ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;\n        var text = seriesModel.getFormattedLabel(idx, 'normal')\n                    || data.getName(idx);\n        var textRect = getBoundingRect(\n            text, font, textAlign, 'top'\n        );\n        hasLabelRotate = !!labelRotate;\n        layout.label = {\n            x: textX,\n            y: textY,\n            position: labelPosition,\n            height: textRect.height,\n            len: labelLineLen,\n            len2: labelLineLen2,\n            linePoints: linePoints,\n            textAlign: textAlign,\n            verticalAlign: 'middle',\n            rotation: labelRotate,\n            inside: isLabelInside\n        };\n\n        // Not layout the inside label\n        if (!isLabelInside) {\n            labelLayoutList.push(layout.label);\n        }\n    });\n    if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n        avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n    }\n};\n\nvar PI2$4 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\n\nvar pieLayout = function (seriesType, ecModel, api, payload) {\n    ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        var center = seriesModel.get('center');\n        var radius = seriesModel.get('radius');\n\n        if (!isArray(radius)) {\n            radius = [0, radius];\n        }\n        if (!isArray(center)) {\n            center = [center, center];\n        }\n\n        var width = api.getWidth();\n        var height = api.getHeight();\n        var size = Math.min(width, height);\n        var cx = parsePercent$1(center[0], width);\n        var cy = parsePercent$1(center[1], height);\n        var r0 = parsePercent$1(radius[0], size / 2);\n        var r = parsePercent$1(radius[1], size / 2);\n\n        var data = seriesModel.getData();\n\n        var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\n        var minAngle = seriesModel.get('minAngle') * RADIAN;\n\n        var validDataCount = 0;\n        data.each('value', function (value) {\n            !isNaN(value) && validDataCount++;\n        });\n\n        var sum = data.getSum('value');\n        // Sum may be 0\n        var unitRadian = Math.PI / (sum || validDataCount) * 2;\n\n        var clockwise = seriesModel.get('clockwise');\n\n        var roseType = seriesModel.get('roseType');\n        var stillShowZeroSum = seriesModel.get('stillShowZeroSum');\n\n        // [0...max]\n        var extent = data.getDataExtent('value');\n        extent[0] = 0;\n\n        // In the case some sector angle is smaller than minAngle\n        var restAngle = PI2$4;\n        var valueSumLargerThanMinAngle = 0;\n\n        var currentAngle = startAngle;\n        var dir = clockwise ? 1 : -1;\n\n        data.each('value', function (value, idx) {\n            var angle;\n            if (isNaN(value)) {\n                data.setItemLayout(idx, {\n                    angle: NaN,\n                    startAngle: NaN,\n                    endAngle: NaN,\n                    clockwise: clockwise,\n                    cx: cx,\n                    cy: cy,\n                    r0: r0,\n                    r: roseType\n                        ? NaN\n                        : r\n                });\n                return;\n            }\n\n            // FIXME  2.0  roseType  area \n            if (roseType !== 'area') {\n                angle = (sum === 0 && stillShowZeroSum)\n                    ? unitRadian : (value * unitRadian);\n            }\n            else {\n                angle = PI2$4 / validDataCount;\n            }\n\n            if (angle < minAngle) {\n                angle = minAngle;\n                restAngle -= minAngle;\n            }\n            else {\n                valueSumLargerThanMinAngle += value;\n            }\n\n            var endAngle = currentAngle + dir * angle;\n            data.setItemLayout(idx, {\n                angle: angle,\n                startAngle: currentAngle,\n                endAngle: endAngle,\n                clockwise: clockwise,\n                cx: cx,\n                cy: cy,\n                r0: r0,\n                r: roseType\n                    ? linearMap(value, extent, [r0, r])\n                    : r\n            });\n\n            currentAngle = endAngle;\n        }, true);\n\n        // Some sector is constrained by minAngle\n        // Rest sectors needs recalculate angle\n        if (restAngle < PI2$4 && validDataCount) {\n            // Average the angle if rest angle is not enough after all angles is\n            // Constrained by minAngle\n            if (restAngle <= 1e-3) {\n                var angle = PI2$4 / validDataCount;\n                data.each('value', function (value, idx) {\n                    if (!isNaN(value)) {\n                        var layout = data.getItemLayout(idx);\n                        layout.angle = angle;\n                        layout.startAngle = startAngle + dir * idx * angle;\n                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n                    }\n                });\n            }\n            else {\n                unitRadian = restAngle / valueSumLargerThanMinAngle;\n                currentAngle = startAngle;\n                data.each('value', function (value, idx) {\n                    if (!isNaN(value)) {\n                        var layout = data.getItemLayout(idx);\n                        var angle = layout.angle === minAngle\n                            ? minAngle : value * unitRadian;\n                        layout.startAngle = currentAngle;\n                        layout.endAngle = currentAngle + dir * angle;\n                        currentAngle += dir * angle;\n                    }\n                });\n            }\n        }\n\n        labelLayout(seriesModel, r, width, height);\n    });\n};\n\nvar dataFilter = function (seriesType, ecModel) {\n    var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n    });\n    if (!legendModels || !legendModels.length) {\n        return;\n    }\n    ecModel.eachSeriesByType(seriesType, function (series) {\n        var data = series.getData();\n        data.filterSelf(function (idx) {\n            var name = data.getName(idx);\n            // If in any legend component the status is not selected.\n            for (var i = 0; i < legendModels.length; i++) {\n                if (!legendModels[i].isSelected(name)) {\n                    return false;\n                }\n            }\n            return true;\n        }, this);\n    }, this);\n};\n\ncreateDataSelectAction('pie', [{\n    type: 'pieToggleSelect',\n    event: 'pieselectchanged',\n    method: 'toggleSelected'\n}, {\n    type: 'pieSelect',\n    event: 'pieselected',\n    method: 'select'\n}, {\n    type: 'pieUnSelect',\n    event: 'pieunselected',\n    method: 'unSelect'\n}]);\n\nregisterVisual(curry(dataColor, 'pie'));\nregisterLayout(curry(pieLayout, 'pie'));\nregisterProcessor(curry(dataFilter, 'pie'));\n\nSeriesModel.extend({\n\n    type: 'series.scatter',\n\n    dependencies: ['grid', 'polar', 'geo', 'singleAxis', 'calendar'],\n\n    getInitialData: function (option, ecModel) {\n        return createListFromArray(option.data, this, ecModel);\n    },\n\n    brushSelector: 'point',\n\n    defaultOption: {\n        coordinateSystem: 'cartesian2d',\n        zlevel: 0,\n        z: 2,\n        legendHoverLink: true,\n\n        hoverAnimation: true,\n        // Cartesian coordinate system\n        // xAxisIndex: 0,\n        // yAxisIndex: 0,\n\n        // Polar coordinate system\n        // polarIndex: 0,\n\n        // Geo coordinate system\n        // geoIndex: 0,\n\n        // symbol: null,        // \n        symbolSize: 10,          // symbolSize * 2\n        // symbolRotate: null,  // \n\n        large: false,\n        // Available when large is true\n        largeThreshold: 2000,\n        // cursor: null,\n\n        // label: {\n            // normal: {\n                // show: false\n                // distance: 5,\n                // formatter: Tooltip.formatter\n                // position: 'top''right'\n                //           'inside'|'left'|'right'|'top'|'bottom'\n                // TEXTSTYLE\n        //     }\n        // },\n        itemStyle: {\n            normal: {\n                opacity: 0.8\n                // color: \n            }\n        }\n    }\n\n});\n\n// TODO Batch by color\n\nvar LargeSymbolPath = extendShape({\n\n    shape: {\n        points: null,\n        sizes: null\n    },\n\n    symbolProxy: null,\n\n    buildPath: function (path, shape) {\n        var points = shape.points;\n        var sizes = shape.sizes;\n\n        var symbolProxy = this.symbolProxy;\n        var symbolProxyShape = symbolProxy.shape;\n        for (var i = 0; i < points.length; i++) {\n            var pt = points[i];\n\n            if (isNaN(pt[0]) || isNaN(pt[1])) {\n                continue;\n            }\n\n            var size = sizes[i];\n            if (size[0] < 4) {\n                // Optimize for small symbol\n                path.rect(\n                    pt[0] - size[0] / 2, pt[1] - size[1] / 2,\n                    size[0], size[1]\n                );\n            }\n            else {\n                symbolProxyShape.x = pt[0] - size[0] / 2;\n                symbolProxyShape.y = pt[1] - size[1] / 2;\n                symbolProxyShape.width = size[0];\n                symbolProxyShape.height = size[1];\n\n                symbolProxy.buildPath(path, symbolProxyShape, true);\n            }\n        }\n    },\n\n    findDataIndex: function (x, y) {\n        var shape = this.shape;\n        var points = shape.points;\n        var sizes = shape.sizes;\n\n        // Not consider transform\n        // Treat each element as a rect\n        // top down traverse\n        for (var i = points.length - 1; i >= 0; i--) {\n            var pt = points[i];\n            var size = sizes[i];\n            var x0 = pt[0] - size[0] / 2;\n            var y0 = pt[1] - size[1] / 2;\n            if (x >= x0 && y >= y0 && x <= x0 + size[0] && y <= y0 + size[1]) {\n                // i is dataIndex\n                return i;\n            }\n        }\n\n        return -1;\n    }\n});\n\nfunction LargeSymbolDraw() {\n    this.group = new Group();\n\n    this._symbolEl = new LargeSymbolPath({\n        // rectHover: true,\n        // cursor: 'default'\n    });\n}\n\nvar largeSymbolProto = LargeSymbolDraw.prototype;\n\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n */\nlargeSymbolProto.updateData = function (data) {\n    this.group.removeAll();\n\n    var symbolEl = this._symbolEl;\n\n    var seriesModel = data.hostModel;\n\n    symbolEl.setShape({\n        points: data.mapArray(data.getItemLayout),\n        sizes: data.mapArray(\n            function (idx) {\n                var size = data.getItemVisual(idx, 'symbolSize');\n                if (!(size instanceof Array)) {\n                    size = [size, size];\n                }\n                return size;\n            }\n        )\n    });\n\n    // Create symbolProxy to build path for each data\n    symbolEl.symbolProxy = createSymbol(\n        data.getVisual('symbol'), 0, 0, 0, 0\n    );\n    // Use symbolProxy setColor method\n    symbolEl.setColor = symbolEl.symbolProxy.setColor;\n\n    symbolEl.useStyle(\n        seriesModel.getModel('itemStyle.normal').getItemStyle(['color'])\n    );\n\n    var visualColor = data.getVisual('color');\n    if (visualColor) {\n        symbolEl.setColor(visualColor);\n    }\n\n    // Enable tooltip\n    // PENDING May have performance issue when path is extremely large\n    symbolEl.seriesIndex = seriesModel.seriesIndex;\n    symbolEl.on('mousemove', function (e) {\n        symbolEl.dataIndex = null;\n        var dataIndex = symbolEl.findDataIndex(e.offsetX, e.offsetY);\n        if (dataIndex >= 0) {\n            // Provide dataIndex for tooltip\n            symbolEl.dataIndex = dataIndex;\n        }\n    });\n\n    // Add back\n    this.group.add(symbolEl);\n};\n\nlargeSymbolProto.updateLayout = function (seriesModel) {\n    var data = seriesModel.getData();\n    this._symbolEl.setShape({\n        points: data.mapArray(data.getItemLayout)\n    });\n};\n\nlargeSymbolProto.remove = function () {\n    this.group.removeAll();\n};\n\nextendChartView({\n\n    type: 'scatter',\n\n    init: function () {\n        this._normalSymbolDraw = new SymbolDraw();\n        this._largeSymbolDraw = new LargeSymbolDraw();\n    },\n\n    render: function (seriesModel, ecModel, api) {\n        var data = seriesModel.getData();\n        var largeSymbolDraw = this._largeSymbolDraw;\n        var normalSymbolDraw = this._normalSymbolDraw;\n        var group = this.group;\n\n        var symbolDraw = seriesModel.get('large') && data.count() > seriesModel.get('largeThreshold')\n            ? largeSymbolDraw : normalSymbolDraw;\n\n        this._symbolDraw = symbolDraw;\n        symbolDraw.updateData(data);\n        group.add(symbolDraw.group);\n\n        group.remove(\n            symbolDraw === largeSymbolDraw\n            ? normalSymbolDraw.group : largeSymbolDraw.group\n        );\n    },\n\n    updateLayout: function (seriesModel) {\n        this._symbolDraw.updateLayout(seriesModel);\n    },\n\n    remove: function (ecModel, api) {\n        this._symbolDraw && this._symbolDraw.remove(api, true);\n    },\n\n    dispose: function () {}\n});\n\n// In case developer forget to include grid component\nregisterVisual(curry(visualSymbol, 'scatter', 'circle', null));\nregisterLayout(curry(layoutPoints, 'scatter'));\n\nfunction IndicatorAxis(dim, scale, radiusExtent) {\n    Axis.call(this, dim, scale, radiusExtent);\n\n    /**\n     * Axis type\n     *  - 'category'\n     *  - 'value'\n     *  - 'time'\n     *  - 'log'\n     * @type {string}\n     */\n    this.type = 'value';\n\n    this.angle = 0;\n\n    /**\n     * Indicator name\n     * @type {string}\n     */\n    this.name = '';\n    /**\n     * @type {module:echarts/model/Model}\n     */\n    this.model;\n}\n\ninherits(IndicatorAxis, Axis);\n\n// TODO clockwise\n\nfunction Radar(radarModel, ecModel, api) {\n\n    this._model = radarModel;\n    /**\n     * Radar dimensions\n     * @type {Array.<string>}\n     */\n    this.dimensions = [];\n\n    this._indicatorAxes = map(radarModel.getIndicatorModels(), function (indicatorModel, idx) {\n        var dim = 'indicator_' + idx;\n        var indicatorAxis = new IndicatorAxis(dim, new IntervalScale());\n        indicatorAxis.name = indicatorModel.get('name');\n        // Inject model and axis\n        indicatorAxis.model = indicatorModel;\n        indicatorModel.axis = indicatorAxis;\n        this.dimensions.push(dim);\n        return indicatorAxis;\n    }, this);\n\n    this.resize(radarModel, api);\n\n    /**\n     * @type {number}\n     * @readOnly\n     */\n    this.cx;\n    /**\n     * @type {number}\n     * @readOnly\n     */\n    this.cy;\n    /**\n     * @type {number}\n     * @readOnly\n     */\n    this.r;\n    /**\n     * @type {number}\n     * @readOnly\n     */\n    this.startAngle;\n}\n\nRadar.prototype.getIndicatorAxes = function () {\n    return this._indicatorAxes;\n};\n\nRadar.prototype.dataToPoint = function (value, indicatorIndex) {\n    var indicatorAxis = this._indicatorAxes[indicatorIndex];\n\n    return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);\n};\n\nRadar.prototype.coordToPoint = function (coord, indicatorIndex) {\n    var indicatorAxis = this._indicatorAxes[indicatorIndex];\n    var angle = indicatorAxis.angle;\n    var x = this.cx + coord * Math.cos(angle);\n    var y = this.cy - coord * Math.sin(angle);\n    return [x, y];\n};\n\nRadar.prototype.pointToData = function (pt) {\n    var dx = pt[0] - this.cx;\n    var dy = pt[1] - this.cy;\n    var radius = Math.sqrt(dx * dx + dy * dy);\n    dx /= radius;\n    dy /= radius;\n\n    var radian = Math.atan2(-dy, dx);\n\n    // Find the closest angle\n    // FIXME index can calculated directly\n    var minRadianDiff = Infinity;\n    var closestAxis;\n    var closestAxisIdx = -1;\n    for (var i = 0; i < this._indicatorAxes.length; i++) {\n        var indicatorAxis = this._indicatorAxes[i];\n        var diff = Math.abs(radian - indicatorAxis.angle);\n        if (diff < minRadianDiff) {\n            closestAxis = indicatorAxis;\n            closestAxisIdx = i;\n            minRadianDiff = diff;\n        }\n    }\n\n    return [closestAxisIdx, +(closestAxis && closestAxis.coodToData(radius))];\n};\n\nRadar.prototype.resize = function (radarModel, api) {\n    var center = radarModel.get('center');\n    var viewWidth = api.getWidth();\n    var viewHeight = api.getHeight();\n    var viewSize = Math.min(viewWidth, viewHeight) / 2;\n    this.cx = parsePercent$1(center[0], viewWidth);\n    this.cy = parsePercent$1(center[1], viewHeight);\n\n    this.startAngle = radarModel.get('startAngle') * Math.PI / 180;\n\n    this.r = parsePercent$1(radarModel.get('radius'), viewSize);\n\n    each$1(this._indicatorAxes, function (indicatorAxis, idx) {\n        indicatorAxis.setExtent(0, this.r);\n        var angle = (this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length);\n        // Normalize to [-PI, PI]\n        angle = Math.atan2(Math.sin(angle), Math.cos(angle));\n        indicatorAxis.angle = angle;\n    }, this);\n};\n\nRadar.prototype.update = function (ecModel, api) {\n    var indicatorAxes = this._indicatorAxes;\n    var radarModel = this._model;\n    each$1(indicatorAxes, function (indicatorAxis) {\n        indicatorAxis.scale.setExtent(Infinity, -Infinity);\n    });\n    ecModel.eachSeriesByType('radar', function (radarSeries, idx) {\n        if (radarSeries.get('coordinateSystem') !== 'radar'\n            || ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel\n        ) {\n            return;\n        }\n        var data = radarSeries.getData();\n        each$1(indicatorAxes, function (indicatorAxis) {\n            indicatorAxis.scale.unionExtentFromData(data, indicatorAxis.dim);\n        });\n    }, this);\n\n    var splitNumber = radarModel.get('splitNumber');\n\n    function increaseInterval(interval) {\n        var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10));\n        // Increase interval\n        var f = interval / exp10;\n        if (f === 2) {\n            f = 5;\n        }\n        else { // f is 2 or 5\n            f *= 2;\n        }\n        return f * exp10;\n    }\n    // Force all the axis fixing the maxSplitNumber.\n    each$1(indicatorAxes, function (indicatorAxis, idx) {\n        var rawExtent = getScaleExtent(indicatorAxis.scale, indicatorAxis.model);\n        niceScaleExtent(indicatorAxis.scale, indicatorAxis.model);\n\n        var axisModel = indicatorAxis.model;\n        var scale = indicatorAxis.scale;\n        var fixedMin = axisModel.getMin();\n        var fixedMax = axisModel.getMax();\n        var interval = scale.getInterval();\n\n        if (fixedMin != null && fixedMax != null) {\n            // User set min, max, divide to get new interval\n            scale.setExtent(+fixedMin, +fixedMax);\n            scale.setInterval(\n                (fixedMax - fixedMin) / splitNumber\n            );\n        }\n        else if (fixedMin != null) {\n            var max;\n            // User set min, expand extent on the other side\n            do {\n                max = fixedMin + interval * splitNumber;\n                scale.setExtent(+fixedMin, max);\n                // Interval must been set after extent\n                // FIXME\n                scale.setInterval(interval);\n\n                interval = increaseInterval(interval);\n            } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));\n        }\n        else if (fixedMax != null) {\n            var min;\n            // User set min, expand extent on the other side\n            do {\n                min = fixedMax - interval * splitNumber;\n                scale.setExtent(min, +fixedMax);\n                scale.setInterval(interval);\n                interval = increaseInterval(interval);\n            } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));\n        }\n        else {\n            var nicedSplitNumber = scale.getTicks().length - 1;\n            if (nicedSplitNumber > splitNumber) {\n                interval = increaseInterval(interval);\n            }\n            // PENDING\n            var center = Math.round((rawExtent[0] + rawExtent[1]) / 2 / interval) * interval;\n            var halfSplitNumber = Math.round(splitNumber / 2);\n            scale.setExtent(\n                round(center - halfSplitNumber * interval),\n                round(center + (splitNumber - halfSplitNumber) * interval)\n            );\n            scale.setInterval(interval);\n        }\n    });\n};\n\n/**\n * Radar dimensions is based on the data\n * @type {Array}\n */\nRadar.dimensions = [];\n\nRadar.create = function (ecModel, api) {\n    var radarList = [];\n    ecModel.eachComponent('radar', function (radarModel) {\n        var radar = new Radar(radarModel, ecModel, api);\n        radarList.push(radar);\n        radarModel.coordinateSystem = radar;\n    });\n    ecModel.eachSeriesByType('radar', function (radarSeries) {\n        if (radarSeries.get('coordinateSystem') === 'radar') {\n            // Inject coordinate system\n            radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0];\n        }\n    });\n    return radarList;\n};\n\nCoordinateSystemManager.register('radar', Radar);\n\nvar valueAxisDefault = axisDefault.valueAxis;\n\nfunction defaultsShow(opt, show) {\n    return defaults({\n        show: show\n    }, opt);\n}\n\nvar RadarModel = extendComponentModel({\n\n    type: 'radar',\n\n    optionUpdated: function () {\n        var boundaryGap = this.get('boundaryGap');\n        var splitNumber = this.get('splitNumber');\n        var scale = this.get('scale');\n        var axisLine = this.get('axisLine');\n        var axisTick = this.get('axisTick');\n        var axisLabel = this.get('axisLabel');\n        var nameTextStyle = this.get('name');\n        var showName = this.get('name.show');\n        var nameFormatter = this.get('name.formatter');\n        var nameGap = this.get('nameGap');\n        var triggerEvent = this.get('triggerEvent');\n\n        var indicatorModels = map(this.get('indicator') || [], function (indicatorOpt) {\n            // PENDING\n            if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {\n                indicatorOpt.min = 0;\n            }\n            else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {\n                indicatorOpt.max = 0;\n            }\n            var iNameTextStyle = nameTextStyle;\n            if(indicatorOpt.color != null) {\n                iNameTextStyle = defaults({color: indicatorOpt.color}, nameTextStyle);\n            }\n            // Use same configuration\n            indicatorOpt = merge(clone(indicatorOpt), {\n                boundaryGap: boundaryGap,\n                splitNumber: splitNumber,\n                scale: scale,\n                axisLine: axisLine,\n                axisTick: axisTick,\n                axisLabel: axisLabel,\n                // Competitable with 2 and use text\n                name: indicatorOpt.text,\n                nameLocation: 'end',\n                nameGap: nameGap,\n                // min: 0,\n                nameTextStyle: iNameTextStyle,\n                triggerEvent: triggerEvent\n            }, false);\n            if (!showName) {\n                indicatorOpt.name = '';\n            }\n            if (typeof nameFormatter === 'string') {\n                var indName = indicatorOpt.name;\n                indicatorOpt.name = nameFormatter.replace('{value}', indName != null ? indName : '');\n            }\n            else if (typeof nameFormatter === 'function') {\n                indicatorOpt.name = nameFormatter(\n                    indicatorOpt.name, indicatorOpt\n                );\n            }\n            var model = extend(\n                new Model(indicatorOpt, null, this.ecModel),\n                axisModelCommonMixin\n            );\n\n            // For triggerEvent.\n            model.mainType = 'radar';\n            model.componentIndex = this.componentIndex;\n\n            return model;\n        }, this);\n\n        this.getIndicatorModels = function () {\n            return indicatorModels;\n        };\n    },\n\n    defaultOption: {\n\n        zlevel: 0,\n\n        z: 0,\n\n        center: ['50%', '50%'],\n\n        radius: '75%',\n\n        startAngle: 90,\n\n        name: {\n            show: true\n            // formatter: null\n            // textStyle: {}\n        },\n\n        boundaryGap: [0, 0],\n\n        splitNumber: 5,\n\n        nameGap: 15,\n\n        scale: false,\n\n        // Polygon or circle\n        shape: 'polygon',\n\n        axisLine: merge(\n            {\n                lineStyle: {\n                    color: '#bbb'\n                }\n            },\n            valueAxisDefault.axisLine\n        ),\n        axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),\n        axisTick: defaultsShow(valueAxisDefault.axisTick, false),\n        splitLine: defaultsShow(valueAxisDefault.splitLine, true),\n        splitArea: defaultsShow(valueAxisDefault.splitArea, true),\n\n        // {text, min, max}\n        indicator: []\n    }\n});\n\nvar axisBuilderAttrs$1 = [\n    'axisLine', 'axisTickLabel', 'axisName'\n];\n\nextendComponentView({\n\n    type: 'radar',\n\n    render: function (radarModel, ecModel, api) {\n        var group = this.group;\n        group.removeAll();\n\n        this._buildAxes(radarModel);\n        this._buildSplitLineAndArea(radarModel);\n    },\n\n    _buildAxes: function (radarModel) {\n        var radar = radarModel.coordinateSystem;\n        var indicatorAxes = radar.getIndicatorAxes();\n        var axisBuilders = map(indicatorAxes, function (indicatorAxis) {\n            var axisBuilder = new AxisBuilder(indicatorAxis.model, {\n                position: [radar.cx, radar.cy],\n                rotation: indicatorAxis.angle,\n                labelDirection: -1,\n                tickDirection: -1,\n                nameDirection: 1\n            });\n            return axisBuilder;\n        });\n\n        each$1(axisBuilders, function (axisBuilder) {\n            each$1(axisBuilderAttrs$1, axisBuilder.add, axisBuilder);\n            this.group.add(axisBuilder.getGroup());\n        }, this);\n    },\n\n    _buildSplitLineAndArea: function (radarModel) {\n        var radar = radarModel.coordinateSystem;\n        var indicatorAxes = radar.getIndicatorAxes();\n        if (!indicatorAxes.length) {\n            return;\n        }\n        var shape = radarModel.get('shape');\n        var splitLineModel = radarModel.getModel('splitLine');\n        var splitAreaModel = radarModel.getModel('splitArea');\n        var lineStyleModel = splitLineModel.getModel('lineStyle');\n        var areaStyleModel = splitAreaModel.getModel('areaStyle');\n\n        var showSplitLine = splitLineModel.get('show');\n        var showSplitArea = splitAreaModel.get('show');\n        var splitLineColors = lineStyleModel.get('color');\n        var splitAreaColors = areaStyleModel.get('color');\n\n        splitLineColors = isArray(splitLineColors) ? splitLineColors : [splitLineColors];\n        splitAreaColors = isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];\n\n        var splitLines = [];\n        var splitAreas = [];\n\n        function getColorIndex(areaOrLine, areaOrLineColorList, idx) {\n            var colorIndex = idx % areaOrLineColorList.length;\n            areaOrLine[colorIndex] = areaOrLine[colorIndex] || [];\n            return colorIndex;\n        }\n\n        if (shape === 'circle') {\n            var ticksRadius = indicatorAxes[0].getTicksCoords();\n            var cx = radar.cx;\n            var cy = radar.cy;\n            for (var i = 0; i < ticksRadius.length; i++) {\n                if (showSplitLine) {\n                    var colorIndex = getColorIndex(splitLines, splitLineColors, i);\n                    splitLines[colorIndex].push(new Circle({\n                        shape: {\n                            cx: cx,\n                            cy: cy,\n                            r: ticksRadius[i]\n                        }\n                    }));\n                }\n                if (showSplitArea && i < ticksRadius.length - 1) {\n                    var colorIndex = getColorIndex(splitAreas, splitAreaColors, i);\n                    splitAreas[colorIndex].push(new Ring({\n                        shape: {\n                            cx: cx,\n                            cy: cy,\n                            r0: ticksRadius[i],\n                            r: ticksRadius[i + 1]\n                        }\n                    }));\n                }\n            }\n        }\n        // Polyyon\n        else {\n            var realSplitNumber;\n            var axesTicksPoints = map(indicatorAxes, function (indicatorAxis, idx) {\n                var ticksCoords = indicatorAxis.getTicksCoords();\n                realSplitNumber = realSplitNumber == null\n                    ? ticksCoords.length - 1\n                    : Math.min(ticksCoords.length - 1, realSplitNumber);\n                return map(ticksCoords, function (tickCoord) {\n                    return radar.coordToPoint(tickCoord, idx);\n                });\n            });\n\n            var prevPoints = [];\n            for (var i = 0; i <= realSplitNumber; i++) {\n                var points = [];\n                for (var j = 0; j < indicatorAxes.length; j++) {\n                    points.push(axesTicksPoints[j][i]);\n                }\n                // Close\n                if (points[0]) {\n                    points.push(points[0].slice());\n                }\n                else {\n                    if (__DEV__) {\n                        console.error('Can\\'t draw value axis ' + i);\n                    }\n                }\n\n                if (showSplitLine) {\n                    var colorIndex = getColorIndex(splitLines, splitLineColors, i);\n                    splitLines[colorIndex].push(new Polyline({\n                        shape: {\n                            points: points\n                        }\n                    }));\n                }\n                if (showSplitArea && prevPoints) {\n                    var colorIndex = getColorIndex(splitAreas, splitAreaColors, i - 1);\n                    splitAreas[colorIndex].push(new Polygon({\n                        shape: {\n                            points: points.concat(prevPoints)\n                        }\n                    }));\n                }\n                prevPoints = points.slice().reverse();\n            }\n        }\n\n        var lineStyle = lineStyleModel.getLineStyle();\n        var areaStyle = areaStyleModel.getAreaStyle();\n        // Add splitArea before splitLine\n        each$1(splitAreas, function (splitAreas, idx) {\n            this.group.add(mergePath(\n                splitAreas, {\n                    style: defaults({\n                        stroke: 'none',\n                        fill: splitAreaColors[idx % splitAreaColors.length]\n                    }, areaStyle),\n                    silent: true\n                }\n            ));\n        }, this);\n\n        each$1(splitLines, function (splitLines, idx) {\n            this.group.add(mergePath(\n                splitLines, {\n                    style: defaults({\n                        fill: 'none',\n                        stroke: splitLineColors[idx % splitLineColors.length]\n                    }, lineStyle),\n                    silent: true\n                }\n            ));\n        }, this);\n\n    }\n});\n\nvar RadarSeries = SeriesModel.extend({\n\n    type: 'series.radar',\n\n    dependencies: ['radar'],\n\n\n    // Overwrite\n    init: function (option) {\n        RadarSeries.superApply(this, 'init', arguments);\n\n        // Enable legend selection for each data item\n        // Use a function instead of direct access because data reference may changed\n        this.legendDataProvider = function () {\n            return this.getRawData();\n        };\n    },\n\n    getInitialData: function (option, ecModel) {\n        var data = option.data || [];\n        var dimensions = completeDimensions(\n            [], data, {extraPrefix: 'indicator_', extraFromZero: true}\n        );\n        var list = new List(dimensions, this);\n        list.initData(data);\n        return list;\n    },\n\n    formatTooltip: function (dataIndex) {\n        var value = this.getRawValue(dataIndex);\n        var coordSys = this.coordinateSystem;\n        var indicatorAxes = coordSys.getIndicatorAxes();\n        var name = this.getData().getName(dataIndex);\n        return encodeHTML(name === '' ? this.name : name) + '<br/>'\n            + map(indicatorAxes, function (axis, idx) {\n                return encodeHTML(axis.name + ' : ' + value[idx]);\n            }).join('<br />');\n    },\n\n    defaultOption: {\n        zlevel: 0,\n        z: 2,\n        coordinateSystem: 'radar',\n        legendHoverLink: true,\n        radarIndex: 0,\n        lineStyle: {\n            normal: {\n                width: 2,\n                type: 'solid'\n            }\n        },\n        label: {\n            normal: {\n                position: 'top'\n            }\n        },\n        // areaStyle: {\n        // },\n        // itemStyle: {}\n        symbol: 'emptyCircle',\n        symbolSize: 4\n        // symbolRotate: null\n    }\n});\n\nfunction normalizeSymbolSize(symbolSize) {\n    if (!isArray(symbolSize)) {\n        symbolSize = [+symbolSize, +symbolSize];\n    }\n    return symbolSize;\n}\n\nextendChartView({\n\n    type: 'radar',\n\n    render: function (seriesModel, ecModel, api) {\n        var polar = seriesModel.coordinateSystem;\n        var group = this.group;\n\n        var data = seriesModel.getData();\n        var oldData = this._data;\n\n        function createSymbol$$1(data, idx) {\n            var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n            var color = data.getItemVisual(idx, 'color');\n            if (symbolType === 'none') {\n                return;\n            }\n            var symbolSize = normalizeSymbolSize(\n                data.getItemVisual(idx, 'symbolSize')\n            );\n            var symbolPath = createSymbol(\n                symbolType, -1, -1, 2, 2, color\n            );\n            symbolPath.attr({\n                style: {\n                    strokeNoScale: true\n                },\n                z2: 100,\n                scale: [symbolSize[0] / 2, symbolSize[1] / 2]\n            });\n            return symbolPath;\n        }\n\n        function updateSymbols(oldPoints, newPoints, symbolGroup, data, idx, isInit) {\n            // Simply rerender all\n            symbolGroup.removeAll();\n            for (var i = 0; i < newPoints.length - 1; i++) {\n                var symbolPath = createSymbol$$1(data, idx);\n                if (symbolPath) {\n                    symbolPath.__dimIdx = i;\n                    if (oldPoints[i]) {\n                        symbolPath.attr('position', oldPoints[i]);\n                        graphic[isInit ? 'initProps' : 'updateProps'](\n                            symbolPath, {\n                                position: newPoints[i]\n                            }, seriesModel, idx\n                        );\n                    }\n                    else {\n                        symbolPath.attr('position', newPoints[i]);\n                    }\n                    symbolGroup.add(symbolPath);\n                }\n            }\n        }\n\n        function getInitialPoints(points) {\n            return map(points, function (pt) {\n                return [polar.cx, polar.cy];\n            });\n        }\n        data.diff(oldData)\n            .add(function (idx) {\n                var points = data.getItemLayout(idx);\n                if (!points) {\n                    return;\n                }\n                var polygon = new Polygon();\n                var polyline = new Polyline();\n                var target = {\n                    shape: {\n                        points: points\n                    }\n                };\n                polygon.shape.points = getInitialPoints(points);\n                polyline.shape.points = getInitialPoints(points);\n                initProps(polygon, target, seriesModel, idx);\n                initProps(polyline, target, seriesModel, idx);\n\n                var itemGroup = new Group();\n                var symbolGroup = new Group();\n                itemGroup.add(polyline);\n                itemGroup.add(polygon);\n                itemGroup.add(symbolGroup);\n\n                updateSymbols(\n                    polyline.shape.points, points, symbolGroup, data, idx, true\n                );\n\n                data.setItemGraphicEl(idx, itemGroup);\n            })\n            .update(function (newIdx, oldIdx) {\n                var itemGroup = oldData.getItemGraphicEl(oldIdx);\n                var polyline = itemGroup.childAt(0);\n                var polygon = itemGroup.childAt(1);\n                var symbolGroup = itemGroup.childAt(2);\n                var target = {\n                    shape: {\n                        points: data.getItemLayout(newIdx)\n                    }\n                };\n                if (!target.shape.points) {\n                    return;\n                }\n                updateSymbols(\n                    polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false\n                );\n\n                updateProps(polyline, target, seriesModel);\n                updateProps(polygon, target, seriesModel);\n\n                data.setItemGraphicEl(newIdx, itemGroup);\n            })\n            .remove(function (idx) {\n                group.remove(oldData.getItemGraphicEl(idx));\n            })\n            .execute();\n\n        data.eachItemGraphicEl(function (itemGroup, idx) {\n            var itemModel = data.getItemModel(idx);\n            var polyline = itemGroup.childAt(0);\n            var polygon = itemGroup.childAt(1);\n            var symbolGroup = itemGroup.childAt(2);\n            var color = data.getItemVisual(idx, 'color');\n\n            group.add(itemGroup);\n\n            polyline.useStyle(\n                defaults(\n                    itemModel.getModel('lineStyle.normal').getLineStyle(),\n                    {\n                        fill: 'none',\n                        stroke: color\n                    }\n                )\n            );\n            polyline.hoverStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();\n\n            var areaStyleModel = itemModel.getModel('areaStyle.normal');\n            var hoverAreaStyleModel = itemModel.getModel('areaStyle.emphasis');\n            var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();\n            var hoverPolygonIgnore = hoverAreaStyleModel.isEmpty() && hoverAreaStyleModel.parentModel.isEmpty();\n\n            hoverPolygonIgnore = hoverPolygonIgnore && polygonIgnore;\n            polygon.ignore = polygonIgnore;\n\n            polygon.useStyle(\n                defaults(\n                    areaStyleModel.getAreaStyle(),\n                    {\n                        fill: color,\n                        opacity: 0.7\n                    }\n                )\n            );\n            polygon.hoverStyle = hoverAreaStyleModel.getAreaStyle();\n\n            var itemStyle = itemModel.getModel('itemStyle.normal').getItemStyle(['color']);\n            var itemHoverStyle = itemModel.getModel('itemStyle.emphasis').getItemStyle();\n            var labelModel = itemModel.getModel('label.normal');\n            var labelHoverModel = itemModel.getModel('label.emphasis');\n            symbolGroup.eachChild(function (symbolPath) {\n                symbolPath.setStyle(itemStyle);\n                symbolPath.hoverStyle = clone(itemHoverStyle);\n\n                setLabelStyle(\n                    symbolPath.style, symbolPath.hoverStyle, labelModel, labelHoverModel,\n                    {\n                        labelFetcher: data.hostModel,\n                        labelDataIndex: idx,\n                        labelDimIndex: symbolPath.__dimIdx,\n                        defaultText: data.get(data.dimensions[symbolPath.__dimIdx], idx),\n                        autoColor: color,\n                        isRectText: true\n                    }\n                );\n            });\n\n            function onEmphasis() {\n                polygon.attr('ignore', hoverPolygonIgnore);\n            }\n\n            function onNormal() {\n                polygon.attr('ignore', polygonIgnore);\n            }\n\n            itemGroup.off('mouseover').off('mouseout').off('normal').off('emphasis');\n            itemGroup.on('emphasis', onEmphasis)\n                .on('mouseover', onEmphasis)\n                .on('normal', onNormal)\n                .on('mouseout', onNormal);\n\n            setHoverStyle(itemGroup);\n        });\n\n        this._data = data;\n    },\n\n    remove: function () {\n        this.group.removeAll();\n        this._data = null;\n    },\n\n    dispose: function () {}\n});\n\nvar radarLayout = function (ecModel) {\n    ecModel.eachSeriesByType('radar', function (seriesModel) {\n        var data = seriesModel.getData();\n        var points = [];\n        var coordSys = seriesModel.coordinateSystem;\n        if (!coordSys) {\n            return;\n        }\n\n        function pointsConverter(val, idx) {\n            points[idx] = points[idx] || [];\n            points[idx][i] = coordSys.dataToPoint(val, i);\n        }\n        for (var i = 0; i < coordSys.getIndicatorAxes().length; i++) {\n            var dim = data.dimensions[i];\n            data.each(dim, pointsConverter);\n        }\n\n        data.each(function (idx) {\n            // Close polygon\n            points[idx][0] && points[idx].push(points[idx][0].slice());\n            data.setItemLayout(idx, points[idx]);\n        });\n    });\n};\n\n// Backward compat for radar chart in 2\nvar backwardCompat$1 = function (option) {\n    var polarOptArr = option.polar;\n    if (polarOptArr) {\n        if (!isArray(polarOptArr)) {\n            polarOptArr = [polarOptArr];\n        }\n        var polarNotRadar = [];\n        each$1(polarOptArr, function (polarOpt, idx) {\n            if (polarOpt.indicator) {\n                if (polarOpt.type && !polarOpt.shape) {\n                    polarOpt.shape = polarOpt.type;\n                }\n                option.radar = option.radar || [];\n                if (!isArray(option.radar)) {\n                    option.radar = [option.radar];\n                }\n                option.radar.push(polarOpt);\n            }\n            else {\n                polarNotRadar.push(polarOpt);\n            }\n        });\n        option.polar = polarNotRadar;\n    }\n    each$1(option.series, function (seriesOpt) {\n        if (seriesOpt && seriesOpt.type === 'radar' && seriesOpt.polarIndex) {\n            seriesOpt.radarIndex = seriesOpt.polarIndex;\n        }\n    });\n};\n\n// Must use radar component\nregisterVisual(curry(dataColor, 'radar'));\nregisterVisual(curry(visualSymbol, 'radar', 'circle', null));\nregisterLayout(radarLayout);\nregisterProcessor(curry(dataFilter, 'radar'));\nregisterPreprocessor(backwardCompat$1);\n\n/**\n * Simple view coordinate system\n * Mapping given x, y to transformd view x, y\n */\n\nvar v2ApplyTransform$1 = applyTransform;\n\n// Dummy transform node\nfunction TransformDummy() {\n    Transformable.call(this);\n}\nmixin(TransformDummy, Transformable);\n\nfunction View(name) {\n    /**\n     * @type {string}\n     */\n    this.name = name;\n\n    /**\n     * @type {Object}\n     */\n    this.zoomLimit;\n\n    Transformable.call(this);\n\n    this._roamTransform = new TransformDummy();\n\n    this._viewTransform = new TransformDummy();\n\n    this._center;\n    this._zoom;\n}\n\nView.prototype = {\n\n    constructor: View,\n\n    type: 'view',\n\n    /**\n     * @param {Array.<string>}\n     * @readOnly\n     */\n    dimensions: ['x', 'y'],\n\n    /**\n     * Set bounding rect\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     */\n\n    // PENDING to getRect\n    setBoundingRect: function (x, y, width, height) {\n        this._rect = new BoundingRect(x, y, width, height);\n        return this._rect;\n    },\n\n    /**\n     * @return {module:zrender/core/BoundingRect}\n     */\n    // PENDING to getRect\n    getBoundingRect: function () {\n        return this._rect;\n    },\n\n    /**\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     */\n    setViewRect: function (x, y, width, height) {\n        this.transformTo(x, y, width, height);\n        this._viewRect = new BoundingRect(x, y, width, height);\n    },\n\n    /**\n     * Transformed to particular position and size\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     */\n    transformTo: function (x, y, width, height) {\n        var rect = this.getBoundingRect();\n        var viewTransform = this._viewTransform;\n\n        viewTransform.transform = rect.calculateTransform(\n            new BoundingRect(x, y, width, height)\n        );\n\n        viewTransform.decomposeTransform();\n\n        this._updateTransform();\n    },\n\n    /**\n     * Set center of view\n     * @param {Array.<number>} [centerCoord]\n     */\n    setCenter: function (centerCoord) {\n        if (!centerCoord) {\n            return;\n        }\n        this._center = centerCoord;\n\n        this._updateCenterAndZoom();\n    },\n\n    /**\n     * @param {number} zoom\n     */\n    setZoom: function (zoom) {\n        zoom = zoom || 1;\n\n        var zoomLimit = this.zoomLimit;\n        if (zoomLimit) {\n            if (zoomLimit.max != null) {\n                zoom = Math.min(zoomLimit.max, zoom);\n            }\n            if (zoomLimit.min != null) {\n                zoom = Math.max(zoomLimit.min, zoom);\n            }\n        }\n        this._zoom = zoom;\n\n        this._updateCenterAndZoom();\n    },\n\n    /**\n     * Get default center without roam\n     */\n    getDefaultCenter: function () {\n        // Rect before any transform\n        var rawRect = this.getBoundingRect();\n        var cx = rawRect.x + rawRect.width / 2;\n        var cy = rawRect.y + rawRect.height / 2;\n\n        return [cx, cy];\n    },\n\n    getCenter: function () {\n        return this._center || this.getDefaultCenter();\n    },\n\n    getZoom: function () {\n        return this._zoom || 1;\n    },\n\n    /**\n     * @return {Array.<number}\n     */\n    getRoamTransform: function () {\n        return this._roamTransform;\n    },\n\n    _updateCenterAndZoom: function () {\n        // Must update after view transform updated\n        var viewTransformMatrix = this._viewTransform.getLocalTransform();\n        var roamTransform = this._roamTransform;\n        var defaultCenter = this.getDefaultCenter();\n        var center = this.getCenter();\n        var zoom = this.getZoom();\n\n        center = applyTransform([], center, viewTransformMatrix);\n        defaultCenter = applyTransform([], defaultCenter, viewTransformMatrix);\n\n        roamTransform.origin = center;\n        roamTransform.position = [\n            defaultCenter[0] - center[0],\n            defaultCenter[1] - center[1]\n        ];\n        roamTransform.scale = [zoom, zoom];\n\n        this._updateTransform();\n    },\n\n    /**\n     * Update transform from roam and mapLocation\n     * @private\n     */\n    _updateTransform: function () {\n        var roamTransform = this._roamTransform;\n        var viewTransform = this._viewTransform;\n\n        viewTransform.parent = roamTransform;\n        roamTransform.updateTransform();\n        viewTransform.updateTransform();\n\n        viewTransform.transform\n            && copy$1(this.transform || (this.transform = []), viewTransform.transform);\n\n        if (this.transform) {\n            this.invTransform = this.invTransform || [];\n            invert(this.invTransform, this.transform);\n        }\n        else {\n            this.invTransform = null;\n        }\n        this.decomposeTransform();\n    },\n\n    /**\n     * @return {module:zrender/core/BoundingRect}\n     */\n    getViewRect: function () {\n        return this._viewRect;\n    },\n\n    /**\n     * Get view rect after roam transform\n     * @return {module:zrender/core/BoundingRect}\n     */\n    getViewRectAfterRoam: function () {\n        var rect = this.getBoundingRect().clone();\n        rect.applyTransform(this.transform);\n        return rect;\n    },\n\n    /**\n     * Convert a single (lon, lat) data item to (x, y) point.\n     * @param {Array.<number>} data\n     * @return {Array.<number>}\n     */\n    dataToPoint: function (data) {\n        var transform = this.transform;\n        return transform\n            ? v2ApplyTransform$1([], data, transform)\n            : [data[0], data[1]];\n    },\n\n    /**\n     * Convert a (x, y) point to (lon, lat) data\n     * @param {Array.<number>} point\n     * @return {Array.<number>}\n     */\n    pointToData: function (point) {\n        var invTransform = this.invTransform;\n        return invTransform\n            ? v2ApplyTransform$1([], point, invTransform)\n            : [point[0], point[1]];\n    },\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    convertToPixel: curry(doConvert$1, 'dataToPoint'),\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    convertFromPixel: curry(doConvert$1, 'pointToData'),\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    containPoint: function (point) {\n        return this.getViewRectAfterRoam().contain(point[0], point[1]);\n    }\n\n    /**\n     * @return {number}\n     */\n    // getScalarScale: function () {\n    //     // Use determinant square root of transform to mutiply scalar\n    //     var m = this.transform;\n    //     var det = Math.sqrt(Math.abs(m[0] * m[3] - m[2] * m[1]));\n    //     return det;\n    // }\n};\n\nmixin(View, Transformable);\n\nfunction doConvert$1(methodName, ecModel, finder, value) {\n    var seriesModel = finder.seriesModel;\n    var coordSys = seriesModel ? seriesModel.coordinateSystem : null; // e.g., graph.\n    return coordSys === this ? coordSys[methodName](value) : null;\n}\n\n// Fix for \n\nvar geoCoord = [126, 25];\n\nvar points$1 = [\n    [[0,3.5],[7,11.2],[15,11.9],[30,7],[42,0.7],[52,0.7],\n        [56,7.7],[59,0.7],[64,0.7],[64,0],[5,0],[0,3.5]],\n    [[13,16.1],[19,14.7],[16,21.7],[11,23.1],[13,16.1]],\n    [[12,32.2],[14,38.5],[15,38.5],[13,32.2],[12,32.2]],\n    [[16,47.6],[12,53.2],[13,53.2],[18,47.6],[16,47.6]],\n    [[6,64.4],[8,70],[9,70],[8,64.4],[6,64.4]],\n    [[23,82.6],[29,79.8],[30,79.8],[25,82.6],[23,82.6]],\n    [[37,70.7],[43,62.3],[44,62.3],[39,70.7],[37,70.7]],\n    [[48,51.1],[51,45.5],[53,45.5],[50,51.1],[48,51.1]],\n    [[51,35],[51,28.7],[53,28.7],[53,35],[51,35]],\n    [[52,22.4],[55,17.5],[56,17.5],[53,22.4],[52,22.4]],\n    [[58,12.6],[62,7],[63,7],[60,12.6],[58,12.6]],\n    [[0,3.5],[0,93.1],[64,93.1],[64,0],[63,0],[63,92.4],\n        [1,92.4],[1,3.5],[0,3.5]]\n];\n\nfor (var i$1 = 0; i$1 < points$1.length; i$1++) {\n    for (var k = 0; k < points$1[i$1].length; k++) {\n        points$1[i$1][k][0] /= 10.5;\n        points$1[i$1][k][1] /= -10.5 / 0.75;\n\n        points$1[i$1][k][0] += geoCoord[0];\n        points$1[i$1][k][1] += geoCoord[1];\n    }\n}\n\nvar fixNanhai = function (geo) {\n    if (geo.map === 'china') {\n        geo.regions.push(new Region(\n            '',\n            map(points$1, function (exterior) {\n                return {\n                    type: 'polygon',\n                    exterior: exterior\n                };\n            }), geoCoord\n        ));\n    }\n};\n\nvar coordsOffsetMap = {\n    '' : [32, 80],\n    // \n    '': [0, -10],\n    '': [10, 5],\n    '': [-10, 10],\n    //'': [-10, 0],\n    '': [5, 5]\n};\n\nvar fixTextCoord = function (geo) {\n    each$1(geo.regions, function (region) {\n        var coordFix = coordsOffsetMap[region.name];\n        if (coordFix) {\n            var cp = region.center;\n            cp[0] += coordFix[0] / 10.5;\n            cp[1] += -coordFix[1] / (10.5 / 0.75);\n        }\n    });\n};\n\nvar geoCoordMap = {\n    'Russia': [100, 60],\n    'United States': [-99, 38],\n    'United States of America': [-99, 38]\n};\n\nvar fixGeoCoord = function (geo) {\n    each$1(geo.regions, function (region) {\n        var geoCoord = geoCoordMap[region.name];\n        if (geoCoord) {\n            var cp = region.center;\n            cp[0] = geoCoord[0];\n            cp[1] = geoCoord[1];\n        }\n    });\n};\n\n// Fix for \n\n// var Region = require('../Region');\n// var zrUtil = require('zrender/src/core/util');\n\n// var geoCoord = [126, 25];\n\nvar points$2 = [\n    [\n        [123.45165252685547, 25.73527164402261],\n        [123.49731445312499, 25.73527164402261],\n        [123.49731445312499, 25.750734064600884],\n        [123.45165252685547, 25.750734064600884],\n        [123.45165252685547, 25.73527164402261]\n    ]\n];\n\nvar fixDiaoyuIsland = function (geo) {\n    if (geo.map === 'china') {\n        for (var i = 0, len = geo.regions.length; i < len; ++i) {\n            if (geo.regions[i].name === '') {\n                geo.regions[i].geometries.push({\n                    type: 'polygon',\n                    exterior: points$2[0]\n                });\n            }\n        }\n    }\n};\n\n// Geo fix functions\nvar geoFixFuncs = [\n    fixNanhai,\n    fixTextCoord,\n    fixGeoCoord,\n    fixDiaoyuIsland\n];\n\n/**\n * [Geo description]\n * @param {string} name Geo name\n * @param {string} map Map type\n * @param {Object} geoJson\n * @param {Object} [specialAreas]\n *        Specify the positioned areas by left, top, width, height\n * @param {Object.<string, string>} [nameMap]\n *        Specify name alias\n */\nfunction Geo(name, map$$1, geoJson, specialAreas, nameMap) {\n\n    View.call(this, name);\n\n    /**\n     * Map type\n     * @type {string}\n     */\n    this.map = map$$1;\n\n    this._nameCoordMap = createHashMap();\n\n    this.loadGeoJson(geoJson, specialAreas, nameMap);\n}\n\nGeo.prototype = {\n\n    constructor: Geo,\n\n    type: 'geo',\n\n    /**\n     * @param {Array.<string>}\n     * @readOnly\n     */\n    dimensions: ['lng', 'lat'],\n\n    /**\n     * If contain given lng,lat coord\n     * @param {Array.<number>}\n     * @readOnly\n     */\n    containCoord: function (coord) {\n        var regions = this.regions;\n        for (var i = 0; i < regions.length; i++) {\n            if (regions[i].contain(coord)) {\n                return true;\n            }\n        }\n        return false;\n    },\n    /**\n     * @param {Object} geoJson\n     * @param {Object} [specialAreas]\n     *        Specify the positioned areas by left, top, width, height\n     * @param {Object.<string, string>} [nameMap]\n     *        Specify name alias\n     */\n    loadGeoJson: function (geoJson, specialAreas, nameMap) {\n        // https://jsperf.com/try-catch-performance-overhead\n        try {\n            this.regions = geoJson ? parseGeoJson(geoJson) : [];\n        }\n        catch (e) {\n            throw 'Invalid geoJson format\\n' + e.message;\n        }\n        specialAreas = specialAreas || {};\n        nameMap = nameMap || {};\n        var regions = this.regions;\n        var regionsMap = createHashMap();\n        for (var i = 0; i < regions.length; i++) {\n            var regionName = regions[i].name;\n            // Try use the alias in nameMap\n            regionName = nameMap.hasOwnProperty(regionName) ? nameMap[regionName] : regionName;\n            regions[i].name = regionName;\n\n            regionsMap.set(regionName, regions[i]);\n            // Add geoJson\n            this.addGeoCoord(regionName, regions[i].center);\n\n            // Some area like Alaska in USA map needs to be tansformed\n            // to look better\n            var specialArea = specialAreas[regionName];\n            if (specialArea) {\n                regions[i].transformTo(\n                    specialArea.left, specialArea.top, specialArea.width, specialArea.height\n                );\n            }\n        }\n\n        this._regionsMap = regionsMap;\n\n        this._rect = null;\n\n        each$1(geoFixFuncs, function (fixFunc) {\n            fixFunc(this);\n        }, this);\n    },\n\n    // Overwrite\n    transformTo: function (x, y, width, height) {\n        var rect = this.getBoundingRect();\n\n        rect = rect.clone();\n        // Longitute is inverted\n        rect.y = -rect.y - rect.height;\n\n        var viewTransform = this._viewTransform;\n\n        viewTransform.transform = rect.calculateTransform(\n            new BoundingRect(x, y, width, height)\n        );\n\n        viewTransform.decomposeTransform();\n\n        var scale = viewTransform.scale;\n        scale[1] = -scale[1];\n\n        viewTransform.updateTransform();\n\n        this._updateTransform();\n    },\n\n    /**\n     * @param {string} name\n     * @return {module:echarts/coord/geo/Region}\n     */\n    getRegion: function (name) {\n        return this._regionsMap.get(name);\n    },\n\n    getRegionByCoord: function (coord) {\n        var regions = this.regions;\n        for (var i = 0; i < regions.length; i++) {\n            if (regions[i].contain(coord)) {\n                return regions[i];\n            }\n        }\n    },\n\n    /**\n     * Add geoCoord for indexing by name\n     * @param {string} name\n     * @param {Array.<number>} geoCoord\n     */\n    addGeoCoord: function (name, geoCoord) {\n        this._nameCoordMap.set(name, geoCoord);\n    },\n\n    /**\n     * Get geoCoord by name\n     * @param {string} name\n     * @return {Array.<number>}\n     */\n    getGeoCoord: function (name) {\n        return this._nameCoordMap.get(name);\n    },\n\n    // Overwrite\n    getBoundingRect: function () {\n        if (this._rect) {\n            return this._rect;\n        }\n        var rect;\n\n        var regions = this.regions;\n        for (var i = 0; i < regions.length; i++) {\n            var regionRect = regions[i].getBoundingRect();\n            rect = rect || regionRect.clone();\n            rect.union(regionRect);\n        }\n        // FIXME Always return new ?\n        return (this._rect = rect || new BoundingRect(0, 0, 0, 0));\n    },\n\n    /**\n     * @param {string|Array.<number>} data\n     * @return {Array.<number>}\n     */\n    dataToPoint: function (data) {\n        if (typeof data === 'string') {\n            // Map area name to geoCoord\n            data = this.getGeoCoord(data);\n        }\n        if (data) {\n            return View.prototype.dataToPoint.call(this, data);\n        }\n    },\n\n    /**\n     * @inheritDoc\n     */\n    convertToPixel: curry(doConvert, 'dataToPoint'),\n\n    /**\n     * @inheritDoc\n     */\n    convertFromPixel: curry(doConvert, 'pointToData')\n\n};\n\nmixin(Geo, View);\n\nfunction doConvert(methodName, ecModel, finder, value) {\n    var geoModel = finder.geoModel;\n    var seriesModel = finder.seriesModel;\n\n    var coordSys = geoModel\n        ? geoModel.coordinateSystem\n        : seriesModel\n        ? (\n            seriesModel.coordinateSystem // For map.\n            || (seriesModel.getReferringComponents('geo')[0] || {}).coordinateSystem\n        )\n        : null;\n\n    return coordSys === this ? coordSys[methodName](value) : null;\n}\n\n/**\n * Resize method bound to the geo\n * @param {module:echarts/coord/geo/GeoModel|module:echarts/chart/map/MapModel} geoModel\n * @param {module:echarts/ExtensionAPI} api\n */\nfunction resizeGeo(geoModel, api) {\n\n    var boundingCoords = geoModel.get('boundingCoords');\n    if (boundingCoords != null) {\n        var leftTop = boundingCoords[0];\n        var rightBottom = boundingCoords[1];\n        if (isNaN(leftTop[0]) || isNaN(leftTop[1]) || isNaN(rightBottom[0]) || isNaN(rightBottom[1])) {\n            if (__DEV__) {\n                console.error('Invalid boundingCoords');\n            }\n        }\n        else {\n            this.setBoundingRect(leftTop[0], leftTop[1], rightBottom[0] - leftTop[0], rightBottom[1] - leftTop[1]);\n        }\n    }\n\n    var rect = this.getBoundingRect();\n\n    var boxLayoutOption;\n\n    var center = geoModel.get('layoutCenter');\n    var size = geoModel.get('layoutSize');\n\n    var viewWidth = api.getWidth();\n    var viewHeight = api.getHeight();\n\n    var aspectScale = geoModel.get('aspectScale') || 0.75;\n    var aspect = rect.width / rect.height * aspectScale;\n\n    var useCenterAndSize = false;\n\n    if (center && size) {\n        center = [\n            parsePercent$1(center[0], viewWidth),\n            parsePercent$1(center[1], viewHeight)\n        ];\n        size = parsePercent$1(size, Math.min(viewWidth, viewHeight));\n\n        if (!isNaN(center[0]) && !isNaN(center[1]) && !isNaN(size)) {\n            useCenterAndSize = true;\n        }\n        else {\n            if (__DEV__) {\n                console.warn('Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead.');\n            }\n        }\n    }\n\n    var viewRect;\n    if (useCenterAndSize) {\n        var viewRect = {};\n        if (aspect > 1) {\n            // Width is same with size\n            viewRect.width = size;\n            viewRect.height = size / aspect;\n        }\n        else {\n            viewRect.height = size;\n            viewRect.width = size * aspect;\n        }\n        viewRect.y = center[1] - viewRect.height / 2;\n        viewRect.x = center[0] - viewRect.width / 2;\n    }\n    else {\n        // Use left/top/width/height\n        boxLayoutOption = geoModel.getBoxLayoutParams();\n\n        // 0.75 rate\n        boxLayoutOption.aspect = aspect;\n\n        viewRect = getLayoutRect(boxLayoutOption, {\n            width: viewWidth,\n            height: viewHeight\n        });\n    }\n\n    this.setViewRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);\n\n    this.setCenter(geoModel.get('center'));\n    this.setZoom(geoModel.get('zoom'));\n}\n\n/**\n * @param {module:echarts/coord/Geo} geo\n * @param {module:echarts/model/Model} model\n * @inner\n */\nfunction setGeoCoords(geo, model) {\n    each$1(model.get('geoCoord'), function (geoCoord, name) {\n        geo.addGeoCoord(name, geoCoord);\n    });\n}\n\nif (__DEV__) {\n    var mapNotExistsError = function (name) {\n        console.error('Map ' + name + ' not exists. You can download map file on http://echarts.baidu.com/download-map.html');\n    };\n}\n\nvar geoCreator = {\n\n    // For deciding which dimensions to use when creating list data\n    dimensions: Geo.prototype.dimensions,\n\n    create: function (ecModel, api) {\n        var geoList = [];\n\n        // FIXME Create each time may be slow\n        ecModel.eachComponent('geo', function (geoModel, idx) {\n            var name = geoModel.get('map');\n            var mapData = getMap(name);\n            if (__DEV__) {\n                if (!mapData) {\n                    mapNotExistsError(name);\n                }\n            }\n            var geo = new Geo(\n                name + idx, name,\n                mapData && mapData.geoJson, mapData && mapData.specialAreas,\n                geoModel.get('nameMap')\n            );\n            geo.zoomLimit = geoModel.get('scaleLimit');\n            geoList.push(geo);\n\n            setGeoCoords(geo, geoModel);\n\n            geoModel.coordinateSystem = geo;\n            geo.model = geoModel;\n\n            // Inject resize method\n            geo.resize = resizeGeo;\n\n            geo.resize(geoModel, api);\n        });\n\n        ecModel.eachSeries(function (seriesModel) {\n            var coordSys = seriesModel.get('coordinateSystem');\n            if (coordSys === 'geo') {\n                var geoIndex = seriesModel.get('geoIndex') || 0;\n                seriesModel.coordinateSystem = geoList[geoIndex];\n            }\n        });\n\n        // If has map series\n        var mapModelGroupBySeries = {};\n\n        ecModel.eachSeriesByType('map', function (seriesModel) {\n            if (!seriesModel.getHostGeoModel()) {\n                var mapType = seriesModel.getMapType();\n                mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || [];\n                mapModelGroupBySeries[mapType].push(seriesModel);\n            }\n        });\n\n        each$1(mapModelGroupBySeries, function (mapSeries, mapType) {\n            var mapData = getMap(mapType);\n            if (__DEV__) {\n                if (!mapData) {\n                    mapNotExistsError(mapSeries[0].get('map'));\n                }\n            }\n\n            var nameMapList = map(mapSeries, function (singleMapSeries) {\n                return singleMapSeries.get('nameMap');\n            });\n            var geo = new Geo(\n                mapType, mapType,\n                mapData && mapData.geoJson, mapData && mapData.specialAreas,\n                mergeAll(nameMapList)\n            );\n            geo.zoomLimit = retrieve.apply(null, map(mapSeries, function (singleMapSeries) {\n                return singleMapSeries.get('scaleLimit');\n            }));\n            geoList.push(geo);\n\n            // Inject resize method\n            geo.resize = resizeGeo;\n\n            geo.resize(mapSeries[0], api);\n\n            each$1(mapSeries, function (singleMapSeries) {\n                singleMapSeries.coordinateSystem = geo;\n\n                setGeoCoords(geo, singleMapSeries);\n            });\n        });\n\n        return geoList;\n    },\n\n    /**\n     * Fill given regions array\n     * @param  {Array.<Object>} originRegionArr\n     * @param  {string} mapName\n     * @param  {Object} [nameMap]\n     * @return {Array}\n     */\n    getFilledRegions: function (originRegionArr, mapName, nameMap) {\n        // Not use the original\n        var regionsArr = (originRegionArr || []).slice();\n        nameMap = nameMap || {};\n\n        var map$$1 = getMap(mapName);\n        var geoJson = map$$1 && map$$1.geoJson;\n        if (!geoJson) {\n            if (__DEV__) {\n                mapNotExistsError(mapName);\n            }\n            return originRegionArr;\n        }\n\n        var dataNameMap = createHashMap();\n        var features = geoJson.features;\n        for (var i = 0; i < regionsArr.length; i++) {\n            dataNameMap.set(regionsArr[i].name, regionsArr[i]);\n        }\n\n        for (var i = 0; i < features.length; i++) {\n            var name = features[i].properties.name;\n            if (!dataNameMap.get(name)) {\n                if (nameMap.hasOwnProperty(name)) {\n                    name = nameMap[name];\n                }\n                regionsArr.push({\n                    name: name\n                });\n            }\n        }\n        return regionsArr;\n    }\n};\n\nregisterCoordinateSystem('geo', geoCreator);\n\nvar MapSeries = SeriesModel.extend({\n\n    type: 'series.map',\n\n    dependencies: ['geo'],\n\n    layoutMode: 'box',\n\n    /**\n     * Only first map series of same mapType will drawMap\n     * @type {boolean}\n     */\n    needsDrawMap: false,\n\n    /**\n     * Group of all map series with same mapType\n     * @type {boolean}\n     */\n    seriesGroup: [],\n\n    init: function (option) {\n\n        this._fillOption(option, this.getMapType());\n        // this.option = option;\n\n        MapSeries.superApply(this, 'init', arguments);\n\n        this.updateSelectedMap(option.data);\n    },\n\n    getInitialData: function (option) {\n        var dimensions = completeDimensions(['value'], option.data || []);\n\n        var list = new List(dimensions, this);\n\n        list.initData(option.data);\n\n        return list;\n    },\n\n    mergeOption: function (newOption) {\n        this._fillOption(newOption, this.getMapType());\n\n        MapSeries.superApply(this, 'mergeOption', arguments);\n\n        this.updateSelectedMap(this.option.data);\n    },\n\n    /**\n     * If no host geo model, return null, which means using a\n     * inner exclusive geo model.\n     */\n    getHostGeoModel: function () {\n        var geoIndex = this.option.geoIndex;\n        return geoIndex != null\n            ? this.dependentModels.geo[geoIndex]\n            : null;\n    },\n\n    getMapType: function () {\n        return (this.getHostGeoModel() || this).option.map;\n    },\n\n    _fillOption: function (option, mapName) {\n        // Shallow clone\n        // option = zrUtil.extend({}, option);\n\n        option.data = geoCreator.getFilledRegions(option.data, mapName, option.nameMap);\n\n        // return option;\n    },\n\n    getRawValue: function (dataIndex) {\n        // Use value stored in data instead because it is calculated from multiple series\n        // FIXME Provide all value of multiple series ?\n        return this.getData().get('value', dataIndex);\n    },\n\n    /**\n     * Get model of region\n     * @param  {string} name\n     * @return {module:echarts/model/Model}\n     */\n    getRegionModel: function (regionName) {\n        var data = this.getData();\n        return data.getItemModel(data.indexOfName(regionName));\n    },\n\n    /**\n     * Map tooltip formatter\n     *\n     * @param {number} dataIndex\n     */\n    formatTooltip: function (dataIndex) {\n        // FIXME orignalData and data is a bit confusing\n        var data = this.getData();\n        var formattedValue = addCommas(this.getRawValue(dataIndex));\n        var name = data.getName(dataIndex);\n\n        var seriesGroup = this.seriesGroup;\n        var seriesNames = [];\n        for (var i = 0; i < seriesGroup.length; i++) {\n            var otherIndex = seriesGroup[i].originalData.indexOfName(name);\n            if (!isNaN(seriesGroup[i].originalData.get('value', otherIndex))) {\n                seriesNames.push(\n                    encodeHTML(seriesGroup[i].name)\n                );\n            }\n        }\n\n        return seriesNames.join(', ') + '<br />'\n            + encodeHTML(name + ' : ' + formattedValue);\n    },\n\n    /**\n     * @implement\n     */\n    getTooltipPosition: function (dataIndex) {\n        if (dataIndex != null) {\n            var name = this.getData().getName(dataIndex);\n            var geo = this.coordinateSystem;\n            var region = geo.getRegion(name);\n\n            return region && geo.dataToPoint(region.center);\n        }\n    },\n\n    setZoom: function (zoom) {\n        this.option.zoom = zoom;\n    },\n\n    setCenter: function (center) {\n        this.option.center = center;\n    },\n\n    defaultOption: {\n        // \n        zlevel: 0,\n        // \n        z: 2,\n\n        coordinateSystem: 'geo',\n\n        // map should be explicitly specified since ec3.\n        map: '',\n\n        // If `geoIndex` is not specified, a exclusive geo will be\n        // created. Otherwise use the specified geo component, and\n        // `map` and `mapType` are ignored.\n        // geoIndex: 0,\n\n        // 'center' | 'left' | 'right' | 'x%' | {number}\n        left: 'center',\n        // 'center' | 'top' | 'bottom' | 'x%' | {number}\n        top: 'center',\n        // right\n        // bottom\n        // width:\n        // height\n\n        // Aspect is width / height. Inited to be geoJson bbox aspect\n        // This parameter is used for scale this aspect\n        aspectScale: 0.75,\n\n        ///// Layout with center and size\n        // If you wan't to put map in a fixed size box with right aspect ratio\n        // This two properties may more conveninet\n        // layoutCenter: [50%, 50%]\n        // layoutSize: 100\n\n\n        // \n        // 'sum' | 'average' | 'max' | 'min'\n        // mapValueCalculation: 'sum',\n        // \n        // mapValuePrecision: 0,\n\n\n        // \n        showLegendSymbol: true,\n        // singlemultiple\n        // selectedMode: false,\n        dataRangeHoverLink: true,\n        // \n        // roam: false,\n\n        // Define left-top, right-bottom coords to control view\n        // For example, [ [180, 90], [-180, -90] ],\n        // higher priority than center and zoom\n        boundingCoords: null,\n\n        // Default on center of map\n        center: null,\n\n        zoom: 1,\n\n        scaleLimit: null,\n\n        label: {\n            normal: {\n                show: false,\n                color: '#000'\n            },\n            emphasis: {\n                show: true,\n                color: 'rgb(100,0,0)'\n            }\n        },\n        // scaleLimit: null,\n        itemStyle: {\n            normal: {\n                // color: ,\n                borderWidth: 0.5,\n                borderColor: '#444',\n                areaColor: '#eee'\n            },\n            // \n            emphasis: {\n                areaColor: 'rgba(255,215,0,0.8)'\n            }\n        }\n    }\n\n});\n\nmixin(MapSeries, selectableMixin);\n\nvar ATTR = '\\0_ec_interaction_mutex';\n\nfunction take(zr, resourceKey, userKey) {\n    var store = getStore(zr);\n    store[resourceKey] = userKey;\n}\n\nfunction release(zr, resourceKey, userKey) {\n    var store = getStore(zr);\n    var uKey = store[resourceKey];\n\n    if (uKey === userKey) {\n        store[resourceKey] = null;\n    }\n}\n\nfunction isTaken(zr, resourceKey) {\n    return !!getStore(zr)[resourceKey];\n}\n\nfunction getStore(zr) {\n    return zr[ATTR] || (zr[ATTR] = {});\n}\n\n/**\n * payload: {\n *     type: 'takeGlobalCursor',\n *     key: 'dataZoomSelect', or 'brush', or ...,\n *         If no userKey, release global cursor.\n * }\n */\nregisterAction(\n    {type: 'takeGlobalCursor', event: 'globalCursorTaken', update: 'update'},\n    function () {}\n);\n\n/**\n * @alias module:echarts/component/helper/RoamController\n * @constructor\n * @mixin {module:zrender/mixin/Eventful}\n *\n * @param {module:zrender/zrender~ZRender} zr\n */\nfunction RoamController(zr) {\n\n    /**\n     * @type {Function}\n     */\n    this.pointerChecker;\n\n    /**\n     * @type {module:zrender}\n     */\n    this._zr = zr;\n\n    /**\n     * @type {Object}\n     */\n    this._opt = {};\n\n    // Avoid two roamController bind the same handler\n    var bind$$1 = bind;\n    var mousedownHandler = bind$$1(mousedown, this);\n    var mousemoveHandler = bind$$1(mousemove, this);\n    var mouseupHandler = bind$$1(mouseup, this);\n    var mousewheelHandler = bind$$1(mousewheel, this);\n    var pinchHandler = bind$$1(pinch, this);\n\n    Eventful.call(this);\n\n    /**\n     * @param {Function} pointerChecker\n     *                   input: x, y\n     *                   output: boolean\n     */\n    this.setPointerChecker = function (pointerChecker) {\n        this.pointerChecker = pointerChecker;\n    };\n\n    /**\n     * Notice: only enable needed types. For example, if 'zoom'\n     * is not needed, 'zoom' should not be enabled, otherwise\n     * default mousewheel behaviour (scroll page) will be disabled.\n     *\n     * @param  {boolean|string} [controlType=true] Specify the control type,\n     *                          which can be null/undefined or true/false\n     *                          or 'pan/move' or 'zoom'/'scale'\n     * @param {Object} [opt]\n     * @param {Object} [opt.zoomOnMouseWheel=true]\n     * @param {Object} [opt.moveOnMouseMove=true]\n     * @param {Object} [opt.preventDefaultMouseMove=true] When pan.\n     */\n    this.enable = function (controlType, opt) {\n\n        // Disable previous first\n        this.disable();\n\n        this._opt = defaults(clone(opt) || {}, {\n            zoomOnMouseWheel: true,\n            moveOnMouseMove: true,\n            preventDefaultMouseMove: true\n        });\n\n        if (controlType == null) {\n            controlType = true;\n        }\n\n        if (controlType === true || (controlType === 'move' || controlType === 'pan')) {\n            zr.on('mousedown', mousedownHandler);\n            zr.on('mousemove', mousemoveHandler);\n            zr.on('mouseup', mouseupHandler);\n        }\n        if (controlType === true || (controlType === 'scale' || controlType === 'zoom')) {\n            zr.on('mousewheel', mousewheelHandler);\n            zr.on('pinch', pinchHandler);\n        }\n    };\n\n    this.disable = function () {\n        zr.off('mousedown', mousedownHandler);\n        zr.off('mousemove', mousemoveHandler);\n        zr.off('mouseup', mouseupHandler);\n        zr.off('mousewheel', mousewheelHandler);\n        zr.off('pinch', pinchHandler);\n    };\n\n    this.dispose = this.disable;\n\n    this.isDragging = function () {\n        return this._dragging;\n    };\n\n    this.isPinching = function () {\n        return this._pinching;\n    };\n}\n\nmixin(RoamController, Eventful);\n\n\nfunction mousedown(e) {\n    if (notLeftMouse(e)\n        || (e.target && e.target.draggable)\n    ) {\n        return;\n    }\n\n    var x = e.offsetX;\n    var y = e.offsetY;\n\n    // Only check on mosedown, but not mousemove.\n    // Mouse can be out of target when mouse moving.\n    if (this.pointerChecker && this.pointerChecker(e, x, y)) {\n        this._x = x;\n        this._y = y;\n        this._dragging = true;\n    }\n}\n\nfunction mousemove(e) {\n    if (notLeftMouse(e)\n        || !checkKeyBinding(this, 'moveOnMouseMove', e)\n        || !this._dragging\n        || e.gestureEvent === 'pinch'\n        || isTaken(this._zr, 'globalPan')\n    ) {\n        return;\n    }\n\n    var x = e.offsetX;\n    var y = e.offsetY;\n\n    var oldX = this._x;\n    var oldY = this._y;\n\n    var dx = x - oldX;\n    var dy = y - oldY;\n\n    this._x = x;\n    this._y = y;\n\n    this._opt.preventDefaultMouseMove && stop(e.event);\n\n    this.trigger('pan', dx, dy, oldX, oldY, x, y);\n}\n\nfunction mouseup(e) {\n    if (!notLeftMouse(e)) {\n        this._dragging = false;\n    }\n}\n\nfunction mousewheel(e) {\n    // wheelDelta maybe -0 in chrome mac.\n    if (!checkKeyBinding(this, 'zoomOnMouseWheel', e) || e.wheelDelta === 0) {\n        return;\n    }\n\n    // Convenience:\n    // Mac and VM Windows on Mac: scroll up: zoom out.\n    // Windows: scroll up: zoom in.\n    var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;\n    zoom.call(this, e, zoomDelta, e.offsetX, e.offsetY);\n}\n\nfunction pinch(e) {\n    if (isTaken(this._zr, 'globalPan')) {\n        return;\n    }\n    var zoomDelta = e.pinchScale > 1 ? 1.1 : 1 / 1.1;\n    zoom.call(this, e, zoomDelta, e.pinchX, e.pinchY);\n}\n\nfunction zoom(e, zoomDelta, zoomX, zoomY) {\n    if (this.pointerChecker && this.pointerChecker(e, zoomX, zoomY)) {\n        // When mouse is out of roamController rect,\n        // default befavoius should not be be disabled, otherwise\n        // page sliding is disabled, contrary to expectation.\n        stop(e.event);\n\n        this.trigger('zoom', zoomDelta, zoomX, zoomY);\n    }\n}\n\nfunction checkKeyBinding(roamController, prop, e) {\n    var setting = roamController._opt[prop];\n    return setting\n        && (!isString(setting) || e.event[setting + 'Key']);\n}\n\n/**\n * For geo and graph.\n *\n * @param {Object} controllerHost\n * @param {module:zrender/Element} controllerHost.target\n */\nfunction updateViewOnPan(controllerHost, dx, dy) {\n    var target = controllerHost.target;\n    var pos = target.position;\n    pos[0] += dx;\n    pos[1] += dy;\n    target.dirty();\n}\n\n/**\n * For geo and graph.\n *\n * @param {Object} controllerHost\n * @param {module:zrender/Element} controllerHost.target\n * @param {number} controllerHost.zoom\n * @param {number} controllerHost.zoomLimit like: {min: 1, max: 2}\n */\nfunction updateViewOnZoom(controllerHost, zoomDelta, zoomX, zoomY) {\n    var target = controllerHost.target;\n    var zoomLimit = controllerHost.zoomLimit;\n    var pos = target.position;\n    var scale = target.scale;\n\n    var newZoom = controllerHost.zoom = controllerHost.zoom || 1;\n    newZoom *= zoomDelta;\n    if (zoomLimit) {\n        var zoomMin = zoomLimit.min || 0;\n        var zoomMax = zoomLimit.max || Infinity;\n        newZoom = Math.max(\n            Math.min(zoomMax, newZoom),\n            zoomMin\n        );\n    }\n    var zoomScale = newZoom / controllerHost.zoom;\n    controllerHost.zoom = newZoom;\n    // Keep the mouse center when scaling\n    pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\n    pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\n    scale[0] *= zoomScale;\n    scale[1] *= zoomScale;\n\n    target.dirty();\n}\n\nvar IRRELEVANT_EXCLUDES = {'axisPointer': 1, 'tooltip': 1, 'brush': 1};\n\n/**\n * Avoid that: mouse click on a elements that is over geo or graph,\n * but roam is triggered.\n */\nfunction onIrrelevantElement(e, api, targetCoordSysModel) {\n    var model = api.getComponentByElement(e.topTarget);\n    // If model is axisModel, it works only if it is injected with coordinateSystem.\n    var coordSys = model && model.coordinateSystem;\n    return model\n        && model !== targetCoordSysModel\n        && !IRRELEVANT_EXCLUDES[model.mainType]\n        && (coordSys && coordSys.model !== targetCoordSysModel);\n}\n\nfunction getFixedItemStyle(model, scale) {\n    var itemStyle = model.getItemStyle();\n    var areaColor = model.get('areaColor');\n\n    // If user want the color not to be changed when hover,\n    // they should both set areaColor and color to be null.\n    if (areaColor != null) {\n        itemStyle.fill = areaColor;\n    }\n\n    return itemStyle;\n}\n\nfunction updateMapSelectHandler(mapDraw, mapOrGeoModel, group, api, fromView) {\n    group.off('click');\n    group.off('mousedown');\n\n    if (mapOrGeoModel.get('selectedMode')) {\n\n        group.on('mousedown', function () {\n            mapDraw._mouseDownFlag = true;\n        });\n\n        group.on('click', function (e) {\n            if (!mapDraw._mouseDownFlag) {\n                return;\n            }\n            mapDraw._mouseDownFlag = false;\n\n            var el = e.target;\n            while (!el.__regions) {\n                el = el.parent;\n            }\n            if (!el) {\n                return;\n            }\n\n            var action = {\n                type: (mapOrGeoModel.mainType === 'geo' ? 'geo' : 'map') + 'ToggleSelect',\n                batch: map(el.__regions, function (region) {\n                    return {\n                        name: region.name,\n                        from: fromView.uid\n                    };\n                })\n            };\n            action[mapOrGeoModel.mainType + 'Id'] = mapOrGeoModel.id;\n\n            api.dispatchAction(action);\n\n            updateMapSelected(mapOrGeoModel, group);\n        });\n    }\n}\n\nfunction updateMapSelected(mapOrGeoModel, group) {\n    // FIXME\n    group.eachChild(function (otherRegionEl) {\n        each$1(otherRegionEl.__regions, function (region) {\n            otherRegionEl.trigger(mapOrGeoModel.isSelected(region.name) ? 'emphasis' : 'normal');\n        });\n    });\n}\n\n/**\n * @alias module:echarts/component/helper/MapDraw\n * @param {module:echarts/ExtensionAPI} api\n * @param {boolean} updateGroup\n */\nfunction MapDraw(api, updateGroup) {\n\n    var group = new Group();\n\n    /**\n     * @type {module:echarts/component/helper/RoamController}\n     * @private\n     */\n    this._controller = new RoamController(api.getZr());\n\n    /**\n     * @type {Object} {target, zoom, zoomLimit}\n     * @private\n     */\n    this._controllerHost = {target: updateGroup ? group : null};\n\n    /**\n     * @type {module:zrender/container/Group}\n     * @readOnly\n     */\n    this.group = group;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this._updateGroup = updateGroup;\n\n    /**\n     * This flag is used to make sure that only one among\n     * `pan`, `zoom`, `click` can occurs, otherwise 'selected'\n     * action may be triggered when `pan`, which is unexpected.\n     * @type {booelan}\n     */\n    this._mouseDownFlag;\n}\n\nMapDraw.prototype = {\n\n    constructor: MapDraw,\n\n    draw: function (mapOrGeoModel, ecModel, api, fromView, payload) {\n\n        var isGeo = mapOrGeoModel.mainType === 'geo';\n\n        // Map series has data. GEO model that controlled by map series\n        // will be assigned with map data. Other GEO model has no data.\n        var data = mapOrGeoModel.getData && mapOrGeoModel.getData();\n        isGeo && ecModel.eachComponent({mainType: 'series', subType: 'map'}, function (mapSeries) {\n            if (!data && mapSeries.getHostGeoModel() === mapOrGeoModel) {\n                data = mapSeries.getData();\n            }\n        });\n\n        var geo = mapOrGeoModel.coordinateSystem;\n\n        var group = this.group;\n\n        var scale = geo.scale;\n        var groupNewProp = {\n            position: geo.position,\n            scale: scale\n        };\n\n        // No animation when first draw or in action\n        if (!group.childAt(0) || payload) {\n            group.attr(groupNewProp);\n        }\n        else {\n            updateProps(group, groupNewProp, mapOrGeoModel);\n        }\n\n        group.removeAll();\n\n        var itemStyleAccessPath = ['itemStyle', 'normal'];\n        var hoverItemStyleAccessPath = ['itemStyle', 'emphasis'];\n        var labelAccessPath = ['label', 'normal'];\n        var hoverLabelAccessPath = ['label', 'emphasis'];\n        var nameMap = createHashMap();\n\n        each$1(geo.regions, function (region) {\n\n            // Consider in GeoJson properties.name may be duplicated, for example,\n            // there is multiple region named \"United Kindom\" or \"France\" (so many\n            // colonies). And it is not appropriate to merge them in geo, which\n            // will make them share the same label and bring trouble in label\n            // location calculation.\n            var regionGroup = nameMap.get(region.name)\n                || nameMap.set(region.name, new Group());\n\n            var compoundPath = new CompoundPath({\n                shape: {\n                    paths: []\n                }\n            });\n            regionGroup.add(compoundPath);\n\n            var regionModel = mapOrGeoModel.getRegionModel(region.name) || mapOrGeoModel;\n\n            var itemStyleModel = regionModel.getModel(itemStyleAccessPath);\n            var hoverItemStyleModel = regionModel.getModel(hoverItemStyleAccessPath);\n            var itemStyle = getFixedItemStyle(itemStyleModel, scale);\n            var hoverItemStyle = getFixedItemStyle(hoverItemStyleModel, scale);\n\n            var labelModel = regionModel.getModel(labelAccessPath);\n            var hoverLabelModel = regionModel.getModel(hoverLabelAccessPath);\n\n            var dataIdx;\n            // Use the itemStyle in data if has data\n            if (data) {\n                dataIdx = data.indexOfName(region.name);\n                // Only visual color of each item will be used. It can be encoded by dataRange\n                // But visual color of series is used in symbol drawing\n                //\n                // Visual color for each series is for the symbol draw\n                var visualColor = data.getItemVisual(dataIdx, 'color', true);\n                if (visualColor) {\n                    itemStyle.fill = visualColor;\n                }\n            }\n\n            each$1(region.geometries, function (geometry) {\n                if (geometry.type !== 'polygon') {\n                    return;\n                }\n                compoundPath.shape.paths.push(new Polygon({\n                    shape: {\n                        points: geometry.exterior\n                    }\n                }));\n\n                for (var i = 0; i < (geometry.interiors ? geometry.interiors.length : 0); i++) {\n                    compoundPath.shape.paths.push(new Polygon({\n                        shape: {\n                            points: geometry.interiors[i]\n                        }\n                    }));\n                }\n            });\n\n            compoundPath.setStyle(itemStyle);\n            compoundPath.style.strokeNoScale = true;\n            compoundPath.culling = true;\n            // Label\n            var showLabel = labelModel.get('show');\n            var hoverShowLabel = hoverLabelModel.get('show');\n\n            var isDataNaN = data && isNaN(data.get('value', dataIdx));\n            var itemLayout = data && data.getItemLayout(dataIdx);\n            // In the following cases label will be drawn\n            // 1. In map series and data value is NaN\n            // 2. In geo component\n            // 4. Region has no series legendSymbol, which will be add a showLabel flag in mapSymbolLayout\n            if (\n                (isGeo || isDataNaN && (showLabel || hoverShowLabel))\n                || (itemLayout && itemLayout.showLabel)\n                ) {\n                var query = !isGeo ? dataIdx : region.name;\n                var labelFetcher;\n\n                // Consider dataIdx not found.\n                if (!data || dataIdx >= 0) {\n                    labelFetcher = mapOrGeoModel;\n                }\n\n                var textEl = new Text({\n                    position: region.center.slice(),\n                    scale: [1 / scale[0], 1 / scale[1]],\n                    z2: 10,\n                    silent: true\n                });\n\n                setLabelStyle(\n                    textEl.style, textEl.hoverStyle = {}, labelModel, hoverLabelModel,\n                    {\n                        labelFetcher: labelFetcher,\n                        labelDataIndex: query,\n                        defaultText: region.name,\n                        useInsideStyle: false\n                    },\n                    {\n                        textAlign: 'center',\n                        textVerticalAlign: 'middle'\n                    }\n                );\n\n                regionGroup.add(textEl);\n            }\n\n            // setItemGraphicEl, setHoverStyle after all polygons and labels\n            // are added to the rigionGroup\n            if (data) {\n                data.setItemGraphicEl(dataIdx, regionGroup);\n            }\n            else {\n                var regionModel = mapOrGeoModel.getRegionModel(region.name);\n                // Package custom mouse event for geo component\n                compoundPath.eventData = {\n                    componentType: 'geo',\n                    geoIndex: mapOrGeoModel.componentIndex,\n                    name: region.name,\n                    region: (regionModel && regionModel.option) || {}\n                };\n            }\n\n            var groupRegions = regionGroup.__regions || (regionGroup.__regions = []);\n            groupRegions.push(region);\n\n            setHoverStyle(\n                regionGroup,\n                hoverItemStyle,\n                {hoverSilentOnTouch: !!mapOrGeoModel.get('selectedMode')}\n            );\n\n            group.add(regionGroup);\n        });\n\n        this._updateController(mapOrGeoModel, ecModel, api);\n\n        updateMapSelectHandler(this, mapOrGeoModel, group, api, fromView);\n\n        updateMapSelected(mapOrGeoModel, group);\n    },\n\n    remove: function () {\n        this.group.removeAll();\n        this._controller.dispose();\n        this._controllerHost = {};\n    },\n\n    _updateController: function (mapOrGeoModel, ecModel, api) {\n        var geo = mapOrGeoModel.coordinateSystem;\n        var controller = this._controller;\n        var controllerHost = this._controllerHost;\n\n        controllerHost.zoomLimit = mapOrGeoModel.get('scaleLimit');\n        controllerHost.zoom = geo.getZoom();\n\n        // roamType is will be set default true if it is null\n        controller.enable(mapOrGeoModel.get('roam') || false);\n        var mainType = mapOrGeoModel.mainType;\n\n        function makeActionBase() {\n            var action = {\n                type: 'geoRoam',\n                componentType: mainType\n            };\n            action[mainType + 'Id'] = mapOrGeoModel.id;\n            return action;\n        }\n\n        controller.off('pan').on('pan', function (dx, dy) {\n            this._mouseDownFlag = false;\n\n            updateViewOnPan(controllerHost, dx, dy);\n\n            api.dispatchAction(extend(makeActionBase(), {\n                dx: dx,\n                dy: dy\n            }));\n        }, this);\n\n        controller.off('zoom').on('zoom', function (zoom, mouseX, mouseY) {\n            this._mouseDownFlag = false;\n\n            updateViewOnZoom(controllerHost, zoom, mouseX, mouseY);\n\n            api.dispatchAction(extend(makeActionBase(), {\n                zoom: zoom,\n                originX: mouseX,\n                originY: mouseY\n            }));\n\n            if (this._updateGroup) {\n                var group = this.group;\n                var scale = group.scale;\n                group.traverse(function (el) {\n                    if (el.type === 'text') {\n                        el.attr('scale', [1 / scale[0], 1 / scale[1]]);\n                    }\n                });\n            }\n        }, this);\n\n        controller.setPointerChecker(function (e, x, y) {\n            return geo.getViewRectAfterRoam().contain(x, y)\n                && !onIrrelevantElement(e, api, mapOrGeoModel);\n        });\n    }\n};\n\nextendChartView({\n\n    type: 'map',\n\n    render: function (mapModel, ecModel, api, payload) {\n        // Not render if it is an toggleSelect action from self\n        if (payload && payload.type === 'mapToggleSelect'\n            && payload.from === this.uid\n        ) {\n            return;\n        }\n\n        var group = this.group;\n        group.removeAll();\n\n        if (mapModel.getHostGeoModel()) {\n            return;\n        }\n\n        // Not update map if it is an roam action from self\n        if (!(payload && payload.type === 'geoRoam'\n                && payload.componentType === 'series'\n                && payload.seriesId === mapModel.id\n            )\n        ) {\n            if (mapModel.needsDrawMap) {\n                var mapDraw = this._mapDraw || new MapDraw(api, true);\n                group.add(mapDraw.group);\n\n                mapDraw.draw(mapModel, ecModel, api, this, payload);\n\n                this._mapDraw = mapDraw;\n            }\n            else {\n                // Remove drawed map\n                this._mapDraw && this._mapDraw.remove();\n                this._mapDraw = null;\n            }\n        }\n        else {\n            var mapDraw = this._mapDraw;\n            mapDraw && group.add(mapDraw.group);\n        }\n\n        mapModel.get('showLegendSymbol') && ecModel.getComponent('legend')\n            && this._renderSymbols(mapModel, ecModel, api);\n    },\n\n    remove: function () {\n        this._mapDraw && this._mapDraw.remove();\n        this._mapDraw = null;\n        this.group.removeAll();\n    },\n\n    dispose: function () {\n        this._mapDraw && this._mapDraw.remove();\n        this._mapDraw = null;\n    },\n\n    _renderSymbols: function (mapModel, ecModel, api) {\n        var originalData = mapModel.originalData;\n        var group = this.group;\n\n        originalData.each('value', function (value, idx) {\n            if (isNaN(value)) {\n                return;\n            }\n\n            var layout = originalData.getItemLayout(idx);\n\n            if (!layout || !layout.point) {\n                // Not exists in map\n                return;\n            }\n\n            var point = layout.point;\n            var offset = layout.offset;\n\n            var circle = new Circle({\n                style: {\n                    // Because the special of map draw.\n                    // Which needs statistic of multiple series and draw on one map.\n                    // And each series also need a symbol with legend color\n                    //\n                    // Layout and visual are put one the different data\n                    fill: mapModel.getData().getVisual('color')\n                },\n                shape: {\n                    cx: point[0] + offset * 9,\n                    cy: point[1],\n                    r: 3\n                },\n                silent: true,\n                // Do not overlap the first series, on which labels are displayed.\n                z2: !offset ? 10 : 8\n            });\n\n            // First data on the same region\n            if (!offset) {\n                var fullData = mapModel.mainSeries.getData();\n                var name = originalData.getName(idx);\n\n                var fullIndex = fullData.indexOfName(name);\n\n                var itemModel = originalData.getItemModel(idx);\n                var labelModel = itemModel.getModel('label.normal');\n                var hoverLabelModel = itemModel.getModel('label.emphasis');\n\n                var polygonGroups = fullData.getItemGraphicEl(fullIndex);\n\n                var normalText = retrieve2(\n                    mapModel.getFormattedLabel(idx, 'normal'),\n                    name\n                );\n                var emphasisText = retrieve2(\n                    mapModel.getFormattedLabel(idx, 'emphasis'),\n                    normalText\n                );\n\n                var onEmphasis = function () {\n                    var hoverStyle = setTextStyle({}, hoverLabelModel, {\n                        text: hoverLabelModel.get('show') ? emphasisText : null\n                    }, {isRectText: true, useInsideStyle: false}, true);\n                    circle.style.extendFrom(hoverStyle);\n                    // Make label upper than others if overlaps.\n                    circle.__mapOriginalZ2 = circle.z2;\n                    circle.z2 += 1;\n                };\n\n                var onNormal = function () {\n                    setTextStyle(circle.style, labelModel, {\n                        text: labelModel.get('show') ? normalText : null,\n                        textPosition: labelModel.getShallow('position') || 'bottom'\n                    }, {isRectText: true, useInsideStyle: false});\n\n                    if (circle.__mapOriginalZ2 != null) {\n                        circle.z2 = circle.__mapOriginalZ2;\n                        circle.__mapOriginalZ2 = null;\n                    }\n                };\n\n                polygonGroups.on('mouseover', onEmphasis)\n                    .on('mouseout', onNormal)\n                    .on('emphasis', onEmphasis)\n                    .on('normal', onNormal);\n\n                onNormal();\n            }\n\n            group.add(circle);\n        });\n    }\n});\n\n/**\n * @param {module:echarts/coord/View} view\n * @param {Object} payload\n * @param {Object} [zoomLimit]\n */\nfunction updateCenterAndZoom(\n    view, payload, zoomLimit\n) {\n    var previousZoom = view.getZoom();\n    var center = view.getCenter();\n    var zoom = payload.zoom;\n\n    var point = view.dataToPoint(center);\n\n    if (payload.dx != null && payload.dy != null) {\n        point[0] -= payload.dx;\n        point[1] -= payload.dy;\n\n        var center = view.pointToData(point);\n        view.setCenter(center);\n    }\n    if (zoom != null) {\n        if (zoomLimit) {\n            var zoomMin = zoomLimit.min || 0;\n            var zoomMax = zoomLimit.max || Infinity;\n            zoom = Math.max(\n                Math.min(previousZoom * zoom, zoomMax),\n                zoomMin\n            ) / previousZoom;\n        }\n\n        // Zoom on given point(originX, originY)\n        view.scale[0] *= zoom;\n        view.scale[1] *= zoom;\n        var position = view.position;\n        var fixX = (payload.originX - position[0]) * (zoom - 1);\n        var fixY = (payload.originY - position[1]) * (zoom - 1);\n\n        position[0] -= fixX;\n        position[1] -= fixY;\n\n        view.updateTransform();\n        // Get the new center\n        var center = view.pointToData(point);\n        view.setCenter(center);\n        view.setZoom(zoom * previousZoom);\n    }\n\n    return {\n        center: view.getCenter(),\n        zoom: view.getZoom()\n    };\n}\n\n/**\n * @payload\n * @property {string} [componentType=series]\n * @property {number} [dx]\n * @property {number} [dy]\n * @property {number} [zoom]\n * @property {number} [originX]\n * @property {number} [originY]\n */\nregisterAction({\n    type: 'geoRoam',\n    event: 'geoRoam',\n    update: 'updateLayout'\n}, function (payload, ecModel) {\n    var componentType = payload.componentType || 'series';\n\n    ecModel.eachComponent(\n        { mainType: componentType, query: payload },\n        function (componentModel) {\n            var geo = componentModel.coordinateSystem;\n            if (geo.type !== 'geo') {\n                return;\n            }\n\n            var res = updateCenterAndZoom(\n                geo, payload, componentModel.get('scaleLimit')\n            );\n\n            componentModel.setCenter\n                && componentModel.setCenter(res.center);\n\n            componentModel.setZoom\n                && componentModel.setZoom(res.zoom);\n\n            // All map series with same `map` use the same geo coordinate system\n            // So the center and zoom must be in sync. Include the series not selected by legend\n            if (componentType === 'series') {\n                each$1(componentModel.seriesGroup, function (seriesModel) {\n                    seriesModel.setCenter(res.center);\n                    seriesModel.setZoom(res.zoom);\n                });\n            }\n        }\n    );\n});\n\nvar mapSymbolLayout = function (ecModel) {\n\n    var processedMapType = {};\n\n    ecModel.eachSeriesByType('map', function (mapSeries) {\n        var mapType = mapSeries.getMapType();\n        if (mapSeries.getHostGeoModel() || processedMapType[mapType]) {\n            return;\n        }\n\n        var mapSymbolOffsets = {};\n\n        each$1(mapSeries.seriesGroup, function (subMapSeries) {\n            var geo = subMapSeries.coordinateSystem;\n            var data = subMapSeries.originalData;\n            if (subMapSeries.get('showLegendSymbol') && ecModel.getComponent('legend')) {\n                data.each('value', function (value, idx) {\n                    var name = data.getName(idx);\n                    var region = geo.getRegion(name);\n\n                    // If input series.data is [11, 22, '-'/null/undefined, 44],\n                    // it will be filled with NaN: [11, 22, NaN, 44] and NaN will\n                    // not be drawn. So here must validate if value is NaN.\n                    if (!region || isNaN(value)) {\n                        return;\n                    }\n\n                    var offset = mapSymbolOffsets[name] || 0;\n\n                    var point = geo.dataToPoint(region.center);\n\n                    mapSymbolOffsets[name] = offset + 1;\n\n                    data.setItemLayout(idx, {\n                        point: point,\n                        offset: offset\n                    });\n                });\n            }\n        });\n\n        // Show label of those region not has legendSymbol(which is offset 0)\n        var data = mapSeries.getData();\n        data.each(function (idx) {\n            var name = data.getName(idx);\n            var layout = data.getItemLayout(idx) || {};\n            layout.showLabel = !mapSymbolOffsets[name];\n            data.setItemLayout(idx, layout);\n        });\n\n        processedMapType[mapType] = true;\n    });\n};\n\nvar mapVisual = function (ecModel) {\n    ecModel.eachSeriesByType('map', function (seriesModel) {\n        var colorList = seriesModel.get('color');\n        var itemStyleModel = seriesModel.getModel('itemStyle.normal');\n\n        var areaColor = itemStyleModel.get('areaColor');\n        var color = itemStyleModel.get('color')\n            || colorList[seriesModel.seriesIndex % colorList.length];\n\n        seriesModel.getData().setVisual({\n            'areaColor': areaColor,\n            'color': color\n        });\n    });\n};\n\n// FIXME \n/**\n * @param {Array.<module:echarts/data/List>} datas\n * @param {string} statisticType 'average' 'sum'\n * @inner\n */\nfunction dataStatistics(datas, statisticType) {\n    var dataNameMap = {};\n    var dims = ['value'];\n\n    each$1(datas, function (data) {\n        data.each(dims, function (value, idx) {\n            // Add prefix to avoid conflict with Object.prototype.\n            var mapKey = 'ec-' + data.getName(idx);\n            dataNameMap[mapKey] = dataNameMap[mapKey] || [];\n            if (!isNaN(value)) {\n                dataNameMap[mapKey].push(value);\n            }\n        });\n    });\n\n    return datas[0].map(dims, function (value, idx) {\n        var mapKey = 'ec-' + datas[0].getName(idx);\n        var sum = 0;\n        var min = Infinity;\n        var max = -Infinity;\n        var len = dataNameMap[mapKey].length;\n        for (var i = 0; i < len; i++) {\n            min = Math.min(min, dataNameMap[mapKey][i]);\n            max = Math.max(max, dataNameMap[mapKey][i]);\n            sum += dataNameMap[mapKey][i];\n        }\n        var result;\n        if (statisticType === 'min') {\n            result = min;\n        }\n        else if (statisticType === 'max') {\n            result = max;\n        }\n        else if (statisticType === 'average') {\n            result = sum / len;\n        }\n        else {\n            result = sum;\n        }\n        return len === 0 ? NaN : result;\n    });\n}\n\nvar mapDataStatistic = function (ecModel) {\n    var seriesGroups = {};\n    ecModel.eachSeriesByType('map', function (seriesModel) {\n        var hostGeoModel = seriesModel.getHostGeoModel();\n        var key = hostGeoModel ? 'o' + hostGeoModel.id : 'i' + seriesModel.getMapType();\n        (seriesGroups[key] = seriesGroups[key] || []).push(seriesModel);\n    });\n\n    each$1(seriesGroups, function (seriesList, key) {\n        var data = dataStatistics(\n            map(seriesList, function (seriesModel) {\n                return seriesModel.getData();\n            }),\n            seriesList[0].get('mapValueCalculation')\n        );\n\n        for (var i = 0; i < seriesList.length; i++) {\n            seriesList[i].originalData = seriesList[i].getData();\n        }\n\n        // FIXME Put where?\n        for (var i = 0; i < seriesList.length; i++) {\n            seriesList[i].seriesGroup = seriesList;\n            seriesList[i].needsDrawMap = i === 0 && !seriesList[i].getHostGeoModel();\n\n            seriesList[i].setData(data.cloneShallow());\n            seriesList[i].mainSeries = seriesList[0];\n        }\n    });\n};\n\nvar backwardCompat$2 = function (option) {\n    // Save geoCoord\n    var mapSeries = [];\n    each$1(option.series, function (seriesOpt) {\n        if (seriesOpt && seriesOpt.type === 'map') {\n            mapSeries.push(seriesOpt);\n            seriesOpt.map = seriesOpt.map || seriesOpt.mapType;\n            // Put x, y, width, height, x2, y2 in the top level\n            defaults(seriesOpt, seriesOpt.mapLocation);\n        }\n    });\n};\n\nregisterLayout(mapSymbolLayout);\nregisterVisual(mapVisual);\nregisterProcessor(PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic);\nregisterPreprocessor(backwardCompat$2);\n\ncreateDataSelectAction('map', [{\n    type: 'mapToggleSelect',\n    event: 'mapselectchanged',\n    method: 'toggleSelected'\n}, {\n    type: 'mapSelect',\n    event: 'mapselected',\n    method: 'select'\n}, {\n    type: 'mapUnSelect',\n    event: 'mapunselected',\n    method: 'unSelect'\n}]);\n\n/**\n * Link lists and struct (graph or tree)\n */\n\nvar each$10 = each$1;\n\nvar DATAS = '\\0__link_datas';\nvar MAIN_DATA = '\\0__link_mainData';\n\n// Caution:\n// In most case, either list or its shallow clones (see list.cloneShallow)\n// is active in echarts process. So considering heap memory consumption,\n// we do not clone tree or graph, but share them among list and its shallow clones.\n// But in some rare case, we have to keep old list (like do animation in chart). So\n// please take care that both the old list and the new list share the same tree/graph.\n\n/**\n * @param {Object} opt\n * @param {module:echarts/data/List} opt.mainData\n * @param {Object} [opt.struct] For example, instance of Graph or Tree.\n * @param {string} [opt.structAttr] designation: list[structAttr] = struct;\n * @param {Object} [opt.datas] {dataType: data},\n *                 like: {node: nodeList, edge: edgeList}.\n *                 Should contain mainData.\n * @param {Object} [opt.datasAttr] {dataType: attr},\n *                 designation: struct[datasAttr[dataType]] = list;\n */\nfunction linkList(opt) {\n    var mainData = opt.mainData;\n    var datas = opt.datas;\n\n    if (!datas) {\n        datas = {main: mainData};\n        opt.datasAttr = {main: 'data'};\n    }\n    opt.datas = opt.mainData = null;\n\n    linkAll(mainData, datas, opt);\n\n    // Porxy data original methods.\n    each$10(datas, function (data) {\n        each$10(mainData.TRANSFERABLE_METHODS, function (methodName) {\n            data.wrapMethod(methodName, curry(transferInjection, opt));\n        });\n\n    });\n\n    // Beyond transfer, additional features should be added to `cloneShallow`.\n    mainData.wrapMethod('cloneShallow', curry(cloneShallowInjection, opt));\n\n    // Only mainData trigger change, because struct.update may trigger\n    // another changable methods, which may bring about dead lock.\n    each$10(mainData.CHANGABLE_METHODS, function (methodName) {\n        mainData.wrapMethod(methodName, curry(changeInjection, opt));\n    });\n\n    // Make sure datas contains mainData.\n    assert(datas[mainData.dataType] === mainData);\n}\n\nfunction transferInjection(opt, res) {\n    if (isMainData(this)) {\n        // Transfer datas to new main data.\n        var datas = extend({}, this[DATAS]);\n        datas[this.dataType] = res;\n        linkAll(res, datas, opt);\n    }\n    else {\n        // Modify the reference in main data to point newData.\n        linkSingle(res, this.dataType, this[MAIN_DATA], opt);\n    }\n    return res;\n}\n\nfunction changeInjection(opt, res) {\n    opt.struct && opt.struct.update(this);\n    return res;\n}\n\nfunction cloneShallowInjection(opt, res) {\n    // cloneShallow, which brings about some fragilities, may be inappropriate\n    // to be exposed as an API. So for implementation simplicity we can make\n    // the restriction that cloneShallow of not-mainData should not be invoked\n    // outside, but only be invoked here.\n    each$10(res[DATAS], function (data, dataType) {\n        data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);\n    });\n    return res;\n}\n\n/**\n * Supplement method to List.\n *\n * @public\n * @param {string} [dataType] If not specified, return mainData.\n * @return {module:echarts/data/List}\n */\nfunction getLinkedData(dataType) {\n    var mainData = this[MAIN_DATA];\n    return (dataType == null || mainData == null)\n        ? mainData\n        : mainData[DATAS][dataType];\n}\n\nfunction isMainData(data) {\n    return data[MAIN_DATA] === data;\n}\n\nfunction linkAll(mainData, datas, opt) {\n    mainData[DATAS] = {};\n    each$10(datas, function (data, dataType) {\n        linkSingle(data, dataType, mainData, opt);\n    });\n}\n\nfunction linkSingle(data, dataType, mainData, opt) {\n    mainData[DATAS][dataType] = data;\n    data[MAIN_DATA] = mainData;\n    data.dataType = dataType;\n\n    if (opt.struct) {\n        data[opt.structAttr] = opt.struct;\n        opt.struct[opt.datasAttr[dataType]] = data;\n    }\n\n    // Supplement method.\n    data.getLinkedData = getLinkedData;\n}\n\n/**\n * Tree data structure\n *\n * @module echarts/data/Tree\n */\n\n/**\n * @constructor module:echarts/data/Tree~TreeNode\n * @param {string} name\n * @param {module:echarts/data/Tree} hostTree\n */\nvar TreeNode = function (name, hostTree) {\n    /**\n     * @type {string}\n     */\n    this.name = name || '';\n\n    /**\n     * Depth of node\n     *\n     * @type {number}\n     * @readOnly\n     */\n    this.depth = 0;\n\n    /**\n     * Height of the subtree rooted at this node.\n     * @type {number}\n     * @readOnly\n     */\n    this.height = 0;\n\n    /**\n     * @type {module:echarts/data/Tree~TreeNode}\n     * @readOnly\n     */\n    this.parentNode = null;\n\n    /**\n     * Reference to list item.\n     * Do not persistent dataIndex outside,\n     * besause it may be changed by list.\n     * If dataIndex -1,\n     * this node is logical deleted (filtered) in list.\n     *\n     * @type {Object}\n     * @readOnly\n     */\n    this.dataIndex = -1;\n\n    /**\n     * @type {Array.<module:echarts/data/Tree~TreeNode>}\n     * @readOnly\n     */\n    this.children = [];\n\n    /**\n     * @type {Array.<module:echarts/data/Tree~TreeNode>}\n     * @pubilc\n     */\n    this.viewChildren = [];\n\n    /**\n     * @type {moduel:echarts/data/Tree}\n     * @readOnly\n     */\n    this.hostTree = hostTree;\n};\n\nTreeNode.prototype = {\n\n    constructor: TreeNode,\n\n    /**\n     * The node is removed.\n     * @return {boolean} is removed.\n     */\n    isRemoved: function () {\n        return this.dataIndex < 0;\n    },\n\n    /**\n     * Travel this subtree (include this node).\n     * Usage:\n     *    node.eachNode(function () { ... }); // preorder\n     *    node.eachNode('preorder', function () { ... }); // preorder\n     *    node.eachNode('postorder', function () { ... }); // postorder\n     *    node.eachNode(\n     *        {order: 'postorder', attr: 'viewChildren'},\n     *        function () { ... }\n     *    ); // postorder\n     *\n     * @param {(Object|string)} options If string, means order.\n     * @param {string=} options.order 'preorder' or 'postorder'\n     * @param {string=} options.attr 'children' or 'viewChildren'\n     * @param {Function} cb If in preorder and return false,\n     *                      its subtree will not be visited.\n     * @param {Object} [context]\n     */\n    eachNode: function (options, cb, context) {\n        if (typeof options === 'function') {\n            context = cb;\n            cb = options;\n            options = null;\n        }\n\n        options = options || {};\n        if (isString(options)) {\n            options = {order: options};\n        }\n\n        var order = options.order || 'preorder';\n        var children = this[options.attr || 'children'];\n\n        var suppressVisitSub;\n        order === 'preorder' && (suppressVisitSub = cb.call(context, this));\n\n        for (var i = 0; !suppressVisitSub && i < children.length; i++) {\n            children[i].eachNode(options, cb, context);\n        }\n\n        order === 'postorder' && cb.call(context, this);\n    },\n\n    /**\n     * Update depth and height of this subtree.\n     *\n     * @param  {number} depth\n     */\n    updateDepthAndHeight: function (depth) {\n        var height = 0;\n        this.depth = depth;\n        for (var i = 0; i < this.children.length; i++) {\n            var child = this.children[i];\n            child.updateDepthAndHeight(depth + 1);\n            if (child.height > height) {\n                height = child.height;\n            }\n        }\n        this.height = height + 1;\n    },\n\n    /**\n     * @param  {string} id\n     * @return {module:echarts/data/Tree~TreeNode}\n     */\n    getNodeById: function (id) {\n        if (this.getId() === id) {\n            return this;\n        }\n        for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n            var res = children[i].getNodeById(id);\n            if (res) {\n                return res;\n            }\n        }\n    },\n\n    /**\n     * @param {module:echarts/data/Tree~TreeNode} node\n     * @return {boolean}\n     */\n    contains: function (node) {\n        if (node === this) {\n            return true;\n        }\n        for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n            var res = children[i].contains(node);\n            if (res) {\n                return res;\n            }\n        }\n    },\n\n    /**\n     * @param {boolean} includeSelf Default false.\n     * @return {Array.<module:echarts/data/Tree~TreeNode>} order: [root, child, grandchild, ...]\n     */\n    getAncestors: function (includeSelf) {\n        var ancestors = [];\n        var node = includeSelf ? this : this.parentNode;\n        while (node) {\n            ancestors.push(node);\n            node = node.parentNode;\n        }\n        ancestors.reverse();\n        return ancestors;\n    },\n\n    /**\n     * @param {string|Array=} [dimension='value'] Default 'value'. can be 0, 1, 2, 3\n     * @return {number} Value.\n     */\n    getValue: function (dimension) {\n        var data = this.hostTree.data;\n        return data.get(data.getDimension(dimension || 'value'), this.dataIndex);\n    },\n\n    /**\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    setLayout: function (layout, merge$$1) {\n        this.dataIndex >= 0\n            && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge$$1);\n    },\n\n    /**\n     * @return {Object} layout\n     */\n    getLayout: function () {\n        return this.hostTree.data.getItemLayout(this.dataIndex);\n    },\n\n    /**\n     * @param {string} [path]\n     * @return {module:echarts/model/Model}\n     */\n    getModel: function (path) {\n        if (this.dataIndex < 0) {\n            return;\n        }\n        var hostTree = this.hostTree;\n        var itemModel = hostTree.data.getItemModel(this.dataIndex);\n        var levelModel = this.getLevelModel();\n        var leavesModel;\n        if (!levelModel && (this.children.length === 0 || (this.children.length !== 0 && this.isExpand === false))) {\n            leavesModel = this.getLeavesModel();\n        }\n        return itemModel.getModel(path, (levelModel || leavesModel || hostTree.hostModel).getModel(path));\n    },\n\n    /**\n     * @return {module:echarts/model/Model}\n     */\n    getLevelModel: function () {\n        return (this.hostTree.levelModels || [])[this.depth];\n    },\n\n    /**\n     * @return {module:echarts/model/Model}\n     */\n    getLeavesModel: function () {\n        return this.hostTree.leavesModel;\n    },\n\n    /**\n     * @example\n     *  setItemVisual('color', color);\n     *  setItemVisual({\n     *      'color': color\n     *  });\n     */\n    setVisual: function (key, value) {\n        this.dataIndex >= 0\n            && this.hostTree.data.setItemVisual(this.dataIndex, key, value);\n    },\n\n    /**\n     * Get item visual\n     */\n    getVisual: function (key, ignoreParent) {\n        return this.hostTree.data.getItemVisual(this.dataIndex, key, ignoreParent);\n    },\n\n    /**\n     * @public\n     * @return {number}\n     */\n    getRawIndex: function () {\n        return this.hostTree.data.getRawIndex(this.dataIndex);\n    },\n\n    /**\n     * @public\n     * @return {string}\n     */\n    getId: function () {\n        return this.hostTree.data.getId(this.dataIndex);\n    }\n};\n\n/**\n * @constructor\n * @alias module:echarts/data/Tree\n * @param {module:echarts/model/Model} hostModel\n * @param {Array.<Object>} levelOptions\n * @param {Object} leavesOption\n */\nfunction Tree(hostModel, levelOptions, leavesOption) {\n    /**\n     * @type {module:echarts/data/Tree~TreeNode}\n     * @readOnly\n     */\n    this.root;\n\n    /**\n     * @type {module:echarts/data/List}\n     * @readOnly\n     */\n    this.data;\n\n    /**\n     * Index of each item is the same as the raw index of coresponding list item.\n     * @private\n     * @type {Array.<module:echarts/data/Tree~TreeNode}\n     */\n    this._nodes = [];\n\n    /**\n     * @private\n     * @readOnly\n     * @type {module:echarts/model/Model}\n     */\n    this.hostModel = hostModel;\n\n    /**\n     * @private\n     * @readOnly\n     * @type {Array.<module:echarts/model/Model}\n     */\n    this.levelModels = map(levelOptions || [], function (levelDefine) {\n        return new Model(levelDefine, hostModel, hostModel.ecModel);\n    });\n\n    this.leavesModel = new Model(leavesOption || {}, hostModel, hostModel.ecModel);\n}\n\nTree.prototype = {\n\n    constructor: Tree,\n\n    type: 'tree',\n\n    /**\n     * Travel this subtree (include this node).\n     * Usage:\n     *    node.eachNode(function () { ... }); // preorder\n     *    node.eachNode('preorder', function () { ... }); // preorder\n     *    node.eachNode('postorder', function () { ... }); // postorder\n     *    node.eachNode(\n     *        {order: 'postorder', attr: 'viewChildren'},\n     *        function () { ... }\n     *    ); // postorder\n     *\n     * @param {(Object|string)} options If string, means order.\n     * @param {string=} options.order 'preorder' or 'postorder'\n     * @param {string=} options.attr 'children' or 'viewChildren'\n     * @param {Function} cb\n     * @param {Object}   [context]\n     */\n    eachNode: function(options, cb, context) {\n        this.root.eachNode(options, cb, context);\n    },\n\n    /**\n     * @param {number} dataIndex\n     * @return {module:echarts/data/Tree~TreeNode}\n     */\n    getNodeByDataIndex: function (dataIndex) {\n        var rawIndex = this.data.getRawIndex(dataIndex);\n        return this._nodes[rawIndex];\n    },\n\n    /**\n     * @param {string} name\n     * @return {module:echarts/data/Tree~TreeNode}\n     */\n    getNodeByName: function (name) {\n        return this.root.getNodeByName(name);\n    },\n\n    /**\n     * Update item available by list,\n     * when list has been performed options like 'filterSelf' or 'map'.\n     */\n    update: function () {\n        var data = this.data;\n        var nodes = this._nodes;\n\n        for (var i = 0, len = nodes.length; i < len; i++) {\n            nodes[i].dataIndex = -1;\n        }\n\n        for (var i = 0, len = data.count(); i < len; i++) {\n            nodes[data.getRawIndex(i)].dataIndex = i;\n        }\n    },\n\n    /**\n     * Clear all layouts\n     */\n    clearLayouts: function () {\n        this.data.clearItemLayouts();\n    }\n};\n\n/**\n * data node format:\n * {\n *     name: ...\n *     value: ...\n *     children: [\n *         {\n *             name: ...\n *             value: ...\n *             children: ...\n *         },\n *         ...\n *     ]\n * }\n *\n * @static\n * @param {Object} dataRoot Root node.\n * @param {module:echarts/model/Model} hostModel\n * @param {Object} treeOptions\n * @param {Array.<Object>} treeOptions.levels\n * @param {Array.<Object>} treeOptions.leaves\n * @return module:echarts/data/Tree\n */\nTree.createTree = function (dataRoot, hostModel, treeOptions) {\n\n    var tree = new Tree(hostModel, treeOptions.levels, treeOptions.leaves);\n    var listData = [];\n    var dimMax = 1;\n\n    buildHierarchy(dataRoot);\n\n    function buildHierarchy(dataNode, parentNode) {\n        var value = dataNode.value;\n        dimMax = Math.max(dimMax, isArray(value) ? value.length : 1);\n\n        listData.push(dataNode);\n\n        var node = new TreeNode(dataNode.name, tree);\n        parentNode\n            ? addChild(node, parentNode)\n            : (tree.root = node);\n\n        tree._nodes.push(node);\n\n        var children = dataNode.children;\n        if (children) {\n            for (var i = 0; i < children.length; i++) {\n                buildHierarchy(children[i], node);\n            }\n        }\n    }\n\n    tree.root.updateDepthAndHeight(0);\n\n    var dimensions = completeDimensions([{name: 'value'}], listData, {dimCount: dimMax});\n    var list = new List(dimensions, hostModel);\n    list.initData(listData);\n\n    linkList({\n        mainData: list,\n        struct: tree,\n        structAttr: 'tree'\n    });\n\n    tree.update();\n\n    return tree;\n};\n\n/**\n * It is needed to consider the mess of 'list', 'hostModel' when creating a TreeNote,\n * so this function is not ready and not necessary to be public.\n *\n * @param {(module:echarts/data/Tree~TreeNode|Object)} child\n */\nfunction addChild(child, node) {\n    var children = node.children;\n    if (child.parentNode === node) {\n        return;\n    }\n\n    children.push(child);\n    child.parentNode = node;\n}\n\n/**\n * @file Create data struct and define tree view's series model\n */\n\nSeriesModel.extend({\n\n    type: 'series.tree',\n\n    layoutInfo: null,\n\n    // can support the position parameters 'left', 'top','right','bottom', 'width',\n    // 'height' in the setOption() with 'merge' mode normal.\n    layoutMode: 'box',\n\n    /**\n     * Init a tree data structure from data in option series\n     * @param  {Object} option  the object used to config echarts view\n     * @return {module:echarts/data/List} storage initial data\n     */\n    getInitialData: function (option) {\n\n        //create an virtual root\n        var root = {name: option.name, children: option.data};\n\n        var leaves = option.leaves || {};\n\n        var treeOption = {};\n\n        treeOption.leaves = leaves;\n\n        var tree = Tree.createTree(root, this, treeOption);\n\n        var treeDepth = 0;\n\n        tree.eachNode('preorder', function (node) {\n            if (node.depth > treeDepth) {\n                treeDepth = node.depth;\n            }\n        });\n\n        var expandAndCollapse = option.expandAndCollapse;\n        var expandTreeDepth = (expandAndCollapse && option.initialTreeDepth >= 0)\n            ? option.initialTreeDepth : treeDepth;\n\n        tree.root.eachNode('preorder', function (node) {\n            var item = node.hostTree.data.getRawDataItem(node.dataIndex);\n            node.isExpand = (item && item.collapsed != null)\n                ? !item.collapsed\n                : node.depth <= expandTreeDepth;\n        });\n\n        return tree.data;\n    },\n\n    /**\n     * @override\n     * @param {number} dataIndex\n     */\n    formatTooltip: function (dataIndex) {\n        var tree = this.getData().tree;\n        var realRoot = tree.root.children[0];\n        var node = tree.getNodeByDataIndex(dataIndex);\n        var value = node.getValue();\n        var name = node.name;\n        while (node && (node !== realRoot)) {\n            name = node.parentNode.name + '.' + name;\n            node = node.parentNode;\n        }\n        return encodeHTML(name + (\n            (isNaN(value) || value == null) ? '' : ' : ' + value\n        ));\n    },\n\n    defaultOption: {\n        zlevel: 0,\n        z: 2,\n\n        // the position of the whole view\n        left: '12%',\n        top: '12%',\n        right: '12%',\n        bottom: '12%',\n\n        // the layout of the tree, two value can be selected, 'orthogonal' or 'radial'\n        layout: 'orthogonal',\n\n        // the orient of orthoginal layout, can be setted to 'horizontal' or 'vertical'\n        orient: 'horizontal',\n\n        symbol: 'emptyCircle',\n\n        symbolSize: 7,\n\n        expandAndCollapse: true,\n\n        initialTreeDepth: 2,\n\n        lineStyle: {\n            normal: {\n                color: '#ccc',\n                width: 1.5,\n                curveness: 0.5\n            }\n        },\n\n        itemStyle: {\n            normal: {\n                color: 'lightsteelblue',\n                borderColor: '#c23531',\n                borderWidth: 1.5\n            }\n        },\n\n        label: {\n            normal: {\n                show: true,\n                color: '#555'\n            }\n        },\n\n        leaves: {\n            label: {\n                normal: {\n                    show: true\n                }\n            }\n        },\n\n        animationEasing: 'linear',\n\n        animationDuration: 700,\n\n        animationDurationUpdate: 1000\n    }\n});\n\n/**\n * @file The layout algorithm of node-link tree diagrams. Here we using Reingold-Tilford algorithm to drawing\n *       the tree.\n * @see https://github.com/d3/d3-hierarchy\n */\n\n/**\n * Initialize all computational message for following algorithm\n * @param  {module:echarts/data/Tree~TreeNode} root   The virtual root of the tree\n */\nfunction init$2(root) {\n    root.hierNode = {\n        defaultAncestor: null,\n        ancestor: root,\n        prelim: 0,\n        modifier: 0,\n        change: 0,\n        shift: 0,\n        i: 0,\n        thread: null\n    };\n\n    var nodes = [root];\n    var node;\n    var children;\n\n    while (node = nodes.pop()) { // jshint ignore:line\n        children = node.children;\n        if (node.isExpand && children.length) {\n            var n = children.length;\n            for (var i = n - 1; i >= 0; i--) {\n                var child = children[i];\n                child.hierNode = {\n                    defaultAncestor: null,\n                    ancestor: child,\n                    prelim: 0,\n                    modifier: 0,\n                    change: 0,\n                    shift: 0,\n                    i: i,\n                    thread: null\n                };\n                nodes.push(child);\n            }\n        }\n    }\n}\n\n/**\n * Computes a preliminary x coordinate for node. Before that, this function is\n * applied recursively to the children of node, as well as the function\n * apportion(). After spacing out the children by calling executeShifts(), the\n * node is placed to the midpoint of its outermost children.\n * @param  {module:echarts/data/Tree~TreeNode} node\n * @param {Function} separation\n */\nfunction firstWalk(node, separation) {\n    var children = node.isExpand ? node.children : [];\n    var siblings = node.parentNode.children;\n    var subtreeW = node.hierNode.i ? siblings[node.hierNode.i -1] : null;\n    if (children.length) {\n        executeShifts(node);\n        var midPoint = (children[0].hierNode.prelim + children[children.length - 1].hierNode.prelim) / 2;\n        if (subtreeW) {\n            node.hierNode.prelim = subtreeW.hierNode.prelim + separation(node, subtreeW);\n            node.hierNode.modifier = node.hierNode.prelim - midPoint;\n        }\n        else {\n            node.hierNode.prelim = midPoint;\n        }\n    }\n    else if (subtreeW) {\n        node.hierNode.prelim = subtreeW.hierNode.prelim + separation(node, subtreeW);\n    }\n    node.parentNode.hierNode.defaultAncestor = apportion(node, subtreeW, node.parentNode.hierNode.defaultAncestor || siblings[0], separation);\n}\n\n\n/**\n * Computes all real x-coordinates by summing up the modifiers recursively.\n * @param  {module:echarts/data/Tree~TreeNode} node\n */\nfunction secondWalk(node) {\n    var nodeX = node.hierNode.prelim + node.parentNode.hierNode.modifier;\n    node.setLayout({x: nodeX}, true);\n    node.hierNode.modifier += node.parentNode.hierNode.modifier;\n}\n\n\nfunction separation(cb) {\n    return arguments.length ? cb : defaultSeparation;\n}\n\n/**\n * Transform the common coordinate to radial coordinate\n * @param  {number} x\n * @param  {number} y\n * @return {Object}\n */\nfunction radialCoordinate(x, y) {\n    var radialCoor = {};\n    x -= Math.PI / 2;\n    radialCoor.x = y * Math.cos(x);\n    radialCoor.y = y * Math.sin(x);\n    return radialCoor;\n}\n\n/**\n * Get the layout position of the whole view\n * @param {module:echarts/model/Series} seriesModel  the model object of sankey series\n * @param {module:echarts/ExtensionAPI} api  provide the API list that the developer can call\n * @return {module:zrender/core/BoundingRect}  size of rect to draw the sankey view\n */\nfunction getViewRect(seriesModel, api) {\n    return getLayoutRect(\n        seriesModel.getBoxLayoutParams(), {\n            width: api.getWidth(),\n            height: api.getHeight()\n        }\n    );\n}\n\n/**\n * All other shifts, applied to the smaller subtrees between w- and w+, are\n * performed by this function.\n * @param  {module:echarts/data/Tree~TreeNode} node\n */\nfunction executeShifts(node) {\n    var children = node.children;\n    var n = children.length;\n    var shift = 0;\n    var change = 0;\n    while (--n >= 0) {\n        var child = children[n];\n        child.hierNode.prelim += shift;\n        child.hierNode.modifier += shift;\n        change += child.hierNode.change;\n        shift += child.hierNode.shift + change;\n    }\n}\n\n/**\n * The core of the algorithm. Here, a new subtree is combined with the\n * previous subtrees. Threads are used to traverse the inside and outside\n * contours of the left and right subtree up to the highest common level.\n * Whenever two nodes of the inside contours conflict, we compute the left\n * one of the greatest uncommon ancestors using the function nextAncestor()\n * and call moveSubtree() to shift the subtree and prepare the shifts of\n * smaller subtrees. Finally, we add a new thread (if necessary).\n * @param  {module:echarts/data/Tree~TreeNode} subtreeV\n * @param  {module:echarts/data/Tree~TreeNode} subtreeW\n * @param  {module:echarts/data/Tree~TreeNode} ancestor\n * @param  {Function} separation\n * @return {module:echarts/data/Tree~TreeNode}\n */\nfunction apportion(subtreeV, subtreeW, ancestor, separation) {\n\n    if (subtreeW) {\n        var nodeOutRight = subtreeV;\n        var nodeInRight = subtreeV;\n        var nodeOutLeft = nodeInRight.parentNode.children[0];\n        var nodeInLeft = subtreeW;\n\n        var sumOutRight = nodeOutRight.hierNode.modifier;\n        var sumInRight = nodeInRight.hierNode.modifier;\n        var sumOutLeft = nodeOutLeft.hierNode.modifier;\n        var sumInLeft = nodeInLeft.hierNode.modifier;\n\n        while (nodeInLeft = nextRight(nodeInLeft), nodeInRight = nextLeft(nodeInRight), nodeInLeft && nodeInRight) {\n            nodeOutRight = nextRight(nodeOutRight);\n            nodeOutLeft = nextLeft(nodeOutLeft);\n            nodeOutRight.hierNode.ancestor = subtreeV;\n            var shift = nodeInLeft.hierNode.prelim + sumInLeft - nodeInRight.hierNode.prelim\n                    - sumInRight + separation(nodeInLeft, nodeInRight);\n            if (shift > 0) {\n                moveSubtree(nextAncestor(nodeInLeft, subtreeV, ancestor), subtreeV, shift);\n                sumInRight += shift;\n                sumOutRight += shift;\n            }\n            sumInLeft += nodeInLeft.hierNode.modifier;\n            sumInRight += nodeInRight.hierNode.modifier;\n            sumOutRight += nodeOutRight.hierNode.modifier;\n            sumOutLeft += nodeOutLeft.hierNode.modifier;\n        }\n        if (nodeInLeft && !nextRight(nodeOutRight)) {\n            nodeOutRight.hierNode.thread = nodeInLeft;\n            nodeOutRight.hierNode.modifier += sumInLeft - sumOutRight;\n\n        }\n        if (nodeInRight && !nextLeft(nodeOutLeft)) {\n            nodeOutLeft.hierNode.thread = nodeInRight;\n            nodeOutLeft.hierNode.modifier += sumInRight - sumOutLeft;\n            ancestor = subtreeV;\n        }\n    }\n    return ancestor;\n}\n\n/**\n * This function is used to traverse the right contour of a subtree.\n * It returns the rightmost child of node or the thread of node. The function\n * returns null if and only if node is on the highest depth of its subtree.\n * @param  {module:echarts/data/Tree~TreeNode} node\n * @return {module:echarts/data/Tree~TreeNode}\n */\nfunction nextRight(node) {\n    var children = node.children;\n    return children.length && node.isExpand ? children[children.length - 1] : node.hierNode.thread;\n}\n\n/**\n * This function is used to traverse the left contour of a subtree (or a subforest).\n * It returns the leftmost child of node or the thread of node. The function\n * returns null if and only if node is on the highest depth of its subtree.\n * @param  {module:echarts/data/Tree~TreeNode} node\n * @return {module:echarts/data/Tree~TreeNode}\n */\nfunction nextLeft(node) {\n    var children = node.children;\n    return children.length && node.isExpand ? children[0] : node.hierNode.thread;\n}\n\n/**\n * If nodeInLefts ancestor is a sibling of node, returns nodeInLefts ancestor.\n * Otherwise, returns the specified ancestor.\n * @param  {module:echarts/data/Tree~TreeNode} nodeInLeft\n * @param  {module:echarts/data/Tree~TreeNode} node\n * @param  {module:echarts/data/Tree~TreeNode} ancestor\n * @return {module:echarts/data/Tree~TreeNode}\n */\nfunction nextAncestor(nodeInLeft, node, ancestor) {\n    return nodeInLeft.hierNode.ancestor.parentNode === node.parentNode\n        ? nodeInLeft.hierNode.ancestor : ancestor;\n}\n\n/**\n * Shifts the current subtree rooted at wr. This is done by increasing prelim(w+) and modifier(w+) by shift.\n * @param  {module:echarts/data/Tree~TreeNode} wl\n * @param  {module:echarts/data/Tree~TreeNode} wr\n * @param  {number} shift [description]\n */\nfunction moveSubtree(wl, wr,shift) {\n    var change = shift / (wr.hierNode.i - wl.hierNode.i);\n    wr.hierNode.change -= change;\n    wr.hierNode.shift += shift;\n    wr.hierNode.modifier += shift;\n    wr.hierNode.prelim += shift;\n    wl.hierNode.change += change;\n}\n\nfunction defaultSeparation(node1, node2) {\n    return node1.parentNode === node2.parentNode ? 1 : 2;\n}\n\n/**\n * @file  This file used to draw tree view\n */\n\nextendChartView({\n\n    type: 'tree',\n\n    /**\n     * Init the chart\n     * @override\n     * @param  {module:echarts/model/Global} ecModel\n     * @param  {module:echarts/ExtensionAPI} api\n     */\n    init: function (ecModel, api) {\n\n        /**\n         * @private\n         * @type {module:echarts/data/Tree}\n         */\n        this._oldTree;\n\n        /**\n         * @private\n         * @type {module:zrender/container/Group}\n         */\n        this._mainGroup = new Group();\n\n        this.group.add(this._mainGroup);\n    },\n\n    render: function (seriesModel, ecModel, api, payload) {\n\n        var data = seriesModel.getData();\n\n        var layoutInfo = seriesModel.layoutInfo;\n\n        var group = this._mainGroup;\n\n        var layout = seriesModel.get('layout');\n\n        if (layout === 'radial') {\n            group.attr('position', [layoutInfo.x + layoutInfo.width / 2, layoutInfo.y + layoutInfo.height / 2]);\n        }\n        else {\n            group.attr('position', [layoutInfo.x, layoutInfo.y]);\n        }\n\n        var oldData = this._data;\n\n        var seriesScope = {\n            expandAndCollapse: seriesModel.get('expandAndCollapse'),\n            layout: layout,\n            orient: seriesModel.get('orient'),\n            curvature: seriesModel.get('lineStyle.normal.curveness'),\n            symbolRotate: seriesModel.get('symbolRotate'),\n            symbolOffset: seriesModel.get('symbolOffset'),\n            hoverAnimation: seriesModel.get('hoverAnimation'),\n            useNameLabel: true,\n            fadeIn: true\n        };\n\n        data.diff(oldData)\n            .add(function (newIdx) {\n                if (symbolNeedsDraw$1(data, newIdx)) {\n                    // create node and edge\n                    updateNode(data, newIdx, null, group, seriesModel, seriesScope);\n                }\n            })\n            .update(function (newIdx, oldIdx) {\n                var symbolEl = oldData.getItemGraphicEl(oldIdx);\n                if (!symbolNeedsDraw$1(data, newIdx)) {\n                    symbolEl && removeNode(data, newIdx, symbolEl, group, seriesModel, seriesScope);\n                    return;\n                }\n                // update  node and edge\n                updateNode(data, newIdx, symbolEl, group, seriesModel, seriesScope);\n            })\n            .remove(function (oldIdx) {\n                var symbolEl = oldData.getItemGraphicEl(oldIdx);\n                removeNode(data, oldIdx, symbolEl, group, seriesModel, seriesScope);\n            })\n            .execute();\n\n        if (seriesScope.expandAndCollapse === true) {\n            data.eachItemGraphicEl(function (el, dataIndex) {\n                el.off('click').on('click', function () {\n                    api.dispatchAction({\n                        type: 'treeExpandAndCollapse',\n                        seriesId: seriesModel.id,\n                        dataIndex: dataIndex\n                    });\n                });\n            });\n        }\n\n        this._data = data;\n    },\n\n    dispose: function () {},\n\n    remove: function () {\n        this._mainGroup.removeAll();\n        this._data = null;\n    }\n\n});\n\nfunction symbolNeedsDraw$1(data, dataIndex) {\n    var layout = data.getItemLayout(dataIndex);\n\n    return layout\n        && !isNaN(layout.x) && !isNaN(layout.y)\n        && data.getItemVisual(dataIndex, 'symbol') !== 'none';\n}\n\nfunction getTreeNodeStyle(node, itemModel, seriesScope) {\n    seriesScope.itemModel = itemModel;\n    seriesScope.itemStyle = itemModel.getModel('itemStyle.normal').getItemStyle();\n    seriesScope.hoverItemStyle = itemModel.getModel('itemStyle.emphasis').getItemStyle();\n    seriesScope.lineStyle = itemModel.getModel('lineStyle.normal').getLineStyle();\n    seriesScope.labelModel = itemModel.getModel('label.normal');\n    seriesScope.hoverLabelModel = itemModel.getModel('label.emphasis');\n\n    if (node.isExpand === false && node.children.length !== 0) {\n        seriesScope.symbolInnerColor = seriesScope.itemStyle.fill;\n    }\n    else {\n        seriesScope.symbolInnerColor = '#fff';\n    }\n\n    return seriesScope;\n}\n\nfunction updateNode(data, dataIndex, symbolEl, group, seriesModel, seriesScope) {\n    var isInit = !symbolEl;\n    var node = data.tree.getNodeByDataIndex(dataIndex);\n    var itemModel = node.getModel();\n    var seriesScope = getTreeNodeStyle(node, itemModel, seriesScope);\n    var virtualRoot = data.tree.root;\n\n    var source = node.parentNode === virtualRoot ? node : node.parentNode || node;\n    var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);\n    var sourceLayout = source.getLayout();\n    var sourceOldLayout = sourceSymbolEl\n        ? {\n            x: sourceSymbolEl.position[0],\n            y: sourceSymbolEl.position[1],\n            rawX: sourceSymbolEl.__radialOldRawX,\n            rawY: sourceSymbolEl.__radialOldRawY\n        }\n        : sourceLayout;\n    var targetLayout = node.getLayout();\n\n    if (isInit) {\n        symbolEl = new SymbolClz$1(data, dataIndex, seriesScope);\n        symbolEl.attr('position', [sourceOldLayout.x, sourceOldLayout.y]);\n    }\n    else {\n        symbolEl.updateData(data, dataIndex, seriesScope);\n    }\n\n    symbolEl.__radialOldRawX = symbolEl.__radialRawX;\n    symbolEl.__radialOldRawY = symbolEl.__radialRawY;\n    symbolEl.__radialRawX = targetLayout.rawX;\n    symbolEl.__radialRawY = targetLayout.rawY;\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(dataIndex, symbolEl);\n    updateProps(symbolEl, {\n        position: [targetLayout.x, targetLayout.y]\n    }, seriesModel);\n\n    var symbolPath = symbolEl.getSymbolPath();\n\n    if (seriesScope.layout === 'radial') {\n        var realRoot = virtualRoot.children[0];\n        var rootLayout = realRoot.getLayout();\n        var length = realRoot.children.length;\n        var rad;\n        var isLeft;\n\n        if (targetLayout.x === rootLayout.x && node.isExpand === true) {\n            var center = {};\n            center.x = (realRoot.children[0].getLayout().x + realRoot.children[length - 1].getLayout().x) / 2;\n            center.y = (realRoot.children[0].getLayout().y + realRoot.children[length - 1].getLayout().y) / 2;\n            rad = Math.atan2(center.y - rootLayout.y, center.x - rootLayout.x);\n            if (rad < 0) {\n                rad = Math.PI * 2 + rad;\n            }\n            isLeft = center.x < rootLayout.x;\n            if (isLeft) {\n                rad = rad - Math.PI;\n            }\n        }\n        else {\n            rad = Math.atan2(targetLayout.y - rootLayout.y, targetLayout.x - rootLayout.x);\n            if (rad < 0) {\n                rad = Math.PI * 2 + rad;\n            }\n            if (node.children.length === 0 || (node.children.length !== 0 && node.isExpand === false)) {\n                isLeft = targetLayout.x < rootLayout.x;\n                if (isLeft) {\n                    rad = rad - Math.PI;\n                }\n            }\n            else {\n                isLeft = targetLayout.x > rootLayout.x;\n                if (!isLeft) {\n                    rad = rad - Math.PI;\n                }\n            }\n        }\n\n        var textPosition = isLeft ? 'left' : 'right';\n        symbolPath.setStyle({\n            textPosition: textPosition,\n            textRotation: -rad,\n            textOrigin: 'center',\n            verticalAlign: 'middle'\n        });\n    }\n\n    if (node.parentNode && node.parentNode !== virtualRoot) {\n        var edge = symbolEl.__edge;\n        if (!edge) {\n            edge = symbolEl.__edge = new BezierCurve({\n                shape: getEdgeShape(seriesScope, sourceOldLayout, sourceOldLayout),\n                style: defaults({opacity: 0}, seriesScope.lineStyle)\n            });\n        }\n\n        updateProps(edge, {\n            shape: getEdgeShape(seriesScope, sourceLayout, targetLayout),\n            style: {opacity: 1}\n        }, seriesModel);\n\n        group.add(edge);\n    }\n}\n\nfunction removeNode(data, dataIndex, symbolEl, group, seriesModel, seriesScope) {\n    var node = data.tree.getNodeByDataIndex(dataIndex);\n    var virtualRoot = data.tree.root;\n    var itemModel = node.getModel();\n    var seriesScope = getTreeNodeStyle(node, itemModel, seriesScope);\n\n    var source = node.parentNode === virtualRoot ? node : node.parentNode || node;\n    var sourceLayout;\n    while (sourceLayout = source.getLayout(), sourceLayout == null) {\n        source = source.parentNode === virtualRoot ? source : source.parentNode || source;\n    }\n\n    updateProps(symbolEl, {\n        position: [sourceLayout.x + 1, sourceLayout.y + 1]\n    }, seriesModel, function () {\n        group.remove(symbolEl);\n        data.setItemGraphicEl(dataIndex, null);\n    });\n\n    symbolEl.fadeOut(null, {keepLabel: true});\n\n    var edge = symbolEl.__edge;\n    if (edge) {\n        updateProps(edge, {\n            shape: getEdgeShape(seriesScope, sourceLayout, sourceLayout),\n            style: {\n                opacity: 0\n            }\n        }, seriesModel, function () {\n            group.remove(edge);\n        });\n    }\n}\n\nfunction getEdgeShape(seriesScope, sourceLayout, targetLayout) {\n    var cpx1;\n    var cpy1;\n    var cpx2;\n    var cpy2;\n    var orient = seriesScope.orient;\n\n    if (seriesScope.layout === 'radial') {\n        var x1 = sourceLayout.rawX;\n        var y1 = sourceLayout.rawY;\n        var x2 = targetLayout.rawX;\n        var y2 = targetLayout.rawY;\n\n        var radialCoor1 = radialCoordinate(x1, y1);\n        var radialCoor2 = radialCoordinate(x1, y1 + (y2 - y1) * seriesScope.curvature);\n        var radialCoor3 = radialCoordinate(x2, y2 + (y1 - y2) * seriesScope.curvature);\n        var radialCoor4 = radialCoordinate(x2, y2);\n\n        return {\n            x1: radialCoor1.x,\n            y1: radialCoor1.y,\n            x2: radialCoor4.x,\n            y2: radialCoor4.y,\n            cpx1: radialCoor2.x,\n            cpy1: radialCoor2.y,\n            cpx2: radialCoor3.x,\n            cpy2: radialCoor3.y\n        };\n    }\n    else {\n        var x1 = sourceLayout.x;\n        var y1 = sourceLayout.y;\n        var x2 = targetLayout.x;\n        var y2 = targetLayout.y;\n\n        if (orient === 'horizontal') {\n            cpx1 = x1 + (x2 - x1) * seriesScope.curvature;\n            cpy1 = y1;\n            cpx2 = x2 + (x1 - x2) * seriesScope.curvature;\n            cpy2 = y2;\n        }\n        if (orient === 'vertical') {\n            cpx1 = x1;\n            cpy1 = y1 + (y2 - y1) * seriesScope.curvature;\n            cpx2 = x2;\n            cpy2 = y2 + (y1 - y2) * seriesScope.curvature;\n        }\n        return {\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2,\n            cpx1: cpx1,\n            cpy1: cpy1,\n            cpx2: cpx2,\n            cpy2: cpy2\n        };\n    }\n}\n\nregisterAction({\n    type: 'treeExpandAndCollapse',\n    event: 'treeExpandAndCollapse',\n    update: 'update'\n}, function (payload, ecModel) {\n    ecModel.eachComponent({mainType: 'series', subType: 'tree', query: payload}, function (seriesModel) {\n        var dataIndex = payload.dataIndex;\n        var tree = seriesModel.getData().tree;\n        var node = tree.getNodeByDataIndex(dataIndex);\n        node.isExpand = !node.isExpand;\n\n    });\n});\n\n/**\n * Traverse the tree from bottom to top and do something\n * @param  {module:echarts/data/Tree~TreeNode} root  The real root of the tree\n * @param  {Function} callback\n */\nfunction eachAfter (root, callback, separation) {\n    var nodes = [root];\n    var next = [];\n    var node;\n\n    while (node = nodes.pop()) { // jshint ignore:line\n        next.push(node);\n        if (node.isExpand) {\n            var children = node.children;\n            if (children.length) {\n                for (var i = 0; i < children.length; i++) {\n                    nodes.push(children[i]);\n                }\n            }\n        }\n    }\n\n    while (node = next.pop()) { // jshint ignore:line\n        callback(node, separation);\n    }\n}\n\n/**\n * Traverse the tree from top to bottom and do something\n * @param  {module:echarts/data/Tree~TreeNode} root  The real root of the tree\n * @param  {Function} callback\n */\nfunction eachBefore (root, callback) {\n    var nodes = [root];\n    var node;\n    while (node = nodes.pop()) { // jshint ignore:line\n        callback(node);\n        if (node.isExpand) {\n            var children = node.children;\n            if (children.length) {\n                for (var i = children.length - 1; i >= 0; i--) {\n                    nodes.push(children[i]);\n                }\n            }\n        }\n    }\n}\n\nvar commonLayout = function (seriesModel, api) {\n\n    var layoutInfo = getViewRect(seriesModel, api);\n    seriesModel.layoutInfo = layoutInfo;\n\n    var layout = seriesModel.get('layout');\n    var width = 0;\n    var height = 0;\n    var separation$$1 = null;\n    if (layout === 'radial') {\n        width = 2 * Math.PI;\n        height = Math.min(layoutInfo.height, layoutInfo.width) / 2;\n        separation$$1 = separation(function (node1, node2) {\n            return (node1.parentNode === node2.parentNode ? 1 : 2) / node1.depth;\n        });\n    }\n    else {\n        width = layoutInfo.width;\n        height = layoutInfo.height;\n        separation$$1 = separation();\n    }\n\n    var virtualRoot = seriesModel.getData().tree.root;\n    var realRoot = virtualRoot.children[0];\n    init$2(virtualRoot);\n    eachAfter(realRoot, firstWalk, separation$$1);\n    virtualRoot.hierNode.modifier = - realRoot.hierNode.prelim;\n    eachBefore(realRoot, secondWalk);\n\n    var left = realRoot;\n    var right = realRoot;\n    var bottom = realRoot;\n    eachBefore(realRoot, function (node) {\n        var x = node.getLayout().x;\n        if (x < left.getLayout().x) {\n            left = node;\n        }\n        if (x > right.getLayout().x) {\n            right = node;\n        }\n        if (node.depth > bottom.depth) {\n            bottom = node;\n        }\n    });\n\n    var delta = left === right ? 1 : separation$$1(left, right) / 2;\n    var tx = delta - left.getLayout().x;\n    var kx = 0;\n    var ky = 0;\n    var coorX = 0;\n    var coorY = 0;\n    if (layout === 'radial') {\n        kx = width / (right.getLayout().x + delta + tx);\n        // here we use (node.depth - 1), bucause the real root's depth is 1\n        ky = height/ ((bottom.depth - 1) || 1);\n        eachBefore(realRoot, function (node) {\n            coorX = (node.getLayout().x + tx) * kx;\n            coorY = (node.depth - 1) * ky;\n            var finalCoor = radialCoordinate(coorX, coorY);\n            node.setLayout({x: finalCoor.x, y: finalCoor.y, rawX: coorX, rawY: coorY}, true);\n        });\n    }\n    else {\n        if (seriesModel.get('orient') === 'horizontal') {\n            ky = height / (right.getLayout().x + delta + tx);\n            kx = width / ((bottom.depth - 1) || 1);\n            eachBefore(realRoot, function (node) {\n                coorY = (node.getLayout().x + tx) * ky;\n                coorX = (node.depth - 1) * kx;\n                node.setLayout({x: coorX, y: coorY}, true);\n            });\n        }\n        else {\n            kx = width / (right.getLayout().x + delta + tx);\n            ky = height / ((bottom.depth - 1) || 1);\n            eachBefore(realRoot, function (node) {\n                coorX = (node.getLayout().x + tx) * kx;\n                coorY = (node.depth - 1) * ky;\n                node.setLayout({x: coorX, y: coorY}, true);\n            });\n        }\n    }\n};\n\nvar orthogonalLayout = function (ecModel, api) {\n    ecModel.eachSeriesByType('tree', function (seriesModel) {\n        commonLayout(seriesModel, api);\n    });\n};\n\nvar radialLayout = function (ecModel, api) {\n    ecModel.eachSeriesByType('tree', function (seriesModel) {\n        commonLayout(seriesModel, api);\n    });\n};\n\nregisterVisual(curry(visualSymbol, 'tree', 'circle', null));\nregisterLayout(orthogonalLayout);\nregisterLayout(radialLayout);\n\nfunction retrieveTargetInfo(payload, seriesModel) {\n    if (payload\n        && (\n            payload.type === 'treemapZoomToNode'\n            || payload.type === 'treemapRootToNode'\n        )\n    ) {\n        var root = seriesModel.getData().tree.root;\n        var targetNode = payload.targetNode;\n        if (targetNode && root.contains(targetNode)) {\n            return {node: targetNode};\n        }\n\n        var targetNodeId = payload.targetNodeId;\n        if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {\n            return {node: targetNode};\n        }\n    }\n}\n\n// Not includes the given node at the last item.\nfunction getPathToRoot(node) {\n    var path = [];\n    while (node) {\n        node = node.parentNode;\n        node && path.push(node);\n    }\n    return path.reverse();\n}\n\nfunction aboveViewRoot(viewRoot, node) {\n    var viewPath = getPathToRoot(viewRoot);\n    return indexOf(viewPath, node) >= 0;\n}\n\n// From root to the input node (the input node will be included).\nfunction wrapTreePathInfo(node, seriesModel) {\n    var treePathInfo = [];\n\n    while (node) {\n        var nodeDataIndex = node.dataIndex;\n        treePathInfo.push({\n            name: node.name,\n            dataIndex: nodeDataIndex,\n            value: seriesModel.getRawValue(nodeDataIndex)\n        });\n        node = node.parentNode;\n    }\n\n    treePathInfo.reverse();\n\n    return treePathInfo;\n}\n\nSeriesModel.extend({\n\n    type: 'series.treemap',\n\n    layoutMode: 'box',\n\n    dependencies: ['grid', 'polar'],\n\n    /**\n     * @type {module:echarts/data/Tree~Node}\n     */\n    _viewRoot: null,\n\n    defaultOption: {\n        // Disable progressive rendering\n        progressive: 0,\n        hoverLayerThreshold: Infinity,\n        // center: ['50%', '50%'],          // not supported in ec3.\n        // size: ['80%', '80%'],            // deprecated, compatible with ec2.\n        left: 'center',\n        top: 'middle',\n        right: null,\n        bottom: null,\n        width: '80%',\n        height: '80%',\n        sort: true,                         // Can be null or false or true\n                                            // (order by desc default, asc not supported yet (strange effect))\n        clipWindow: 'origin',               // Size of clipped window when zooming. 'origin' or 'fullscreen'\n        squareRatio: 0.5 * (1 + Math.sqrt(5)), // golden ratio\n        leafDepth: null,                    // Nodes on depth from root are regarded as leaves.\n                                            // Count from zero (zero represents only view root).\n        drillDownIcon: '',                 // Use html character temporarily because it is complicated\n                                            // to align specialized icon. \n\n        zoomToNodeRatio: 0.32 * 0.32,       // Be effective when using zoomToNode. Specify the proportion of the\n                                            // target node area in the view area.\n        roam: true,                         // true, false, 'scale' or 'zoom', 'move'.\n        nodeClick: 'zoomToNode',            // Leaf node click behaviour: 'zoomToNode', 'link', false.\n                                            // If leafDepth is set and clicking a node which has children but\n                                            // be on left depth, the behaviour would be changing root. Otherwise\n                                            // use behavious defined above.\n        animation: true,\n        animationDurationUpdate: 900,\n        animationEasing: 'quinticInOut',\n        breadcrumb: {\n            show: true,\n            height: 22,\n            left: 'center',\n            top: 'bottom',\n            // right\n            // bottom\n            emptyItemWidth: 25,             // Width of empty node.\n            itemStyle: {\n                normal: {\n                    color: 'rgba(0,0,0,0.7)', //'#5793f3',\n                    borderColor: 'rgba(255,255,255,0.7)',\n                    borderWidth: 1,\n                    shadowColor: 'rgba(150,150,150,1)',\n                    shadowBlur: 3,\n                    shadowOffsetX: 0,\n                    shadowOffsetY: 0,\n                    textStyle: {\n                        color: '#fff'\n                    }\n                },\n                emphasis: {\n                    textStyle: {}\n                }\n            }\n        },\n        label: {\n            normal: {\n                show: true,\n                // Do not use textDistance, for ellipsis rect just the same as treemap node rect.\n                distance: 0,\n                padding: 5,\n                position: 'inside', // Can be [5, '5%'] or position stirng like 'insideTopLeft', ...\n                // formatter: null,\n                color: '#fff',\n                ellipsis: true\n                // align\n                // verticalAlign\n            }\n        },\n        upperLabel: {                   // Label when node is parent.\n            normal: {\n                show: false,\n                position: [0, '50%'],\n                height: 20,\n                // formatter: null,\n                color: '#fff',\n                ellipsis: true,\n                // align: null,\n                verticalAlign: 'middle'\n            },\n            emphasis: {\n                show: true,\n                position: [0, '50%'],\n                color: '#fff',\n                ellipsis: true,\n                verticalAlign: 'middle'\n            }\n        },\n        itemStyle: {\n            normal: {\n                color: null,            // Can be 'none' if not necessary.\n                colorAlpha: null,       // Can be 'none' if not necessary.\n                colorSaturation: null,  // Can be 'none' if not necessary.\n                borderWidth: 0,\n                gapWidth: 0,\n                borderColor: '#fff',\n                borderColorSaturation: null // If specified, borderColor will be ineffective, and the\n                                            // border color is evaluated by color of current node and\n                                            // borderColorSaturation.\n            },\n            emphasis: {\n\n            }\n        },\n\n        visualDimension: 0,                 // Can be 0, 1, 2, 3.\n        visualMin: null,\n        visualMax: null,\n\n        color: [],                  // + treemapSeries.color should not be modified. Please only modified\n                                    // level[n].color (if necessary).\n                                    // + Specify color list of each level. level[0].color would be global\n                                    // color list if not specified. (see method `setDefault`).\n                                    // + But set as a empty array to forbid fetch color from global palette\n                                    // when using nodeModel.get('color'), otherwise nodes on deep level\n                                    // will always has color palette set and are not able to inherit color\n                                    // from parent node.\n                                    // + TreemapSeries.color can not be set as 'none', otherwise effect\n                                    // legend color fetching (see seriesColor.js).\n        colorAlpha: null,           // Array. Specify color alpha range of each level, like [0.2, 0.8]\n        colorSaturation: null,      // Array. Specify color saturation of each level, like [0.2, 0.5]\n        colorMappingBy: 'index',    // 'value' or 'index' or 'id'.\n        visibleMin: 10,             // If area less than this threshold (unit: pixel^2), node will not\n                                    // be rendered. Only works when sort is 'asc' or 'desc'.\n        childrenVisibleMin: null,   // If area of a node less than this threshold (unit: pixel^2),\n                                    // grandchildren will not show.\n                                    // Why grandchildren? If not grandchildren but children,\n                                    // some siblings show children and some not,\n                                    // the appearance may be mess and not consistent,\n        levels: []                  // Each item: {\n                                    //     visibleMin, itemStyle, visualDimension, label\n                                    // }\n        // data: {\n        //      value: [],\n        //      children: [],\n        //      link: 'http://xxx.xxx.xxx',\n        //      target: 'blank' or 'self'\n        // }\n    },\n\n    /**\n     * @override\n     */\n    getInitialData: function (option, ecModel) {\n        // Create a virtual root.\n        var root = {name: option.name, children: option.data};\n\n        completeTreeValue(root);\n\n        var levels = option.levels || [];\n\n        levels = option.levels = setDefault(levels, ecModel);\n\n        var treeOption = {};\n\n        treeOption.levels = levels;\n\n        // Make sure always a new tree is created when setOption,\n        // in TreemapView, we check whether oldTree === newTree\n        // to choose mappings approach among old shapes and new shapes.\n        return Tree.createTree(root, this, treeOption).data;\n    },\n\n    optionUpdated: function () {\n        this.resetViewRoot();\n    },\n\n    /**\n     * @override\n     * @param {number} dataIndex\n     * @param {boolean} [mutipleSeries=false]\n     */\n    formatTooltip: function (dataIndex) {\n        var data = this.getData();\n        var value = this.getRawValue(dataIndex);\n        var formattedValue = isArray(value)\n            ? addCommas(value[0]) : addCommas(value);\n        var name = data.getName(dataIndex);\n\n        return encodeHTML(name + ': ' + formattedValue);\n    },\n\n    /**\n     * Add tree path to tooltip param\n     *\n     * @override\n     * @param {number} dataIndex\n     * @return {Object}\n     */\n    getDataParams: function (dataIndex) {\n        var params = SeriesModel.prototype.getDataParams.apply(this, arguments);\n\n        var node = this.getData().tree.getNodeByDataIndex(dataIndex);\n        params.treePathInfo = wrapTreePathInfo(node, this);\n\n        return params;\n    },\n\n    /**\n     * @public\n     * @param {Object} layoutInfo {\n     *                                x: containerGroup x\n     *                                y: containerGroup y\n     *                                width: containerGroup width\n     *                                height: containerGroup height\n     *                            }\n     */\n    setLayoutInfo: function (layoutInfo) {\n        /**\n         * @readOnly\n         * @type {Object}\n         */\n        this.layoutInfo = this.layoutInfo || {};\n        extend(this.layoutInfo, layoutInfo);\n    },\n\n    /**\n     * @param  {string} id\n     * @return {number} index\n     */\n    mapIdToIndex: function (id) {\n        // A feature is implemented:\n        // index is monotone increasing with the sequence of\n        // input id at the first time.\n        // This feature can make sure that each data item and its\n        // mapped color have the same index between data list and\n        // color list at the beginning, which is useful for user\n        // to adjust data-color mapping.\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        var idIndexMap = this._idIndexMap;\n\n        if (!idIndexMap) {\n            idIndexMap = this._idIndexMap = createHashMap();\n            /**\n             * @private\n             * @type {number}\n             */\n            this._idIndexMapCount = 0;\n        }\n\n        var index = idIndexMap.get(id);\n        if (index == null) {\n            idIndexMap.set(id, index = this._idIndexMapCount++);\n        }\n\n        return index;\n    },\n\n    getViewRoot: function () {\n        return this._viewRoot;\n    },\n\n    /**\n     * @param {module:echarts/data/Tree~Node} [viewRoot]\n     */\n    resetViewRoot: function (viewRoot) {\n        viewRoot\n            ? (this._viewRoot = viewRoot)\n            : (viewRoot = this._viewRoot);\n\n        var root = this.getData().tree.root;\n\n        if (!viewRoot\n            || (viewRoot !== root && !root.contains(viewRoot))\n        ) {\n            this._viewRoot = root;\n        }\n    }\n});\n\n/**\n * @param {Object} dataNode\n */\nfunction completeTreeValue(dataNode) {\n    // Postorder travel tree.\n    // If value of none-leaf node is not set,\n    // calculate it by suming up the value of all children.\n    var sum = 0;\n\n    each$1(dataNode.children, function (child) {\n\n        completeTreeValue(child);\n\n        var childValue = child.value;\n        isArray(childValue) && (childValue = childValue[0]);\n\n        sum += childValue;\n    });\n\n    var thisValue = dataNode.value;\n    if (isArray(thisValue)) {\n        thisValue = thisValue[0];\n    }\n\n    if (thisValue == null || isNaN(thisValue)) {\n        thisValue = sum;\n    }\n    // Value should not less than 0.\n    if (thisValue < 0) {\n        thisValue = 0;\n    }\n\n    isArray(dataNode.value)\n        ? (dataNode.value[0] = thisValue)\n        : (dataNode.value = thisValue);\n}\n\n/**\n * set default to level configuration\n */\nfunction setDefault(levels, ecModel) {\n    var globalColorList = ecModel.get('color');\n\n    if (!globalColorList) {\n        return;\n    }\n\n    levels = levels || [];\n    var hasColorDefine;\n    each$1(levels, function (levelDefine) {\n        var model = new Model(levelDefine);\n        var modelColor = model.get('color');\n\n        if (model.get('itemStyle.normal.color')\n            || (modelColor && modelColor !== 'none')\n        ) {\n            hasColorDefine = true;\n        }\n    });\n\n    if (!hasColorDefine) {\n        var level0 = levels[0] || (levels[0] = {});\n        level0.color = globalColorList.slice();\n    }\n\n    return levels;\n}\n\nvar TEXT_PADDING = 8;\nvar ITEM_GAP = 8;\nvar ARRAY_LENGTH = 5;\n\nfunction Breadcrumb(containerGroup) {\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n    this.group = new Group();\n\n    containerGroup.add(this.group);\n}\n\nBreadcrumb.prototype = {\n\n    constructor: Breadcrumb,\n\n    render: function (seriesModel, api, targetNode, onSelect) {\n        var model = seriesModel.getModel('breadcrumb');\n        var thisGroup = this.group;\n\n        thisGroup.removeAll();\n\n        if (!model.get('show') || !targetNode) {\n            return;\n        }\n\n        var normalStyleModel = model.getModel('itemStyle.normal');\n        // var emphasisStyleModel = model.getModel('itemStyle.emphasis');\n        var textStyleModel = normalStyleModel.getModel('textStyle');\n\n        var layoutParam = {\n            pos: {\n                left: model.get('left'),\n                right: model.get('right'),\n                top: model.get('top'),\n                bottom: model.get('bottom')\n            },\n            box: {\n                width: api.getWidth(),\n                height: api.getHeight()\n            },\n            emptyItemWidth: model.get('emptyItemWidth'),\n            totalWidth: 0,\n            renderList: []\n        };\n\n        this._prepare(targetNode, layoutParam, textStyleModel);\n        this._renderContent(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect);\n\n        positionElement(thisGroup, layoutParam.pos, layoutParam.box);\n    },\n\n    /**\n     * Prepare render list and total width\n     * @private\n     */\n    _prepare: function (targetNode, layoutParam, textStyleModel) {\n        for (var node = targetNode; node; node = node.parentNode) {\n            var text = node.getModel().get('name');\n            var textRect = textStyleModel.getTextRect(text);\n            var itemWidth = Math.max(\n                textRect.width + TEXT_PADDING * 2,\n                layoutParam.emptyItemWidth\n            );\n            layoutParam.totalWidth += itemWidth + ITEM_GAP;\n            layoutParam.renderList.push({node: node, text: text, width: itemWidth});\n        }\n    },\n\n    /**\n     * @private\n     */\n    _renderContent: function (\n        seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect\n    ) {\n        // Start rendering.\n        var lastX = 0;\n        var emptyItemWidth = layoutParam.emptyItemWidth;\n        var height = seriesModel.get('breadcrumb.height');\n        var availableSize = getAvailableSize(layoutParam.pos, layoutParam.box);\n        var totalWidth = layoutParam.totalWidth;\n        var renderList = layoutParam.renderList;\n\n        for (var i = renderList.length - 1; i >= 0; i--) {\n            var item = renderList[i];\n            var itemNode = item.node;\n            var itemWidth = item.width;\n            var text = item.text;\n\n            // Hdie text and shorten width if necessary.\n            if (totalWidth > availableSize.width) {\n                totalWidth -= itemWidth - emptyItemWidth;\n                itemWidth = emptyItemWidth;\n                text = null;\n            }\n\n            var el = new Polygon({\n                shape: {\n                    points: makeItemPoints(\n                        lastX, 0, itemWidth, height,\n                        i === renderList.length - 1, i === 0\n                    )\n                },\n                style: defaults(\n                    normalStyleModel.getItemStyle(),\n                    {\n                        lineJoin: 'bevel',\n                        text: text,\n                        textFill: textStyleModel.getTextColor(),\n                        textFont: textStyleModel.getFont()\n                    }\n                ),\n                z: 10,\n                onclick: curry(onSelect, itemNode)\n            });\n            this.group.add(el);\n\n            packEventData(el, seriesModel, itemNode);\n\n            lastX += itemWidth + ITEM_GAP;\n        }\n    },\n\n    /**\n     * @override\n     */\n    remove: function () {\n        this.group.removeAll();\n    }\n};\n\nfunction makeItemPoints(x, y, itemWidth, itemHeight, head, tail) {\n    var points = [\n        [head ? x : x - ARRAY_LENGTH, y],\n        [x + itemWidth, y],\n        [x + itemWidth, y + itemHeight],\n        [head ? x : x - ARRAY_LENGTH, y + itemHeight]\n    ];\n    !tail && points.splice(2, 0, [x + itemWidth + ARRAY_LENGTH, y + itemHeight / 2]);\n    !head && points.push([x, y + itemHeight / 2]);\n    return points;\n}\n\n// Package custom mouse event.\nfunction packEventData(el, seriesModel, itemNode) {\n    el.eventData = {\n        componentType: 'series',\n        componentSubType: 'treemap',\n        seriesIndex: seriesModel.componentIndex,\n        seriesName: seriesModel.name,\n        seriesType: 'treemap',\n        selfType: 'breadcrumb', // Distinguish with click event on treemap node.\n        nodeData: {\n            dataIndex: itemNode && itemNode.dataIndex,\n            name: itemNode && itemNode.name\n        },\n        treePathInfo: itemNode && wrapTreePathInfo(itemNode, seriesModel)\n    };\n}\n\n/**\n * @param {number} [time=500] Time in ms\n * @param {string} [easing='linear']\n * @param {number} [delay=0]\n * @param {Function} [callback]\n *\n * @example\n *  // Animate position\n *  animation\n *      .createWrap()\n *      .add(el1, {position: [10, 10]})\n *      .add(el2, {shape: {width: 500}, style: {fill: 'red'}}, 400)\n *      .done(function () { // done })\n *      .start('cubicOut');\n */\nfunction createWrap() {\n\n    var storage = [];\n    var elExistsMap = {};\n    var doneCallback;\n\n    return {\n\n        /**\n         * Caution: a el can only be added once, otherwise 'done'\n         * might not be called. This method checks this (by el.id),\n         * suppresses adding and returns false when existing el found.\n         *\n         * @param {modele:zrender/Element} el\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         * @param {string} [easing='linear']\n         * @return {boolean} Whether adding succeeded.\n         *\n         * @example\n         *     add(el, target, time, delay, easing);\n         *     add(el, target, time, easing);\n         *     add(el, target, time);\n         *     add(el, target);\n         */\n        add: function (el, target, time, delay, easing) {\n            if (isString(delay)) {\n                easing = delay;\n                delay = 0;\n            }\n\n            if (elExistsMap[el.id]) {\n                return false;\n            }\n            elExistsMap[el.id] = 1;\n\n            storage.push(\n                {el: el, target: target, time: time, delay: delay, easing: easing}\n            );\n\n            return true;\n        },\n\n        /**\n         * Only execute when animation finished. Will not execute when any\n         * of 'stop' or 'stopAnimation' called.\n         *\n         * @param {Function} callback\n         */\n        done: function (callback) {\n            doneCallback = callback;\n            return this;\n        },\n\n        /**\n         * Will stop exist animation firstly.\n         */\n        start: function () {\n            var count = storage.length;\n\n            for (var i = 0, len = storage.length; i < len; i++) {\n                var item = storage[i];\n                item.el.animateTo(item.target, item.time, item.delay, item.easing, done);\n            }\n\n            return this;\n\n            function done() {\n                count--;\n                if (!count) {\n                    storage.length = 0;\n                    elExistsMap = {};\n                    doneCallback && doneCallback();\n                }\n            }\n        }\n    };\n}\n\nvar bind$1 = bind;\nvar Group$2 = Group;\nvar Rect$1 = Rect;\nvar each$11 = each$1;\n\nvar DRAG_THRESHOLD = 3;\nvar PATH_LABEL_NOAMAL = ['label', 'normal'];\nvar PATH_LABEL_EMPHASIS = ['label', 'emphasis'];\nvar PATH_UPPERLABEL_NORMAL = ['upperLabel', 'normal'];\nvar PATH_UPPERLABEL_EMPHASIS = ['upperLabel', 'emphasis'];\nvar Z_BASE = 10; // Should bigger than every z.\nvar Z_BG = 1;\nvar Z_CONTENT = 2;\n\nvar getItemStyleEmphasis = makeStyleMapper([\n    ['fill', 'color'],\n    // `borderColor` and `borderWidth` has been occupied,\n    // so use `stroke` to indicate the stroke of the rect.\n    ['stroke', 'strokeColor'],\n    ['lineWidth', 'strokeWidth'],\n    ['shadowBlur'],\n    ['shadowOffsetX'],\n    ['shadowOffsetY'],\n    ['shadowColor']\n]);\nvar getItemStyleNormal = function (model) {\n    // Normal style props should include emphasis style props.\n    var itemStyle = getItemStyleEmphasis(model);\n    // Clear styles set by emphasis.\n    itemStyle.stroke = itemStyle.fill = itemStyle.lineWidth = null;\n    return itemStyle;\n};\n\nextendChartView({\n\n    type: 'treemap',\n\n    /**\n     * @override\n     */\n    init: function (o, api) {\n\n        /**\n         * @private\n         * @type {module:zrender/container/Group}\n         */\n        this._containerGroup;\n\n        /**\n         * @private\n         * @type {Object.<string, Array.<module:zrender/container/Group>>}\n         */\n        this._storage = createStorage();\n\n        /**\n         * @private\n         * @type {module:echarts/data/Tree}\n         */\n        this._oldTree;\n\n        /**\n         * @private\n         * @type {module:echarts/chart/treemap/Breadcrumb}\n         */\n        this._breadcrumb;\n\n        /**\n         * @private\n         * @type {module:echarts/component/helper/RoamController}\n         */\n        this._controller;\n\n        /**\n         * 'ready', 'animating'\n         * @private\n         */\n        this._state = 'ready';\n    },\n\n    /**\n     * @override\n     */\n    render: function (seriesModel, ecModel, api, payload) {\n\n        var models = ecModel.findComponents({\n            mainType: 'series', subType: 'treemap', query: payload\n        });\n        if (indexOf(models, seriesModel) < 0) {\n            return;\n        }\n\n        this.seriesModel = seriesModel;\n        this.api = api;\n        this.ecModel = ecModel;\n\n        var targetInfo = retrieveTargetInfo(payload, seriesModel);\n        var payloadType = payload && payload.type;\n        var layoutInfo = seriesModel.layoutInfo;\n        var isInit = !this._oldTree;\n        var thisStorage = this._storage;\n\n        // Mark new root when action is treemapRootToNode.\n        var reRoot = (payloadType === 'treemapRootToNode' && targetInfo && thisStorage)\n            ? {\n                rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],\n                direction: payload.direction\n            }\n            : null;\n\n        var containerGroup = this._giveContainerGroup(layoutInfo);\n\n        var renderResult = this._doRender(containerGroup, seriesModel, reRoot);\n        (\n            !isInit && (\n                !payloadType\n                || payloadType === 'treemapZoomToNode'\n                || payloadType === 'treemapRootToNode'\n            )\n        )\n            ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot)\n            : renderResult.renderFinally();\n\n        this._resetController(api);\n\n        this._renderBreadcrumb(seriesModel, api, targetInfo);\n    },\n\n    /**\n     * @private\n     */\n    _giveContainerGroup: function (layoutInfo) {\n        var containerGroup = this._containerGroup;\n        if (!containerGroup) {\n            // FIXME\n            // containerGroupclipclip\n            containerGroup = this._containerGroup = new Group$2();\n            this._initEvents(containerGroup);\n            this.group.add(containerGroup);\n        }\n        containerGroup.attr('position', [layoutInfo.x, layoutInfo.y]);\n\n        return containerGroup;\n    },\n\n    /**\n     * @private\n     */\n    _doRender: function (containerGroup, seriesModel, reRoot) {\n        var thisTree = seriesModel.getData().tree;\n        var oldTree = this._oldTree;\n\n        // Clear last shape records.\n        var lastsForAnimation = createStorage();\n        var thisStorage = createStorage();\n        var oldStorage = this._storage;\n        var willInvisibleEls = [];\n        var doRenderNode = curry(\n            renderNode, seriesModel,\n            thisStorage, oldStorage, reRoot,\n            lastsForAnimation, willInvisibleEls\n        );\n\n        // Notice: when thisTree and oldTree are the same tree (see list.cloneShallow),\n        // the oldTree is actually losted, so we can not find all of the old graphic\n        // elements from tree. So we use this stragegy: make element storage, move\n        // from old storage to new storage, clear old storage.\n\n        dualTravel(\n            thisTree.root ? [thisTree.root] : [],\n            (oldTree && oldTree.root) ? [oldTree.root] : [],\n            containerGroup,\n            thisTree === oldTree || !oldTree,\n            0\n        );\n\n        // Process all removing.\n        var willDeleteEls = clearStorage(oldStorage);\n\n        this._oldTree = thisTree;\n        this._storage = thisStorage;\n\n        return {\n            lastsForAnimation: lastsForAnimation,\n            willDeleteEls: willDeleteEls,\n            renderFinally: renderFinally\n        };\n\n        function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, depth) {\n            // When 'render' is triggered by action,\n            // 'this' and 'old' may be the same tree,\n            // we use rawIndex in that case.\n            if (sameTree) {\n                oldViewChildren = thisViewChildren;\n                each$11(thisViewChildren, function (child, index) {\n                    !child.isRemoved() && processNode(index, index);\n                });\n            }\n            // Diff hierarchically (diff only in each subtree, but not whole).\n            // because, consistency of view is important.\n            else {\n                (new DataDiffer(oldViewChildren, thisViewChildren, getKey, getKey))\n                    .add(processNode)\n                    .update(processNode)\n                    .remove(curry(processNode, null))\n                    .execute();\n            }\n\n            function getKey(node) {\n                // Identify by name or raw index.\n                return node.getId();\n            }\n\n            function processNode(newIndex, oldIndex) {\n                var thisNode = newIndex != null ? thisViewChildren[newIndex] : null;\n                var oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;\n\n                var group = doRenderNode(thisNode, oldNode, parentGroup, depth);\n\n                group && dualTravel(\n                    thisNode && thisNode.viewChildren || [],\n                    oldNode && oldNode.viewChildren || [],\n                    group,\n                    sameTree,\n                    depth + 1\n                );\n            }\n        }\n\n        function clearStorage(storage) {\n            var willDeleteEls = createStorage();\n            storage && each$11(storage, function (store, storageName) {\n                var delEls = willDeleteEls[storageName];\n                each$11(store, function (el) {\n                    el && (delEls.push(el), el.__tmWillDelete = 1);\n                });\n            });\n            return willDeleteEls;\n        }\n\n        function renderFinally() {\n            each$11(willDeleteEls, function (els) {\n                each$11(els, function (el) {\n                    el.parent && el.parent.remove(el);\n                });\n            });\n            each$11(willInvisibleEls, function (el) {\n                el.invisible = true;\n                // Setting invisible is for optimizing, so no need to set dirty,\n                // just mark as invisible.\n                el.dirty();\n            });\n        }\n    },\n\n    /**\n     * @private\n     */\n    _doAnimation: function (containerGroup, renderResult, seriesModel, reRoot) {\n        if (!seriesModel.get('animation')) {\n            return;\n        }\n\n        var duration = seriesModel.get('animationDurationUpdate');\n        var easing = seriesModel.get('animationEasing');\n        var animationWrap = createWrap();\n\n        // Make delete animations.\n        each$11(renderResult.willDeleteEls, function (store, storageName) {\n            each$11(store, function (el, rawIndex) {\n                if (el.invisible) {\n                    return;\n                }\n\n                var parent = el.parent; // Always has parent, and parent is nodeGroup.\n                var target;\n\n                if (reRoot && reRoot.direction === 'drillDown') {\n                    target = parent === reRoot.rootNodeGroup\n                        // This is the content element of view root.\n                        // Only `content` will enter this branch, because\n                        // `background` and `nodeGroup` will not be deleted.\n                        ? {\n                            shape: {\n                                x: 0,\n                                y: 0,\n                                width: parent.__tmNodeWidth,\n                                height: parent.__tmNodeHeight\n                            },\n                            style: {\n                                opacity: 0\n                            }\n                        }\n                        // Others.\n                        : {style: {opacity: 0}};\n                }\n                else {\n                    var targetX = 0;\n                    var targetY = 0;\n\n                    if (!parent.__tmWillDelete) {\n                        // Let node animate to right-bottom corner, cooperating with fadeout,\n                        // which is appropriate for user understanding.\n                        // Divided by 2 for reRoot rolling up effect.\n                        targetX = parent.__tmNodeWidth / 2;\n                        targetY = parent.__tmNodeHeight / 2;\n                    }\n\n                    target = storageName === 'nodeGroup'\n                        ? {position: [targetX, targetY], style: {opacity: 0}}\n                        : {\n                            shape: {x: targetX, y: targetY, width: 0, height: 0},\n                            style: {opacity: 0}\n                        };\n                }\n\n                target && animationWrap.add(el, target, duration, easing);\n            });\n        });\n\n        // Make other animations\n        each$11(this._storage, function (store, storageName) {\n            each$11(store, function (el, rawIndex) {\n                var last = renderResult.lastsForAnimation[storageName][rawIndex];\n                var target = {};\n\n                if (!last) {\n                    return;\n                }\n\n                if (storageName === 'nodeGroup') {\n                    if (last.old) {\n                        target.position = el.position.slice();\n                        el.attr('position', last.old);\n                    }\n                }\n                else {\n                    if (last.old) {\n                        target.shape = extend({}, el.shape);\n                        el.setShape(last.old);\n                    }\n\n                    if (last.fadein) {\n                        el.setStyle('opacity', 0);\n                        target.style = {opacity: 1};\n                    }\n                    // When animation is stopped for succedent animation starting,\n                    // el.style.opacity might not be 1\n                    else if (el.style.opacity !== 1) {\n                        target.style = {opacity: 1};\n                    }\n                }\n\n                animationWrap.add(el, target, duration, easing);\n            });\n        }, this);\n\n        this._state = 'animating';\n\n        animationWrap\n            .done(bind$1(function () {\n                this._state = 'ready';\n                renderResult.renderFinally();\n            }, this))\n            .start();\n    },\n\n    /**\n     * @private\n     */\n    _resetController: function (api) {\n        var controller = this._controller;\n\n        // Init controller.\n        if (!controller) {\n            controller = this._controller = new RoamController(api.getZr());\n            controller.enable(this.seriesModel.get('roam'));\n            controller.on('pan', bind$1(this._onPan, this));\n            controller.on('zoom', bind$1(this._onZoom, this));\n        }\n\n        var rect = new BoundingRect(0, 0, api.getWidth(), api.getHeight());\n        controller.setPointerChecker(function (e, x, y) {\n            return rect.contain(x, y);\n        });\n    },\n\n    /**\n     * @private\n     */\n    _clearController: function () {\n        var controller = this._controller;\n        if (controller) {\n            controller.dispose();\n            controller = null;\n        }\n    },\n\n    /**\n     * @private\n     */\n    _onPan: function (dx, dy) {\n        if (this._state !== 'animating'\n            && (Math.abs(dx) > DRAG_THRESHOLD || Math.abs(dy) > DRAG_THRESHOLD)\n        ) {\n            // These param must not be cached.\n            var root = this.seriesModel.getData().tree.root;\n\n            if (!root) {\n                return;\n            }\n\n            var rootLayout = root.getLayout();\n\n            if (!rootLayout) {\n                return;\n            }\n\n            this.api.dispatchAction({\n                type: 'treemapMove',\n                from: this.uid,\n                seriesId: this.seriesModel.id,\n                rootRect: {\n                    x: rootLayout.x + dx, y: rootLayout.y + dy,\n                    width: rootLayout.width, height: rootLayout.height\n                }\n            });\n        }\n    },\n\n    /**\n     * @private\n     */\n    _onZoom: function (scale, mouseX, mouseY) {\n        if (this._state !== 'animating') {\n            // These param must not be cached.\n            var root = this.seriesModel.getData().tree.root;\n\n            if (!root) {\n                return;\n            }\n\n            var rootLayout = root.getLayout();\n\n            if (!rootLayout) {\n                return;\n            }\n\n            var rect = new BoundingRect(\n                rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height\n            );\n            var layoutInfo = this.seriesModel.layoutInfo;\n\n            // Transform mouse coord from global to containerGroup.\n            mouseX -= layoutInfo.x;\n            mouseY -= layoutInfo.y;\n\n            // Scale root bounding rect.\n            var m = create$1();\n            translate(m, m, [-mouseX, -mouseY]);\n            scale$1(m, m, [scale, scale]);\n            translate(m, m, [mouseX, mouseY]);\n\n            rect.applyTransform(m);\n\n            this.api.dispatchAction({\n                type: 'treemapRender',\n                from: this.uid,\n                seriesId: this.seriesModel.id,\n                rootRect: {\n                    x: rect.x, y: rect.y,\n                    width: rect.width, height: rect.height\n                }\n            });\n        }\n    },\n\n    /**\n     * @private\n     */\n    _initEvents: function (containerGroup) {\n        containerGroup.on('click', function (e) {\n            if (this._state !== 'ready') {\n                return;\n            }\n\n            var nodeClick = this.seriesModel.get('nodeClick', true);\n\n            if (!nodeClick) {\n                return;\n            }\n\n            var targetInfo = this.findTarget(e.offsetX, e.offsetY);\n\n            if (!targetInfo) {\n                return;\n            }\n\n            var node = targetInfo.node;\n            if (node.getLayout().isLeafRoot) {\n                this._rootToNode(targetInfo);\n            }\n            else {\n                if (nodeClick === 'zoomToNode') {\n                    this._zoomToNode(targetInfo);\n                }\n                else if (nodeClick === 'link') {\n                    var itemModel = node.hostTree.data.getItemModel(node.dataIndex);\n                    var link = itemModel.get('link', true);\n                    var linkTarget = itemModel.get('target', true) || 'blank';\n                    link && window.open(link, linkTarget);\n                }\n            }\n\n        }, this);\n    },\n\n    /**\n     * @private\n     */\n    _renderBreadcrumb: function (seriesModel, api, targetInfo) {\n        if (!targetInfo) {\n            targetInfo = seriesModel.get('leafDepth', true) != null\n                ? {node: seriesModel.getViewRoot()}\n                // FIXME\n                // better way?\n                // Find breadcrumb tail on center of containerGroup.\n                : this.findTarget(api.getWidth() / 2, api.getHeight() / 2);\n\n            if (!targetInfo) {\n                targetInfo = {node: seriesModel.getData().tree.root};\n            }\n        }\n\n        (this._breadcrumb || (this._breadcrumb = new Breadcrumb(this.group)))\n            .render(seriesModel, api, targetInfo.node, bind$1(onSelect, this));\n\n        function onSelect(node) {\n            if (this._state !== 'animating') {\n                aboveViewRoot(seriesModel.getViewRoot(), node)\n                    ? this._rootToNode({node: node})\n                    : this._zoomToNode({node: node});\n            }\n        }\n    },\n\n    /**\n     * @override\n     */\n    remove: function () {\n        this._clearController();\n        this._containerGroup && this._containerGroup.removeAll();\n        this._storage = createStorage();\n        this._state = 'ready';\n        this._breadcrumb && this._breadcrumb.remove();\n    },\n\n    dispose: function () {\n        this._clearController();\n    },\n\n    /**\n     * @private\n     */\n    _zoomToNode: function (targetInfo) {\n        this.api.dispatchAction({\n            type: 'treemapZoomToNode',\n            from: this.uid,\n            seriesId: this.seriesModel.id,\n            targetNode: targetInfo.node\n        });\n    },\n\n    /**\n     * @private\n     */\n    _rootToNode: function (targetInfo) {\n        this.api.dispatchAction({\n            type: 'treemapRootToNode',\n            from: this.uid,\n            seriesId: this.seriesModel.id,\n            targetNode: targetInfo.node\n        });\n    },\n\n    /**\n     * @public\n     * @param {number} x Global coord x.\n     * @param {number} y Global coord y.\n     * @return {Object} info If not found, return undefined;\n     * @return {number} info.node Target node.\n     * @return {number} info.offsetX x refer to target node.\n     * @return {number} info.offsetY y refer to target node.\n     */\n    findTarget: function (x, y) {\n        var targetInfo;\n        var viewRoot = this.seriesModel.getViewRoot();\n\n        viewRoot.eachNode({attr: 'viewChildren', order: 'preorder'}, function (node) {\n            var bgEl = this._storage.background[node.getRawIndex()];\n            // If invisible, there might be no element.\n            if (bgEl) {\n                var point = bgEl.transformCoordToLocal(x, y);\n                var shape = bgEl.shape;\n\n                // For performance consideration, dont use 'getBoundingRect'.\n                if (shape.x <= point[0]\n                    && point[0] <= shape.x + shape.width\n                    && shape.y <= point[1]\n                    && point[1] <= shape.y + shape.height\n                ) {\n                    targetInfo = {node: node, offsetX: point[0], offsetY: point[1]};\n                }\n                else {\n                    return false; // Suppress visit subtree.\n                }\n            }\n        }, this);\n\n        return targetInfo;\n    }\n\n});\n\n/**\n * @inner\n */\nfunction createStorage() {\n    return {nodeGroup: [], background: [], content: []};\n}\n\n/**\n * @inner\n * @return Return undefined means do not travel further.\n */\nfunction renderNode(\n    seriesModel, thisStorage, oldStorage, reRoot,\n    lastsForAnimation, willInvisibleEls,\n    thisNode, oldNode, parentGroup, depth\n) {\n    // Whether under viewRoot.\n    if (!thisNode) {\n        // Deleting nodes will be performed finally. This method just find\n        // element from old storage, or create new element, set them to new\n        // storage, and set styles.\n        return;\n    }\n\n    // -------------------------------------------------------------------\n    // Start of closure variables available in \"Procedures in renderNode\".\n\n    var thisLayout = thisNode.getLayout();\n\n    if (!thisLayout || !thisLayout.isInView) {\n        return;\n    }\n\n    var thisWidth = thisLayout.width;\n    var thisHeight = thisLayout.height;\n    var borderWidth = thisLayout.borderWidth;\n    var thisInvisible = thisLayout.invisible;\n\n    var thisRawIndex = thisNode.getRawIndex();\n    var oldRawIndex = oldNode && oldNode.getRawIndex();\n\n    var thisViewChildren = thisNode.viewChildren;\n    var upperHeight = thisLayout.upperHeight;\n    var isParent = thisViewChildren && thisViewChildren.length;\n    var itemStyleNormalModel = thisNode.getModel('itemStyle.normal');\n    var itemStyleEmphasisModel = thisNode.getModel('itemStyle.emphasis');\n\n    // End of closure ariables available in \"Procedures in renderNode\".\n    // -----------------------------------------------------------------\n\n    // Node group\n    var group = giveGraphic('nodeGroup', Group$2);\n\n    if (!group) {\n        return;\n    }\n\n    parentGroup.add(group);\n    // x,y are not set when el is above view root.\n    group.attr('position', [thisLayout.x || 0, thisLayout.y || 0]);\n    group.__tmNodeWidth = thisWidth;\n    group.__tmNodeHeight = thisHeight;\n\n    if (thisLayout.isAboveViewRoot) {\n        return group;\n    }\n\n    // Background\n    var bg = giveGraphic('background', Rect$1, depth, Z_BG);\n    bg && renderBackground(group, bg, isParent && thisLayout.upperHeight);\n\n    // No children, render content.\n    if (!isParent) {\n        var content = giveGraphic('content', Rect$1, depth, Z_CONTENT);\n        content && renderContent(group, content);\n    }\n\n    return group;\n\n    // ----------------------------\n    // | Procedures in renderNode |\n    // ----------------------------\n\n    function renderBackground(group, bg, useUpperLabel) {\n        // For tooltip.\n        bg.dataIndex = thisNode.dataIndex;\n        bg.seriesIndex = seriesModel.seriesIndex;\n\n        bg.setShape({x: 0, y: 0, width: thisWidth, height: thisHeight});\n        var visualBorderColor = thisNode.getVisual('borderColor', true);\n        var emphasisBorderColor = itemStyleEmphasisModel.get('borderColor');\n\n        updateStyle(bg, function () {\n            var normalStyle = getItemStyleNormal(itemStyleNormalModel);\n            normalStyle.fill = visualBorderColor;\n            var emphasisStyle = getItemStyleEmphasis(itemStyleEmphasisModel);\n            emphasisStyle.fill = emphasisBorderColor;\n\n            if (useUpperLabel) {\n                var upperLabelWidth = thisWidth - 2 * borderWidth;\n\n                prepareText(\n                    normalStyle, emphasisStyle, visualBorderColor, upperLabelWidth, upperHeight,\n                    {x: borderWidth, y: 0, width: upperLabelWidth, height: upperHeight}\n                );\n            }\n            // For old bg.\n            else {\n                normalStyle.text = emphasisStyle.text = null;\n            }\n\n            bg.setStyle(normalStyle);\n            setHoverStyle(bg, emphasisStyle);\n        });\n\n        group.add(bg);\n    }\n\n    function renderContent(group, content) {\n        // For tooltip.\n        content.dataIndex = thisNode.dataIndex;\n        content.seriesIndex = seriesModel.seriesIndex;\n\n        var contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);\n        var contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);\n\n        content.culling = true;\n        content.setShape({\n            x: borderWidth,\n            y: borderWidth,\n            width: contentWidth,\n            height: contentHeight\n        });\n\n        var visualColor = thisNode.getVisual('color', true);\n        updateStyle(content, function () {\n            var normalStyle = getItemStyleNormal(itemStyleNormalModel);\n            normalStyle.fill = visualColor;\n            var emphasisStyle = getItemStyleEmphasis(itemStyleEmphasisModel);\n\n            prepareText(normalStyle, emphasisStyle, visualColor, contentWidth, contentHeight);\n\n            content.setStyle(normalStyle);\n            setHoverStyle(content, emphasisStyle);\n        });\n\n        group.add(content);\n    }\n\n    function updateStyle(element, cb) {\n        if (!thisInvisible) {\n            // If invisible, do not set visual, otherwise the element will\n            // change immediately before animation. We think it is OK to\n            // remain its origin color when moving out of the view window.\n            cb();\n\n            if (!element.__tmWillVisible) {\n                element.invisible = false;\n            }\n        }\n        else {\n            // Delay invisible setting utill animation finished,\n            // avoid element vanish suddenly before animation.\n            !element.invisible && willInvisibleEls.push(element);\n        }\n    }\n\n    function prepareText(normalStyle, emphasisStyle, visualColor, width, height, upperLabelRect) {\n        var nodeModel = thisNode.getModel();\n        var text = retrieve(\n            seriesModel.getFormattedLabel(\n                thisNode.dataIndex, 'normal', null, null, upperLabelRect ? 'upperLabel' : 'label'\n            ),\n            nodeModel.get('name')\n        );\n        if (!upperLabelRect && thisLayout.isLeafRoot) {\n            var iconChar = seriesModel.get('drillDownIcon', true);\n            text = iconChar ? iconChar + ' ' + text : text;\n        }\n\n        var normalLabelModel = nodeModel.getModel(\n            upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL\n        );\n        var emphasisLabelModel = nodeModel.getModel(\n            upperLabelRect ? PATH_UPPERLABEL_EMPHASIS : PATH_LABEL_EMPHASIS\n        );\n\n        var isShow = normalLabelModel.getShallow('show');\n\n        setLabelStyle(\n            normalStyle, emphasisStyle, normalLabelModel, emphasisLabelModel,\n            {\n                defaultText: isShow ? text : null,\n                autoColor: visualColor,\n                isRectText: true\n            }\n        );\n\n        upperLabelRect && (normalStyle.textRect = clone(upperLabelRect));\n\n        normalStyle.truncate = (isShow && normalLabelModel.get('ellipsis'))\n            ? {\n                outerWidth: width,\n                outerHeight: height,\n                minChar: 2\n            }\n            : null;\n    }\n\n    function giveGraphic(storageName, Ctor, depth, z) {\n        var element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];\n        var lasts = lastsForAnimation[storageName];\n\n        if (element) {\n            // Remove from oldStorage\n            oldStorage[storageName][oldRawIndex] = null;\n            prepareAnimationWhenHasOld(lasts, element, storageName);\n        }\n        // If invisible and no old element, do not create new element (for optimizing).\n        else if (!thisInvisible) {\n            element = new Ctor({z: calculateZ(depth, z)});\n            element.__tmDepth = depth;\n            element.__tmStorageName = storageName;\n            prepareAnimationWhenNoOld(lasts, element, storageName);\n        }\n\n        // Set to thisStorage\n        return (thisStorage[storageName][thisRawIndex] = element);\n    }\n\n    function prepareAnimationWhenHasOld(lasts, element, storageName) {\n        var lastCfg = lasts[thisRawIndex] = {};\n        lastCfg.old = storageName === 'nodeGroup'\n            ? element.position.slice()\n            : extend({}, element.shape);\n    }\n\n    // If a element is new, we need to find the animation start point carefully,\n    // otherwise it will looks strange when 'zoomToNode'.\n    function prepareAnimationWhenNoOld(lasts, element, storageName) {\n        var lastCfg = lasts[thisRawIndex] = {};\n        var parentNode = thisNode.parentNode;\n\n        if (parentNode && (!reRoot || reRoot.direction === 'drillDown')) {\n            var parentOldX = 0;\n            var parentOldY = 0;\n\n            // New nodes appear from right-bottom corner in 'zoomToNode' animation.\n            // For convenience, get old bounding rect from background.\n            var parentOldBg = lastsForAnimation.background[parentNode.getRawIndex()];\n            if (!reRoot && parentOldBg && parentOldBg.old) {\n                parentOldX = parentOldBg.old.width;\n                parentOldY = parentOldBg.old.height;\n            }\n\n            // When no parent old shape found, its parent is new too,\n            // so we can just use {x:0, y:0}.\n            lastCfg.old = storageName === 'nodeGroup'\n                ? [0, parentOldY]\n                : {x: parentOldX, y: parentOldY, width: 0, height: 0};\n        }\n\n        // Fade in, user can be aware that these nodes are new.\n        lastCfg.fadein = storageName !== 'nodeGroup';\n    }\n}\n\n// We can not set all backgroud with the same z, Because the behaviour of\n// drill down and roll up differ background creation sequence from tree\n// hierarchy sequence, which cause that lowser background element overlap\n// upper ones. So we calculate z based on depth.\n// Moreover, we try to shrink down z interval to [0, 1] to avoid that\n// treemap with large z overlaps other components.\nfunction calculateZ(depth, zInLevel) {\n    var zb = depth * Z_BASE + zInLevel;\n    return (zb - 1) / zb;\n}\n\n/**\n * @file Treemap action\n */\n\nvar noop$1 = function () {};\n\nvar actionTypes = [\n    'treemapZoomToNode',\n    'treemapRender',\n    'treemapMove'\n];\n\nfor (var i$2 = 0; i$2 < actionTypes.length; i$2++) {\n    registerAction({type: actionTypes[i$2], update: 'updateView'}, noop$1);\n}\n\nregisterAction(\n    {type: 'treemapRootToNode', update: 'updateView'},\n    function (payload, ecModel) {\n\n        ecModel.eachComponent(\n            {mainType: 'series', subType: 'treemap', query: payload},\n            handleRootToNode\n        );\n\n        function handleRootToNode(model, index) {\n            var targetInfo = retrieveTargetInfo(payload, model);\n\n            if (targetInfo) {\n                var originViewRoot = model.getViewRoot();\n                if (originViewRoot) {\n                    payload.direction = aboveViewRoot(originViewRoot, targetInfo.node)\n                        ? 'rollUp' : 'drillDown';\n                }\n                model.resetViewRoot(targetInfo.node);\n            }\n        }\n    }\n);\n\nvar each$12 = each$1;\nvar isObject$5 = isObject;\n\nvar CATEGORY_DEFAULT_VISUAL_INDEX = -1;\n\n/**\n * @param {Object} option\n * @param {string} [option.type] See visualHandlers.\n * @param {string} [option.mappingMethod] 'linear' or 'piecewise' or 'category' or 'fixed'\n * @param {Array.<number>=} [option.dataExtent] [minExtent, maxExtent],\n *                                              required when mappingMethod is 'linear'\n * @param {Array.<Object>=} [option.pieceList] [\n *                                             {value: someValue},\n *                                             {interval: [min1, max1], visual: {...}},\n *                                             {interval: [min2, max2]}\n *                                             ],\n *                                            required when mappingMethod is 'piecewise'.\n *                                            Visual for only each piece can be specified.\n * @param {Array.<string|Object>=} [option.categories] ['cate1', 'cate2']\n *                                            required when mappingMethod is 'category'.\n *                                            If no option.categories, categories is set\n *                                            as [0, 1, 2, ...].\n * @param {boolean} [option.loop=false] Whether loop mapping when mappingMethod is 'category'.\n * @param {(Array|Object|*)} [option.visual]  Visual data.\n *                                            when mappingMethod is 'category',\n *                                            visual data can be array or object\n *                                            (like: {cate1: '#222', none: '#fff'})\n *                                            or primary types (which represents\n *                                            defualt category visual), otherwise visual\n *                                            can be array or primary (which will be\n *                                            normalized to array).\n *\n */\nvar VisualMapping = function (option) {\n    var mappingMethod = option.mappingMethod;\n    var visualType = option.type;\n\n    /**\n     * @readOnly\n     * @type {Object}\n     */\n    var thisOption = this.option = clone(option);\n\n    /**\n     * @readOnly\n     * @type {string}\n     */\n    this.type = visualType;\n\n    /**\n     * @readOnly\n     * @type {string}\n     */\n    this.mappingMethod = mappingMethod;\n\n    /**\n     * @private\n     * @type {Function}\n     */\n    this._normalizeData = normalizers[mappingMethod];\n\n    var visualHandler = visualHandlers[visualType];\n\n    /**\n     * @public\n     * @type {Function}\n     */\n    this.applyVisual = visualHandler.applyVisual;\n\n    /**\n     * @public\n     * @type {Function}\n     */\n    this.getColorMapper = visualHandler.getColorMapper;\n\n    /**\n     * @private\n     * @type {Function}\n     */\n    this._doMap = visualHandler._doMap[mappingMethod];\n\n    if (mappingMethod === 'piecewise') {\n        normalizeVisualRange(thisOption);\n        preprocessForPiecewise(thisOption);\n    }\n    else if (mappingMethod === 'category') {\n        thisOption.categories\n            ? preprocessForSpecifiedCategory(thisOption)\n            // categories is ordinal when thisOption.categories not specified,\n            // which need no more preprocess except normalize visual.\n            : normalizeVisualRange(thisOption, true);\n    }\n    else { // mappingMethod === 'linear' or 'fixed'\n        assert(mappingMethod !== 'linear' || thisOption.dataExtent);\n        normalizeVisualRange(thisOption);\n    }\n};\n\nVisualMapping.prototype = {\n\n    constructor: VisualMapping,\n\n    mapValueToVisual: function (value) {\n        var normalized = this._normalizeData(value);\n        return this._doMap(normalized, value);\n    },\n\n    getNormalizer: function () {\n        return bind(this._normalizeData, this);\n    }\n};\n\nvar visualHandlers = VisualMapping.visualHandlers = {\n\n    color: {\n\n        applyVisual: makeApplyVisual('color'),\n\n        /**\n         * Create a mapper function\n         * @return {Function}\n         */\n        getColorMapper: function () {\n            var thisOption = this.option;\n\n            return bind(\n                thisOption.mappingMethod === 'category'\n                    ? function (value, isNormalized) {\n                        !isNormalized && (value = this._normalizeData(value));\n                        return doMapCategory.call(this, value);\n                    }\n                    : function (value, isNormalized, out) {\n                        // If output rgb array\n                        // which will be much faster and useful in pixel manipulation\n                        var returnRGBArray = !!out;\n                        !isNormalized && (value = this._normalizeData(value));\n                        out = fastLerp(value, thisOption.parsedVisual, out);\n                        return returnRGBArray ? out : stringify(out, 'rgba');\n                    },\n                this\n            );\n        },\n\n        _doMap: {\n            linear: function (normalized) {\n                return stringify(\n                    fastLerp(normalized, this.option.parsedVisual),\n                    'rgba'\n                );\n            },\n            category: doMapCategory,\n            piecewise: function (normalized, value) {\n                var result = getSpecifiedVisual.call(this, value);\n                if (result == null) {\n                    result = stringify(\n                        fastLerp(normalized, this.option.parsedVisual),\n                        'rgba'\n                    );\n                }\n                return result;\n            },\n            fixed: doMapFixed\n        }\n    },\n\n    colorHue: makePartialColorVisualHandler(function (color, value) {\n        return modifyHSL(color, value);\n    }),\n\n    colorSaturation: makePartialColorVisualHandler(function (color, value) {\n        return modifyHSL(color, null, value);\n    }),\n\n    colorLightness: makePartialColorVisualHandler(function (color, value) {\n        return modifyHSL(color, null, null, value);\n    }),\n\n    colorAlpha: makePartialColorVisualHandler(function (color, value) {\n        return modifyAlpha(color, value);\n    }),\n\n    opacity: {\n        applyVisual: makeApplyVisual('opacity'),\n        _doMap: makeDoMap([0, 1])\n    },\n\n    symbol: {\n        applyVisual: function (value, getter, setter) {\n            var symbolCfg = this.mapValueToVisual(value);\n            if (isString(symbolCfg)) {\n                setter('symbol', symbolCfg);\n            }\n            else if (isObject$5(symbolCfg)) {\n                for (var name in symbolCfg) {\n                    if (symbolCfg.hasOwnProperty(name)) {\n                        setter(name, symbolCfg[name]);\n                    }\n                }\n            }\n        },\n        _doMap: {\n            linear: doMapToArray,\n            category: doMapCategory,\n            piecewise: function (normalized, value) {\n                var result = getSpecifiedVisual.call(this, value);\n                if (result == null) {\n                    result = doMapToArray.call(this, normalized);\n                }\n                return result;\n            },\n            fixed: doMapFixed\n        }\n    },\n\n    symbolSize: {\n        applyVisual: makeApplyVisual('symbolSize'),\n        _doMap: makeDoMap([0, 1])\n    }\n};\n\n\nfunction preprocessForPiecewise(thisOption) {\n    var pieceList = thisOption.pieceList;\n    thisOption.hasSpecialVisual = false;\n\n    each$1(pieceList, function (piece, index) {\n        piece.originIndex = index;\n        // piece.visual is \"result visual value\" but not\n        // a visual range, so it does not need to be normalized.\n        if (piece.visual != null) {\n            thisOption.hasSpecialVisual = true;\n        }\n    });\n}\n\nfunction preprocessForSpecifiedCategory(thisOption) {\n    // Hash categories.\n    var categories = thisOption.categories;\n    var visual = thisOption.visual;\n\n    var categoryMap = thisOption.categoryMap = {};\n    each$12(categories, function (cate, index) {\n        categoryMap[cate] = index;\n    });\n\n    // Process visual map input.\n    if (!isArray(visual)) {\n        var visualArr = [];\n\n        if (isObject(visual)) {\n            each$12(visual, function (v, cate) {\n                var index = categoryMap[cate];\n                visualArr[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;\n            });\n        }\n        else { // Is primary type, represents default visual.\n            visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;\n        }\n\n        visual = setVisualToOption(thisOption, visualArr);\n    }\n\n    // Remove categories that has no visual,\n    // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.\n    for (var i = categories.length - 1; i >= 0; i--) {\n        if (visual[i] == null) {\n            delete categoryMap[categories[i]];\n            categories.pop();\n        }\n    }\n}\n\nfunction normalizeVisualRange(thisOption, isCategory) {\n    var visual = thisOption.visual;\n    var visualArr = [];\n\n    if (isObject(visual)) {\n        each$12(visual, function (v) {\n            visualArr.push(v);\n        });\n    }\n    else if (visual != null) {\n        visualArr.push(visual);\n    }\n\n    var doNotNeedPair = {color: 1, symbol: 1};\n\n    if (!isCategory\n        && visualArr.length === 1\n        && !doNotNeedPair.hasOwnProperty(thisOption.type)\n    ) {\n        // Do not care visualArr.length === 0, which is illegal.\n        visualArr[1] = visualArr[0];\n    }\n\n    setVisualToOption(thisOption, visualArr);\n}\n\nfunction makePartialColorVisualHandler(applyValue) {\n    return {\n        applyVisual: function (value, getter, setter) {\n            value = this.mapValueToVisual(value);\n            // Must not be array value\n            setter('color', applyValue(getter('color'), value));\n        },\n        _doMap: makeDoMap([0, 1])\n    };\n}\n\nfunction doMapToArray(normalized) {\n    var visual = this.option.visual;\n    return visual[\n        Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))\n    ] || {};\n}\n\nfunction makeApplyVisual(visualType) {\n    return function (value, getter, setter) {\n        setter(visualType, this.mapValueToVisual(value));\n    };\n}\n\nfunction doMapCategory(normalized) {\n    var visual = this.option.visual;\n    return visual[\n        (this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX)\n            ? normalized % visual.length\n            : normalized\n    ];\n}\n\nfunction doMapFixed() {\n    return this.option.visual[0];\n}\n\nfunction makeDoMap(sourceExtent) {\n    return {\n        linear: function (normalized) {\n            return linearMap(normalized, sourceExtent, this.option.visual, true);\n        },\n        category: doMapCategory,\n        piecewise: function (normalized, value) {\n            var result = getSpecifiedVisual.call(this, value);\n            if (result == null) {\n                result = linearMap(normalized, sourceExtent, this.option.visual, true);\n            }\n            return result;\n        },\n        fixed: doMapFixed\n    };\n}\n\nfunction getSpecifiedVisual(value) {\n    var thisOption = this.option;\n    var pieceList = thisOption.pieceList;\n    if (thisOption.hasSpecialVisual) {\n        var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);\n        var piece = pieceList[pieceIndex];\n        if (piece && piece.visual) {\n            return piece.visual[this.type];\n        }\n    }\n}\n\nfunction setVisualToOption(thisOption, visualArr) {\n    thisOption.visual = visualArr;\n    if (thisOption.type === 'color') {\n        thisOption.parsedVisual = map(visualArr, function (item) {\n            return parse(item);\n        });\n    }\n    return visualArr;\n}\n\n\n/**\n * Normalizers by mapping methods.\n */\nvar normalizers = {\n\n    linear: function (value) {\n        return linearMap(value, this.option.dataExtent, [0, 1], true);\n    },\n\n    piecewise: function (value) {\n        var pieceList = this.option.pieceList;\n        var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);\n        if (pieceIndex != null) {\n            return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);\n        }\n    },\n\n    category: function (value) {\n        var index = this.option.categories\n            ? this.option.categoryMap[value]\n            : value; // ordinal\n        return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;\n    },\n\n    fixed: noop\n};\n\n\n\n/**\n * List available visual types.\n *\n * @public\n * @return {Array.<string>}\n */\nVisualMapping.listVisualTypes = function () {\n    var visualTypes = [];\n    each$1(visualHandlers, function (handler, key) {\n        visualTypes.push(key);\n    });\n    return visualTypes;\n};\n\n/**\n * @public\n */\nVisualMapping.addVisualHandler = function (name, handler) {\n    visualHandlers[name] = handler;\n};\n\n/**\n * @public\n */\nVisualMapping.isValidType = function (visualType) {\n    return visualHandlers.hasOwnProperty(visualType);\n};\n\n/**\n * Convinent method.\n * Visual can be Object or Array or primary type.\n *\n * @public\n */\nVisualMapping.eachVisual = function (visual, callback, context) {\n    if (isObject(visual)) {\n        each$1(visual, callback, context);\n    }\n    else {\n        callback.call(context, visual);\n    }\n};\n\nVisualMapping.mapVisual = function (visual, callback, context) {\n    var isPrimary;\n    var newVisual = isArray(visual)\n        ? []\n        : isObject(visual)\n        ? {}\n        : (isPrimary = true, null);\n\n    VisualMapping.eachVisual(visual, function (v, key) {\n        var newVal = callback.call(context, v, key);\n        isPrimary ? (newVisual = newVal) : (newVisual[key] = newVal);\n    });\n    return newVisual;\n};\n\n/**\n * @public\n * @param {Object} obj\n * @return {Object} new object containers visual values.\n *                 If no visuals, return null.\n */\nVisualMapping.retrieveVisuals = function (obj) {\n    var ret = {};\n    var hasVisual;\n\n    obj && each$12(visualHandlers, function (h, visualType) {\n        if (obj.hasOwnProperty(visualType)) {\n            ret[visualType] = obj[visualType];\n            hasVisual = true;\n        }\n    });\n\n    return hasVisual ? ret : null;\n};\n\n/**\n * Give order to visual types, considering colorSaturation, colorAlpha depends on color.\n *\n * @public\n * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}\n *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']\n * @return {Array.<string>} Sorted visual types.\n */\nVisualMapping.prepareVisualTypes = function (visualTypes) {\n    if (isObject$5(visualTypes)) {\n        var types = [];\n        each$12(visualTypes, function (item, type) {\n            types.push(type);\n        });\n        visualTypes = types;\n    }\n    else if (isArray(visualTypes)) {\n        visualTypes = visualTypes.slice();\n    }\n    else {\n        return [];\n    }\n\n    visualTypes.sort(function (type1, type2) {\n        // color should be front of colorSaturation, colorAlpha, ...\n        // symbol and symbolSize do not matter.\n        return (type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0)\n            ? 1 : -1;\n    });\n\n    return visualTypes;\n};\n\n/**\n * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.\n * Other visuals are only depends on themself.\n *\n * @public\n * @param {string} visualType1\n * @param {string} visualType2\n * @return {boolean}\n */\nVisualMapping.dependsOn = function (visualType1, visualType2) {\n    return visualType2 === 'color'\n        ? !!(visualType1 && visualType1.indexOf(visualType2) === 0)\n        : visualType1 === visualType2;\n};\n\n/**\n * @param {number} value\n * @param {Array.<Object>} pieceList [{value: ..., interval: [min, max]}, ...]\n *                         Always from small to big.\n * @param {boolean} [findClosestWhenOutside=false]\n * @return {number} index\n */\nVisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {\n    var possibleI;\n    var abs = Infinity;\n\n    // value has the higher priority.\n    for (var i = 0, len = pieceList.length; i < len; i++) {\n        var pieceValue = pieceList[i].value;\n        if (pieceValue != null) {\n            if (pieceValue === value\n                // FIXME\n                // It is supposed to compare value according to value type of dimension,\n                // but currently value type can exactly be string or number.\n                // Compromise for numeric-like string (like '12'), especially\n                // in the case that visualMap.categories is ['22', '33'].\n                || (typeof pieceValue === 'string' && pieceValue === value + '')\n            ) {\n                return i;\n            }\n            findClosestWhenOutside && updatePossible(pieceValue, i);\n        }\n    }\n\n    for (var i = 0, len = pieceList.length; i < len; i++) {\n        var piece = pieceList[i];\n        var interval = piece.interval;\n        var close = piece.close;\n\n        if (interval) {\n            if (interval[0] === -Infinity) {\n                if (littleThan(close[1], value, interval[1])) {\n                    return i;\n                }\n            }\n            else if (interval[1] === Infinity) {\n                if (littleThan(close[0], interval[0], value)) {\n                    return i;\n                }\n            }\n            else if (\n                littleThan(close[0], interval[0], value)\n                && littleThan(close[1], value, interval[1])\n            ) {\n                return i;\n            }\n            findClosestWhenOutside && updatePossible(interval[0], i);\n            findClosestWhenOutside && updatePossible(interval[1], i);\n        }\n    }\n\n    if (findClosestWhenOutside) {\n        return value === Infinity\n            ? pieceList.length - 1\n            : value === -Infinity\n            ? 0\n            : possibleI;\n    }\n\n    function updatePossible(val, index) {\n        var newAbs = Math.abs(val - value);\n        if (newAbs < abs) {\n            abs = newAbs;\n            possibleI = index;\n        }\n    }\n\n};\n\nfunction littleThan(close, a, b) {\n    return close ? a <= b : a < b;\n}\n\nvar isArray$2 = isArray;\n\nvar ITEM_STYLE_NORMAL = 'itemStyle.normal';\n\nvar treemapVisual = function (ecModel, api, payload) {\n\n    var condition = {mainType: 'series', subType: 'treemap', query: payload};\n    ecModel.eachComponent(condition, function (seriesModel) {\n\n        var tree = seriesModel.getData().tree;\n        var root = tree.root;\n        var seriesItemStyleModel = seriesModel.getModel(ITEM_STYLE_NORMAL);\n\n        if (root.isRemoved()) {\n            return;\n        }\n\n        var levelItemStyles = map(tree.levelModels, function (levelModel) {\n            return levelModel ? levelModel.get(ITEM_STYLE_NORMAL) : null;\n        });\n\n        travelTree(\n            root, // Visual should calculate from tree root but not view root.\n            {},\n            levelItemStyles,\n            seriesItemStyleModel,\n            seriesModel.getViewRoot().getAncestors(),\n            seriesModel\n        );\n    });\n};\n\nfunction travelTree(\n    node, designatedVisual, levelItemStyles, seriesItemStyleModel,\n    viewRootAncestors, seriesModel\n) {\n    var nodeModel = node.getModel();\n    var nodeLayout = node.getLayout();\n\n    // Optimize\n    if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {\n        return;\n    }\n\n    var nodeItemStyleModel = node.getModel(ITEM_STYLE_NORMAL);\n    var levelItemStyle = levelItemStyles[node.depth];\n    var visuals = buildVisuals(\n        nodeItemStyleModel, designatedVisual, levelItemStyle, seriesItemStyleModel\n    );\n\n    // calculate border color\n    var borderColor = nodeItemStyleModel.get('borderColor');\n    var borderColorSaturation = nodeItemStyleModel.get('borderColorSaturation');\n    var thisNodeColor;\n    if (borderColorSaturation != null) {\n        // For performance, do not always execute 'calculateColor'.\n        thisNodeColor = calculateColor(visuals, node);\n        borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);\n    }\n    node.setVisual('borderColor', borderColor);\n\n    var viewChildren = node.viewChildren;\n    if (!viewChildren || !viewChildren.length) {\n        thisNodeColor = calculateColor(visuals, node);\n        // Apply visual to this node.\n        node.setVisual('color', thisNodeColor);\n    }\n    else {\n        var mapping = buildVisualMapping(\n            node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren\n        );\n\n        // Designate visual to children.\n        each$1(viewChildren, function (child, index) {\n            // If higher than viewRoot, only ancestors of viewRoot is needed to visit.\n            if (child.depth >= viewRootAncestors.length\n                || child === viewRootAncestors[child.depth]\n            ) {\n                var childVisual = mapVisual$1(\n                    nodeModel, visuals, child, index, mapping, seriesModel\n                );\n                travelTree(\n                    child, childVisual, levelItemStyles, seriesItemStyleModel,\n                    viewRootAncestors, seriesModel\n                );\n            }\n        });\n    }\n}\n\nfunction buildVisuals(\n    nodeItemStyleModel, designatedVisual, levelItemStyle, seriesItemStyleModel\n) {\n    var visuals = extend({}, designatedVisual);\n\n    each$1(['color', 'colorAlpha', 'colorSaturation'], function (visualName) {\n        // Priority: thisNode > thisLevel > parentNodeDesignated > seriesModel\n        var val = nodeItemStyleModel.get(visualName, true); // Ignore parent\n        val == null && levelItemStyle && (val = levelItemStyle[visualName]);\n        val == null && (val = designatedVisual[visualName]);\n        val == null && (val = seriesItemStyleModel.get(visualName));\n\n        val != null && (visuals[visualName] = val);\n    });\n\n    return visuals;\n}\n\nfunction calculateColor(visuals) {\n    var color = getValueVisualDefine(visuals, 'color');\n\n    if (color) {\n        var colorAlpha = getValueVisualDefine(visuals, 'colorAlpha');\n        var colorSaturation = getValueVisualDefine(visuals, 'colorSaturation');\n        if (colorSaturation) {\n            color = modifyHSL(color, null, null, colorSaturation);\n        }\n        if (colorAlpha) {\n            color = modifyAlpha(color, colorAlpha);\n        }\n\n        return color;\n    }\n}\n\nfunction calculateBorderColor(borderColorSaturation, thisNodeColor) {\n    return thisNodeColor != null\n            ? modifyHSL(thisNodeColor, null, null, borderColorSaturation)\n            : null;\n}\n\nfunction getValueVisualDefine(visuals, name) {\n    var value = visuals[name];\n    if (value != null && value !== 'none') {\n        return value;\n    }\n}\n\nfunction buildVisualMapping(\n    node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren\n) {\n    if (!viewChildren || !viewChildren.length) {\n        return;\n    }\n\n    var rangeVisual = getRangeVisual(nodeModel, 'color')\n        || (\n            visuals.color != null\n            && visuals.color !== 'none'\n            && (\n                getRangeVisual(nodeModel, 'colorAlpha')\n                || getRangeVisual(nodeModel, 'colorSaturation')\n            )\n        );\n\n    if (!rangeVisual) {\n        return;\n    }\n\n    var visualMin = nodeModel.get('visualMin');\n    var visualMax = nodeModel.get('visualMax');\n    var dataExtent = nodeLayout.dataExtent.slice();\n    visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin);\n    visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax);\n\n    var colorMappingBy = nodeModel.get('colorMappingBy');\n    var opt = {\n        type: rangeVisual.name,\n        dataExtent: dataExtent,\n        visual: rangeVisual.range\n    };\n    if (opt.type === 'color'\n        && (colorMappingBy === 'index' || colorMappingBy === 'id')\n    ) {\n        opt.mappingMethod = 'category';\n        opt.loop = true;\n        // categories is ordinal, so do not set opt.categories.\n    }\n    else {\n        opt.mappingMethod = 'linear';\n    }\n\n    var mapping = new VisualMapping(opt);\n    mapping.__drColorMappingBy = colorMappingBy;\n\n    return mapping;\n}\n\n// Notice: If we dont have the attribute 'colorRange', but only use\n// attribute 'color' to represent both concepts of 'colorRange' and 'color',\n// (It means 'colorRange' when 'color' is Array, means 'color' when not array),\n// this problem will be encountered:\n// If a level-1 node dont have children, and its siblings has children,\n// and colorRange is set on level-1, then the node can not be colored.\n// So we separate 'colorRange' and 'color' to different attributes.\nfunction getRangeVisual(nodeModel, name) {\n    // 'colorRange', 'colorARange', 'colorSRange'.\n    // If not exsits on this node, fetch from levels and series.\n    var range = nodeModel.get(name);\n    return (isArray$2(range) && range.length) ? {name: name, range: range} : null;\n}\n\nfunction mapVisual$1(nodeModel, visuals, child, index, mapping, seriesModel) {\n    var childVisuals = extend({}, visuals);\n\n    if (mapping) {\n        var mappingType = mapping.type;\n        var colorMappingBy = mappingType === 'color' && mapping.__drColorMappingBy;\n        var value =\n            colorMappingBy === 'index'\n            ? index\n            : colorMappingBy === 'id'\n            ? seriesModel.mapIdToIndex(child.getId())\n            : child.getValue(nodeModel.get('visualDimension'));\n\n        childVisuals[mappingType] = mapping.mapValueToVisual(value);\n    }\n\n    return childVisuals;\n}\n\nvar mathMax$4 = Math.max;\nvar mathMin$4 = Math.min;\nvar retrieveValue$1 = retrieve;\nvar each$13 = each$1;\n\nvar PATH_BORDER_WIDTH = ['itemStyle', 'normal', 'borderWidth'];\nvar PATH_GAP_WIDTH = ['itemStyle', 'normal', 'gapWidth'];\nvar PATH_UPPER_LABEL_SHOW = ['upperLabel', 'normal', 'show'];\nvar PATH_UPPER_LABEL_HEIGHT = ['upperLabel', 'normal', 'height'];\n\n/**\n * @public\n */\nvar treemapLayout = function (ecModel, api, payload) {\n    // Layout result in each node:\n    // {x, y, width, height, area, borderWidth}\n    var condition = {mainType: 'series', subType: 'treemap', query: payload};\n    ecModel.eachComponent(condition, function (seriesModel) {\n\n        var ecWidth = api.getWidth();\n        var ecHeight = api.getHeight();\n        var seriesOption = seriesModel.option;\n\n        var layoutInfo = getLayoutRect(\n            seriesModel.getBoxLayoutParams(),\n            {\n                width: api.getWidth(),\n                height: api.getHeight()\n            }\n        );\n\n        var size = seriesOption.size || []; // Compatible with ec2.\n        var containerWidth = parsePercent$1(\n            retrieveValue$1(layoutInfo.width, size[0]),\n            ecWidth\n        );\n        var containerHeight = parsePercent$1(\n            retrieveValue$1(layoutInfo.height, size[1]),\n            ecHeight\n        );\n\n        // Fetch payload info.\n        var payloadType = payload && payload.type;\n        var targetInfo = retrieveTargetInfo(payload, seriesModel);\n        var rootRect = (payloadType === 'treemapRender' || payloadType === 'treemapMove')\n            ? payload.rootRect : null;\n        var viewRoot = seriesModel.getViewRoot();\n        var viewAbovePath = getPathToRoot(viewRoot);\n\n        if (payloadType !== 'treemapMove') {\n            var rootSize = payloadType === 'treemapZoomToNode'\n                ? estimateRootSize(\n                    seriesModel, targetInfo, viewRoot, containerWidth, containerHeight\n                )\n                : rootRect\n                ? [rootRect.width, rootRect.height]\n                : [containerWidth, containerHeight];\n\n            var sort = seriesOption.sort;\n            if (sort && sort !== 'asc' && sort !== 'desc') {\n                sort = 'desc';\n            }\n            var options = {\n                squareRatio: seriesOption.squareRatio,\n                sort: sort,\n                leafDepth: seriesOption.leafDepth\n            };\n\n            // layout should be cleared because using updateView but not update.\n            viewRoot.hostTree.clearLayouts();\n\n            // TODO\n            // optimize: if out of view clip, do not layout.\n            // But take care that if do not render node out of view clip,\n            // how to calculate start po\n\n            var viewRootLayout = {\n                x: 0, y: 0,\n                width: rootSize[0], height: rootSize[1],\n                area: rootSize[0] * rootSize[1]\n            };\n            viewRoot.setLayout(viewRootLayout);\n\n            squarify(viewRoot, options, false, 0);\n            // Supplement layout.\n            var viewRootLayout = viewRoot.getLayout();\n            each$13(viewAbovePath, function (node, index) {\n                var childValue = (viewAbovePath[index + 1] || viewRoot).getValue();\n                node.setLayout(extend(\n                    {dataExtent: [childValue, childValue], borderWidth: 0, upperHeight: 0},\n                    viewRootLayout\n                ));\n            });\n        }\n\n        var treeRoot = seriesModel.getData().tree.root;\n\n        treeRoot.setLayout(\n            calculateRootPosition(layoutInfo, rootRect, targetInfo),\n            true\n        );\n\n        seriesModel.setLayoutInfo(layoutInfo);\n\n        // FIXME\n        // clipec\n        prunning(\n            treeRoot,\n            // Transform to base element coordinate system.\n            new BoundingRect(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight),\n            viewAbovePath,\n            viewRoot,\n            0\n        );\n    });\n};\n\n/**\n * Layout treemap with squarify algorithm.\n * @see https://graphics.ethz.ch/teaching/scivis_common/Literature/squarifiedTreeMaps.pdf\n * @see https://github.com/mbostock/d3/blob/master/src/layout/treemap.js\n *\n * @protected\n * @param {module:echarts/data/Tree~TreeNode} node\n * @param {Object} options\n * @param {string} options.sort 'asc' or 'desc'\n * @param {number} options.squareRatio\n * @param {boolean} hideChildren\n * @param {number} depth\n */\nfunction squarify(node, options, hideChildren, depth) {\n    var width;\n    var height;\n\n    if (node.isRemoved()) {\n        return;\n    }\n\n    var thisLayout = node.getLayout();\n    width = thisLayout.width;\n    height = thisLayout.height;\n\n    // Considering border and gap\n    var nodeModel = node.getModel();\n    var borderWidth = nodeModel.get(PATH_BORDER_WIDTH);\n    var halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;\n    var upperLabelHeight = getUpperLabelHeight(nodeModel);\n    var upperHeight = Math.max(borderWidth, upperLabelHeight);\n    var layoutOffset = borderWidth - halfGapWidth;\n    var layoutOffsetUpper = upperHeight - halfGapWidth;\n    var nodeModel = node.getModel();\n\n    node.setLayout({\n        borderWidth: borderWidth,\n        upperHeight: upperHeight,\n        upperLabelHeight: upperLabelHeight\n    }, true);\n\n    width = mathMax$4(width - 2 * layoutOffset, 0);\n    height = mathMax$4(height - layoutOffset - layoutOffsetUpper, 0);\n\n    var totalArea = width * height;\n    var viewChildren = initChildren(\n        node, nodeModel, totalArea, options, hideChildren, depth\n    );\n\n    if (!viewChildren.length) {\n        return;\n    }\n\n    var rect = {x: layoutOffset, y: layoutOffsetUpper, width: width, height: height};\n    var rowFixedLength = mathMin$4(width, height);\n    var best = Infinity; // the best row score so far\n    var row = [];\n    row.area = 0;\n\n    for (var i = 0, len = viewChildren.length; i < len;) {\n        var child = viewChildren[i];\n\n        row.push(child);\n        row.area += child.getLayout().area;\n        var score = worst(row, rowFixedLength, options.squareRatio);\n\n        // continue with this orientation\n        if (score <= best) {\n            i++;\n            best = score;\n        }\n        // abort, and try a different orientation\n        else {\n            row.area -= row.pop().getLayout().area;\n            position(row, rowFixedLength, rect, halfGapWidth, false);\n            rowFixedLength = mathMin$4(rect.width, rect.height);\n            row.length = row.area = 0;\n            best = Infinity;\n        }\n    }\n\n    if (row.length) {\n        position(row, rowFixedLength, rect, halfGapWidth, true);\n    }\n\n    if (!hideChildren) {\n        var childrenVisibleMin = nodeModel.get('childrenVisibleMin');\n        if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {\n            hideChildren = true;\n        }\n    }\n\n    for (var i = 0, len = viewChildren.length; i < len; i++) {\n        squarify(viewChildren[i], options, hideChildren, depth + 1);\n    }\n}\n\n/**\n * Set area to each child, and calculate data extent for visual coding.\n */\nfunction initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {\n    var viewChildren = node.children || [];\n    var orderBy = options.sort;\n    orderBy !== 'asc' && orderBy !== 'desc' && (orderBy = null);\n\n    var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth;\n\n    // leafDepth has higher priority.\n    if (hideChildren && !overLeafDepth) {\n        return (node.viewChildren = []);\n    }\n\n    // Sort children, order by desc.\n    viewChildren = filter(viewChildren, function (child) {\n        return !child.isRemoved();\n    });\n\n    sort$1(viewChildren, orderBy);\n\n    var info = statistic(nodeModel, viewChildren, orderBy);\n\n    if (info.sum === 0) {\n        return (node.viewChildren = []);\n    }\n\n    info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);\n\n    if (info.sum === 0) {\n        return (node.viewChildren = []);\n    }\n\n    // Set area to each child.\n    for (var i = 0, len = viewChildren.length; i < len; i++) {\n        var area = viewChildren[i].getValue() / info.sum * totalArea;\n        // Do not use setLayout({...}, true), because it is needed to clear last layout.\n        viewChildren[i].setLayout({area: area});\n    }\n\n    if (overLeafDepth) {\n        viewChildren.length && node.setLayout({isLeafRoot: true}, true);\n        viewChildren.length = 0;\n    }\n\n    node.viewChildren = viewChildren;\n    node.setLayout({dataExtent: info.dataExtent}, true);\n\n    return viewChildren;\n}\n\n/**\n * Consider 'visibleMin'. Modify viewChildren and get new sum.\n */\nfunction filterByThreshold(nodeModel, totalArea, sum, orderBy, orderedChildren) {\n\n    // visibleMin is not supported yet when no option.sort.\n    if (!orderBy) {\n        return sum;\n    }\n\n    var visibleMin = nodeModel.get('visibleMin');\n    var len = orderedChildren.length;\n    var deletePoint = len;\n\n    // Always travel from little value to big value.\n    for (var i = len - 1; i >= 0; i--) {\n        var value = orderedChildren[\n            orderBy === 'asc' ? len - i - 1 : i\n        ].getValue();\n\n        if (value / sum * totalArea < visibleMin) {\n            deletePoint = i;\n            sum -= value;\n        }\n    }\n\n    orderBy === 'asc'\n        ? orderedChildren.splice(0, len - deletePoint)\n        : orderedChildren.splice(deletePoint, len - deletePoint);\n\n    return sum;\n}\n\n/**\n * Sort\n */\nfunction sort$1(viewChildren, orderBy) {\n    if (orderBy) {\n        viewChildren.sort(function (a, b) {\n            var diff = orderBy === 'asc'\n                ?  a.getValue() - b.getValue() : b.getValue() - a.getValue();\n            return diff === 0\n                ? (orderBy === 'asc'\n                    ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex\n                )\n                : diff;\n        });\n    }\n    return viewChildren;\n}\n\n/**\n * Statistic\n */\nfunction statistic(nodeModel, children, orderBy) {\n    // Calculate sum.\n    var sum = 0;\n    for (var i = 0, len = children.length; i < len; i++) {\n        sum += children[i].getValue();\n    }\n\n    // Statistic data extent for latter visual coding.\n    // Notice: data extent should be calculate based on raw children\n    // but not filtered view children, otherwise visual mapping will not\n    // be stable when zoom (where children is filtered by visibleMin).\n\n    var dimension = nodeModel.get('visualDimension');\n    var dataExtent;\n\n    // The same as area dimension.\n    if (!children || !children.length) {\n        dataExtent = [NaN, NaN];\n    }\n    else if (dimension === 'value' && orderBy) {\n        dataExtent = [\n            children[children.length - 1].getValue(),\n            children[0].getValue()\n        ];\n        orderBy === 'asc' && dataExtent.reverse();\n    }\n    // Other dimension.\n    else {\n        var dataExtent = [Infinity, -Infinity];\n        each$13(children, function (child) {\n            var value = child.getValue(dimension);\n            value < dataExtent[0] && (dataExtent[0] = value);\n            value > dataExtent[1] && (dataExtent[1] = value);\n        });\n    }\n\n    return {sum: sum, dataExtent: dataExtent};\n}\n\n/**\n * Computes the score for the specified row,\n * as the worst aspect ratio.\n */\nfunction worst(row, rowFixedLength, ratio) {\n    var areaMax = 0;\n    var areaMin = Infinity;\n\n    for (var i = 0, area, len = row.length; i < len; i++) {\n        area = row[i].getLayout().area;\n        if (area) {\n            area < areaMin && (areaMin = area);\n            area > areaMax && (areaMax = area);\n        }\n    }\n\n    var squareArea = row.area * row.area;\n    var f = rowFixedLength * rowFixedLength * ratio;\n\n    return squareArea\n        ? mathMax$4(\n            (f * areaMax) / squareArea,\n            squareArea / (f * areaMin)\n        )\n        : Infinity;\n}\n\n/**\n * Positions the specified row of nodes. Modifies `rect`.\n */\nfunction position(row, rowFixedLength, rect, halfGapWidth, flush) {\n    // When rowFixedLength === rect.width,\n    // it is horizontal subdivision,\n    // rowFixedLength is the width of the subdivision,\n    // rowOtherLength is the height of the subdivision,\n    // and nodes will be positioned from left to right.\n\n    // wh[idx0WhenH] means: when horizontal,\n    //      wh[idx0WhenH] => wh[0] => 'width'.\n    //      xy[idx1WhenH] => xy[1] => 'y'.\n    var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;\n    var idx1WhenH = 1 - idx0WhenH;\n    var xy = ['x', 'y'];\n    var wh = ['width', 'height'];\n\n    var last = rect[xy[idx0WhenH]];\n    var rowOtherLength = rowFixedLength\n        ? row.area / rowFixedLength : 0;\n\n    if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {\n        rowOtherLength = rect[wh[idx1WhenH]]; // over+underflow\n    }\n    for (var i = 0, rowLen = row.length; i < rowLen; i++) {\n        var node = row[i];\n        var nodeLayout = {};\n        var step = rowOtherLength\n            ? node.getLayout().area / rowOtherLength : 0;\n\n        var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax$4(rowOtherLength - 2 * halfGapWidth, 0);\n\n        // We use Math.max/min to avoid negative width/height when considering gap width.\n        var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;\n        var modWH = (i === rowLen - 1 || remain < step) ? remain : step;\n        var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax$4(modWH - 2 * halfGapWidth, 0);\n\n        nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin$4(halfGapWidth, wh1 / 2);\n        nodeLayout[xy[idx0WhenH]] = last + mathMin$4(halfGapWidth, wh0 / 2);\n\n        last += modWH;\n        node.setLayout(nodeLayout, true);\n    }\n\n    rect[xy[idx1WhenH]] += rowOtherLength;\n    rect[wh[idx1WhenH]] -= rowOtherLength;\n}\n\n// Return [containerWidth, containerHeight] as defualt.\nfunction estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {\n    // If targetInfo.node exists, we zoom to the node,\n    // so estimate whold width and heigth by target node.\n    var currNode = (targetInfo || {}).node;\n    var defaultSize = [containerWidth, containerHeight];\n\n    if (!currNode || currNode === viewRoot) {\n        return defaultSize;\n    }\n\n    var parent;\n    var viewArea = containerWidth * containerHeight;\n    var area = viewArea * seriesModel.option.zoomToNodeRatio;\n\n    while (parent = currNode.parentNode) { // jshint ignore:line\n        var sum = 0;\n        var siblings = parent.children;\n\n        for (var i = 0, len = siblings.length; i < len; i++) {\n            sum += siblings[i].getValue();\n        }\n        var currNodeValue = currNode.getValue();\n        if (currNodeValue === 0) {\n            return defaultSize;\n        }\n        area *= sum / currNodeValue;\n\n        // Considering border, suppose aspect ratio is 1.\n        var parentModel = parent.getModel();\n        var borderWidth = parentModel.get(PATH_BORDER_WIDTH);\n        var upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel, borderWidth));\n        area += 4 * borderWidth * borderWidth\n            + (3 * borderWidth + upperHeight) * Math.pow(area, 0.5);\n\n        area > MAX_SAFE_INTEGER && (area = MAX_SAFE_INTEGER);\n\n        currNode = parent;\n    }\n\n    area < viewArea && (area = viewArea);\n    var scale = Math.pow(area / viewArea, 0.5);\n\n    return [containerWidth * scale, containerHeight * scale];\n}\n\n// Root postion base on coord of containerGroup\nfunction calculateRootPosition(layoutInfo, rootRect, targetInfo) {\n    if (rootRect) {\n        return {x: rootRect.x, y: rootRect.y};\n    }\n\n    var defaultPosition = {x: 0, y: 0};\n    if (!targetInfo) {\n        return defaultPosition;\n    }\n\n    // If targetInfo is fetched by 'retrieveTargetInfo',\n    // old tree and new tree are the same tree,\n    // so the node still exists and we can visit it.\n\n    var targetNode = targetInfo.node;\n    var layout = targetNode.getLayout();\n\n    if (!layout) {\n        return defaultPosition;\n    }\n\n    // Transform coord from local to container.\n    var targetCenter = [layout.width / 2, layout.height / 2];\n    var node = targetNode;\n    while (node) {\n        var nodeLayout = node.getLayout();\n        targetCenter[0] += nodeLayout.x;\n        targetCenter[1] += nodeLayout.y;\n        node = node.parentNode;\n    }\n\n    return {\n        x: layoutInfo.width / 2 - targetCenter[0],\n        y: layoutInfo.height / 2 - targetCenter[1]\n    };\n}\n\n// Mark nodes visible for prunning when visual coding and rendering.\n// Prunning depends on layout and root position, so we have to do it after layout.\nfunction prunning(node, clipRect, viewAbovePath, viewRoot, depth) {\n    var nodeLayout = node.getLayout();\n    var nodeInViewAbovePath = viewAbovePath[depth];\n    var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;\n\n    if (\n        (nodeInViewAbovePath && !isAboveViewRoot)\n        || (depth === viewAbovePath.length && node !== viewRoot)\n    ) {\n        return;\n    }\n\n    node.setLayout({\n        // isInView means: viewRoot sub tree + viewAbovePath\n        isInView: true,\n        // invisible only means: outside view clip so that the node can not\n        // see but still layout for animation preparation but not render.\n        invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),\n        isAboveViewRoot: isAboveViewRoot\n    }, true);\n\n    // Transform to child coordinate.\n    var childClipRect = new BoundingRect(\n        clipRect.x - nodeLayout.x,\n        clipRect.y - nodeLayout.y,\n        clipRect.width,\n        clipRect.height\n    );\n\n    each$13(node.viewChildren || [], function (child) {\n        prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);\n    });\n}\n\nfunction getUpperLabelHeight(model) {\n    return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0;\n}\n\nregisterVisual(treemapVisual);\nregisterLayout(treemapLayout);\n\n/**\n * Graph data structure\n *\n * @module echarts/data/Graph\n * @author Yi Shen(https://www.github.com/pissang)\n */\n\n// id may be function name of Object, add a prefix to avoid this problem.\nfunction generateNodeKey (id) {\n    return '_EC_' + id;\n}\n/**\n * @alias module:echarts/data/Graph\n * @constructor\n * @param {boolean} directed\n */\nvar Graph = function(directed) {\n    /**\n     * \n     * @type {boolean}\n     * @private\n     */\n    this._directed = directed || false;\n\n    /**\n     * @type {Array.<module:echarts/data/Graph.Node>}\n     * @readOnly\n     */\n    this.nodes = [];\n\n    /**\n     * @type {Array.<module:echarts/data/Graph.Edge>}\n     * @readOnly\n     */\n    this.edges = [];\n\n    /**\n     * @type {Object.<string, module:echarts/data/Graph.Node>}\n     * @private\n     */\n    this._nodesMap = {};\n    /**\n     * @type {Object.<string, module:echarts/data/Graph.Edge>}\n     * @private\n     */\n    this._edgesMap = {};\n\n    /**\n     * @type {module:echarts/data/List}\n     * @readOnly\n     */\n    this.data;\n\n    /**\n     * @type {module:echarts/data/List}\n     * @readOnly\n     */\n    this.edgeData;\n};\n\nvar graphProto = Graph.prototype;\n/**\n * @type {string}\n */\ngraphProto.type = 'graph';\n\n/**\n * If is directed graph\n * @return {boolean}\n */\ngraphProto.isDirected = function () {\n    return this._directed;\n};\n\n/**\n * Add a new node\n * @param {string} id\n * @param {number} [dataIndex]\n */\ngraphProto.addNode = function (id, dataIndex) {\n    id = id || ('' + dataIndex);\n\n    var nodesMap = this._nodesMap;\n\n    if (nodesMap[generateNodeKey(id)]) {\n        if (__DEV__) {\n            console.error('Graph nodes have duplicate name or id');\n        }\n        return;\n    }\n\n    var node = new Node(id, dataIndex);\n    node.hostGraph = this;\n\n    this.nodes.push(node);\n\n    nodesMap[generateNodeKey(id)] = node;\n    return node;\n};\n\n/**\n * Get node by data index\n * @param  {number} dataIndex\n * @return {module:echarts/data/Graph~Node}\n */\ngraphProto.getNodeByIndex = function (dataIndex) {\n    var rawIdx = this.data.getRawIndex(dataIndex);\n    return this.nodes[rawIdx];\n};\n/**\n * Get node by id\n * @param  {string} id\n * @return {module:echarts/data/Graph.Node}\n */\ngraphProto.getNodeById = function (id) {\n    return this._nodesMap[generateNodeKey(id)];\n};\n\n/**\n * Add a new edge\n * @param {number|string|module:echarts/data/Graph.Node} n1\n * @param {number|string|module:echarts/data/Graph.Node} n2\n * @param {number} [dataIndex=-1]\n * @return {module:echarts/data/Graph.Edge}\n */\ngraphProto.addEdge = function (n1, n2, dataIndex) {\n    var nodesMap = this._nodesMap;\n    var edgesMap = this._edgesMap;\n\n    // PNEDING\n    if (typeof n1 === 'number') {\n        n1 = this.nodes[n1];\n    }\n    if (typeof n2 === 'number') {\n        n2 = this.nodes[n2];\n    }\n\n    if (!(n1 instanceof Node)) {\n        n1 = nodesMap[generateNodeKey(n1)];\n    }\n    if (!(n2 instanceof Node)) {\n        n2 = nodesMap[generateNodeKey(n2)];\n    }\n    if (!n1 || !n2) {\n        return;\n    }\n\n    var key = n1.id + '-' + n2.id;\n    // PENDING\n    if (edgesMap[key]) {\n        return;\n    }\n\n    var edge = new Edge(n1, n2, dataIndex);\n    edge.hostGraph = this;\n\n    if (this._directed) {\n        n1.outEdges.push(edge);\n        n2.inEdges.push(edge);\n    }\n    n1.edges.push(edge);\n    if (n1 !== n2) {\n        n2.edges.push(edge);\n    }\n\n    this.edges.push(edge);\n    edgesMap[key] = edge;\n\n    return edge;\n};\n\n/**\n * Get edge by data index\n * @param  {number} dataIndex\n * @return {module:echarts/data/Graph~Node}\n */\ngraphProto.getEdgeByIndex = function (dataIndex) {\n    var rawIdx = this.edgeData.getRawIndex(dataIndex);\n    return this.edges[rawIdx];\n};\n/**\n * Get edge by two linked nodes\n * @param  {module:echarts/data/Graph.Node|string} n1\n * @param  {module:echarts/data/Graph.Node|string} n2\n * @return {module:echarts/data/Graph.Edge}\n */\ngraphProto.getEdge = function (n1, n2) {\n    if (n1 instanceof Node) {\n        n1 = n1.id;\n    }\n    if (n2 instanceof Node) {\n        n2 = n2.id;\n    }\n\n    var edgesMap = this._edgesMap;\n\n    if (this._directed) {\n        return edgesMap[n1 + '-' + n2];\n    } else {\n        return edgesMap[n1 + '-' + n2]\n            || edgesMap[n2 + '-' + n1];\n    }\n};\n\n/**\n * Iterate all nodes\n * @param  {Function} cb\n * @param  {*} [context]\n */\ngraphProto.eachNode = function (cb, context) {\n    var nodes = this.nodes;\n    var len = nodes.length;\n    for (var i = 0; i < len; i++) {\n        if (nodes[i].dataIndex >= 0) {\n            cb.call(context, nodes[i], i);\n        }\n    }\n};\n\n/**\n * Iterate all edges\n * @param  {Function} cb\n * @param  {*} [context]\n */\ngraphProto.eachEdge = function (cb, context) {\n    var edges = this.edges;\n    var len = edges.length;\n    for (var i = 0; i < len; i++) {\n        if (edges[i].dataIndex >= 0\n            && edges[i].node1.dataIndex >= 0\n            && edges[i].node2.dataIndex >= 0\n        ) {\n            cb.call(context, edges[i], i);\n        }\n    }\n};\n\n/**\n * Breadth first traverse\n * @param {Function} cb\n * @param {module:echarts/data/Graph.Node} startNode\n * @param {string} [direction='none'] 'none'|'in'|'out'\n * @param {*} [context]\n */\ngraphProto.breadthFirstTraverse = function (\n    cb, startNode, direction, context\n) {\n    if (!(startNode instanceof Node)) {\n        startNode = this._nodesMap[generateNodeKey(startNode)];\n    }\n    if (!startNode) {\n        return;\n    }\n\n    var edgeType = direction === 'out'\n        ? 'outEdges' : (direction === 'in' ? 'inEdges' : 'edges');\n\n    for (var i = 0; i < this.nodes.length; i++) {\n        this.nodes[i].__visited = false;\n    }\n\n    if (cb.call(context, startNode, null)) {\n        return;\n    }\n\n    var queue = [startNode];\n    while (queue.length) {\n        var currentNode = queue.shift();\n        var edges = currentNode[edgeType];\n\n        for (var i = 0; i < edges.length; i++) {\n            var e = edges[i];\n            var otherNode = e.node1 === currentNode\n                ? e.node2 : e.node1;\n            if (!otherNode.__visited) {\n                if (cb.call(context, otherNode, currentNode)) {\n                    // Stop traversing\n                    return;\n                }\n                queue.push(otherNode);\n                otherNode.__visited = true;\n            }\n        }\n    }\n};\n\n// TODO\n// graphProto.depthFirstTraverse = function (\n//     cb, startNode, direction, context\n// ) {\n\n// };\n\n// Filter update\ngraphProto.update = function () {\n    var data = this.data;\n    var edgeData = this.edgeData;\n    var nodes = this.nodes;\n    var edges = this.edges;\n\n    for (var i = 0, len = nodes.length; i < len; i++) {\n        nodes[i].dataIndex = -1;\n    }\n    for (var i = 0, len = data.count(); i < len; i++) {\n        nodes[data.getRawIndex(i)].dataIndex = i;\n    }\n\n    edgeData.filterSelf(function (idx) {\n        var edge = edges[edgeData.getRawIndex(idx)];\n        return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;\n    });\n\n    // Update edge\n    for (var i = 0, len = edges.length; i < len; i++) {\n        edges[i].dataIndex = -1;\n    }\n    for (var i = 0, len = edgeData.count(); i < len; i++) {\n        edges[edgeData.getRawIndex(i)].dataIndex = i;\n    }\n};\n\n/**\n * @return {module:echarts/data/Graph}\n */\ngraphProto.clone = function () {\n    var graph = new Graph(this._directed);\n    var nodes = this.nodes;\n    var edges = this.edges;\n    for (var i = 0; i < nodes.length; i++) {\n        graph.addNode(nodes[i].id, nodes[i].dataIndex);\n    }\n    for (var i = 0; i < edges.length; i++) {\n        var e = edges[i];\n        graph.addEdge(e.node1.id, e.node2.id, e.dataIndex);\n    }\n    return graph;\n};\n\n\n/**\n * @alias module:echarts/data/Graph.Node\n */\nfunction Node(id, dataIndex) {\n    /**\n    * @type {string}\n    */\n    this.id = id == null ? '' : id;\n\n    /**\n    * @type {Array.<module:echarts/data/Graph.Edge>}\n    */\n    this.inEdges = [];\n    /**\n    * @type {Array.<module:echarts/data/Graph.Edge>}\n    */\n    this.outEdges = [];\n    /**\n    * @type {Array.<module:echarts/data/Graph.Edge>}\n    */\n    this.edges = [];\n    /**\n     * @type {module:echarts/data/Graph}\n     */\n    this.hostGraph;\n\n    /**\n     * @type {number}\n     */\n    this.dataIndex = dataIndex == null ? -1 : dataIndex;\n}\n\nNode.prototype = {\n\n    constructor: Node,\n\n    /**\n     * @return {number}\n     */\n    degree: function () {\n        return this.edges.length;\n    },\n\n    /**\n     * @return {number}\n     */\n    inDegree: function () {\n        return this.inEdges.length;\n    },\n\n    /**\n    * @return {number}\n    */\n    outDegree: function () {\n        return this.outEdges.length;\n    },\n\n    /**\n     * @param {string} [path]\n     * @return {module:echarts/model/Model}\n     */\n    getModel: function (path) {\n        if (this.dataIndex < 0) {\n            return;\n        }\n        var graph = this.hostGraph;\n        var itemModel = graph.data.getItemModel(this.dataIndex);\n\n        return itemModel.getModel(path);\n    }\n};\n\n/**\n * \n * @alias module:echarts/data/Graph.Edge\n * @param {module:echarts/data/Graph.Node} n1\n * @param {module:echarts/data/Graph.Node} n2\n * @param {number} [dataIndex=-1]\n */\nfunction Edge(n1, n2, dataIndex) {\n\n    /**\n     * 1\n     * @type {module:echarts/data/Graph.Node}\n     */\n    this.node1 = n1;\n\n    /**\n     * 2\n     * @type {module:echarts/data/Graph.Node}\n     */\n    this.node2 = n2;\n\n    this.dataIndex = dataIndex == null ? -1 : dataIndex;\n}\n\n/**\n * @param {string} [path]\n * @return {module:echarts/model/Model}\n */\n    Edge.prototype.getModel = function (path) {\n    if (this.dataIndex < 0) {\n        return;\n    }\n    var graph = this.hostGraph;\n    var itemModel = graph.edgeData.getItemModel(this.dataIndex);\n\n    return itemModel.getModel(path);\n};\n\nvar createGraphDataProxyMixin = function (hostName, dataName) {\n    return {\n        /**\n         * @param {string=} [dimension='value'] Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.\n         * @return {number}\n         */\n        getValue: function (dimension) {\n            var data = this[hostName][dataName];\n            return data.get(data.getDimension(dimension || 'value'), this.dataIndex);\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} [value]\n         */\n        setVisual: function (key, value) {\n            this.dataIndex >= 0\n                && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);\n        },\n\n        /**\n         * @param {string} key\n         * @return {boolean}\n         */\n        getVisual: function (key, ignoreParent) {\n            return this[hostName][dataName].getItemVisual(this.dataIndex, key, ignoreParent);\n        },\n\n        /**\n         * @param {Object} layout\n         * @return {boolean} [merge=false]\n         */\n        setLayout: function (layout, merge$$1) {\n            this.dataIndex >= 0\n                && this[hostName][dataName].setItemLayout(this.dataIndex, layout, merge$$1);\n        },\n\n        /**\n         * @return {Object}\n         */\n        getLayout: function () {\n            return this[hostName][dataName].getItemLayout(this.dataIndex);\n        },\n\n        /**\n         * @return {module:zrender/Element}\n         */\n        getGraphicEl: function () {\n            return this[hostName][dataName].getItemGraphicEl(this.dataIndex);\n        },\n\n        /**\n         * @return {number}\n         */\n        getRawIndex: function () {\n            return this[hostName][dataName].getRawIndex(this.dataIndex);\n        }\n    };\n};\n\nmixin(Node, createGraphDataProxyMixin('hostGraph', 'data'));\nmixin(Edge, createGraphDataProxyMixin('hostGraph', 'edgeData'));\n\nGraph.Node = Node;\nGraph.Edge = Edge;\n\nvar createGraphFromNodeEdge = function (nodes, edges, hostModel, directed, beforeLink) {\n    var graph = new Graph(directed);\n    for (var i = 0; i < nodes.length; i++) {\n        graph.addNode(retrieve(\n            // Id, name, dataIndex\n            nodes[i].id, nodes[i].name, i\n        ), i);\n    }\n\n    var linkNameList = [];\n    var validEdges = [];\n    var linkCount = 0;\n    for (var i = 0; i < edges.length; i++) {\n        var link = edges[i];\n        var source = link.source;\n        var target = link.target;\n        // addEdge may fail when source or target not exists\n        if (graph.addEdge(source, target, linkCount)) {\n            validEdges.push(link);\n            linkNameList.push(retrieve(link.id, source + ' > ' + target));\n            linkCount++;\n        }\n    }\n\n    var coordSys = hostModel.get('coordinateSystem');\n    var nodeData;\n    if (coordSys === 'cartesian2d' || coordSys === 'polar') {\n        nodeData = createListFromArray(nodes, hostModel, hostModel.ecModel);\n    }\n    else {\n        // FIXME\n        var coordSysCtor = CoordinateSystemManager.get(coordSys);\n        // FIXME\n        var dimensionNames = completeDimensions(\n            ((coordSysCtor && coordSysCtor.type !== 'view') ? (coordSysCtor.dimensions || []) : []).concat(['value']),\n            nodes\n        );\n        nodeData = new List(dimensionNames, hostModel);\n        nodeData.initData(nodes);\n    }\n\n    var edgeData = new List(['value'], hostModel);\n    edgeData.initData(validEdges, linkNameList);\n\n    beforeLink && beforeLink(nodeData, edgeData);\n\n    linkList({\n        mainData: nodeData,\n        struct: graph,\n        structAttr: 'graph',\n        datas: {node: nodeData, edge: edgeData},\n        datasAttr: {node: 'data', edge: 'edgeData'}\n    });\n\n    // Update dataIndex of nodes and edges because invalid edge may be removed\n    graph.update();\n\n    return graph;\n};\n\nvar GraphSeries = extendSeriesModel({\n\n    type: 'series.graph',\n\n    init: function (option) {\n        GraphSeries.superApply(this, 'init', arguments);\n\n        // Provide data for legend select\n        this.legendDataProvider = function () {\n            return this._categoriesData;\n        };\n\n        this.fillDataTextStyle(option.edges || option.links);\n\n        this._updateCategoriesData();\n    },\n\n    mergeOption: function (option) {\n        GraphSeries.superApply(this, 'mergeOption', arguments);\n\n        this.fillDataTextStyle(option.edges || option.links);\n\n        this._updateCategoriesData();\n    },\n\n    mergeDefaultAndTheme: function (option) {\n        GraphSeries.superApply(this, 'mergeDefaultAndTheme', arguments);\n        defaultEmphasis(option.edgeLabel, ['show']);\n    },\n\n    getInitialData: function (option, ecModel) {\n        var edges = option.edges || option.links || [];\n        var nodes = option.data || option.nodes || [];\n        var self = this;\n\n        if (nodes && edges) {\n            return createGraphFromNodeEdge(nodes, edges, this, true, beforeLink).data;\n        }\n\n        function beforeLink(nodeData, edgeData) {\n            // Overwrite nodeData.getItemModel to\n            nodeData.wrapMethod('getItemModel', function (model) {\n                var categoriesModels = self._categoriesModels;\n                var categoryIdx = model.getShallow('category');\n                var categoryModel = categoriesModels[categoryIdx];\n                if (categoryModel) {\n                    categoryModel.parentModel = model.parentModel;\n                    model.parentModel = categoryModel;\n                }\n                return model;\n            });\n\n            var edgeLabelModel = self.getModel('edgeLabel');\n            // For option `edgeLabel` can be found by label.xxx.xxx on item mode.\n            var fakeSeriesModel = new Model(\n                {label: edgeLabelModel.option},\n                edgeLabelModel.parentModel,\n                ecModel\n            );\n\n            edgeData.wrapMethod('getItemModel', function (model) {\n                model.customizeGetParent(edgeGetParent);\n                return model;\n            });\n\n            function edgeGetParent(path) {\n                path = this.parsePath(path);\n                return (path && path[0] === 'label')\n                    ? fakeSeriesModel\n                    : this.parentModel;\n            }\n        }\n    },\n\n    /**\n     * @return {module:echarts/data/Graph}\n     */\n    getGraph: function () {\n        return this.getData().graph;\n    },\n\n    /**\n     * @return {module:echarts/data/List}\n     */\n    getEdgeData: function () {\n        return this.getGraph().edgeData;\n    },\n\n    /**\n     * @return {module:echarts/data/List}\n     */\n    getCategoriesData: function () {\n        return this._categoriesData;\n    },\n\n    /**\n     * @override\n     */\n    formatTooltip: function (dataIndex, multipleSeries, dataType) {\n        if (dataType === 'edge') {\n            var nodeData = this.getData();\n            var params = this.getDataParams(dataIndex, dataType);\n            var edge = nodeData.graph.getEdgeByIndex(dataIndex);\n            var sourceName = nodeData.getName(edge.node1.dataIndex);\n            var targetName = nodeData.getName(edge.node2.dataIndex);\n\n            var html = [];\n            sourceName != null && html.push(sourceName);\n            targetName != null && html.push(targetName);\n            html = encodeHTML(html.join(' > '));\n\n            if (params.value) {\n                html += ' : ' + encodeHTML(params.value);\n            }\n            return html;\n        }\n        else { // dataType === 'node' or empty\n            return GraphSeries.superApply(this, 'formatTooltip', arguments);\n        }\n    },\n\n    _updateCategoriesData: function () {\n        var categories = map(this.option.categories || [], function (category) {\n            // Data must has value\n            return category.value != null ? category : extend({\n                value: 0\n            }, category);\n        });\n        var categoriesData = new List(['value'], this);\n        categoriesData.initData(categories);\n\n        this._categoriesData = categoriesData;\n\n        this._categoriesModels = categoriesData.mapArray(function (idx) {\n            return categoriesData.getItemModel(idx, true);\n        });\n    },\n\n    setZoom: function (zoom) {\n        this.option.zoom = zoom;\n    },\n\n    setCenter: function (center) {\n        this.option.center = center;\n    },\n\n    isAnimationEnabled: function () {\n        return GraphSeries.superCall(this, 'isAnimationEnabled')\n            // Not enable animation when do force layout\n            && !(this.get('layout') === 'force' && this.get('force.layoutAnimation'));\n    },\n\n    defaultOption: {\n        zlevel: 0,\n        z: 2,\n\n        coordinateSystem: 'view',\n\n        // Default option for all coordinate systems\n        // xAxisIndex: 0,\n        // yAxisIndex: 0,\n        // polarIndex: 0,\n        // geoIndex: 0,\n\n        legendHoverLink: true,\n\n        hoverAnimation: true,\n\n        layout: null,\n\n        focusNodeAdjacency: false,\n\n        // Configuration of circular layout\n        circular: {\n            rotateLabel: false\n        },\n        // Configuration of force directed layout\n        force: {\n            initLayout: null,\n            // Node repulsion. Can be an array to represent range.\n            repulsion: [0, 50],\n            gravity: 0.1,\n\n            // Edge length. Can be an array to represent range.\n            edgeLength: 30,\n\n            layoutAnimation: true\n        },\n\n        left: 'center',\n        top: 'center',\n        // right: null,\n        // bottom: null,\n        // width: '80%',\n        // height: '80%',\n\n        symbol: 'circle',\n        symbolSize: 10,\n\n        edgeSymbol: ['none', 'none'],\n        edgeSymbolSize: 10,\n        edgeLabel: {\n            normal: {\n                position: 'middle'\n            },\n            emphasis: {}\n        },\n\n        draggable: false,\n\n        roam: false,\n\n        // Default on center of graph\n        center: null,\n\n        zoom: 1,\n        // Symbol size scale ratio in roam\n        nodeScaleRatio: 0.6,\n        // cursor: null,\n\n        // categories: [],\n\n        // data: []\n        // Or\n        // nodes: []\n        //\n        // links: []\n        // Or\n        // edges: []\n\n        label: {\n            normal: {\n                show: false,\n                formatter: '{b}'\n            },\n            emphasis: {\n                show: true\n            }\n        },\n\n        itemStyle: {\n            normal: {},\n            emphasis: {}\n        },\n\n        lineStyle: {\n            normal: {\n                color: '#aaa',\n                width: 1,\n                curveness: 0,\n                opacity: 0.5\n            },\n            emphasis: {}\n        }\n    }\n});\n\n/**\n * Line path for bezier and straight line draw\n */\n\nvar straightLineProto = Line.prototype;\nvar bezierCurveProto = BezierCurve.prototype;\n\nfunction isLine(shape) {\n    return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);\n}\n\nvar LinePath = extendShape({\n\n    type: 'ec-line',\n\n    style: {\n        stroke: '#000',\n        fill: null\n    },\n\n    shape: {\n        x1: 0,\n        y1: 0,\n        x2: 0,\n        y2: 0,\n        percent: 1,\n        cpx1: null,\n        cpy1: null\n    },\n\n    buildPath: function (ctx, shape) {\n        (isLine(shape) ? straightLineProto : bezierCurveProto).buildPath(ctx, shape);\n    },\n\n    pointAt: function (t) {\n        return isLine(this.shape)\n            ? straightLineProto.pointAt.call(this, t)\n            : bezierCurveProto.pointAt.call(this, t);\n    },\n\n    tangentAt: function (t) {\n        var shape = this.shape;\n        var p = isLine(shape)\n            ? [shape.x2 - shape.x1, shape.y2 - shape.y1]\n            : bezierCurveProto.tangentAt.call(this, t);\n        return normalize(p, p);\n    }\n});\n\n/**\n * @module echarts/chart/helper/Line\n */\n\nvar SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];\n\nfunction makeSymbolTypeKey(symbolCategory) {\n    return '_' + symbolCategory + 'Type';\n}\n/**\n * @inner\n */\nfunction createSymbol$1(name, lineData, idx) {\n    var color = lineData.getItemVisual(idx, 'color');\n    var symbolType = lineData.getItemVisual(idx, name);\n    var symbolSize = lineData.getItemVisual(idx, name + 'Size');\n\n    if (!symbolType || symbolType === 'none') {\n        return;\n    }\n\n    if (!isArray(symbolSize)) {\n        symbolSize = [symbolSize, symbolSize];\n    }\n    var symbolPath = createSymbol(\n        symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,\n        symbolSize[0], symbolSize[1], color\n    );\n\n    symbolPath.name = name;\n\n    return symbolPath;\n}\n\nfunction createLine(points) {\n    var line = new LinePath({\n        name: 'line'\n    });\n    setLinePoints(line.shape, points);\n    return line;\n}\n\nfunction setLinePoints(targetShape, points) {\n    var p1 = points[0];\n    var p2 = points[1];\n    var cp1 = points[2];\n    targetShape.x1 = p1[0];\n    targetShape.y1 = p1[1];\n    targetShape.x2 = p2[0];\n    targetShape.y2 = p2[1];\n    targetShape.percent = 1;\n\n    if (cp1) {\n        targetShape.cpx1 = cp1[0];\n        targetShape.cpy1 = cp1[1];\n    }\n    else {\n        targetShape.cpx1 = NaN;\n        targetShape.cpy1 = NaN;\n    }\n}\n\nfunction updateSymbolAndLabelBeforeLineUpdate () {\n    var lineGroup = this;\n    var symbolFrom = lineGroup.childOfName('fromSymbol');\n    var symbolTo = lineGroup.childOfName('toSymbol');\n    var label = lineGroup.childOfName('label');\n    // Quick reject\n    if (!symbolFrom && !symbolTo && label.ignore) {\n        return;\n    }\n\n    var invScale = 1;\n    var parentNode = this.parent;\n    while (parentNode) {\n        if (parentNode.scale) {\n            invScale /= parentNode.scale[0];\n        }\n        parentNode = parentNode.parent;\n    }\n\n    var line = lineGroup.childOfName('line');\n    // If line not changed\n    // FIXME Parent scale changed\n    if (!this.__dirty && !line.__dirty) {\n        return;\n    }\n\n    var percent = line.shape.percent;\n    var fromPos = line.pointAt(0);\n    var toPos = line.pointAt(percent);\n\n    var d = sub([], toPos, fromPos);\n    normalize(d, d);\n\n    if (symbolFrom) {\n        symbolFrom.attr('position', fromPos);\n        var tangent = line.tangentAt(0);\n        symbolFrom.attr('rotation', Math.PI / 2 - Math.atan2(\n            tangent[1], tangent[0]\n        ));\n        symbolFrom.attr('scale', [invScale * percent, invScale * percent]);\n    }\n    if (symbolTo) {\n        symbolTo.attr('position', toPos);\n        var tangent = line.tangentAt(1);\n        symbolTo.attr('rotation', -Math.PI / 2 - Math.atan2(\n            tangent[1], tangent[0]\n        ));\n        symbolTo.attr('scale', [invScale * percent, invScale * percent]);\n    }\n\n    if (!label.ignore) {\n        label.attr('position', toPos);\n\n        var textPosition;\n        var textAlign;\n        var textVerticalAlign;\n\n        var distance$$1 = 5 * invScale;\n        // End\n        if (label.__position === 'end') {\n            textPosition = [d[0] * distance$$1 + toPos[0], d[1] * distance$$1 + toPos[1]];\n            textAlign = d[0] > 0.8 ? 'left' : (d[0] < -0.8 ? 'right' : 'center');\n            textVerticalAlign = d[1] > 0.8 ? 'top' : (d[1] < -0.8 ? 'bottom' : 'middle');\n        }\n        // Middle\n        else if (label.__position === 'middle') {\n            var halfPercent = percent / 2;\n            var tangent = line.tangentAt(halfPercent);\n            var n = [tangent[1], -tangent[0]];\n            var cp = line.pointAt(halfPercent);\n            if (n[1] > 0) {\n                n[0] = -n[0];\n                n[1] = -n[1];\n            }\n            textPosition = [cp[0] + n[0] * distance$$1, cp[1] + n[1] * distance$$1];\n            textAlign = 'center';\n            textVerticalAlign = 'bottom';\n            var rotation = -Math.atan2(tangent[1], tangent[0]);\n            if (toPos[0] < fromPos[0]) {\n                rotation = Math.PI + rotation;\n            }\n            label.attr('rotation', rotation);\n        }\n        // Start\n        else {\n            textPosition = [-d[0] * distance$$1 + fromPos[0], -d[1] * distance$$1 + fromPos[1]];\n            textAlign = d[0] > 0.8 ? 'right' : (d[0] < -0.8 ? 'left' : 'center');\n            textVerticalAlign = d[1] > 0.8 ? 'bottom' : (d[1] < -0.8 ? 'top' : 'middle');\n        }\n        label.attr({\n            style: {\n                // Use the user specified text align and baseline first\n                textVerticalAlign: label.__verticalAlign || textVerticalAlign,\n                textAlign: label.__textAlign || textAlign\n            },\n            position: textPosition,\n            scale: [invScale, invScale]\n        });\n    }\n}\n\n/**\n * @constructor\n * @extends {module:zrender/graphic/Group}\n * @alias {module:echarts/chart/helper/Line}\n */\nfunction Line$1(lineData, idx, seriesScope) {\n    Group.call(this);\n\n    this._createLine(lineData, idx, seriesScope);\n}\n\nvar lineProto = Line$1.prototype;\n\n// Update symbol position and rotation\nlineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;\n\nlineProto._createLine = function (lineData, idx, seriesScope) {\n    var seriesModel = lineData.hostModel;\n    var linePoints = lineData.getItemLayout(idx);\n\n    var line = createLine(linePoints);\n    line.shape.percent = 0;\n    initProps(line, {\n        shape: {\n            percent: 1\n        }\n    }, seriesModel, idx);\n\n    this.add(line);\n\n    var label = new Text({\n        name: 'label'\n    });\n    this.add(label);\n\n    each$1(SYMBOL_CATEGORIES, function (symbolCategory) {\n        var symbol = createSymbol$1(symbolCategory, lineData, idx);\n        // symbols must added after line to make sure\n        // it will be updated after line#update.\n        // Or symbol position and rotation update in line#beforeUpdate will be one frame slow\n        this.add(symbol);\n        this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);\n    }, this);\n\n    this._updateCommonStl(lineData, idx, seriesScope);\n};\n\nlineProto.updateData = function (lineData, idx, seriesScope) {\n    var seriesModel = lineData.hostModel;\n\n    var line = this.childOfName('line');\n    var linePoints = lineData.getItemLayout(idx);\n    var target = {\n        shape: {}\n    };\n    setLinePoints(target.shape, linePoints);\n    updateProps(line, target, seriesModel, idx);\n\n    each$1(SYMBOL_CATEGORIES, function (symbolCategory) {\n        var symbolType = lineData.getItemVisual(idx, symbolCategory);\n        var key = makeSymbolTypeKey(symbolCategory);\n        // Symbol changed\n        if (this[key] !== symbolType) {\n            this.remove(this.childOfName(symbolCategory));\n            var symbol = createSymbol$1(symbolCategory, lineData, idx);\n            this.add(symbol);\n        }\n        this[key] = symbolType;\n    }, this);\n\n    this._updateCommonStl(lineData, idx, seriesScope);\n};\n\nlineProto._updateCommonStl = function (lineData, idx, seriesScope) {\n    var seriesModel = lineData.hostModel;\n\n    var line = this.childOfName('line');\n\n    var lineStyle = seriesScope && seriesScope.lineStyle;\n    var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;\n    var labelModel = seriesScope && seriesScope.labelModel;\n    var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n\n    // Optimization for large dataset\n    if (!seriesScope || lineData.hasItemOption) {\n        var itemModel = lineData.getItemModel(idx);\n\n        lineStyle = itemModel.getModel('lineStyle.normal').getLineStyle();\n        hoverLineStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();\n\n        labelModel = itemModel.getModel('label.normal');\n        hoverLabelModel = itemModel.getModel('label.emphasis');\n    }\n\n    var visualColor = lineData.getItemVisual(idx, 'color');\n    var visualOpacity = retrieve3(\n        lineData.getItemVisual(idx, 'opacity'),\n        lineStyle.opacity,\n        1\n    );\n\n    line.useStyle(defaults(\n        {\n            strokeNoScale: true,\n            fill: 'none',\n            stroke: visualColor,\n            opacity: visualOpacity\n        },\n        lineStyle\n    ));\n    line.hoverStyle = hoverLineStyle;\n\n    // Update symbol\n    each$1(SYMBOL_CATEGORIES, function (symbolCategory) {\n        var symbol = this.childOfName(symbolCategory);\n        if (symbol) {\n            symbol.setColor(visualColor);\n            symbol.setStyle({\n                opacity: visualOpacity\n            });\n        }\n    }, this);\n\n    var showLabel = labelModel.getShallow('show');\n    var hoverShowLabel = hoverLabelModel.getShallow('show');\n\n    var label = this.childOfName('label');\n    var defaultLabelColor;\n    var defaultText;\n    var normalText;\n    var emphasisText;\n\n    if (showLabel || hoverShowLabel) {\n        var rawVal = seriesModel.getRawValue(idx);\n        defaultText = rawVal == null\n            ? defaultText = lineData.getName(idx)\n            : isFinite(rawVal)\n            ? round(rawVal)\n            : rawVal;\n        defaultLabelColor = visualColor || '#000';\n\n        normalText = retrieve2(\n            seriesModel.getFormattedLabel(idx, 'normal', lineData.dataType),\n            defaultText\n        );\n        emphasisText = retrieve2(\n            seriesModel.getFormattedLabel(idx, 'emphasis', lineData.dataType),\n            normalText\n        );\n    }\n\n    // label.afterUpdate = lineAfterUpdate;\n    if (showLabel) {\n        var labelStyle = setTextStyle(label.style, labelModel, {\n            text: normalText\n        }, {\n            autoColor: defaultLabelColor\n        });\n\n        label.__textAlign = labelStyle.textAlign;\n        label.__verticalAlign = labelStyle.textVerticalAlign;\n        // 'start', 'middle', 'end'\n        label.__position = labelModel.get('position') || 'middle';\n    }\n    else {\n        label.setStyle('text', null);\n    }\n\n    if (hoverShowLabel) {\n        // Only these properties supported in this emphasis style here.\n        label.hoverStyle = {\n            text: emphasisText,\n            textFill: hoverLabelModel.getTextColor(true),\n            // For merging hover style to normal style, do not use\n            // `hoverLabelModel.getFont()` here.\n            fontStyle: hoverLabelModel.getShallow('fontStyle'),\n            fontWeight: hoverLabelModel.getShallow('fontWeight'),\n            fontSize: hoverLabelModel.getShallow('fontSize'),\n            fontFamily: hoverLabelModel.getShallow('fontFamily')\n        };\n    }\n    else {\n        label.hoverStyle = {\n            text: null\n        };\n    }\n\n    label.ignore = !showLabel && !hoverShowLabel;\n\n    setHoverStyle(this);\n};\n\nlineProto.highlight = function () {\n    this.trigger('emphasis');\n};\n\nlineProto.downplay = function () {\n    this.trigger('normal');\n};\n\nlineProto.updateLayout = function (lineData, idx) {\n    this.setLinePoints(lineData.getItemLayout(idx));\n};\n\nlineProto.setLinePoints = function (points) {\n    var linePath = this.childOfName('line');\n    setLinePoints(linePath.shape, points);\n    linePath.dirty();\n};\n\ninherits(Line$1, Group);\n\n/**\n * @module echarts/chart/helper/LineDraw\n */\n\nfunction isPointNaN(pt) {\n    return isNaN(pt[0]) || isNaN(pt[1]);\n}\nfunction lineNeedsDraw(pts) {\n    return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);\n}\n/**\n * @alias module:echarts/component/marker/LineDraw\n * @constructor\n */\nfunction LineDraw(ctor) {\n    this._ctor = ctor || Line$1;\n    this.group = new Group();\n}\n\nvar lineDrawProto = LineDraw.prototype;\n\n/**\n * @param {module:echarts/data/List} lineData\n */\nlineDrawProto.updateData = function (lineData) {\n\n    var oldLineData = this._lineData;\n    var group = this.group;\n    var LineCtor = this._ctor;\n\n    var hostModel = lineData.hostModel;\n\n    var seriesScope = {\n        lineStyle: hostModel.getModel('lineStyle.normal').getLineStyle(),\n        hoverLineStyle: hostModel.getModel('lineStyle.emphasis').getLineStyle(),\n        labelModel: hostModel.getModel('label.normal'),\n        hoverLabelModel: hostModel.getModel('label.emphasis')\n    };\n\n    lineData.diff(oldLineData)\n        .add(function (idx) {\n            if (!lineNeedsDraw(lineData.getItemLayout(idx))) {\n                return;\n            }\n            var lineGroup = new LineCtor(lineData, idx, seriesScope);\n\n            lineData.setItemGraphicEl(idx, lineGroup);\n\n            group.add(lineGroup);\n        })\n        .update(function (newIdx, oldIdx) {\n            var lineGroup = oldLineData.getItemGraphicEl(oldIdx);\n            if (!lineNeedsDraw(lineData.getItemLayout(newIdx))) {\n                group.remove(lineGroup);\n                return;\n            }\n\n            if (!lineGroup) {\n                lineGroup = new LineCtor(lineData, newIdx, seriesScope);\n            }\n            else {\n                lineGroup.updateData(lineData, newIdx, seriesScope);\n            }\n\n            lineData.setItemGraphicEl(newIdx, lineGroup);\n\n            group.add(lineGroup);\n        })\n        .remove(function (idx) {\n            group.remove(oldLineData.getItemGraphicEl(idx));\n        })\n        .execute();\n\n    this._lineData = lineData;\n};\n\nlineDrawProto.updateLayout = function () {\n    var lineData = this._lineData;\n    lineData.eachItemGraphicEl(function (el, idx) {\n        el.updateLayout(lineData, idx);\n    }, this);\n};\n\nlineDrawProto.remove = function () {\n    this.group.removeAll();\n};\n\nvar v1 = [];\nvar v2 = [];\nvar v3 = [];\nvar quadraticAt$1 = quadraticAt;\nvar v2DistSquare = distSquare;\nvar mathAbs$1 = Math.abs;\nfunction intersectCurveCircle(curvePoints, center, radius) {\n    var p0 = curvePoints[0];\n    var p1 = curvePoints[1];\n    var p2 = curvePoints[2];\n\n    var d = Infinity;\n    var t;\n    var radiusSquare = radius * radius;\n    var interval = 0.1;\n\n    for (var _t = 0.1; _t <= 0.9; _t += 0.1) {\n        v1[0] = quadraticAt$1(p0[0], p1[0], p2[0], _t);\n        v1[1] = quadraticAt$1(p0[1], p1[1], p2[1], _t);\n        var diff = mathAbs$1(v2DistSquare(v1, center) - radiusSquare);\n        if (diff < d) {\n            d = diff;\n            t = _t;\n        }\n    }\n\n    // Assume the segment is monotoneFind root through Bisection method\n    // At most 32 iteration\n    for (var i = 0; i < 32; i++) {\n        // var prev = t - interval;\n        var next = t + interval;\n        // v1[0] = quadraticAt(p0[0], p1[0], p2[0], prev);\n        // v1[1] = quadraticAt(p0[1], p1[1], p2[1], prev);\n        v2[0] = quadraticAt$1(p0[0], p1[0], p2[0], t);\n        v2[1] = quadraticAt$1(p0[1], p1[1], p2[1], t);\n        v3[0] = quadraticAt$1(p0[0], p1[0], p2[0], next);\n        v3[1] = quadraticAt$1(p0[1], p1[1], p2[1], next);\n\n        var diff = v2DistSquare(v2, center) - radiusSquare;\n        if (mathAbs$1(diff) < 1e-2) {\n            break;\n        }\n\n        // var prevDiff = v2DistSquare(v1, center) - radiusSquare;\n        var nextDiff = v2DistSquare(v3, center) - radiusSquare;\n\n        interval /= 2;\n        if (diff < 0) {\n            if (nextDiff >= 0) {\n                t = t + interval;\n            }\n            else {\n                t = t - interval;\n            }\n        }\n        else {\n            if (nextDiff >= 0) {\n                t = t - interval;\n            }\n            else {\n                t = t + interval;\n            }\n        }\n    }\n\n    return t;\n}\n\n// Adjust edge to avoid\nvar adjustEdge = function (graph, scale$$1) {\n    var tmp0 = [];\n    var quadraticSubdivide$$1 = quadraticSubdivide;\n    var pts = [[], [], []];\n    var pts2 = [[], []];\n    var v = [];\n    scale$$1 /= 2;\n\n    function getSymbolSize(node) {\n        var symbolSize = node.getVisual('symbolSize');\n        if (symbolSize instanceof Array) {\n            symbolSize = (symbolSize[0] + symbolSize[1]) / 2;\n        }\n        return symbolSize;\n    }\n    graph.eachEdge(function (edge, idx) {\n        var linePoints = edge.getLayout();\n        var fromSymbol = edge.getVisual('fromSymbol');\n        var toSymbol = edge.getVisual('toSymbol');\n\n        if (!linePoints.__original) {\n            linePoints.__original = [\n                clone$1(linePoints[0]),\n                clone$1(linePoints[1])\n            ];\n            if (linePoints[2]) {\n                linePoints.__original.push(clone$1(linePoints[2]));\n            }\n        }\n        var originalPoints = linePoints.__original;\n        // Quadratic curve\n        if (linePoints[2] != null) {\n            copy(pts[0], originalPoints[0]);\n            copy(pts[1], originalPoints[2]);\n            copy(pts[2], originalPoints[1]);\n            if (fromSymbol && fromSymbol != 'none') {\n                var symbolSize = getSymbolSize(edge.node1);\n\n                var t = intersectCurveCircle(pts, originalPoints[0], symbolSize * scale$$1);\n                // Subdivide and get the second\n                quadraticSubdivide$$1(pts[0][0], pts[1][0], pts[2][0], t, tmp0);\n                pts[0][0] = tmp0[3];\n                pts[1][0] = tmp0[4];\n                quadraticSubdivide$$1(pts[0][1], pts[1][1], pts[2][1], t, tmp0);\n                pts[0][1] = tmp0[3];\n                pts[1][1] = tmp0[4];\n            }\n            if (toSymbol && toSymbol != 'none') {\n                var symbolSize = getSymbolSize(edge.node2);\n\n                var t = intersectCurveCircle(pts, originalPoints[1], symbolSize * scale$$1);\n                // Subdivide and get the first\n                quadraticSubdivide$$1(pts[0][0], pts[1][0], pts[2][0], t, tmp0);\n                pts[1][0] = tmp0[1];\n                pts[2][0] = tmp0[2];\n                quadraticSubdivide$$1(pts[0][1], pts[1][1], pts[2][1], t, tmp0);\n                pts[1][1] = tmp0[1];\n                pts[2][1] = tmp0[2];\n            }\n            // Copy back to layout\n            copy(linePoints[0], pts[0]);\n            copy(linePoints[1], pts[2]);\n            copy(linePoints[2], pts[1]);\n        }\n        // Line\n        else {\n            copy(pts2[0], originalPoints[0]);\n            copy(pts2[1], originalPoints[1]);\n\n            sub(v, pts2[1], pts2[0]);\n            normalize(v, v);\n            if (fromSymbol && fromSymbol != 'none') {\n\n                var symbolSize = getSymbolSize(edge.node1);\n\n                scaleAndAdd(pts2[0], pts2[0], v, symbolSize * scale$$1);\n            }\n            if (toSymbol && toSymbol != 'none') {\n                var symbolSize = getSymbolSize(edge.node2);\n\n                scaleAndAdd(pts2[1], pts2[1], v, -symbolSize * scale$$1);\n            }\n            copy(linePoints[0], pts2[0]);\n            copy(linePoints[1], pts2[1]);\n        }\n    });\n};\n\nvar nodeOpacityPath = ['itemStyle', 'normal', 'opacity'];\nvar lineOpacityPath = ['lineStyle', 'normal', 'opacity'];\n\nfunction getItemOpacity(item, opacityPath) {\n    return item.getVisual('opacity') || item.getModel().get(opacityPath);\n}\n\nfunction fadeOutItem(item, opacityPath, opacityRatio) {\n    var el = item.getGraphicEl();\n\n    var opacity = getItemOpacity(item, opacityPath);\n    if (opacityRatio != null) {\n        opacity == null && (opacity = 1);\n        opacity *= opacityRatio;\n    }\n\n    el.downplay && el.downplay();\n    el.traverse(function (child) {\n        if (child.type !== 'group') {\n            child.setStyle('opacity', opacity);\n        }\n    });\n}\n\nfunction fadeInItem(item, opacityPath) {\n    var opacity = getItemOpacity(item, opacityPath);\n    var el = item.getGraphicEl();\n\n    el.highlight && el.highlight();\n    el.traverse(function (child) {\n        if (child.type !== 'group') {\n            child.setStyle('opacity', opacity);\n        }\n    });\n}\n\nextendChartView({\n\n    type: 'graph',\n\n    init: function (ecModel, api) {\n        var symbolDraw = new SymbolDraw();\n        var lineDraw = new LineDraw();\n        var group = this.group;\n\n        this._controller = new RoamController(api.getZr());\n        this._controllerHost = {target: group};\n\n        group.add(symbolDraw.group);\n        group.add(lineDraw.group);\n\n        this._symbolDraw = symbolDraw;\n        this._lineDraw = lineDraw;\n\n        this._firstRender = true;\n    },\n\n    render: function (seriesModel, ecModel, api) {\n        var coordSys = seriesModel.coordinateSystem;\n\n        this._model = seriesModel;\n        this._nodeScaleRatio = seriesModel.get('nodeScaleRatio');\n\n        var symbolDraw = this._symbolDraw;\n        var lineDraw = this._lineDraw;\n\n        var group = this.group;\n\n        if (coordSys.type === 'view') {\n            var groupNewProp = {\n                position: coordSys.position,\n                scale: coordSys.scale\n            };\n            if (this._firstRender) {\n                group.attr(groupNewProp);\n            }\n            else {\n                updateProps(group, groupNewProp, seriesModel);\n            }\n        }\n        // Fix edge contact point with node\n        adjustEdge(seriesModel.getGraph(), this._getNodeGlobalScale(seriesModel));\n\n        var data = seriesModel.getData();\n        symbolDraw.updateData(data);\n\n        var edgeData = seriesModel.getEdgeData();\n        lineDraw.updateData(edgeData);\n\n        this._updateNodeAndLinkScale();\n\n        this._updateController(seriesModel, ecModel, api);\n\n        clearTimeout(this._layoutTimeout);\n        var forceLayout = seriesModel.forceLayout;\n        var layoutAnimation = seriesModel.get('force.layoutAnimation');\n        if (forceLayout) {\n            this._startForceLayoutIteration(forceLayout, layoutAnimation);\n        }\n\n        data.eachItemGraphicEl(function (el, idx) {\n            var itemModel = data.getItemModel(idx);\n            // Update draggable\n            el.off('drag').off('dragend');\n            var draggable = data.getItemModel(idx).get('draggable');\n            if (draggable) {\n                el.on('drag', function () {\n                    if (forceLayout) {\n                        forceLayout.warmUp();\n                        !this._layouting\n                            && this._startForceLayoutIteration(forceLayout, layoutAnimation);\n                        forceLayout.setFixed(idx);\n                        // Write position back to layout\n                        data.setItemLayout(idx, el.position);\n                    }\n                }, this).on('dragend', function () {\n                    if (forceLayout) {\n                        forceLayout.setUnfixed(idx);\n                    }\n                }, this);\n            }\n            el.setDraggable(draggable && forceLayout);\n\n            el.off('mouseover', el.__focusNodeAdjacency);\n            el.off('mouseout', el.__unfocusNodeAdjacency);\n\n            if (itemModel.get('focusNodeAdjacency')) {\n                el.on('mouseover', el.__focusNodeAdjacency = function () {\n                    api.dispatchAction({\n                        type: 'focusNodeAdjacency',\n                        seriesId: seriesModel.id,\n                        dataIndex: el.dataIndex\n                    });\n                });\n                el.on('mouseout', el.__unfocusNodeAdjacency = function () {\n                    api.dispatchAction({\n                        type: 'unfocusNodeAdjacency',\n                        seriesId: seriesModel.id\n                    });\n                });\n\n            }\n\n        }, this);\n\n        data.graph.eachEdge(function (edge) {\n            var el = edge.getGraphicEl();\n\n            el.off('mouseover', el.__focusNodeAdjacency);\n            el.off('mouseout', el.__unfocusNodeAdjacency);\n\n            if (edge.getModel().get('focusNodeAdjacency')) {\n                el.on('mouseover', el.__focusNodeAdjacency = function () {\n                    api.dispatchAction({\n                        type: 'focusNodeAdjacency',\n                        seriesId: seriesModel.id,\n                        edgeDataIndex: edge.dataIndex\n                    });\n                });\n                el.on('mouseout', el.__unfocusNodeAdjacency = function () {\n                    api.dispatchAction({\n                        type: 'unfocusNodeAdjacency',\n                        seriesId: seriesModel.id\n                    });\n                });\n            }\n        });\n\n        var circularRotateLabel = seriesModel.get('layout') === 'circular'\n            && seriesModel.get('circular.rotateLabel');\n        var cx = data.getLayout('cx');\n        var cy = data.getLayout('cy');\n        data.eachItemGraphicEl(function (el, idx) {\n            var symbolPath = el.getSymbolPath();\n            if (circularRotateLabel) {\n                var pos = data.getItemLayout(idx);\n                var rad = Math.atan2(pos[1] - cy, pos[0] - cx);\n                if (rad < 0) {\n                    rad = Math.PI * 2 + rad;\n                }\n                var isLeft = pos[0] < cx;\n                if (isLeft) {\n                    rad = rad - Math.PI;\n                }\n                var textPosition = isLeft ? 'left' : 'right';\n                symbolPath.setStyle({\n                    textRotation: -rad,\n                    textPosition: textPosition,\n                    textOrigin: 'center'\n                });\n                symbolPath.hoverStyle && (symbolPath.hoverStyle.textPosition = textPosition);\n            }\n            else {\n                symbolPath.setStyle({\n                    textRotation: 0\n                });\n            }\n        });\n\n        this._firstRender = false;\n    },\n\n    dispose: function () {\n        this._controller && this._controller.dispose();\n        this._controllerHost = {};\n    },\n\n    focusNodeAdjacency: function (seriesModel, ecModel, api, payload) {\n        var data = this._model.getData();\n        var graph = data.graph;\n        var dataIndex = payload.dataIndex;\n        var edgeDataIndex = payload.edgeDataIndex;\n\n        var node = graph.getNodeByIndex(dataIndex);\n        var edge = graph.getEdgeByIndex(edgeDataIndex);\n\n        if (!node && !edge) {\n            return;\n        }\n\n        graph.eachNode(function (node) {\n            fadeOutItem(node, nodeOpacityPath, 0.1);\n        });\n        graph.eachEdge(function (edge) {\n            fadeOutItem(edge, lineOpacityPath, 0.1);\n        });\n\n        if (node) {\n            fadeInItem(node, nodeOpacityPath);\n            each$1(node.edges, function (adjacentEdge) {\n                if (adjacentEdge.dataIndex < 0) {\n                    return;\n                }\n                fadeInItem(adjacentEdge, lineOpacityPath);\n                fadeInItem(adjacentEdge.node1, nodeOpacityPath);\n                fadeInItem(adjacentEdge.node2, nodeOpacityPath);\n            });\n        }\n        if (edge) {\n            fadeInItem(edge, lineOpacityPath);\n            fadeInItem(edge.node1, nodeOpacityPath);\n            fadeInItem(edge.node2, nodeOpacityPath);\n        }\n    },\n\n    unfocusNodeAdjacency: function (seriesModel, ecModel, api, payload) {\n        var graph = this._model.getData().graph;\n\n        graph.eachNode(function (node) {\n            fadeOutItem(node, nodeOpacityPath);\n        });\n        graph.eachEdge(function (edge) {\n            fadeOutItem(edge, lineOpacityPath);\n        });\n    },\n\n    _startForceLayoutIteration: function (forceLayout, layoutAnimation) {\n        var self = this;\n        (function step() {\n            forceLayout.step(function (stopped) {\n                self.updateLayout(self._model);\n                (self._layouting = !stopped) && (\n                    layoutAnimation\n                        ? (self._layoutTimeout = setTimeout(step, 16))\n                        : step()\n                );\n            });\n        })();\n    },\n\n    _updateController: function (seriesModel, ecModel, api) {\n        var controller = this._controller;\n        var controllerHost = this._controllerHost;\n        var group = this.group;\n\n        controller.setPointerChecker(function (e, x, y) {\n            var rect = group.getBoundingRect();\n            rect.applyTransform(group.transform);\n            return rect.contain(x, y)\n                && !onIrrelevantElement(e, api, seriesModel);\n        });\n\n        if (seriesModel.coordinateSystem.type !== 'view') {\n            controller.disable();\n            return;\n        }\n        controller.enable(seriesModel.get('roam'));\n        controllerHost.zoomLimit = seriesModel.get('scaleLimit');\n        controllerHost.zoom = seriesModel.coordinateSystem.getZoom();\n\n        controller\n            .off('pan')\n            .off('zoom')\n            .on('pan', function (dx, dy) {\n                updateViewOnPan(controllerHost, dx, dy);\n                api.dispatchAction({\n                    seriesId: seriesModel.id,\n                    type: 'graphRoam',\n                    dx: dx,\n                    dy: dy\n                });\n            })\n            .on('zoom', function (zoom, mouseX, mouseY) {\n                updateViewOnZoom(controllerHost, zoom, mouseX, mouseY);\n                api.dispatchAction({\n                    seriesId: seriesModel.id,\n                    type: 'graphRoam',\n                    zoom:  zoom,\n                    originX: mouseX,\n                    originY: mouseY\n                });\n                this._updateNodeAndLinkScale();\n                adjustEdge(seriesModel.getGraph(), this._getNodeGlobalScale(seriesModel));\n                this._lineDraw.updateLayout();\n            }, this);\n    },\n\n    _updateNodeAndLinkScale: function () {\n        var seriesModel = this._model;\n        var data = seriesModel.getData();\n\n        var nodeScale = this._getNodeGlobalScale(seriesModel);\n        var invScale = [nodeScale, nodeScale];\n\n        data.eachItemGraphicEl(function (el, idx) {\n            el.attr('scale', invScale);\n        });\n    },\n\n    _getNodeGlobalScale: function (seriesModel) {\n        var coordSys = seriesModel.coordinateSystem;\n        if (coordSys.type !== 'view') {\n            return 1;\n        }\n\n        var nodeScaleRatio = this._nodeScaleRatio;\n\n        var groupScale = coordSys.scale;\n        var groupZoom = (groupScale && groupScale[0]) || 1;\n        // Scale node when zoom changes\n        var roamZoom = coordSys.getZoom();\n        var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;\n\n        return nodeScale / groupZoom;\n    },\n\n    updateLayout: function (seriesModel) {\n        adjustEdge(seriesModel.getGraph(), this._getNodeGlobalScale(seriesModel));\n\n        this._symbolDraw.updateLayout();\n        this._lineDraw.updateLayout();\n    },\n\n    remove: function (ecModel, api) {\n        this._symbolDraw && this._symbolDraw.remove();\n        this._lineDraw && this._lineDraw.remove();\n    }\n});\n\nvar actionInfo = {\n    type: 'graphRoam',\n    event: 'graphRoam',\n    update: 'none'\n};\n\n/**\n * @payload\n * @property {string} name Series name\n * @property {number} [dx]\n * @property {number} [dy]\n * @property {number} [zoom]\n * @property {number} [originX]\n * @property {number} [originY]\n */\nregisterAction(actionInfo, function (payload, ecModel) {\n    ecModel.eachComponent({mainType: 'series', query: payload}, function (seriesModel) {\n        var coordSys = seriesModel.coordinateSystem;\n\n        var res = updateCenterAndZoom(coordSys, payload);\n\n        seriesModel.setCenter\n            && seriesModel.setCenter(res.center);\n\n        seriesModel.setZoom\n            && seriesModel.setZoom(res.zoom);\n    });\n});\n\n\n/**\n * @payload\n * @property {number} [seriesIndex]\n * @property {string} [seriesId]\n * @property {string} [seriesName]\n * @property {number} [dataIndex]\n */\nregisterAction({\n    type: 'focusNodeAdjacency',\n    event: 'focusNodeAdjacency',\n    update: 'series.graph:focusNodeAdjacency'\n}, function () {});\n\n/**\n * @payload\n * @property {number} [seriesIndex]\n * @property {string} [seriesId]\n * @property {string} [seriesName]\n */\nregisterAction({\n    type: 'unfocusNodeAdjacency',\n    event: 'unfocusNodeAdjacency',\n    update: 'series.graph:unfocusNodeAdjacency'\n}, function () {});\n\nvar categoryFilter = function (ecModel) {\n    var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n    });\n    if (!legendModels || !legendModels.length) {\n        return;\n    }\n    ecModel.eachSeriesByType('graph', function (graphSeries) {\n        var categoriesData = graphSeries.getCategoriesData();\n        var graph = graphSeries.getGraph();\n        var data = graph.data;\n\n        var categoryNames = categoriesData.mapArray(categoriesData.getName);\n\n        data.filterSelf(function (idx) {\n            var model = data.getItemModel(idx);\n            var category = model.getShallow('category');\n            if (category != null) {\n                if (typeof category === 'number') {\n                    category = categoryNames[category];\n                }\n                // If in any legend component the status is not selected.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(category)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        });\n    }, this);\n};\n\nvar categoryVisual = function (ecModel) {\n\n    var paletteScope = {};\n    ecModel.eachSeriesByType('graph', function (seriesModel) {\n        var categoriesData = seriesModel.getCategoriesData();\n        var data = seriesModel.getData();\n\n        var categoryNameIdxMap = {};\n\n        categoriesData.each(function (idx) {\n            var name = categoriesData.getName(idx);\n            // Add prefix to avoid conflict with Object.prototype.\n            categoryNameIdxMap['ec-' + name] = idx;\n\n            var itemModel = categoriesData.getItemModel(idx);\n            var color = itemModel.get('itemStyle.normal.color')\n                || seriesModel.getColorFromPalette(name, paletteScope);\n            categoriesData.setItemVisual(idx, 'color', color);\n        });\n\n        // Assign category color to visual\n        if (categoriesData.count()) {\n            data.each(function (idx) {\n                var model = data.getItemModel(idx);\n                var category = model.getShallow('category');\n                if (category != null) {\n                    if (typeof category === 'string') {\n                        category = categoryNameIdxMap['ec-' + category];\n                    }\n                    if (!data.getItemVisual(idx, 'color', true)) {\n                        data.setItemVisual(\n                            idx, 'color',\n                            categoriesData.getItemVisual(category, 'color')\n                        );\n                    }\n                }\n            });\n        }\n    });\n};\n\nfunction normalize$1(a) {\n    if (!(a instanceof Array)) {\n        a = [a, a];\n    }\n    return a;\n}\n\nvar edgeVisual = function (ecModel) {\n    ecModel.eachSeriesByType('graph', function (seriesModel) {\n        var graph = seriesModel.getGraph();\n        var edgeData = seriesModel.getEdgeData();\n        var symbolType = normalize$1(seriesModel.get('edgeSymbol'));\n        var symbolSize = normalize$1(seriesModel.get('edgeSymbolSize'));\n\n        var colorQuery = 'lineStyle.normal.color'.split('.');\n        var opacityQuery = 'lineStyle.normal.opacity'.split('.');\n\n        edgeData.setVisual('fromSymbol', symbolType && symbolType[0]);\n        edgeData.setVisual('toSymbol', symbolType && symbolType[1]);\n        edgeData.setVisual('fromSymbolSize', symbolSize && symbolSize[0]);\n        edgeData.setVisual('toSymbolSize', symbolSize && symbolSize[1]);\n        edgeData.setVisual('color', seriesModel.get(colorQuery));\n        edgeData.setVisual('opacity', seriesModel.get(opacityQuery));\n\n        edgeData.each(function (idx) {\n            var itemModel = edgeData.getItemModel(idx);\n            var edge = graph.getEdgeByIndex(idx);\n            var symbolType = normalize$1(itemModel.getShallow('symbol', true));\n            var symbolSize = normalize$1(itemModel.getShallow('symbolSize', true));\n            // Edge visual must after node visual\n            var color = itemModel.get(colorQuery);\n            var opacity = itemModel.get(opacityQuery);\n            switch (color) {\n                case 'source':\n                    color = edge.node1.getVisual('color');\n                    break;\n                case 'target':\n                    color = edge.node2.getVisual('color');\n                    break;\n            }\n\n            symbolType[0] && edge.setVisual('fromSymbol', symbolType[0]);\n            symbolType[1] && edge.setVisual('toSymbol', symbolType[1]);\n            symbolSize[0] && edge.setVisual('fromSymbolSize', symbolSize[0]);\n            symbolSize[1] && edge.setVisual('toSymbolSize', symbolSize[1]);\n\n            edge.setVisual('color', color);\n            edge.setVisual('opacity', opacity);\n        });\n    });\n};\n\nfunction simpleLayout$1(seriesModel) {\n    var coordSys = seriesModel.coordinateSystem;\n    if (coordSys && coordSys.type !== 'view') {\n        return;\n    }\n    var graph = seriesModel.getGraph();\n\n    graph.eachNode(function (node) {\n        var model = node.getModel();\n        node.setLayout([+model.get('x'), +model.get('y')]);\n    });\n\n    simpleLayoutEdge(graph);\n}\n\nfunction simpleLayoutEdge(graph) {\n    graph.eachEdge(function (edge) {\n        var curveness = edge.getModel().get('lineStyle.normal.curveness') || 0;\n        var p1 = clone$1(edge.node1.getLayout());\n        var p2 = clone$1(edge.node2.getLayout());\n        var points = [p1, p2];\n        if (+curveness) {\n            points.push([\n                (p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * curveness,\n                (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * curveness\n            ]);\n        }\n        edge.setLayout(points);\n    });\n}\n\nvar simpleLayout = function (ecModel, api) {\n    ecModel.eachSeriesByType('graph', function (seriesModel) {\n        var layout = seriesModel.get('layout');\n        var coordSys = seriesModel.coordinateSystem;\n        if (coordSys && coordSys.type !== 'view') {\n            var data = seriesModel.getData();\n            var dimensions = coordSys.dimensions;\n\n            data.each(dimensions, function () {\n                var hasValue;\n                var args = arguments;\n                var value = [];\n                for (var i = 0; i < dimensions.length; i++) {\n                    if (!isNaN(args[i])) {\n                        hasValue = true;\n                    }\n                    value.push(args[i]);\n                }\n                var idx = args[args.length - 1];\n\n                if (hasValue) {\n                    data.setItemLayout(idx, coordSys.dataToPoint(value));\n                }\n                else {\n                    // Also {Array.<number>}, not undefined to avoid if...else... statement\n                    data.setItemLayout(idx, [NaN, NaN]);\n                }\n            });\n\n            simpleLayoutEdge(data.graph);\n        }\n        else if (!layout || layout === 'none') {\n            simpleLayout$1(seriesModel);\n        }\n    });\n};\n\nfunction circularLayout$1(seriesModel) {\n    var coordSys = seriesModel.coordinateSystem;\n    if (coordSys && coordSys.type !== 'view') {\n        return;\n    }\n\n    var rect = coordSys.getBoundingRect();\n\n    var nodeData = seriesModel.getData();\n    var graph = nodeData.graph;\n\n    var angle = 0;\n    var sum = nodeData.getSum('value');\n    var unitAngle = Math.PI * 2 / (sum || nodeData.count());\n\n    var cx = rect.width / 2 + rect.x;\n    var cy = rect.height / 2 + rect.y;\n\n    var r = Math.min(rect.width, rect.height) / 2;\n\n    graph.eachNode(function (node) {\n        var value = node.getValue('value');\n\n        angle += unitAngle * (sum ? value : 1) / 2;\n\n        node.setLayout([\n            r * Math.cos(angle) + cx,\n            r * Math.sin(angle) + cy\n        ]);\n\n        angle += unitAngle * (sum ? value : 1) / 2;\n    });\n\n    nodeData.setLayout({\n        cx: cx,\n        cy: cy\n    });\n\n    graph.eachEdge(function (edge) {\n        var curveness = edge.getModel().get('lineStyle.normal.curveness') || 0;\n        var p1 = clone$1(edge.node1.getLayout());\n        var p2 = clone$1(edge.node2.getLayout());\n        var cp1;\n        var x12 = (p1[0] + p2[0]) / 2;\n        var y12 = (p1[1] + p2[1]) / 2;\n        if (+curveness) {\n            curveness *= 3;\n            cp1 = [\n                cx * curveness + x12 * (1 - curveness),\n                cy * curveness + y12 * (1 - curveness)\n            ];\n        }\n        edge.setLayout([p1, p2, cp1]);\n    });\n}\n\nvar circularLayout = function (ecModel) {\n    ecModel.eachSeriesByType('graph', function (seriesModel) {\n        if (seriesModel.get('layout') === 'circular') {\n            circularLayout$1(seriesModel);\n        }\n    });\n};\n\nvar scaleAndAdd$2 = scaleAndAdd;\n\n// function adjacentNode(n, e) {\n//     return e.n1 === n ? e.n2 : e.n1;\n// }\n\nfunction forceLayout$1(nodes, edges, opts) {\n    var rect = opts.rect;\n    var width = rect.width;\n    var height = rect.height;\n    var center = [rect.x + width / 2, rect.y + height / 2];\n    // var scale = opts.scale || 1;\n    var gravity = opts.gravity == null ? 0.1 : opts.gravity;\n\n    // for (var i = 0; i < edges.length; i++) {\n    //     var e = edges[i];\n    //     var n1 = e.n1;\n    //     var n2 = e.n2;\n    //     n1.edges = n1.edges || [];\n    //     n2.edges = n2.edges || [];\n    //     n1.edges.push(e);\n    //     n2.edges.push(e);\n    // }\n    // Init position\n    for (var i = 0; i < nodes.length; i++) {\n        var n = nodes[i];\n        if (!n.p) {\n            // Use the position from first adjecent node with defined position\n            // Or use a random position\n            // From d3\n            // if (n.edges) {\n            //     var j = -1;\n            //     while (++j < n.edges.length) {\n            //         var e = n.edges[j];\n            //         var other = adjacentNode(n, e);\n            //         if (other.p) {\n            //             n.p = vec2.clone(other.p);\n            //             break;\n            //         }\n            //     }\n            // }\n            // if (!n.p) {\n                n.p = create(\n                    width * (Math.random() - 0.5) + center[0],\n                    height * (Math.random() - 0.5) + center[1]\n                );\n            // }\n        }\n        n.pp = clone$1(n.p);\n        n.edges = null;\n    }\n\n    // Formula in 'Graph Drawing by Force-directed Placement'\n    // var k = scale * Math.sqrt(width * height / nodes.length);\n    // var k2 = k * k;\n\n    var friction = 0.6;\n\n    return {\n        warmUp: function () {\n            friction = 0.5;\n        },\n\n        setFixed: function (idx) {\n            nodes[idx].fixed = true;\n        },\n\n        setUnfixed: function (idx) {\n            nodes[idx].fixed = false;\n        },\n\n        step: function (cb) {\n            var v12 = [];\n            var nLen = nodes.length;\n            for (var i = 0; i < edges.length; i++) {\n                var e = edges[i];\n                var n1 = e.n1;\n                var n2 = e.n2;\n\n                sub(v12, n2.p, n1.p);\n                var d = len(v12) - e.d;\n                var w = n2.w / (n1.w + n2.w);\n\n                if (isNaN(w)) {\n                    w = 0;\n                }\n\n                normalize(v12, v12);\n\n                !n1.fixed && scaleAndAdd$2(n1.p, n1.p, v12, w * d * friction);\n                !n2.fixed && scaleAndAdd$2(n2.p, n2.p, v12, -(1 - w) * d * friction);\n            }\n            // Gravity\n            for (var i = 0; i < nLen; i++) {\n                var n = nodes[i];\n                if (!n.fixed) {\n                    sub(v12, center, n.p);\n                    // var d = vec2.len(v12);\n                    // vec2.scale(v12, v12, 1 / d);\n                    // var gravityFactor = gravity;\n                    scaleAndAdd$2(n.p, n.p, v12, gravity * friction);\n                }\n            }\n\n            // Repulsive\n            // PENDING\n            for (var i = 0; i < nLen; i++) {\n                var n1 = nodes[i];\n                for (var j = i + 1; j < nLen; j++) {\n                    var n2 = nodes[j];\n                    sub(v12, n2.p, n1.p);\n                    var d = len(v12);\n                    if (d === 0) {\n                        // Random repulse\n                        set(v12, Math.random() - 0.5, Math.random() - 0.5);\n                        d = 1;\n                    }\n                    var repFact = (n1.rep + n2.rep) / d / d;\n                    !n1.fixed && scaleAndAdd$2(n1.pp, n1.pp, v12, repFact);\n                    !n2.fixed && scaleAndAdd$2(n2.pp, n2.pp, v12, -repFact);\n                }\n            }\n            var v = [];\n            for (var i = 0; i < nLen; i++) {\n                var n = nodes[i];\n                if (!n.fixed) {\n                    sub(v, n.p, n.pp);\n                    scaleAndAdd$2(n.p, n.p, v, friction);\n                    copy(n.pp, n.p);\n                }\n            }\n\n            friction = friction * 0.992;\n\n            cb && cb(nodes, edges, friction < 0.01);\n        }\n    };\n}\n\nvar forceLayout = function (ecModel) {\n    ecModel.eachSeriesByType('graph', function (graphSeries) {\n        var coordSys = graphSeries.coordinateSystem;\n        if (coordSys && coordSys.type !== 'view') {\n            return;\n        }\n        if (graphSeries.get('layout') === 'force') {\n            var preservedPoints = graphSeries.preservedPoints || {};\n            var graph = graphSeries.getGraph();\n            var nodeData = graph.data;\n            var edgeData = graph.edgeData;\n            var forceModel = graphSeries.getModel('force');\n            var initLayout = forceModel.get('initLayout');\n            if (graphSeries.preservedPoints) {\n                nodeData.each(function (idx) {\n                    var id = nodeData.getId(idx);\n                    nodeData.setItemLayout(idx, preservedPoints[id] || [NaN, NaN]);\n                });\n            }\n            else if (!initLayout || initLayout === 'none') {\n                simpleLayout$1(graphSeries);\n            }\n            else if (initLayout === 'circular') {\n                circularLayout$1(graphSeries);\n            }\n\n            var nodeDataExtent = nodeData.getDataExtent('value');\n            var edgeDataExtent = edgeData.getDataExtent('value');\n            // var edgeDataExtent = edgeData.getDataExtent('value');\n            var repulsion = forceModel.get('repulsion');\n            var edgeLength = forceModel.get('edgeLength');\n            if (!isArray(repulsion)) {\n                repulsion = [repulsion, repulsion];\n            }\n            if (!isArray(edgeLength)) {\n                edgeLength = [edgeLength, edgeLength];\n            }\n            // Larger value has smaller length\n            edgeLength = [edgeLength[1], edgeLength[0]];\n\n            var nodes = nodeData.mapArray('value', function (value, idx) {\n                var point = nodeData.getItemLayout(idx);\n                var rep = linearMap(value, nodeDataExtent, repulsion);\n                if (isNaN(rep)) {\n                    rep = (repulsion[0] + repulsion[1]) / 2;\n                }\n                return {\n                    w: rep,\n                    rep: rep,\n                    fixed: nodeData.getItemModel(idx).get('fixed'),\n                    p: (!point || isNaN(point[0]) || isNaN(point[1])) ? null : point\n                };\n            });\n            var edges = edgeData.mapArray('value', function (value, idx) {\n                var edge = graph.getEdgeByIndex(idx);\n                var d = linearMap(value, edgeDataExtent, edgeLength);\n                if (isNaN(d)) {\n                    d = (edgeLength[0] + edgeLength[1]) / 2;\n                }\n                return {\n                    n1: nodes[edge.node1.dataIndex],\n                    n2: nodes[edge.node2.dataIndex],\n                    d: d,\n                    curveness: edge.getModel().get('lineStyle.normal.curveness') || 0\n                };\n            });\n\n            var coordSys = graphSeries.coordinateSystem;\n            var rect = coordSys.getBoundingRect();\n            var forceInstance = forceLayout$1(nodes, edges, {\n                rect: rect,\n                gravity: forceModel.get('gravity')\n            });\n            var oldStep = forceInstance.step;\n            forceInstance.step = function (cb) {\n                for (var i = 0, l = nodes.length; i < l; i++) {\n                    if (nodes[i].fixed) {\n                        // Write back to layout instance\n                        copy(nodes[i].p, graph.getNodeByIndex(i).getLayout());\n                    }\n                }\n                oldStep(function (nodes, edges, stopped) {\n                    for (var i = 0, l = nodes.length; i < l; i++) {\n                        if (!nodes[i].fixed) {\n                            graph.getNodeByIndex(i).setLayout(nodes[i].p);\n                        }\n                        preservedPoints[nodeData.getId(i)] = nodes[i].p;\n                    }\n                    for (var i = 0, l = edges.length; i < l; i++) {\n                        var e = edges[i];\n                        var edge = graph.getEdgeByIndex(i);\n                        var p1 = e.n1.p;\n                        var p2 = e.n2.p;\n                        var points = edge.getLayout();\n                        points = points ? points.slice() : [];\n                        points[0] = points[0] || [];\n                        points[1] = points[1] || [];\n                        copy(points[0], p1);\n                        copy(points[1], p2);\n                        if (+e.curveness) {\n                            points[2] = [\n                                (p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e.curveness,\n                                (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e.curveness\n                            ];\n                        }\n                        edge.setLayout(points);\n                    }\n                    // Update layout\n\n                    cb && cb(stopped);\n                });\n            };\n            graphSeries.forceLayout = forceInstance;\n            graphSeries.preservedPoints = preservedPoints;\n\n            // Step to get the layout\n            forceInstance.step();\n        }\n        else {\n            // Remove prev injected forceLayout instance\n            graphSeries.forceLayout = null;\n        }\n    });\n};\n\n// FIXME Where to create the simple view coordinate system\nfunction getViewRect$1(seriesModel, api, aspect) {\n    var option = seriesModel.getBoxLayoutParams();\n    option.aspect = aspect;\n    return getLayoutRect(option, {\n        width: api.getWidth(),\n        height: api.getHeight()\n    });\n}\n\nvar createView = function (ecModel, api) {\n    var viewList = [];\n    ecModel.eachSeriesByType('graph', function (seriesModel) {\n        var coordSysType = seriesModel.get('coordinateSystem');\n        if (!coordSysType || coordSysType === 'view') {\n\n            var data = seriesModel.getData();\n            var positions = data.mapArray(function (idx) {\n                var itemModel = data.getItemModel(idx);\n                return [+itemModel.get('x'), +itemModel.get('y')];\n            });\n\n            var min = [];\n            var max = [];\n\n            fromPoints(positions, min, max);\n\n            // If width or height is 0\n            if (max[0] - min[0] === 0) {\n                max[0] += 1;\n                min[0] -= 1;\n            }\n            if (max[1] - min[1] === 0) {\n                max[1] += 1;\n                min[1] -= 1;\n            }\n            var aspect = (max[0] - min[0]) / (max[1] - min[1]);\n            // FIXME If get view rect after data processed?\n            var viewRect = getViewRect$1(seriesModel, api, aspect);\n            // Position may be NaN, use view rect instead\n            if (isNaN(aspect)) {\n                min = [viewRect.x, viewRect.y];\n                max = [viewRect.x + viewRect.width, viewRect.y + viewRect.height];\n            }\n\n            var bbWidth = max[0] - min[0];\n            var bbHeight = max[1] - min[1];\n\n            var viewWidth = viewRect.width;\n            var viewHeight = viewRect.height;\n\n            var viewCoordSys = seriesModel.coordinateSystem = new View();\n            viewCoordSys.zoomLimit = seriesModel.get('scaleLimit');\n\n            viewCoordSys.setBoundingRect(\n                min[0], min[1], bbWidth, bbHeight\n            );\n            viewCoordSys.setViewRect(\n                viewRect.x, viewRect.y, viewWidth, viewHeight\n            );\n\n            // Update roam info\n            viewCoordSys.setCenter(seriesModel.get('center'));\n            viewCoordSys.setZoom(seriesModel.get('zoom'));\n\n            viewList.push(viewCoordSys);\n        }\n    });\n\n    return viewList;\n};\n\nregisterProcessor(categoryFilter);\n\nregisterVisual(curry(\n    visualSymbol, 'graph', 'circle', null\n));\nregisterVisual(categoryVisual);\nregisterVisual(edgeVisual);\n\nregisterLayout(simpleLayout);\nregisterLayout(circularLayout);\nregisterLayout(forceLayout);\n\n// Graph view coordinate system\nregisterCoordinateSystem('graphView', {\n    create: createView\n});\n\nvar GaugeSeries = SeriesModel.extend({\n\n    type: 'series.gauge',\n\n    getInitialData: function (option, ecModel) {\n        var list = new List(['value'], this);\n        var dataOpt = option.data || [];\n        if (!isArray(dataOpt)) {\n            dataOpt = [dataOpt];\n        }\n        // Only use the first data item\n        list.initData(dataOpt);\n        return list;\n    },\n\n    defaultOption: {\n        zlevel: 0,\n        z: 2,\n        // \n        center: ['50%', '50%'],\n        legendHoverLink: true,\n        radius: '75%',\n        startAngle: 225,\n        endAngle: -45,\n        clockwise: true,\n        // \n        min: 0,\n        // \n        max: 100,\n        // 10\n        splitNumber: 10,\n        // \n        axisLine: {\n            // show\n            show: true,\n            lineStyle: {       // lineStyle\n                color: [[0.2, '#91c7ae'], [0.8, '#63869e'], [1, '#c23531']],\n                width: 30\n            }\n        },\n        // \n        splitLine: {\n            // show\n            show: true,\n            // length\n            length: 30,\n            // lineStylelineStyle\n            lineStyle: {\n                color: '#eee',\n                width: 2,\n                type: 'solid'\n            }\n        },\n        // \n        axisTick: {\n            // show\n            show: true,\n            // split\n            splitNumber: 5,\n            // length\n            length: 8,\n            // lineStyle\n            lineStyle: {\n                color: '#eee',\n                width: 1,\n                type: 'solid'\n            }\n        },\n        axisLabel: {\n            show: true,\n            distance: 5,\n            // formatter: null,\n            color: 'auto'\n        },\n        pointer: {\n            show: true,\n            length: '80%',\n            width: 8\n        },\n        itemStyle: {\n            normal: {\n                color: 'auto'\n            }\n        },\n        title: {\n            show: true,\n            // x, ypx\n            offsetCenter: [0, '-40%'],\n            // TEXTSTYLE\n            color: '#333',\n            fontSize: 15\n        },\n        detail: {\n            show: true,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderWidth: 0,\n            borderColor: '#ccc',\n            width: 100,\n            height: null, // self-adaption\n            padding: [5, 10],\n            // x, ypx\n            offsetCenter: [0, '40%'],\n            // formatter: null,\n            // TEXTSTYLE\n            color: 'auto',\n            fontSize: 30\n        }\n    }\n});\n\nvar PointerPath = Path.extend({\n\n    type: 'echartsGaugePointer',\n\n    shape: {\n        angle: 0,\n\n        width: 10,\n\n        r: 10,\n\n        x: 0,\n\n        y: 0\n    },\n\n    buildPath: function (ctx, shape) {\n        var mathCos = Math.cos;\n        var mathSin = Math.sin;\n\n        var r = shape.r;\n        var width = shape.width;\n        var angle = shape.angle;\n        var x = shape.x - mathCos(angle) * width * (width >= r / 3 ? 1 : 2);\n        var y = shape.y - mathSin(angle) * width * (width >= r / 3 ? 1 : 2);\n\n        angle = shape.angle - Math.PI / 2;\n        ctx.moveTo(x, y);\n        ctx.lineTo(\n            shape.x + mathCos(angle) * width,\n            shape.y + mathSin(angle) * width\n        );\n        ctx.lineTo(\n            shape.x + mathCos(shape.angle) * r,\n            shape.y + mathSin(shape.angle) * r\n        );\n        ctx.lineTo(\n            shape.x - mathCos(angle) * width,\n            shape.y - mathSin(angle) * width\n        );\n        ctx.lineTo(x, y);\n        return;\n    }\n});\n\nfunction parsePosition(seriesModel, api) {\n    var center = seriesModel.get('center');\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    var cx = parsePercent$1(center[0], api.getWidth());\n    var cy = parsePercent$1(center[1], api.getHeight());\n    var r = parsePercent$1(seriesModel.get('radius'), size / 2);\n\n    return {\n        cx: cx,\n        cy: cy,\n        r: r\n    };\n}\n\nfunction formatLabel(label, labelFormatter) {\n    if (labelFormatter) {\n        if (typeof labelFormatter === 'string') {\n            label = labelFormatter.replace('{value}', label != null ? label : '');\n        }\n        else if (typeof labelFormatter === 'function') {\n            label = labelFormatter(label);\n        }\n    }\n\n    return label;\n}\n\nvar PI2$5 = Math.PI * 2;\n\nvar GaugeView = Chart.extend({\n\n    type: 'gauge',\n\n    render: function (seriesModel, ecModel, api) {\n\n        this.group.removeAll();\n\n        var colorList = seriesModel.get('axisLine.lineStyle.color');\n        var posInfo = parsePosition(seriesModel, api);\n\n        this._renderMain(\n            seriesModel, ecModel, api, colorList, posInfo\n        );\n    },\n\n    dispose: function () {},\n\n    _renderMain: function (seriesModel, ecModel, api, colorList, posInfo) {\n        var group = this.group;\n\n        var axisLineModel = seriesModel.getModel('axisLine');\n        var lineStyleModel = axisLineModel.getModel('lineStyle');\n\n        var clockwise = seriesModel.get('clockwise');\n        var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;\n        var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;\n\n        var angleRangeSpan = (endAngle - startAngle) % PI2$5;\n\n        var prevEndAngle = startAngle;\n        var axisLineWidth = lineStyleModel.get('width');\n\n        for (var i = 0; i < colorList.length; i++) {\n            // Clamp\n            var percent = Math.min(Math.max(colorList[i][0], 0), 1);\n            var endAngle = startAngle + angleRangeSpan * percent;\n            var sector = new Sector({\n                shape: {\n                    startAngle: prevEndAngle,\n                    endAngle: endAngle,\n                    cx: posInfo.cx,\n                    cy: posInfo.cy,\n                    clockwise: clockwise,\n                    r0: posInfo.r - axisLineWidth,\n                    r: posInfo.r\n                },\n                silent: true\n            });\n\n            sector.setStyle({\n                fill: colorList[i][1]\n            });\n\n            sector.setStyle(lineStyleModel.getLineStyle(\n                // Because we use sector to simulate arc\n                // so the properties for stroking are useless\n                ['color', 'borderWidth', 'borderColor']\n            ));\n\n            group.add(sector);\n\n            prevEndAngle = endAngle;\n        }\n\n        var getColor = function (percent) {\n            // Less than 0\n            if (percent <= 0) {\n                return colorList[0][1];\n            }\n            for (var i = 0; i < colorList.length; i++) {\n                if (colorList[i][0] >= percent\n                    && (i === 0 ? 0 : colorList[i - 1][0]) < percent\n                ) {\n                    return colorList[i][1];\n                }\n            }\n            // More than 1\n            return colorList[i - 1][1];\n        };\n\n        if (!clockwise) {\n            var tmp = startAngle;\n            startAngle = endAngle;\n            endAngle = tmp;\n        }\n\n        this._renderTicks(\n            seriesModel, ecModel, api, getColor, posInfo,\n            startAngle, endAngle, clockwise\n        );\n\n        this._renderPointer(\n            seriesModel, ecModel, api, getColor, posInfo,\n            startAngle, endAngle, clockwise\n        );\n\n        this._renderTitle(\n            seriesModel, ecModel, api, getColor, posInfo\n        );\n        this._renderDetail(\n            seriesModel, ecModel, api, getColor, posInfo\n        );\n    },\n\n    _renderTicks: function (\n        seriesModel, ecModel, api, getColor, posInfo,\n        startAngle, endAngle, clockwise\n    ) {\n        var group = this.group;\n        var cx = posInfo.cx;\n        var cy = posInfo.cy;\n        var r = posInfo.r;\n\n        var minVal = +seriesModel.get('min');\n        var maxVal = +seriesModel.get('max');\n\n        var splitLineModel = seriesModel.getModel('splitLine');\n        var tickModel = seriesModel.getModel('axisTick');\n        var labelModel = seriesModel.getModel('axisLabel');\n\n        var splitNumber = seriesModel.get('splitNumber');\n        var subSplitNumber = tickModel.get('splitNumber');\n\n        var splitLineLen = parsePercent$1(\n            splitLineModel.get('length'), r\n        );\n        var tickLen = parsePercent$1(\n            tickModel.get('length'), r\n        );\n\n        var angle = startAngle;\n        var step = (endAngle - startAngle) / splitNumber;\n        var subStep = step / subSplitNumber;\n\n        var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();\n        var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();\n\n        for (var i = 0; i <= splitNumber; i++) {\n            var unitX = Math.cos(angle);\n            var unitY = Math.sin(angle);\n            // Split line\n            if (splitLineModel.get('show')) {\n                var splitLine = new Line({\n                    shape: {\n                        x1: unitX * r + cx,\n                        y1: unitY * r + cy,\n                        x2: unitX * (r - splitLineLen) + cx,\n                        y2: unitY * (r - splitLineLen) + cy\n                    },\n                    style: splitLineStyle,\n                    silent: true\n                });\n                if (splitLineStyle.stroke === 'auto') {\n                    splitLine.setStyle({\n                        stroke: getColor(i / splitNumber)\n                    });\n                }\n\n                group.add(splitLine);\n            }\n\n            // Label\n            if (labelModel.get('show')) {\n                var label = formatLabel(\n                    round(i / splitNumber * (maxVal - minVal) + minVal),\n                    labelModel.get('formatter')\n                );\n                var distance = labelModel.get('distance');\n                var autoColor = getColor(i / splitNumber);\n\n                group.add(new Text({\n                    style: setTextStyle({}, labelModel, {\n                        text: label,\n                        x: unitX * (r - splitLineLen - distance) + cx,\n                        y: unitY * (r - splitLineLen - distance) + cy,\n                        textVerticalAlign: unitY < -0.4 ? 'top' : (unitY > 0.4 ? 'bottom' : 'middle'),\n                        textAlign: unitX < -0.4 ? 'left' : (unitX > 0.4 ? 'right' : 'center')\n                    }, {autoColor: autoColor}),\n                    silent: true\n                }));\n            }\n\n            // Axis tick\n            if (tickModel.get('show') && i !== splitNumber) {\n                for (var j = 0; j <= subSplitNumber; j++) {\n                    var unitX = Math.cos(angle);\n                    var unitY = Math.sin(angle);\n                    var tickLine = new Line({\n                        shape: {\n                            x1: unitX * r + cx,\n                            y1: unitY * r + cy,\n                            x2: unitX * (r - tickLen) + cx,\n                            y2: unitY * (r - tickLen) + cy\n                        },\n                        silent: true,\n                        style: tickLineStyle\n                    });\n\n                    if (tickLineStyle.stroke === 'auto') {\n                        tickLine.setStyle({\n                            stroke: getColor((i + j / subSplitNumber) / splitNumber)\n                        });\n                    }\n\n                    group.add(tickLine);\n                    angle += subStep;\n                }\n                angle -= subStep;\n            }\n            else {\n                angle += step;\n            }\n        }\n    },\n\n    _renderPointer: function (\n        seriesModel, ecModel, api, getColor, posInfo,\n        startAngle, endAngle, clockwise\n    ) {\n\n        var group = this.group;\n        var oldData = this._data;\n\n        if (!seriesModel.get('pointer.show')) {\n            // Remove old element\n            oldData && oldData.eachItemGraphicEl(function (el) {\n                group.remove(el);\n            });\n            return;\n        }\n\n        var valueExtent = [+seriesModel.get('min'), +seriesModel.get('max')];\n        var angleExtent = [startAngle, endAngle];\n\n        var data = seriesModel.getData();\n\n        data.diff(oldData)\n            .add(function (idx) {\n                var pointer = new PointerPath({\n                    shape: {\n                        angle: startAngle\n                    }\n                });\n\n                initProps(pointer, {\n                    shape: {\n                        angle: linearMap(data.get('value', idx), valueExtent, angleExtent, true)\n                    }\n                }, seriesModel);\n\n                group.add(pointer);\n                data.setItemGraphicEl(idx, pointer);\n            })\n            .update(function (newIdx, oldIdx) {\n                var pointer = oldData.getItemGraphicEl(oldIdx);\n\n                updateProps(pointer, {\n                    shape: {\n                        angle: linearMap(data.get('value', newIdx), valueExtent, angleExtent, true)\n                    }\n                }, seriesModel);\n\n                group.add(pointer);\n                data.setItemGraphicEl(newIdx, pointer);\n            })\n            .remove(function (idx) {\n                var pointer = oldData.getItemGraphicEl(idx);\n                group.remove(pointer);\n            })\n            .execute();\n\n        data.eachItemGraphicEl(function (pointer, idx) {\n            var itemModel = data.getItemModel(idx);\n            var pointerModel = itemModel.getModel('pointer');\n\n            pointer.setShape({\n                x: posInfo.cx,\n                y: posInfo.cy,\n                width: parsePercent$1(\n                    pointerModel.get('width'), posInfo.r\n                ),\n                r: parsePercent$1(pointerModel.get('length'), posInfo.r)\n            });\n\n            pointer.useStyle(itemModel.getModel('itemStyle.normal').getItemStyle());\n\n            if (pointer.style.fill === 'auto') {\n                pointer.setStyle('fill', getColor(\n                    linearMap(data.get('value', idx), valueExtent, [0, 1], true)\n                ));\n            }\n\n            setHoverStyle(\n                pointer, itemModel.getModel('itemStyle.emphasis').getItemStyle()\n            );\n        });\n\n        this._data = data;\n    },\n\n    _renderTitle: function (\n        seriesModel, ecModel, api, getColor, posInfo\n    ) {\n        var titleModel = seriesModel.getModel('title');\n        if (titleModel.get('show')) {\n            var offsetCenter = titleModel.get('offsetCenter');\n            var x = posInfo.cx + parsePercent$1(offsetCenter[0], posInfo.r);\n            var y = posInfo.cy + parsePercent$1(offsetCenter[1], posInfo.r);\n\n            var minVal = +seriesModel.get('min');\n            var maxVal = +seriesModel.get('max');\n            var value = seriesModel.getData().get('value', 0);\n            var autoColor = getColor(\n                linearMap(value, [minVal, maxVal], [0, 1], true)\n            );\n\n            this.group.add(new Text({\n                silent: true,\n                style: setTextStyle({}, titleModel, {\n                    x: x,\n                    y: y,\n                    // FIXME First data name ?\n                    text: seriesModel.getData().getName(0),\n                    textAlign: 'center',\n                    textVerticalAlign: 'middle'\n                }, {autoColor: autoColor, forceRich: true})\n            }));\n        }\n    },\n\n    _renderDetail: function (\n        seriesModel, ecModel, api, getColor, posInfo\n    ) {\n        var detailModel = seriesModel.getModel('detail');\n        var minVal = +seriesModel.get('min');\n        var maxVal = +seriesModel.get('max');\n        if (detailModel.get('show')) {\n            var offsetCenter = detailModel.get('offsetCenter');\n            var x = posInfo.cx + parsePercent$1(offsetCenter[0], posInfo.r);\n            var y = posInfo.cy + parsePercent$1(offsetCenter[1], posInfo.r);\n            var width = parsePercent$1(detailModel.get('width'), posInfo.r);\n            var height = parsePercent$1(detailModel.get('height'), posInfo.r);\n            var value = seriesModel.getData().get('value', 0);\n            var autoColor = getColor(\n                linearMap(value, [minVal, maxVal], [0, 1], true)\n            );\n\n            this.group.add(new Text({\n                silent: true,\n                style: setTextStyle({}, detailModel, {\n                    x: x,\n                    y: y,\n                    text: formatLabel(\n                        // FIXME First data name ?\n                        value, detailModel.get('formatter')\n                    ),\n                    textWidth: isNaN(width) ? null : width,\n                    textHeight: isNaN(height) ? null : height,\n                    textAlign: 'center',\n                    textVerticalAlign: 'middle'\n                }, {autoColor: autoColor, forceRich: true})\n            }));\n        }\n    }\n});\n\nvar FunnelSeries = extendSeriesModel({\n\n    type: 'series.funnel',\n\n    init: function (option) {\n        FunnelSeries.superApply(this, 'init', arguments);\n\n        // Enable legend selection for each data item\n        // Use a function instead of direct access because data reference may changed\n        this.legendDataProvider = function () {\n            return this.getRawData();\n        };\n        // Extend labelLine emphasis\n        this._defaultLabelLine(option);\n    },\n\n    getInitialData: function (option, ecModel) {\n        var dimensions = completeDimensions(['value'], option.data);\n        var list = new List(dimensions, this);\n        list.initData(option.data);\n        return list;\n    },\n\n    _defaultLabelLine: function (option) {\n        // Extend labelLine emphasis\n        defaultEmphasis(option.labelLine, ['show']);\n\n        var labelLineNormalOpt = option.labelLine.normal;\n        var labelLineEmphasisOpt = option.labelLine.emphasis;\n        // Not show label line if `label.normal.show = false`\n        labelLineNormalOpt.show = labelLineNormalOpt.show\n            && option.label.normal.show;\n        labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n            && option.label.emphasis.show;\n    },\n\n    // Overwrite\n    getDataParams: function (dataIndex) {\n        var data = this.getData();\n        var params = FunnelSeries.superCall(this, 'getDataParams', dataIndex);\n        var sum = data.getSum('value');\n        // Percent is 0 if sum is 0\n        params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\n        params.$vars.push('percent');\n        return params;\n    },\n\n    defaultOption: {\n        zlevel: 0,                  // \n        z: 2,                       // \n        legendHoverLink: true,\n        left: 80,\n        top: 60,\n        right: 80,\n        bottom: 60,\n        // width: {totalWidth} - left - right,\n        // height: {totalHeight} - top - bottom,\n\n        // \n        // min: 0,\n        // max: 100,\n        minSize: '0%',\n        maxSize: '100%',\n        sort: 'descending', // 'ascending', 'descending'\n        gap: 0,\n        funnelAlign: 'center',\n        label: {\n            normal: {\n                show: true,\n                position: 'outer'\n                // formatter: Tooltip.formatter\n            },\n            emphasis: {\n                show: true\n            }\n        },\n        labelLine: {\n            normal: {\n                show: true,\n                length: 20,\n                lineStyle: {\n                    // color: ,\n                    width: 1,\n                    type: 'solid'\n                }\n            },\n            emphasis: {}\n        },\n        itemStyle: {\n            normal: {\n                // color: ,\n                borderColor: '#fff',\n                borderWidth: 1\n            },\n            emphasis: {\n                // color: ,\n            }\n        }\n    }\n});\n\n/**\n * Piece of pie including Sector, Label, LabelLine\n * @constructor\n * @extends {module:zrender/graphic/Group}\n */\nfunction FunnelPiece(data, idx) {\n\n    Group.call(this);\n\n    var polygon = new Polygon();\n    var labelLine = new Polyline();\n    var text = new Text();\n    this.add(polygon);\n    this.add(labelLine);\n    this.add(text);\n\n    this.updateData(data, idx, true);\n\n    // Hover to change label and labelLine\n    function onEmphasis() {\n        labelLine.ignore = labelLine.hoverIgnore;\n        text.ignore = text.hoverIgnore;\n    }\n    function onNormal() {\n        labelLine.ignore = labelLine.normalIgnore;\n        text.ignore = text.normalIgnore;\n    }\n    this.on('emphasis', onEmphasis)\n        .on('normal', onNormal)\n        .on('mouseover', onEmphasis)\n        .on('mouseout', onNormal);\n}\n\nvar funnelPieceProto = FunnelPiece.prototype;\n\nvar opacityAccessPath = ['itemStyle', 'normal', 'opacity'];\nfunnelPieceProto.updateData = function (data, idx, firstCreate) {\n\n    var polygon = this.childAt(0);\n\n    var seriesModel = data.hostModel;\n    var itemModel = data.getItemModel(idx);\n    var layout = data.getItemLayout(idx);\n    var opacity = data.getItemModel(idx).get(opacityAccessPath);\n    opacity = opacity == null ? 1 : opacity;\n\n    // Reset style\n    polygon.useStyle({});\n\n    if (firstCreate) {\n        polygon.setShape({\n            points: layout.points\n        });\n        polygon.setStyle({ opacity : 0 });\n        initProps(polygon, {\n            style: {\n                opacity: opacity\n            }\n        }, seriesModel, idx);\n    }\n    else {\n        updateProps(polygon, {\n            style: {\n                opacity: opacity\n            },\n            shape: {\n                points: layout.points\n            }\n        }, seriesModel, idx);\n    }\n\n    // Update common style\n    var itemStyleModel = itemModel.getModel('itemStyle');\n    var visualColor = data.getItemVisual(idx, 'color');\n\n    polygon.setStyle(\n        defaults(\n            {\n                lineJoin: 'round',\n                fill: visualColor\n            },\n            itemStyleModel.getModel('normal').getItemStyle(['opacity'])\n        )\n    );\n    polygon.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\n    this._updateLabel(data, idx);\n\n    setHoverStyle(this);\n};\n\nfunnelPieceProto._updateLabel = function (data, idx) {\n\n    var labelLine = this.childAt(1);\n    var labelText = this.childAt(2);\n\n    var seriesModel = data.hostModel;\n    var itemModel = data.getItemModel(idx);\n    var layout = data.getItemLayout(idx);\n    var labelLayout = layout.label;\n    var visualColor = data.getItemVisual(idx, 'color');\n\n    updateProps(labelLine, {\n        shape: {\n            points: labelLayout.linePoints || labelLayout.linePoints\n        }\n    }, seriesModel, idx);\n\n    updateProps(labelText, {\n        style: {\n            x: labelLayout.x,\n            y: labelLayout.y\n        }\n    }, seriesModel, idx);\n    labelText.attr({\n        rotation: labelLayout.rotation,\n        origin: [labelLayout.x, labelLayout.y],\n        z2: 10\n    });\n\n    var labelModel = itemModel.getModel('label.normal');\n    var labelHoverModel = itemModel.getModel('label.emphasis');\n    var labelLineModel = itemModel.getModel('labelLine.normal');\n    var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n    var visualColor = data.getItemVisual(idx, 'color');\n\n    setLabelStyle(\n        labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel,\n        {\n            labelFetcher: data.hostModel,\n            labelDataIndex: idx,\n            defaultText: data.getName(idx),\n            autoColor: visualColor,\n            useInsideStyle: !!labelLayout.inside\n        },\n        {\n            textAlign: labelLayout.textAlign,\n            textVerticalAlign: labelLayout.verticalAlign\n        }\n    );\n\n    labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n    labelText.hoverIgnore = !labelHoverModel.get('show');\n\n    labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n    labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\n    // Default use item visual color\n    labelLine.setStyle({\n        stroke: visualColor\n    });\n    labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\n    labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n};\n\ninherits(FunnelPiece, Group);\n\n\nvar FunnelView = Chart.extend({\n\n    type: 'funnel',\n\n    render: function (seriesModel, ecModel, api) {\n        var data = seriesModel.getData();\n        var oldData = this._data;\n\n        var group = this.group;\n\n        data.diff(oldData)\n            .add(function (idx) {\n                var funnelPiece = new FunnelPiece(data, idx);\n\n                data.setItemGraphicEl(idx, funnelPiece);\n\n                group.add(funnelPiece);\n            })\n            .update(function (newIdx, oldIdx) {\n                var piePiece = oldData.getItemGraphicEl(oldIdx);\n\n                piePiece.updateData(data, newIdx);\n\n                group.add(piePiece);\n                data.setItemGraphicEl(newIdx, piePiece);\n            })\n            .remove(function (idx) {\n                var piePiece = oldData.getItemGraphicEl(idx);\n                group.remove(piePiece);\n            })\n            .execute();\n\n        this._data = data;\n    },\n\n    remove: function () {\n        this.group.removeAll();\n        this._data = null;\n    },\n\n    dispose: function () {}\n});\n\nfunction getViewRect$2(seriesModel, api) {\n    return getLayoutRect(\n        seriesModel.getBoxLayoutParams(), {\n            width: api.getWidth(),\n            height: api.getHeight()\n        }\n    );\n}\n\nfunction getSortedIndices(data, sort) {\n    var valueArr = data.mapArray('value', function (val) {\n        return val;\n    });\n    var indices = [];\n    var isAscending = sort === 'ascending';\n    for (var i = 0, len = data.count(); i < len; i++) {\n        indices[i] = i;\n    }\n\n    // Add custom sortable function & none sortable opetion by \"options.sort\"\n    if (typeof sort === 'function') {\n        indices.sort(sort);\n    } else if (sort !== 'none') {\n        indices.sort(function (a, b) {\n            return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];\n        });\n    }\n    return indices;\n}\n\nfunction labelLayout$1(data) {\n    data.each(function (idx) {\n        var itemModel = data.getItemModel(idx);\n        var labelModel = itemModel.getModel('label.normal');\n        var labelPosition = labelModel.get('position');\n\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n\n        var layout = data.getItemLayout(idx);\n        var points = layout.points;\n\n        var isLabelInside = labelPosition === 'inner'\n            || labelPosition === 'inside' || labelPosition === 'center';\n\n        var textAlign;\n        var textX;\n        var textY;\n        var linePoints;\n\n        if (isLabelInside) {\n            textX = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4;\n            textY = (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4;\n            textAlign = 'center';\n            linePoints = [\n                [textX, textY], [textX, textY]\n            ];\n        }\n        else {\n            var x1;\n            var y1;\n            var x2;\n            var labelLineLen = labelLineModel.get('length');\n            if (labelPosition === 'left') {\n                // Left side\n                x1 = (points[3][0] + points[0][0]) / 2;\n                y1 = (points[3][1] + points[0][1]) / 2;\n                x2 = x1 - labelLineLen;\n                textX = x2 - 5;\n                textAlign = 'right';\n            }\n            else {\n                // Right side\n                x1 = (points[1][0] + points[2][0]) / 2;\n                y1 = (points[1][1] + points[2][1]) / 2;\n                x2 = x1 + labelLineLen;\n                textX = x2 + 5;\n                textAlign = 'left';\n            }\n            var y2 = y1;\n\n            linePoints = [[x1, y1], [x2, y2]];\n            textY = y2;\n        }\n\n        layout.label = {\n            linePoints: linePoints,\n            x: textX,\n            y: textY,\n            verticalAlign: 'middle',\n            textAlign: textAlign,\n            inside: isLabelInside\n        };\n    });\n}\n\nvar funnelLayout = function (ecModel, api, payload) {\n    ecModel.eachSeriesByType('funnel', function (seriesModel) {\n        var data = seriesModel.getData();\n        var sort = seriesModel.get('sort');\n        var viewRect = getViewRect$2(seriesModel, api);\n        var indices = getSortedIndices(data, sort);\n\n        var sizeExtent = [\n            parsePercent$1(seriesModel.get('minSize'), viewRect.width),\n            parsePercent$1(seriesModel.get('maxSize'), viewRect.width)\n        ];\n        var dataExtent = data.getDataExtent('value');\n        var min = seriesModel.get('min');\n        var max = seriesModel.get('max');\n        if (min == null) {\n            min = Math.min(dataExtent[0], 0);\n        }\n        if (max == null) {\n            max = dataExtent[1];\n        }\n\n        var funnelAlign = seriesModel.get('funnelAlign');\n        var gap = seriesModel.get('gap');\n        var itemHeight = (viewRect.height - gap * (data.count() - 1)) / data.count();\n\n        var y = viewRect.y;\n\n        var getLinePoints = function (idx, offY) {\n            // End point index is data.count() and we assign it 0\n            var val = data.get('value', idx) || 0;\n            var itemWidth = linearMap(val, [min, max], sizeExtent, true);\n            var x0;\n            switch (funnelAlign) {\n                case 'left':\n                    x0 = viewRect.x;\n                    break;\n                case 'center':\n                    x0 = viewRect.x + (viewRect.width - itemWidth) / 2;\n                    break;\n                case 'right':\n                    x0 = viewRect.x + viewRect.width - itemWidth;\n                    break;\n            }\n            return [\n                [x0, offY],\n                [x0 + itemWidth, offY]\n            ];\n        };\n\n        if (sort === 'ascending') {\n            // From bottom to top\n            itemHeight = -itemHeight;\n            gap = -gap;\n            y += viewRect.height;\n            indices = indices.reverse();\n        }\n\n        for (var i = 0; i < indices.length; i++) {\n            var idx = indices[i];\n            var nextIdx = indices[i + 1];\n            var start = getLinePoints(idx, y);\n            var end = getLinePoints(nextIdx, y + itemHeight);\n\n            y += itemHeight + gap;\n\n            data.setItemLayout(idx, {\n                points: start.concat(end.slice().reverse())\n            });\n        }\n\n        labelLayout$1(data);\n    });\n};\n\nregisterVisual(curry(dataColor, 'funnel'));\nregisterLayout(funnelLayout);\nregisterProcessor(curry(dataFilter, 'funnel'));\n\nvar parallelPreprocessor = function (option) {\n    createParallelIfNeeded(option);\n    mergeAxisOptionFromParallel(option);\n};\n\n/**\n * Create a parallel coordinate if not exists.\n * @inner\n */\nfunction createParallelIfNeeded(option) {\n    if (option.parallel) {\n        return;\n    }\n\n    var hasParallelSeries = false;\n\n    each$1(option.series, function (seriesOpt) {\n        if (seriesOpt && seriesOpt.type === 'parallel') {\n            hasParallelSeries = true;\n        }\n    });\n\n    if (hasParallelSeries) {\n        option.parallel = [{}];\n    }\n}\n\n/**\n * Merge aixs definition from parallel option (if exists) to axis option.\n * @inner\n */\nfunction mergeAxisOptionFromParallel(option) {\n    var axes = normalizeToArray(option.parallelAxis);\n\n    each$1(axes, function (axisOption) {\n        if (!isObject(axisOption)) {\n            return;\n        }\n\n        var parallelIndex = axisOption.parallelIndex || 0;\n        var parallelOption = normalizeToArray(option.parallel)[parallelIndex];\n\n        if (parallelOption && parallelOption.parallelAxisDefault) {\n            merge(axisOption, parallelOption.parallelAxisDefault, false);\n        }\n    });\n}\n\n/**\n * @constructor module:echarts/coord/parallel/ParallelAxis\n * @extends {module:echarts/coord/Axis}\n * @param {string} dim\n * @param {*} scale\n * @param {Array.<number>} coordExtent\n * @param {string} axisType\n */\nvar ParallelAxis = function (dim, scale, coordExtent, axisType, axisIndex) {\n\n    Axis.call(this, dim, scale, coordExtent);\n\n    /**\n     * Axis type\n     *  - 'category'\n     *  - 'value'\n     *  - 'time'\n     *  - 'log'\n     * @type {string}\n     */\n    this.type = axisType || 'value';\n\n    /**\n     * @type {number}\n     * @readOnly\n     */\n    this.axisIndex = axisIndex;\n};\n\nParallelAxis.prototype = {\n\n    constructor: ParallelAxis,\n\n    /**\n     * Axis model\n     * @param {module:echarts/coord/parallel/AxisModel}\n     */\n    model: null,\n\n    /**\n     * @override\n     */\n    isHorizontal: function () {\n        return this.coordinateSystem.getModel().get('layout') !== 'horizontal';\n    }\n\n};\n\ninherits(ParallelAxis, Axis);\n\n/**\n * Calculate slider move result.\n * Usage:\n * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as\n * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.\n * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.\n *\n * @param {number} delta Move length.\n * @param {Array.<number>} handleEnds handleEnds[0] can be bigger then handleEnds[1].\n *              handleEnds will be modified in this method.\n * @param {Array.<number>} extent handleEnds is restricted by extent.\n *              extent[0] should less or equals than extent[1].\n * @param {number|string} handleIndex Can be 'all', means that both move the two handleEnds,\n *              where the input minSpan and maxSpan will not work.\n * @param {number} [minSpan] The range of dataZoom can not be smaller than that.\n *              If not set, handle0 and cross handle1. If set as a non-negative\n *              number (including `0`), handles will push each other when reaching\n *              the minSpan.\n * @param {number} [maxSpan] The range of dataZoom can not be larger than that.\n * @return {Array.<number>} The input handleEnds.\n */\nvar sliderMove = function (delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {\n    // Normalize firstly.\n    handleEnds[0] = restrict$1(handleEnds[0], extent);\n    handleEnds[1] = restrict$1(handleEnds[1], extent);\n\n    delta = delta || 0;\n\n    var extentSpan = extent[1] - extent[0];\n\n    // Notice maxSpan and minSpan can be null/undefined.\n    if (minSpan != null) {\n        minSpan = restrict$1(minSpan, [0, extentSpan]);\n    }\n    if (maxSpan != null) {\n        maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);\n    }\n    if (handleIndex === 'all') {\n        minSpan = maxSpan = Math.abs(handleEnds[1] - handleEnds[0]);\n        handleIndex = 0;\n    }\n\n    var originalDistSign = getSpanSign(handleEnds, handleIndex);\n\n    handleEnds[handleIndex] += delta;\n\n    // Restrict in extent.\n    var extentMinSpan = minSpan || 0;\n    var realExtent = extent.slice();\n    originalDistSign.sign < 0 ? (realExtent[0] += extentMinSpan) : (realExtent[1] -= extentMinSpan);\n    handleEnds[handleIndex] = restrict$1(handleEnds[handleIndex], realExtent);\n\n    // Expand span.\n    var currDistSign = getSpanSign(handleEnds, handleIndex);\n    if (minSpan != null && (\n        currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan\n    )) {\n        // If minSpan exists, 'cross' is forbinden.\n        handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;\n    }\n\n    // Shrink span.\n    var currDistSign = getSpanSign(handleEnds, handleIndex);\n    if (maxSpan != null && currDistSign.span > maxSpan) {\n        handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;\n    }\n\n    return handleEnds;\n};\n\nfunction getSpanSign(handleEnds, handleIndex) {\n    var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex];\n    // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]\n    // is at left of handleEnds[1] for non-cross case.\n    return {span: Math.abs(dist), sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1};\n}\n\nfunction restrict$1(value, extend) {\n    return Math.min(extend[1], Math.max(extend[0], value));\n}\n\n/**\n * Parallel Coordinates\n * <https://en.wikipedia.org/wiki/Parallel_coordinates>\n */\n\nvar each$14 = each$1;\nvar mathMin$5 = Math.min;\nvar mathMax$5 = Math.max;\nvar mathFloor$2 = Math.floor;\nvar mathCeil$2 = Math.ceil;\nvar round$2 = round;\n\nvar PI$3 = Math.PI;\n\nfunction Parallel(parallelModel, ecModel, api) {\n\n    /**\n     * key: dimension\n     * @type {Object.<string, module:echarts/coord/parallel/Axis>}\n     * @private\n     */\n    this._axesMap = createHashMap();\n\n    /**\n     * key: dimension\n     * value: {position: [], rotation, }\n     * @type {Object.<string, Object>}\n     * @private\n     */\n    this._axesLayout = {};\n\n    /**\n     * Always follow axis order.\n     * @type {Array.<string>}\n     * @readOnly\n     */\n    this.dimensions = parallelModel.dimensions;\n\n    /**\n     * @type {module:zrender/core/BoundingRect}\n     */\n    this._rect;\n\n    /**\n     * @type {module:echarts/coord/parallel/ParallelModel}\n     */\n    this._model = parallelModel;\n\n    this._init(parallelModel, ecModel, api);\n}\n\nParallel.prototype = {\n\n    type: 'parallel',\n\n    constructor: Parallel,\n\n    /**\n     * Initialize cartesian coordinate systems\n     * @private\n     */\n    _init: function (parallelModel, ecModel, api) {\n\n        var dimensions = parallelModel.dimensions;\n        var parallelAxisIndex = parallelModel.parallelAxisIndex;\n\n        each$14(dimensions, function (dim, idx) {\n\n            var axisIndex = parallelAxisIndex[idx];\n            var axisModel = ecModel.getComponent('parallelAxis', axisIndex);\n\n            var axis = this._axesMap.set(dim, new ParallelAxis(\n                dim,\n                createScaleByModel(axisModel),\n                [0, 0],\n                axisModel.get('type'),\n                axisIndex\n            ));\n\n            var isCategory = axis.type === 'category';\n            axis.onBand = isCategory && axisModel.get('boundaryGap');\n            axis.inverse = axisModel.get('inverse');\n\n            // Injection\n            axisModel.axis = axis;\n            axis.model = axisModel;\n            axis.coordinateSystem = axisModel.coordinateSystem = this;\n\n        }, this);\n    },\n\n    /**\n     * Update axis scale after data processed\n     * @param  {module:echarts/model/Global} ecModel\n     * @param  {module:echarts/ExtensionAPI} api\n     */\n    update: function (ecModel, api) {\n        this._updateAxesFromSeries(this._model, ecModel);\n    },\n\n    /**\n     * @override\n     */\n    containPoint: function (point) {\n        var layoutInfo = this._makeLayoutInfo();\n        var axisBase = layoutInfo.axisBase;\n        var layoutBase = layoutInfo.layoutBase;\n        var pixelDimIndex = layoutInfo.pixelDimIndex;\n        var pAxis = point[1 - pixelDimIndex];\n        var pLayout = point[pixelDimIndex];\n\n        return pAxis >= axisBase\n            && pAxis <= axisBase + layoutInfo.axisLength\n            && pLayout >= layoutBase\n            && pLayout <= layoutBase + layoutInfo.layoutLength;\n    },\n\n    getModel: function () {\n        return this._model;\n    },\n\n    /**\n     * Update properties from series\n     * @private\n     */\n    _updateAxesFromSeries: function (parallelModel, ecModel) {\n        ecModel.eachSeries(function (seriesModel) {\n\n            if (!parallelModel.contains(seriesModel, ecModel)) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n\n            each$14(this.dimensions, function (dim) {\n                var axis = this._axesMap.get(dim);\n                axis.scale.unionExtentFromData(data, dim);\n                niceScaleExtent(axis.scale, axis.model);\n            }, this);\n        }, this);\n    },\n\n    /**\n     * Resize the parallel coordinate system.\n     * @param {module:echarts/coord/parallel/ParallelModel} parallelModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    resize: function (parallelModel, api) {\n        this._rect = getLayoutRect(\n            parallelModel.getBoxLayoutParams(),\n            {\n                width: api.getWidth(),\n                height: api.getHeight()\n            }\n        );\n\n        this._layoutAxes();\n    },\n\n    /**\n     * @return {module:zrender/core/BoundingRect}\n     */\n    getRect: function () {\n        return this._rect;\n    },\n\n    /**\n     * @private\n     */\n    _makeLayoutInfo: function () {\n        var parallelModel = this._model;\n        var rect = this._rect;\n        var xy = ['x', 'y'];\n        var wh = ['width', 'height'];\n        var layout = parallelModel.get('layout');\n        var pixelDimIndex = layout === 'horizontal' ? 0 : 1;\n        var layoutLength = rect[wh[pixelDimIndex]];\n        var layoutExtent = [0, layoutLength];\n        var axisCount = this.dimensions.length;\n\n        var axisExpandWidth = restrict(parallelModel.get('axisExpandWidth'), layoutExtent);\n        var axisExpandCount = restrict(parallelModel.get('axisExpandCount') || 0, [0, axisCount]);\n        var axisExpandable = parallelModel.get('axisExpandable')\n            && axisCount > 3\n            && axisCount > axisExpandCount\n            && axisExpandCount > 1\n            && axisExpandWidth > 0\n            && layoutLength > 0;\n\n        // `axisExpandWindow` is According to the coordinates of [0, axisExpandLength],\n        // for sake of consider the case that axisCollapseWidth is 0 (when screen is narrow),\n        // where collapsed axes should be overlapped.\n        var axisExpandWindow = parallelModel.get('axisExpandWindow');\n        var winSize;\n        if (!axisExpandWindow) {\n            winSize = restrict(axisExpandWidth * (axisExpandCount - 1), layoutExtent);\n            var axisExpandCenter = parallelModel.get('axisExpandCenter') || mathFloor$2(axisCount / 2);\n            axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2];\n            axisExpandWindow[1] = axisExpandWindow[0] + winSize;\n        }\n        else {\n                winSize = restrict(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent);\n                axisExpandWindow[1] = axisExpandWindow[0] + winSize;\n        }\n\n        var axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount);\n        // Avoid axisCollapseWidth is too small.\n        axisCollapseWidth < 3 && (axisCollapseWidth = 0);\n\n        // Find the first and last indices > ewin[0] and < ewin[1].\n        var winInnerIndices = [\n            mathFloor$2(round$2(axisExpandWindow[0] / axisExpandWidth, 1)) + 1,\n            mathCeil$2(round$2(axisExpandWindow[1] / axisExpandWidth, 1)) - 1\n        ];\n\n        // Pos in ec coordinates.\n        var axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0];\n\n        return {\n            layout: layout,\n            pixelDimIndex: pixelDimIndex,\n            layoutBase: rect[xy[pixelDimIndex]],\n            layoutLength: layoutLength,\n            axisBase: rect[xy[1 - pixelDimIndex]],\n            axisLength: rect[wh[1 - pixelDimIndex]],\n            axisExpandable: axisExpandable,\n            axisExpandWidth: axisExpandWidth,\n            axisCollapseWidth: axisCollapseWidth,\n            axisExpandWindow: axisExpandWindow,\n            axisCount: axisCount,\n            winInnerIndices: winInnerIndices,\n            axisExpandWindow0Pos: axisExpandWindow0Pos\n        };\n    },\n\n    /**\n     * @private\n     */\n    _layoutAxes: function () {\n        var rect = this._rect;\n        var axes = this._axesMap;\n        var dimensions = this.dimensions;\n        var layoutInfo = this._makeLayoutInfo();\n        var layout = layoutInfo.layout;\n\n        axes.each(function (axis) {\n            var axisExtent = [0, layoutInfo.axisLength];\n            var idx = axis.inverse ? 1 : 0;\n            axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);\n        });\n\n        each$14(dimensions, function (dim, idx) {\n            var posInfo = (layoutInfo.axisExpandable\n                ? layoutAxisWithExpand : layoutAxisWithoutExpand\n            )(idx, layoutInfo);\n\n            var positionTable = {\n                horizontal: {\n                    x: posInfo.position,\n                    y: layoutInfo.axisLength\n                },\n                vertical: {\n                    x: 0,\n                    y: posInfo.position\n                }\n            };\n            var rotationTable = {\n                horizontal: PI$3 / 2,\n                vertical: 0\n            };\n\n            var position = [\n                positionTable[layout].x + rect.x,\n                positionTable[layout].y + rect.y\n            ];\n\n            var rotation = rotationTable[layout];\n            var transform = create$1();\n            rotate(transform, transform, rotation);\n            translate(transform, transform, position);\n\n            // TODO\n            // tick\n\n            // TODO\n            // axis order  dimensions\n\n            this._axesLayout[dim] = {\n                position: position,\n                rotation: rotation,\n                transform: transform,\n                axisNameAvailableWidth: posInfo.axisNameAvailableWidth,\n                axisLabelShow: posInfo.axisLabelShow,\n                nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,\n                tickDirection: 1,\n                labelDirection: 1,\n                labelInterval: axes.get(dim).getLabelInterval()\n            };\n        }, this);\n    },\n\n    /**\n     * Get axis by dim.\n     * @param {string} dim\n     * @return {module:echarts/coord/parallel/ParallelAxis} [description]\n     */\n    getAxis: function (dim) {\n        return this._axesMap.get(dim);\n    },\n\n    /**\n     * Convert a dim value of a single item of series data to Point.\n     * @param {*} value\n     * @param {string} dim\n     * @return {Array}\n     */\n    dataToPoint: function (value, dim) {\n        return this.axisCoordToPoint(\n            this._axesMap.get(dim).dataToCoord(value),\n            dim\n        );\n    },\n\n    /**\n     * Travel data for one time, get activeState of each data item.\n     * @param {module:echarts/data/List} data\n     * @param {Functio} cb param: {string} activeState 'active' or 'inactive' or 'normal'\n     *                            {number} dataIndex\n     * @param {Object} context\n     */\n    eachActiveState: function (data, callback, context) {\n        var dimensions = this.dimensions;\n        var axesMap = this._axesMap;\n        var hasActiveSet = this.hasAxisBrushed();\n\n        for (var i = 0, len = data.count(); i < len; i++) {\n            var values = data.getValues(dimensions, i);\n            var activeState;\n\n            if (!hasActiveSet) {\n                activeState = 'normal';\n            }\n            else {\n                activeState = 'active';\n                for (var j = 0, lenj = dimensions.length; j < lenj; j++) {\n                    var dimName = dimensions[j];\n                    var state = axesMap.get(dimName).model.getActiveState(values[j], j);\n\n                    if (state === 'inactive') {\n                        activeState = 'inactive';\n                        break;\n                    }\n                }\n            }\n\n            callback.call(context, activeState, i);\n        }\n    },\n\n    /**\n     * Whether has any activeSet.\n     * @return {boolean}\n     */\n    hasAxisBrushed: function () {\n        var dimensions = this.dimensions;\n        var axesMap = this._axesMap;\n        var hasActiveSet = false;\n\n        for (var j = 0, lenj = dimensions.length; j < lenj; j++) {\n            if (axesMap.get(dimensions[j]).model.getActiveState() !== 'normal') {\n                hasActiveSet = true;\n            }\n        }\n\n        return hasActiveSet;\n    },\n\n    /**\n     * Convert coords of each axis to Point.\n     *  Return point. For example: [10, 20]\n     * @param {Array.<number>} coords\n     * @param {string} dim\n     * @return {Array.<number>}\n     */\n    axisCoordToPoint: function (coord, dim) {\n        var axisLayout = this._axesLayout[dim];\n        return applyTransform$1([coord, 0], axisLayout.transform);\n    },\n\n    /**\n     * Get axis layout.\n     */\n    getAxisLayout: function (dim) {\n        return clone(this._axesLayout[dim]);\n    },\n\n    /**\n     * @param {Array.<number>} point\n     * @return {Object} {axisExpandWindow, delta, behavior: 'jump' | 'slide' | 'none'}.\n     */\n    getSlidedAxisExpandWindow: function (point) {\n        var layoutInfo = this._makeLayoutInfo();\n        var pixelDimIndex = layoutInfo.pixelDimIndex;\n        var axisExpandWindow = layoutInfo.axisExpandWindow.slice();\n        var winSize = axisExpandWindow[1] - axisExpandWindow[0];\n        var extent = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)];\n\n        // Out of the area of coordinate system.\n        if (!this.containPoint(point)) {\n            return {behavior: 'none', axisExpandWindow: axisExpandWindow};\n        }\n\n        // Conver the point from global to expand coordinates.\n        var pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos;\n\n        // For dragging operation convenience, the window should not be\n        // slided when mouse is the center area of the window.\n        var delta;\n        var behavior = 'slide';\n        var axisCollapseWidth = layoutInfo.axisCollapseWidth;\n        var triggerArea = this._model.get('axisExpandSlideTriggerArea');\n        // But consider touch device, jump is necessary.\n        var useJump = triggerArea[0] != null;\n\n        if (axisCollapseWidth) {\n            if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {\n                behavior = 'jump';\n                delta = pointCoord - winSize * triggerArea[2];\n            }\n            else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {\n                behavior = 'jump';\n                delta = pointCoord - winSize * (1 - triggerArea[2]);\n            }\n            else {\n                (delta = pointCoord - winSize * triggerArea[1]) >= 0\n                    && (delta = pointCoord - winSize * (1 - triggerArea[1])) <= 0\n                    && (delta = 0);\n            }\n            delta *= layoutInfo.axisExpandWidth / axisCollapseWidth;\n            delta\n                ? sliderMove(delta, axisExpandWindow, extent, 'all')\n                // Avoid nonsense triger on mousemove.\n                : (behavior = 'none');\n        }\n        // When screen is too narrow, make it visible and slidable, although it is hard to interact.\n        else {\n            var winSize = axisExpandWindow[1] - axisExpandWindow[0];\n            var pos = extent[1] * pointCoord / winSize;\n            axisExpandWindow = [mathMax$5(0, pos - winSize / 2)];\n            axisExpandWindow[1] = mathMin$5(extent[1], axisExpandWindow[0] + winSize);\n            axisExpandWindow[0] = axisExpandWindow[1] - winSize;\n        }\n\n        return {\n            axisExpandWindow: axisExpandWindow,\n            behavior: behavior\n        };\n    }\n};\n\nfunction restrict(len, extent) {\n    return mathMin$5(mathMax$5(len, extent[0]), extent[1]);\n}\n\nfunction layoutAxisWithoutExpand(axisIndex, layoutInfo) {\n    var step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1);\n    return {\n        position: step * axisIndex,\n        axisNameAvailableWidth: step,\n        axisLabelShow: true\n    };\n}\n\nfunction layoutAxisWithExpand(axisIndex, layoutInfo) {\n    var layoutLength = layoutInfo.layoutLength;\n    var axisExpandWidth = layoutInfo.axisExpandWidth;\n    var axisCount = layoutInfo.axisCount;\n    var axisCollapseWidth = layoutInfo.axisCollapseWidth;\n    var winInnerIndices = layoutInfo.winInnerIndices;\n\n    var position;\n    var axisNameAvailableWidth = axisCollapseWidth;\n    var axisLabelShow = false;\n    var nameTruncateMaxWidth;\n\n    if (axisIndex < winInnerIndices[0]) {\n        position = axisIndex * axisCollapseWidth;\n        nameTruncateMaxWidth = axisCollapseWidth;\n    }\n    else if (axisIndex <= winInnerIndices[1]) {\n        position = layoutInfo.axisExpandWindow0Pos\n            + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0];\n        axisNameAvailableWidth = axisExpandWidth;\n        axisLabelShow = true;\n    }\n    else {\n        position = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth;\n        nameTruncateMaxWidth = axisCollapseWidth;\n    }\n\n    return {\n        position: position,\n        axisNameAvailableWidth: axisNameAvailableWidth,\n        axisLabelShow: axisLabelShow,\n        nameTruncateMaxWidth: nameTruncateMaxWidth\n    };\n}\n\n/**\n * Parallel coordinate system creater.\n */\n\nfunction create$2(ecModel, api) {\n    var coordSysList = [];\n\n    ecModel.eachComponent('parallel', function (parallelModel, idx) {\n        var coordSys = new Parallel(parallelModel, ecModel, api);\n\n        coordSys.name = 'parallel_' + idx;\n        coordSys.resize(parallelModel, api);\n\n        parallelModel.coordinateSystem = coordSys;\n        coordSys.model = parallelModel;\n\n        coordSysList.push(coordSys);\n    });\n\n    // Inject the coordinateSystems into seriesModel\n    ecModel.eachSeries(function (seriesModel) {\n        if (seriesModel.get('coordinateSystem') === 'parallel') {\n            var parallelModel = ecModel.queryComponents({\n                mainType: 'parallel',\n                index: seriesModel.get('parallelIndex'),\n                id: seriesModel.get('parallelId')\n            })[0];\n            seriesModel.coordinateSystem = parallelModel.coordinateSystem;\n        }\n    });\n\n    return coordSysList;\n}\n\nCoordinateSystemManager.register('parallel', {create: create$2});\n\nvar AxisModel$2 = ComponentModel.extend({\n\n    type: 'baseParallelAxis',\n\n    /**\n     * @type {module:echarts/coord/parallel/Axis}\n     */\n    axis: null,\n\n    /**\n     * @type {Array.<Array.<number>}\n     * @readOnly\n     */\n    activeIntervals: [],\n\n    /**\n     * @return {Object}\n     */\n    getAreaSelectStyle: function () {\n        return makeStyleMapper(\n            [\n                ['fill', 'color'],\n                ['lineWidth', 'borderWidth'],\n                ['stroke', 'borderColor'],\n                ['width', 'width'],\n                ['opacity', 'opacity']\n            ]\n        )(this.getModel('areaSelectStyle'));\n    },\n\n    /**\n     * The code of this feature is put on AxisModel but not ParallelAxis,\n     * because axisModel can be alive after echarts updating but instance of\n     * ParallelAxis having been disposed. this._activeInterval should be kept\n     * when action dispatched (i.e. legend click).\n     *\n     * @param {Array.<Array<number>>} intervals interval.length === 0\n     *                                          means set all active.\n     * @public\n     */\n    setActiveIntervals: function (intervals) {\n        var activeIntervals = this.activeIntervals = clone(intervals);\n\n        // Normalize\n        if (activeIntervals) {\n            for (var i = activeIntervals.length - 1; i >= 0; i--) {\n                asc(activeIntervals[i]);\n            }\n        }\n    },\n\n    /**\n     * @param {number|string} [value] When attempting to detect 'no activeIntervals set',\n     *                         value can not be input.\n     * @return {string} 'normal': no activeIntervals set,\n     *                  'active',\n     *                  'inactive'.\n     * @public\n     */\n    getActiveState: function (value) {\n        var activeIntervals = this.activeIntervals;\n\n        if (!activeIntervals.length) {\n            return 'normal';\n        }\n\n        if (value == null) {\n            return 'inactive';\n        }\n\n        for (var i = 0, len = activeIntervals.length; i < len; i++) {\n            if (activeIntervals[i][0] <= value && value <= activeIntervals[i][1]) {\n                return 'active';\n            }\n        }\n        return 'inactive';\n    }\n\n});\n\nvar defaultOption$1 = {\n\n    type: 'value',\n\n    /**\n     * @type {Array.<number>}\n     */\n    dim: null, // 0, 1, 2, ...\n\n    // parallelIndex: null,\n\n    areaSelectStyle: {\n        width: 20,\n        borderWidth: 1,\n        borderColor: 'rgba(160,197,232)',\n        color: 'rgba(160,197,232)',\n        opacity: 0.3\n    },\n\n    realtime: true, // Whether realtime update view when select.\n\n    z: 10\n};\n\nmerge(AxisModel$2.prototype, axisModelCommonMixin);\n\nfunction getAxisType$1(axisName, option) {\n    return option.type || (option.data ? 'category' : 'value');\n}\n\naxisModelCreator('parallel', AxisModel$2, getAxisType$1, defaultOption$1);\n\nComponentModel.extend({\n\n    type: 'parallel',\n\n    dependencies: ['parallelAxis'],\n\n    /**\n     * @type {module:echarts/coord/parallel/Parallel}\n     */\n    coordinateSystem: null,\n\n    /**\n     * Each item like: 'dim0', 'dim1', 'dim2', ...\n     * @type {Array.<string>}\n     * @readOnly\n     */\n    dimensions: null,\n\n    /**\n     * Coresponding to dimensions.\n     * @type {Array.<number>}\n     * @readOnly\n     */\n    parallelAxisIndex: null,\n\n    layoutMode: 'box',\n\n    defaultOption: {\n        zlevel: 0,\n        z: 0,\n        left: 80,\n        top: 60,\n        right: 80,\n        bottom: 60,\n        // width: {totalWidth} - left - right,\n        // height: {totalHeight} - top - bottom,\n\n        layout: 'horizontal',      // 'horizontal' or 'vertical'\n\n        // FIXME\n        // naming?\n        axisExpandable: false,\n        axisExpandCenter: null,\n        axisExpandCount: 0,\n        axisExpandWidth: 50,      // FIXME '10%' ?\n        axisExpandRate: 17,\n        axisExpandDebounce: 50,\n        // [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full.\n        // Do not doc to user until necessary.\n        axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],\n        axisExpandTriggerOn: 'click', // 'mousemove' or 'click'\n\n        parallelAxisDefault: null\n    },\n\n    /**\n     * @override\n     */\n    init: function () {\n        ComponentModel.prototype.init.apply(this, arguments);\n\n        this.mergeOption({});\n    },\n\n    /**\n     * @override\n     */\n    mergeOption: function (newOption) {\n        var thisOption = this.option;\n\n        newOption && merge(thisOption, newOption, true);\n\n        this._initDimensions();\n    },\n\n    /**\n     * Whether series or axis is in this coordinate system.\n     * @param {module:echarts/model/Series|module:echarts/coord/parallel/AxisModel} model\n     * @param {module:echarts/model/Global} ecModel\n     */\n    contains: function (model, ecModel) {\n        var parallelIndex = model.get('parallelIndex');\n        return parallelIndex != null\n            && ecModel.getComponent('parallel', parallelIndex) === this;\n    },\n\n    setAxisExpand: function (opt) {\n        each$1(\n            ['axisExpandable', 'axisExpandCenter', 'axisExpandCount', 'axisExpandWidth', 'axisExpandWindow'],\n            function (name) {\n                if (opt.hasOwnProperty(name)) {\n                    this.option[name] = opt[name];\n                }\n            },\n            this\n        );\n    },\n\n    /**\n     * @private\n     */\n    _initDimensions: function () {\n        var dimensions = this.dimensions = [];\n        var parallelAxisIndex = this.parallelAxisIndex = [];\n\n        var axisModels = filter(this.dependentModels.parallelAxis, function (axisModel) {\n            // Can not use this.contains here, because\n            // initialization has not been completed yet.\n            return (axisModel.get('parallelIndex') || 0) === this.componentIndex;\n        }, this);\n\n        each$1(axisModels, function (axisModel) {\n            dimensions.push('dim' + axisModel.get('dim'));\n            parallelAxisIndex.push(axisModel.componentIndex);\n        });\n    }\n\n});\n\n/**\n * @payload\n * @property {string} parallelAxisId\n * @property {Array.<Array.<number>>} intervals\n */\nvar actionInfo$1 = {\n    type: 'axisAreaSelect',\n    event: 'axisAreaSelected',\n    update: 'updateVisual'\n};\n\nregisterAction(actionInfo$1, function (payload, ecModel) {\n    ecModel.eachComponent(\n        {mainType: 'parallelAxis', query: payload},\n        function (parallelAxisModel) {\n            parallelAxisModel.axis.model.setActiveIntervals(payload.intervals);\n        }\n    );\n});\n\n/**\n * @payload\n */\nregisterAction('parallelAxisExpand', function (payload, ecModel) {\n    ecModel.eachComponent(\n        {mainType: 'parallel', query: payload},\n        function (parallelModel) {\n            parallelModel.setAxisExpand(payload);\n        }\n    );\n\n});\n\nvar curry$2 = curry;\nvar each$15 = each$1;\nvar map$3 = map;\nvar mathMin$6 = Math.min;\nvar mathMax$6 = Math.max;\nvar mathPow$2 = Math.pow;\n\nvar COVER_Z = 10000;\nvar UNSELECT_THRESHOLD = 6;\nvar MIN_RESIZE_LINE_WIDTH = 6;\nvar MUTEX_RESOURCE_KEY = 'globalPan';\n\nvar DIRECTION_MAP = {\n    w: [0, 0],\n    e: [0, 1],\n    n: [1, 0],\n    s: [1, 1]\n};\nvar CURSOR_MAP = {\n    w: 'ew',\n    e: 'ew',\n    n: 'ns',\n    s: 'ns',\n    ne: 'nesw',\n    sw: 'nesw',\n    nw: 'nwse',\n    se: 'nwse'\n};\nvar DEFAULT_BRUSH_OPT = {\n    brushStyle: {\n        lineWidth: 2,\n        stroke: 'rgba(0,0,0,0.3)',\n        fill: 'rgba(0,0,0,0.1)'\n    },\n    transformable: true,\n    brushMode: 'single',\n    removeOnClick: false\n};\n\nvar baseUID = 0;\n\n/**\n * @alias module:echarts/component/helper/BrushController\n * @constructor\n * @mixin {module:zrender/mixin/Eventful}\n * @event module:echarts/component/helper/BrushController#brush\n *        params:\n *            areas: Array.<Array>, coord relates to container group,\n *                                    If no container specified, to global.\n *            opt {\n *                isEnd: boolean,\n *                removeOnClick: boolean\n *            }\n *\n * @param {module:zrender/zrender~ZRender} zr\n */\nfunction BrushController(zr) {\n\n    if (__DEV__) {\n        assert(zr);\n    }\n\n    Eventful.call(this);\n\n    /**\n     * @type {module:zrender/zrender~ZRender}\n     * @private\n     */\n    this._zr = zr;\n\n    /**\n     * @type {module:zrender/container/Group}\n     * @readOnly\n     */\n    this.group = new Group();\n\n    /**\n     * Only for drawing (after enabledBrush).\n     *     'line', 'rect', 'polygon' or false\n     *     If passing false/null/undefined, disable brush.\n     *     If passing 'auto', determined by panel.defaultBrushType\n     * @private\n     * @type {string}\n     */\n    this._brushType;\n\n    /**\n     * Only for drawing (after enabledBrush).\n     *\n     * @private\n     * @type {Object}\n     */\n    this._brushOption;\n\n    /**\n     * @private\n     * @type {Object}\n     */\n    this._panels;\n\n    /**\n     * @private\n     * @type {Array.<nubmer>}\n     */\n    this._track = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this._dragging;\n\n    /**\n     * @private\n     * @type {Array}\n     */\n    this._covers = [];\n\n    /**\n     * @private\n     * @type {moudule:zrender/container/Group}\n     */\n    this._creatingCover;\n\n    /**\n     * `true` means global panel\n     * @private\n     * @type {module:zrender/container/Group|boolean}\n     */\n    this._creatingPanel;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this._enableGlobalPan;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    if (__DEV__) {\n        this._mounted;\n    }\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this._uid = 'brushController_' + baseUID++;\n\n    /**\n     * @private\n     * @type {Object}\n     */\n    this._handlers = {};\n    each$15(mouseHandlers, function (handler, eventName) {\n        this._handlers[eventName] = bind(handler, this);\n    }, this);\n}\n\nBrushController.prototype = {\n\n    constructor: BrushController,\n\n    /**\n     * If set to null/undefined/false, select disabled.\n     * @param {Object} brushOption\n     * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false\n     *                          If passing false/null/undefined, disable brush.\n     *                          If passing 'auto', determined by panel.defaultBrushType.\n     *                              ('auto' can not be used in global panel)\n     * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'\n     * @param {boolean} [brushOption.transformable=true]\n     * @param {boolean} [brushOption.removeOnClick=false]\n     * @param {Object} [brushOption.brushStyle]\n     * @param {number} [brushOption.brushStyle.width]\n     * @param {number} [brushOption.brushStyle.lineWidth]\n     * @param {string} [brushOption.brushStyle.stroke]\n     * @param {string} [brushOption.brushStyle.fill]\n     * @param {number} [brushOption.z]\n     */\n    enableBrush: function (brushOption) {\n        if (__DEV__) {\n            assert(this._mounted);\n        }\n\n        this._brushType && doDisableBrush(this);\n        brushOption.brushType && doEnableBrush(this, brushOption);\n\n        return this;\n    },\n\n    /**\n     * @param {Array.<Object>} panelOpts If not pass, it is global brush.\n     *        Each items: {\n     *            panelId, // mandatory.\n     *            clipPath, // mandatory. function.\n     *            isTargetByCursor, // mandatory. function.\n     *            defaultBrushType, // optional, only used when brushType is 'auto'.\n     *            getLinearBrushOtherExtent, // optional. function.\n     *        }\n     */\n    setPanels: function (panelOpts) {\n        if (panelOpts && panelOpts.length) {\n            var panels = this._panels = {};\n            each$1(panelOpts, function (panelOpts) {\n                panels[panelOpts.panelId] = clone(panelOpts);\n            });\n        }\n        else {\n            this._panels = null;\n        }\n        return this;\n    },\n\n    /**\n     * @param {Object} [opt]\n     * @return {boolean} [opt.enableGlobalPan=false]\n     */\n    mount: function (opt) {\n        opt = opt || {};\n\n        if (__DEV__) {\n            this._mounted = true; // should be at first.\n        }\n\n        this._enableGlobalPan = opt.enableGlobalPan;\n\n        var thisGroup = this.group;\n        this._zr.add(thisGroup);\n\n        thisGroup.attr({\n            position: opt.position || [0, 0],\n            rotation: opt.rotation || 0,\n            scale: opt.scale || [1, 1]\n        });\n        this._transform = thisGroup.getLocalTransform();\n\n        return this;\n    },\n\n    eachCover: function (cb, context) {\n        each$15(this._covers, cb, context);\n    },\n\n    /**\n     * Update covers.\n     * @param {Array.<Object>} brushOptionList Like:\n     *        [\n     *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},\n     *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},\n     *            ...\n     *        ]\n     *        `brushType` is required in each cover info. (can not be 'auto')\n     *        `id` is not mandatory.\n     *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.\n     *        If brushOptionList is null/undefined, all covers removed.\n     */\n    updateCovers: function (brushOptionList) {\n        if (__DEV__) {\n            assert(this._mounted);\n        }\n\n        brushOptionList = map(brushOptionList, function (brushOption) {\n            return merge(clone(DEFAULT_BRUSH_OPT), brushOption, true);\n        });\n\n        var tmpIdPrefix = '\\0-brush-index-';\n        var oldCovers = this._covers;\n        var newCovers = this._covers = [];\n        var controller = this;\n        var creatingCover = this._creatingCover;\n\n        (new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey))\n            .add(addOrUpdate)\n            .update(addOrUpdate)\n            .remove(remove)\n            .execute();\n\n        return this;\n\n        function getKey(brushOption, index) {\n            return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index)\n                + '-' + brushOption.brushType;\n        }\n\n        function oldGetKey(cover, index) {\n            return getKey(cover.__brushOption, index);\n        }\n\n        function addOrUpdate(newIndex, oldIndex) {\n            var newBrushOption = brushOptionList[newIndex];\n            // Consider setOption in event listener of brushSelect,\n            // where updating cover when creating should be forbiden.\n            if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n                newCovers[newIndex] = oldCovers[oldIndex];\n            }\n            else {\n                var cover = newCovers[newIndex] = oldIndex != null\n                    ? (\n                        oldCovers[oldIndex].__brushOption = newBrushOption,\n                        oldCovers[oldIndex]\n                    )\n                    : endCreating(controller, createCover(controller, newBrushOption));\n                updateCoverAfterCreation(controller, cover);\n            }\n        }\n\n        function remove(oldIndex) {\n            if (oldCovers[oldIndex] !== creatingCover) {\n                controller.group.remove(oldCovers[oldIndex]);\n            }\n        }\n    },\n\n    unmount: function () {\n        if (__DEV__) {\n            if (!this._mounted) {\n                return;\n            }\n        }\n\n        this.enableBrush(false);\n\n        // container may 'removeAll' outside.\n        clearCovers(this);\n        this._zr.remove(this.group);\n\n        if (__DEV__) {\n            this._mounted = false; // should be at last.\n        }\n\n        return this;\n    },\n\n    dispose: function () {\n        this.unmount();\n        this.off();\n    }\n};\n\nmixin(BrushController, Eventful);\n\nfunction doEnableBrush(controller, brushOption) {\n    var zr = controller._zr;\n\n    // Consider roam, which takes globalPan too.\n    if (!controller._enableGlobalPan) {\n        take(zr, MUTEX_RESOURCE_KEY, controller._uid);\n    }\n\n    each$15(controller._handlers, function (handler, eventName) {\n        zr.on(eventName, handler);\n    });\n\n    controller._brushType = brushOption.brushType;\n    controller._brushOption = merge(clone(DEFAULT_BRUSH_OPT), brushOption, true);\n}\n\nfunction doDisableBrush(controller) {\n    var zr = controller._zr;\n\n    release(zr, MUTEX_RESOURCE_KEY, controller._uid);\n\n    each$15(controller._handlers, function (handler, eventName) {\n        zr.off(eventName, handler);\n    });\n\n    controller._brushType = controller._brushOption = null;\n}\n\nfunction createCover(controller, brushOption) {\n    var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n    cover.__brushOption = brushOption;\n    updateZ$1(cover, brushOption);\n    controller.group.add(cover);\n    return cover;\n}\n\nfunction endCreating(controller, creatingCover) {\n    var coverRenderer = getCoverRenderer(creatingCover);\n    if (coverRenderer.endCreating) {\n        coverRenderer.endCreating(controller, creatingCover);\n        updateZ$1(creatingCover, creatingCover.__brushOption);\n    }\n    return creatingCover;\n}\n\nfunction updateCoverShape(controller, cover) {\n    var brushOption = cover.__brushOption;\n    getCoverRenderer(cover).updateCoverShape(\n        controller, cover, brushOption.range, brushOption\n    );\n}\n\nfunction updateZ$1(cover, brushOption) {\n    var z = brushOption.z;\n    z == null && (z = COVER_Z);\n    cover.traverse(function (el) {\n        el.z = z;\n        el.z2 = z; // Consider in given container.\n    });\n}\n\nfunction updateCoverAfterCreation(controller, cover) {\n    getCoverRenderer(cover).updateCommon(controller, cover);\n    updateCoverShape(controller, cover);\n}\n\nfunction getCoverRenderer(cover) {\n    return coverRenderers[cover.__brushOption.brushType];\n}\n\n// return target panel or `true` (means global panel)\nfunction getPanelByPoint(controller, e, localCursorPoint) {\n    var panels = controller._panels;\n    if (!panels) {\n        return true; // Global panel\n    }\n    var panel;\n    var transform = controller._transform;\n    each$15(panels, function (pn) {\n        pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n    });\n    return panel;\n}\n\n// Return a panel or true\nfunction getPanelByCover(controller, cover) {\n    var panels = controller._panels;\n    if (!panels) {\n        return true; // Global panel\n    }\n    var panelId = cover.__brushOption.panelId;\n    // User may give cover without coord sys info,\n    // which is then treated as global panel.\n    return panelId != null ? panels[panelId] : true;\n}\n\nfunction clearCovers(controller) {\n    var covers = controller._covers;\n    var originalLength = covers.length;\n    each$15(covers, function (cover) {\n        controller.group.remove(cover);\n    }, controller);\n    covers.length = 0;\n\n    return !!originalLength;\n}\n\nfunction trigger(controller, opt) {\n    var areas = map$3(controller._covers, function (cover) {\n        var brushOption = cover.__brushOption;\n        var range = clone(brushOption.range);\n        return {\n            brushType: brushOption.brushType,\n            panelId: brushOption.panelId,\n            range: range\n        };\n    });\n\n    controller.trigger('brush', areas, {\n        isEnd: !!opt.isEnd,\n        removeOnClick: !!opt.removeOnClick\n    });\n}\n\nfunction shouldShowCover(controller) {\n    var track = controller._track;\n\n    if (!track.length) {\n        return false;\n    }\n\n    var p2 = track[track.length - 1];\n    var p1 = track[0];\n    var dx = p2[0] - p1[0];\n    var dy = p2[1] - p1[1];\n    var dist = mathPow$2(dx * dx + dy * dy, 0.5);\n\n    return dist > UNSELECT_THRESHOLD;\n}\n\nfunction getTrackEnds(track) {\n    var tail = track.length - 1;\n    tail < 0 && (tail = 0);\n    return [track[0], track[tail]];\n}\n\nfunction createBaseRectCover(doDrift, controller, brushOption, edgeNames) {\n    var cover = new Group();\n\n    cover.add(new Rect({\n        name: 'main',\n        style: makeStyle(brushOption),\n        silent: true,\n        draggable: true,\n        cursor: 'move',\n        drift: curry$2(doDrift, controller, cover, 'nswe'),\n        ondragend: curry$2(trigger, controller, {isEnd: true})\n    }));\n\n    each$15(\n        edgeNames,\n        function (name) {\n            cover.add(new Rect({\n                name: name,\n                style: {opacity: 0},\n                draggable: true,\n                silent: true,\n                invisible: true,\n                drift: curry$2(doDrift, controller, cover, name),\n                ondragend: curry$2(trigger, controller, {isEnd: true})\n            }));\n        }\n    );\n\n    return cover;\n}\n\nfunction updateBaseRect(controller, cover, localRange, brushOption) {\n    var lineWidth = brushOption.brushStyle.lineWidth || 0;\n    var handleSize = mathMax$6(lineWidth, MIN_RESIZE_LINE_WIDTH);\n    var x = localRange[0][0];\n    var y = localRange[1][0];\n    var xa = x - lineWidth / 2;\n    var ya = y - lineWidth / 2;\n    var x2 = localRange[0][1];\n    var y2 = localRange[1][1];\n    var x2a = x2 - handleSize + lineWidth / 2;\n    var y2a = y2 - handleSize + lineWidth / 2;\n    var width = x2 - x;\n    var height = y2 - y;\n    var widtha = width + lineWidth;\n    var heighta = height + lineWidth;\n\n    updateRectShape(controller, cover, 'main', x, y, width, height);\n\n    if (brushOption.transformable) {\n        updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n        updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n        updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n        updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n\n        updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n        updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n        updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n        updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n    }\n}\n\nfunction updateCommon(controller, cover) {\n    var brushOption = cover.__brushOption;\n    var transformable = brushOption.transformable;\n\n    var mainEl = cover.childAt(0);\n    mainEl.useStyle(makeStyle(brushOption));\n    mainEl.attr({\n        silent: !transformable,\n        cursor: transformable ? 'move' : 'default'\n    });\n\n    each$15(\n        ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'],\n        function (name) {\n            var el = cover.childOfName(name);\n            var globalDir = getGlobalDirection(controller, name);\n\n            el && el.attr({\n                silent: !transformable,\n                invisible: !transformable,\n                cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n            });\n        }\n    );\n}\n\nfunction updateRectShape(controller, cover, name, x, y, w, h) {\n    var el = cover.childOfName(name);\n    el && el.setShape(pointsToRect(\n        clipByPanel(controller, cover, [[x, y], [x + w, y + h]])\n    ));\n}\n\nfunction makeStyle(brushOption) {\n    return defaults({strokeNoScale: true}, brushOption.brushStyle);\n}\n\nfunction formatRectRange(x, y, x2, y2) {\n    var min = [mathMin$6(x, x2), mathMin$6(y, y2)];\n    var max = [mathMax$6(x, x2), mathMax$6(y, y2)];\n\n    return [\n        [min[0], max[0]], // x range\n        [min[1], max[1]] // y range\n    ];\n}\n\nfunction getTransform$1(controller) {\n    return getTransform(controller.group);\n}\n\nfunction getGlobalDirection(controller, localDirection) {\n    if (localDirection.length > 1) {\n        localDirection = localDirection.split('');\n        var globalDir = [\n            getGlobalDirection(controller, localDirection[0]),\n            getGlobalDirection(controller, localDirection[1])\n        ];\n        (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n        return globalDir.join('');\n    }\n    else {\n        var map$$1 = {w: 'left', e: 'right', n: 'top', s: 'bottom'};\n        var inverseMap = {left: 'w', right: 'e', top: 'n', bottom: 's'};\n        var globalDir = transformDirection(\n            map$$1[localDirection], getTransform$1(controller)\n        );\n        return inverseMap[globalDir];\n    }\n}\n\nfunction driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {\n    var brushOption = cover.__brushOption;\n    var rectRange = toRectRange(brushOption.range);\n    var localDelta = toLocalDelta(controller, dx, dy);\n\n    each$15(name.split(''), function (namePart) {\n        var ind = DIRECTION_MAP[namePart];\n        rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n    });\n\n    brushOption.range = fromRectRange(formatRectRange(\n        rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]\n    ));\n\n    updateCoverAfterCreation(controller, cover);\n    trigger(controller, {isEnd: false});\n}\n\nfunction driftPolygon(controller, cover, dx, dy, e) {\n    var range = cover.__brushOption.range;\n    var localDelta = toLocalDelta(controller, dx, dy);\n\n    each$15(range, function (point) {\n        point[0] += localDelta[0];\n        point[1] += localDelta[1];\n    });\n\n    updateCoverAfterCreation(controller, cover);\n    trigger(controller, {isEnd: false});\n}\n\nfunction toLocalDelta(controller, dx, dy) {\n    var thisGroup = controller.group;\n    var localD = thisGroup.transformCoordToLocal(dx, dy);\n    var localZero = thisGroup.transformCoordToLocal(0, 0);\n\n    return [localD[0] - localZero[0], localD[1] - localZero[1]];\n}\n\nfunction clipByPanel(controller, cover, data) {\n    var panel = getPanelByCover(controller, cover);\n\n    return (panel && panel !== true)\n        ? panel.clipPath(data, controller._transform)\n        : clone(data);\n}\n\nfunction pointsToRect(points) {\n    var xmin = mathMin$6(points[0][0], points[1][0]);\n    var ymin = mathMin$6(points[0][1], points[1][1]);\n    var xmax = mathMax$6(points[0][0], points[1][0]);\n    var ymax = mathMax$6(points[0][1], points[1][1]);\n\n    return {\n        x: xmin,\n        y: ymin,\n        width: xmax - xmin,\n        height: ymax - ymin\n    };\n}\n\nfunction resetCursor(controller, e, localCursorPoint) {\n    // Check active\n    if (!controller._brushType) {\n        return;\n    }\n\n    var zr = controller._zr;\n    var covers = controller._covers;\n    var currPanel = getPanelByPoint(controller, e, localCursorPoint);\n\n    // Check whether in covers.\n    if (!controller._dragging) {\n        for (var i = 0; i < covers.length; i++) {\n            var brushOption = covers[i].__brushOption;\n            if (currPanel\n                && (currPanel === true || brushOption.panelId === currPanel.panelId)\n                && coverRenderers[brushOption.brushType].contain(\n                    covers[i], localCursorPoint[0], localCursorPoint[1]\n                )\n            ) {\n                // Use cursor style set on cover.\n                return;\n            }\n        }\n    }\n\n    currPanel && zr.setCursorStyle('crosshair');\n}\n\nfunction preventDefault(e) {\n    var rawE = e.event;\n    rawE.preventDefault && rawE.preventDefault();\n}\n\nfunction mainShapeContain(cover, x, y) {\n    return cover.childOfName('main').contain(x, y);\n}\n\nfunction updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n    var creatingCover = controller._creatingCover;\n    var panel = controller._creatingPanel;\n    var thisBrushOption = controller._brushOption;\n    var eventParams;\n\n    controller._track.push(localCursorPoint.slice());\n\n    if (shouldShowCover(controller) || creatingCover) {\n\n        if (panel && !creatingCover) {\n            thisBrushOption.brushMode === 'single' && clearCovers(controller);\n            var brushOption = clone(thisBrushOption);\n            brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n            brushOption.panelId = panel === true ? null : panel.panelId;\n            creatingCover = controller._creatingCover = createCover(controller, brushOption);\n            controller._covers.push(creatingCover);\n        }\n\n        if (creatingCover) {\n            var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n            var coverBrushOption = creatingCover.__brushOption;\n\n            coverBrushOption.range = coverRenderer.getCreatingRange(\n                clipByPanel(controller, creatingCover, controller._track)\n            );\n\n            if (isEnd) {\n                endCreating(controller, creatingCover);\n                coverRenderer.updateCommon(controller, creatingCover);\n            }\n\n            updateCoverShape(controller, creatingCover);\n\n            eventParams = {isEnd: isEnd};\n        }\n    }\n    else if (\n        isEnd\n        && thisBrushOption.brushMode === 'single'\n        && thisBrushOption.removeOnClick\n    ) {\n        // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n        // But a single click do not clear covers, because user may have casual\n        // clicks (for example, click on other component and do not expect covers\n        // disappear).\n        // Only some cover removed, trigger action, but not every click trigger action.\n        if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n            eventParams = {isEnd: isEnd, removeOnClick: true};\n        }\n    }\n\n    return eventParams;\n}\n\nfunction determineBrushType(brushType, panel) {\n    if (brushType === 'auto') {\n        if (__DEV__) {\n            assert(\n                panel && panel.defaultBrushType,\n                'MUST have defaultBrushType when brushType is \"atuo\"'\n            );\n        }\n        return panel.defaultBrushType;\n    }\n    return brushType;\n}\n\nvar mouseHandlers = {\n\n    mousedown: function (e) {\n        if (this._dragging) {\n            // In case some browser do not support globalOut,\n            // and release mose out side the browser.\n            handleDragEnd.call(this, e);\n        }\n        else if (!e.target || !e.target.draggable) {\n\n            preventDefault(e);\n\n            var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n\n            this._creatingCover = null;\n            var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n\n            if (panel) {\n                this._dragging = true;\n                this._track = [localCursorPoint.slice()];\n            }\n        }\n    },\n\n    mousemove: function (e) {\n        var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n\n        resetCursor(this, e, localCursorPoint);\n\n        if (this._dragging) {\n\n            preventDefault(e);\n\n            var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n\n            eventParams && trigger(this, eventParams);\n        }\n    },\n\n    mouseup: handleDragEnd //,\n\n    // FIXME\n    // in tooltip, globalout should not be triggered.\n    // globalout: handleDragEnd\n};\n\nfunction handleDragEnd(e) {\n    if (this._dragging) {\n\n        preventDefault(e);\n\n        var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n        var eventParams = updateCoverByMouse(this, e, localCursorPoint, true);\n\n        this._dragging = false;\n        this._track = [];\n        this._creatingCover = null;\n\n        // trigger event shoule be at final, after procedure will be nested.\n        eventParams && trigger(this, eventParams);\n    }\n}\n\n/**\n * key: brushType\n * @type {Object}\n */\nvar coverRenderers = {\n\n    lineX: getLineRenderer(0),\n\n    lineY: getLineRenderer(1),\n\n    rect: {\n        createCover: function (controller, brushOption) {\n            return createBaseRectCover(\n                curry$2(\n                    driftRect,\n                    function (range) {\n                        return range;\n                    },\n                    function (range) {\n                        return range;\n                    }\n                ),\n                controller,\n                brushOption,\n                ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']\n            );\n        },\n        getCreatingRange: function (localTrack) {\n            var ends = getTrackEnds(localTrack);\n            return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n        },\n        updateCoverShape: function (controller, cover, localRange, brushOption) {\n            updateBaseRect(controller, cover, localRange, brushOption);\n        },\n        updateCommon: updateCommon,\n        contain: mainShapeContain\n    },\n\n    polygon: {\n        createCover: function (controller, brushOption) {\n            var cover = new Group();\n\n            // Do not use graphic.Polygon because graphic.Polyline do not close the\n            // border of the shape when drawing, which is a better experience for user.\n            cover.add(new Polyline({\n                name: 'main',\n                style: makeStyle(brushOption),\n                silent: true\n            }));\n\n            return cover;\n        },\n        getCreatingRange: function (localTrack) {\n            return localTrack;\n        },\n        endCreating: function (controller, cover) {\n            cover.remove(cover.childAt(0));\n            // Use graphic.Polygon close the shape.\n            cover.add(new Polygon({\n                name: 'main',\n                draggable: true,\n                drift: curry$2(driftPolygon, controller, cover),\n                ondragend: curry$2(trigger, controller, {isEnd: true})\n            }));\n        },\n        updateCoverShape: function (controller, cover, localRange, brushOption) {\n            cover.childAt(0).setShape({\n                points: clipByPanel(controller, cover, localRange)\n            });\n        },\n        updateCommon: updateCommon,\n        contain: mainShapeContain\n    }\n};\n\nfunction getLineRenderer(xyIndex) {\n    return {\n        createCover: function (controller, brushOption) {\n            return createBaseRectCover(\n                curry$2(\n                    driftRect,\n                    function (range) {\n                        var rectRange = [range, [0, 100]];\n                        xyIndex && rectRange.reverse();\n                        return rectRange;\n                    },\n                    function (rectRange) {\n                        return rectRange[xyIndex];\n                    }\n                ),\n                controller,\n                brushOption,\n                [['w', 'e'], ['n', 's']][xyIndex]\n            );\n        },\n        getCreatingRange: function (localTrack) {\n            var ends = getTrackEnds(localTrack);\n            var min = mathMin$6(ends[0][xyIndex], ends[1][xyIndex]);\n            var max = mathMax$6(ends[0][xyIndex], ends[1][xyIndex]);\n\n            return [min, max];\n        },\n        updateCoverShape: function (controller, cover, localRange, brushOption) {\n            var otherExtent;\n            // If brushWidth not specified, fit the panel.\n            var panel = getPanelByCover(controller, cover);\n            if (panel !== true && panel.getLinearBrushOtherExtent) {\n                otherExtent = panel.getLinearBrushOtherExtent(\n                    xyIndex, controller._transform\n                );\n            }\n            else {\n                var zr = controller._zr;\n                otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n            }\n            var rectRange = [localRange, otherExtent];\n            xyIndex && rectRange.reverse();\n\n            updateBaseRect(controller, cover, rectRange, brushOption);\n        },\n        updateCommon: updateCommon,\n        contain: mainShapeContain\n    };\n}\n\nfunction makeRectPanelClipPath(rect) {\n    rect = normalizeRect(rect);\n    return function (localPoints, transform) {\n        return clipPointsByRect(localPoints, rect);\n    };\n}\n\nfunction makeLinearBrushOtherExtent(rect, specifiedXYIndex) {\n    rect = normalizeRect(rect);\n    return function (xyIndex) {\n        var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;\n        var brushWidth = idx ? rect.width : rect.height;\n        var base = idx ? rect.x : rect.y;\n        return [base, base + (brushWidth || 0)];\n    };\n}\n\nfunction makeRectIsTargetByCursor(rect, api, targetModel) {\n    rect = normalizeRect(rect);\n    return function (e, localCursorPoint, transform) {\n        return rect.contain(localCursorPoint[0], localCursorPoint[1])\n            && !onIrrelevantElement(e, api, targetModel);\n    };\n}\n\n// Consider width/height is negative.\nfunction normalizeRect(rect) {\n    return BoundingRect.create(rect);\n}\n\nvar elementList = ['axisLine', 'axisTickLabel', 'axisName'];\n\nvar AxisView$2 = extendComponentView({\n\n    type: 'parallelAxis',\n\n    /**\n     * @override\n     */\n    init: function (ecModel, api) {\n        AxisView$2.superApply(this, 'init', arguments);\n\n        /**\n         * @type {module:echarts/component/helper/BrushController}\n         */\n        (this._brushController = new BrushController(api.getZr()))\n            .on('brush', bind(this._onBrush, this));\n    },\n\n    /**\n     * @override\n     */\n    render: function (axisModel, ecModel, api, payload) {\n        if (fromAxisAreaSelect(axisModel, ecModel, payload)) {\n            return;\n        }\n\n        this.axisModel = axisModel;\n        this.api = api;\n\n        this.group.removeAll();\n\n        var oldAxisGroup = this._axisGroup;\n        this._axisGroup = new Group();\n        this.group.add(this._axisGroup);\n\n        if (!axisModel.get('show')) {\n            return;\n        }\n\n        var coordSysModel = getCoordSysModel(axisModel, ecModel);\n        var coordSys = coordSysModel.coordinateSystem;\n\n        var areaSelectStyle = axisModel.getAreaSelectStyle();\n        var areaWidth = areaSelectStyle.width;\n\n        var dim = axisModel.axis.dim;\n        var axisLayout = coordSys.getAxisLayout(dim);\n\n        var builderOpt = extend(\n            {strokeContainThreshold: areaWidth},\n            axisLayout\n        );\n\n        var axisBuilder = new AxisBuilder(axisModel, builderOpt);\n\n        each$1(elementList, axisBuilder.add, axisBuilder);\n\n        this._axisGroup.add(axisBuilder.getGroup());\n\n        this._refreshBrushController(\n            builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api\n        );\n\n        var animationModel = (payload && payload.animation === false) ? null : axisModel;\n        groupTransition(oldAxisGroup, this._axisGroup, animationModel);\n    },\n\n    /**\n     * @override\n     */\n    updateVisual: function (axisModel, ecModel, api, payload) {\n        this._brushController && this._brushController\n            .updateCovers(getCoverInfoList(axisModel));\n    },\n\n    _refreshBrushController: function (\n        builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api\n    ) {\n        // After filtering, axis may change, select area needs to be update.\n        var extent = axisModel.axis.getExtent();\n        var extentLen = extent[1] - extent[0];\n        var extra = Math.min(30, Math.abs(extentLen) * 0.1); // Arbitrary value.\n\n        // width/height might be negative, which will be\n        // normalized in BoundingRect.\n        var rect = BoundingRect.create({\n            x: extent[0],\n            y: -areaWidth / 2,\n            width: extentLen,\n            height: areaWidth\n        });\n        rect.x -= extra;\n        rect.width += 2 * extra;\n\n        this._brushController\n            .mount({\n                enableGlobalPan: true,\n                rotation: builderOpt.rotation,\n                position: builderOpt.position\n            })\n            .setPanels([{\n                panelId: 'pl',\n                clipPath: makeRectPanelClipPath(rect),\n                isTargetByCursor: makeRectIsTargetByCursor(rect, api, coordSysModel),\n                getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect, 0)\n            }])\n            .enableBrush({\n                brushType: 'lineX',\n                brushStyle: areaSelectStyle,\n                removeOnClick: true\n            })\n            .updateCovers(getCoverInfoList(axisModel));\n    },\n\n    _onBrush: function (coverInfoList, opt) {\n        // Do not cache these object, because the mey be changed.\n        var axisModel = this.axisModel;\n        var axis = axisModel.axis;\n        var intervals = map(coverInfoList, function (coverInfo) {\n            return [\n                axis.coordToData(coverInfo.range[0], true),\n                axis.coordToData(coverInfo.range[1], true)\n            ];\n        });\n\n        // If realtime is true, action is not dispatched on drag end, because\n        // the drag end emits the same params with the last drag move event,\n        // and may have some delay when using touch pad.\n        if (!axisModel.option.realtime === opt.isEnd || opt.removeOnClick) { // jshint ignore:line\n            this.api.dispatchAction({\n                type: 'axisAreaSelect',\n                parallelAxisId: axisModel.id,\n                intervals: intervals\n            });\n        }\n    },\n\n    /**\n     * @override\n     */\n    dispose: function () {\n        this._brushController.dispose();\n    }\n});\n\nfunction fromAxisAreaSelect(axisModel, ecModel, payload) {\n    return payload\n        && payload.type === 'axisAreaSelect'\n        && ecModel.findComponents(\n            {mainType: 'parallelAxis', query: payload}\n        )[0] === axisModel;\n}\n\nfunction getCoverInfoList(axisModel) {\n    var axis = axisModel.axis;\n    return map(axisModel.activeIntervals, function (interval) {\n        return {\n            brushType: 'lineX',\n            panelId: 'pl',\n            range: [\n                axis.dataToCoord(interval[0], true),\n                axis.dataToCoord(interval[1], true)\n            ]\n        };\n    });\n}\n\nfunction getCoordSysModel(axisModel, ecModel) {\n    return ecModel.getComponent(\n        'parallel', axisModel.get('parallelIndex')\n    );\n}\n\nvar CLICK_THRESHOLD = 5; // > 4\n\n// Parallel view\nextendComponentView({\n    type: 'parallel',\n\n    render: function (parallelModel, ecModel, api) {\n        this._model = parallelModel;\n        this._api = api;\n\n        if (!this._handlers) {\n            this._handlers = {};\n            each$1(handlers, function (handler, eventName) {\n                api.getZr().on(eventName, this._handlers[eventName] = bind(handler, this));\n            }, this);\n        }\n\n        createOrUpdate(\n            this,\n            '_throttledDispatchExpand',\n            parallelModel.get('axisExpandRate'),\n            'fixRate'\n        );\n    },\n\n    dispose: function (ecModel, api) {\n        each$1(this._handlers, function (handler, eventName) {\n            api.getZr().off(eventName, handler);\n        });\n        this._handlers = null;\n    },\n\n    /**\n     * @param {Object} [opt] If null, cancle the last action triggering for debounce.\n     */\n    _throttledDispatchExpand: function (opt) {\n        this._dispatchExpand(opt);\n    },\n\n    _dispatchExpand: function (opt) {\n        opt && this._api.dispatchAction(\n            extend({type: 'parallelAxisExpand'}, opt)\n        );\n    }\n\n});\n\nvar handlers = {\n\n    mousedown: function (e) {\n        if (checkTrigger(this, 'click')) {\n            this._mouseDownPoint = [e.offsetX, e.offsetY];\n        }\n    },\n\n    mouseup: function (e) {\n        var mouseDownPoint = this._mouseDownPoint;\n\n        if (checkTrigger(this, 'click') && mouseDownPoint) {\n            var point = [e.offsetX, e.offsetY];\n            var dist = Math.pow(mouseDownPoint[0] - point[0], 2)\n                + Math.pow(mouseDownPoint[1] - point[1], 2);\n\n            if (dist > CLICK_THRESHOLD) {\n                return;\n            }\n\n            var result = this._model.coordinateSystem.getSlidedAxisExpandWindow(\n                [e.offsetX, e.offsetY]\n            );\n\n            result.behavior !== 'none' && this._dispatchExpand({\n                axisExpandWindow: result.axisExpandWindow\n            });\n        }\n\n        this._mouseDownPoint = null;\n    },\n\n    mousemove: function (e) {\n        // Should do nothing when brushing.\n        if (this._mouseDownPoint || !checkTrigger(this, 'mousemove')) {\n            return;\n        }\n        var model = this._model;\n        var result = model.coordinateSystem.getSlidedAxisExpandWindow(\n            [e.offsetX, e.offsetY]\n        );\n\n        var behavior = result.behavior;\n        behavior === 'jump' && this._throttledDispatchExpand.debounceNextCall(model.get('axisExpandDebounce'));\n        this._throttledDispatchExpand(\n            behavior === 'none'\n                ? null // Cancle the last trigger, in case that mouse slide out of the area quickly.\n                : {\n                    axisExpandWindow: result.axisExpandWindow,\n                    // Jumping uses animation, and sliding suppresses animation.\n                    animation: behavior === 'jump'  ? null : false\n                }\n        );\n    }\n};\n\nfunction checkTrigger(view, triggerOn) {\n    var model = view._model;\n    return model.get('axisExpandable') && model.get('axisExpandTriggerOn') === triggerOn;\n}\n\nregisterPreprocessor(parallelPreprocessor);\n\nSeriesModel.extend({\n\n    type: 'series.parallel',\n\n    dependencies: ['parallel'],\n\n    visualColorAccessPath: 'lineStyle.normal.color',\n\n    getInitialData: function (option, ecModel) {\n        var parallelModel = ecModel.getComponent(\n            'parallel', this.get('parallelIndex')\n        );\n        var parallelAxisIndices = parallelModel.parallelAxisIndex;\n\n        var rawData = option.data;\n        var modelDims = parallelModel.dimensions;\n\n        var dataDims = generateDataDims(modelDims, rawData);\n\n        var dataDimsInfo = map(dataDims, function (dim, dimIndex) {\n\n            var modelDimsIndex = indexOf(modelDims, dim);\n            var axisModel = modelDimsIndex >= 0 && ecModel.getComponent(\n                'parallelAxis', parallelAxisIndices[modelDimsIndex]\n            );\n\n            if (axisModel && axisModel.get('type') === 'category') {\n                translateCategoryValue(axisModel, dim, rawData);\n                return {name: dim, type: 'ordinal'};\n            }\n            else if (modelDimsIndex < 0) {\n                return completeDimensions.guessOrdinal(rawData, dimIndex)\n                    ? {name: dim, type: 'ordinal'}\n                    : dim;\n            }\n            else {\n                return dim;\n            }\n        });\n\n        var list = new List(dataDimsInfo, this);\n        list.initData(rawData);\n\n        // Anication is forbiden in progressive data mode.\n        if (this.option.progressive) {\n            this.option.animation = false;\n        }\n\n        return list;\n    },\n\n    /**\n     * User can get data raw indices on 'axisAreaSelected' event received.\n     *\n     * @public\n     * @param {string} activeState 'active' or 'inactive' or 'normal'\n     * @return {Array.<number>} Raw indices\n     */\n    getRawIndicesByActiveState: function (activeState) {\n        var coordSys = this.coordinateSystem;\n        var data = this.getData();\n        var indices = [];\n\n        coordSys.eachActiveState(data, function (theActiveState, dataIndex) {\n            if (activeState === theActiveState) {\n                indices.push(data.getRawIndex(dataIndex));\n            }\n        });\n\n        return indices;\n    },\n\n    defaultOption: {\n        zlevel: 0,                  // \n        z: 2,                       // \n\n        coordinateSystem: 'parallel',\n        parallelIndex: 0,\n\n        label: {\n            normal: {\n                show: false\n            },\n            emphasis: {\n                show: false\n            }\n        },\n\n        inactiveOpacity: 0.05,\n        activeOpacity: 1,\n\n        lineStyle: {\n            normal: {\n                width: 1,\n                opacity: 0.45,\n                type: 'solid'\n            }\n        },\n        progressive: false, // 100\n        smooth: false,\n\n        animationEasing: 'linear'\n    }\n});\n\nfunction translateCategoryValue(axisModel, dim, rawData) {\n    var axisData = axisModel.get('data');\n    var numberDim = convertDimNameToNumber(dim);\n\n    if (axisData && axisData.length) {\n        each$1(rawData, function (dataItem) {\n            if (!dataItem) {\n                return;\n            }\n            // FIXME\n            // time consuming, should use hash?\n            var index = indexOf(axisData, dataItem[numberDim]);\n            dataItem[numberDim] = index >= 0 ? index : NaN;\n        });\n    }\n    // FIXME\n    // axis data, \n}\n\nfunction convertDimNameToNumber(dimName) {\n    return +dimName.replace('dim', '');\n}\n\nfunction generateDataDims(modelDims, rawData) {\n    // parallelModel.dimension should not be regarded as data\n    // dimensions. Consider dimensions = ['dim4', 'dim2', 'dim6'];\n\n    // We detect max dim by parallelModel.dimensions and fist\n    // item in rawData arbitrarily.\n    var maxDimNum = 0;\n    each$1(modelDims, function (dimName) {\n        var numberDim = convertDimNameToNumber(dimName);\n        numberDim > maxDimNum && (maxDimNum = numberDim);\n    });\n\n    var firstItem = rawData[0];\n    if (firstItem && firstItem.length - 1 > maxDimNum) {\n        maxDimNum = firstItem.length - 1;\n    }\n\n    var dataDims = [];\n    for (var i = 0; i <= maxDimNum; i++) {\n        dataDims.push('dim' + i);\n    }\n\n    return dataDims;\n}\n\nvar SMOOTH = 0.3;\n\nvar ParallelView = Chart.extend({\n\n    type: 'parallel',\n\n    init: function () {\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @private\n         */\n        this._dataGroup = new Group();\n\n        this.group.add(this._dataGroup);\n\n        /**\n         * @type {module:echarts/data/List}\n         */\n        this._data;\n    },\n\n    /**\n     * @override\n     */\n    render: function (seriesModel, ecModel, api, payload) {\n        this._renderForNormal(seriesModel, payload);\n        // this[\n        //     seriesModel.option.progressive\n        //         ? '_renderForProgressive'\n        //         : '_renderForNormal'\n        // ](seriesModel);\n    },\n\n    dispose: function () {},\n\n    /**\n     * @private\n     */\n    _renderForNormal: function (seriesModel, payload) {\n        var dataGroup = this._dataGroup;\n        var data = seriesModel.getData();\n        var oldData = this._data;\n        var coordSys = seriesModel.coordinateSystem;\n        var dimensions = coordSys.dimensions;\n        var option = seriesModel.option;\n        var smooth = option.smooth ? SMOOTH : null;\n\n        // Consider switch between progressive and not.\n        // oldData && oldData.__plProgressive && dataGroup.removeAll();\n\n        data.diff(oldData)\n            .add(add)\n            .update(update)\n            .remove(remove)\n            .execute();\n\n        // Update style\n        updateElCommon(data, smooth);\n\n        // First create\n        if (!this._data) {\n            var clipPath = createGridClipShape$1(\n                coordSys, seriesModel, function () {\n                    // Callback will be invoked immediately if there is no animation\n                    setTimeout(function () {\n                        dataGroup.removeClipPath();\n                    });\n                }\n            );\n            dataGroup.setClipPath(clipPath);\n        }\n\n        this._data = data;\n\n        function add(newDataIndex) {\n            addEl(data, dataGroup, newDataIndex, dimensions, coordSys, null, smooth);\n        }\n\n        function update(newDataIndex, oldDataIndex) {\n            var line = oldData.getItemGraphicEl(oldDataIndex);\n            var points = createLinePoints(data, newDataIndex, dimensions, coordSys);\n            data.setItemGraphicEl(newDataIndex, line);\n            var animationModel = (payload && payload.animation === false) ? null : seriesModel;\n            updateProps(line, {shape: {points: points}}, animationModel, newDataIndex);\n        }\n\n        function remove(oldDataIndex) {\n            var line = oldData.getItemGraphicEl(oldDataIndex);\n            dataGroup.remove(line);\n        }\n\n    },\n\n    /**\n     * @private\n     */\n    // _renderForProgressive: function (seriesModel) {\n    //     var dataGroup = this._dataGroup;\n    //     var data = seriesModel.getData();\n    //     var oldData = this._data;\n    //     var coordSys = seriesModel.coordinateSystem;\n    //     var dimensions = coordSys.dimensions;\n    //     var option = seriesModel.option;\n    //     var progressive = option.progressive;\n    //     var smooth = option.smooth ? SMOOTH : null;\n\n    //     // In progressive animation is disabled, so use simple data diff,\n    //     // which effects performance less.\n    //     // (Typically performance for data with length 7000+ like:\n    //     // simpleDiff: 60ms, addEl: 184ms,\n    //     // in RMBP 2.4GHz intel i7, OSX 10.9 chrome 50.0.2661.102 (64-bit))\n    //     if (simpleDiff(oldData, data, dimensions)) {\n    //         dataGroup.removeAll();\n    //         data.each(function (dataIndex) {\n    //             addEl(data, dataGroup, dataIndex, dimensions, coordSys);\n    //         });\n    //     }\n\n    //     updateElCommon(data, progressive, smooth);\n\n    //     // Consider switch between progressive and not.\n    //     data.__plProgressive = true;\n    //     this._data = data;\n    // },\n\n    /**\n     * @override\n     */\n    remove: function () {\n        this._dataGroup && this._dataGroup.removeAll();\n        this._data = null;\n    }\n});\n\nfunction createGridClipShape$1(coordSys, seriesModel, cb) {\n    var parallelModel = coordSys.model;\n    var rect = coordSys.getRect();\n    var rectEl = new Rect({\n        shape: {\n            x: rect.x,\n            y: rect.y,\n            width: rect.width,\n            height: rect.height\n        }\n    });\n\n    var dim = parallelModel.get('layout') === 'horizontal' ? 'width' : 'height';\n    rectEl.setShape(dim, 0);\n    initProps(rectEl, {\n        shape: {\n            width: rect.width,\n            height: rect.height\n        }\n    }, seriesModel, cb);\n    return rectEl;\n}\n\nfunction createLinePoints(data, dataIndex, dimensions, coordSys) {\n    var points = [];\n    for (var i = 0; i < dimensions.length; i++) {\n        var dimName = dimensions[i];\n        var value = data.get(dimName, dataIndex);\n        if (!isEmptyValue(value, coordSys.getAxis(dimName).type)) {\n            points.push(coordSys.dataToPoint(value, dimName));\n        }\n    }\n    return points;\n}\n\nfunction addEl(data, dataGroup, dataIndex, dimensions, coordSys) {\n    var points = createLinePoints(data, dataIndex, dimensions, coordSys);\n    var line = new Polyline({\n        shape: {points: points},\n        silent: true,\n        z2: 10\n    });\n    dataGroup.add(line);\n    data.setItemGraphicEl(dataIndex, line);\n}\n\nfunction updateElCommon(data, smooth) {\n    var seriesStyleModel = data.hostModel.getModel('lineStyle.normal');\n    var lineStyle = seriesStyleModel.getLineStyle();\n    data.eachItemGraphicEl(function (line, dataIndex) {\n        if (data.hasItemOption) {\n            var itemModel = data.getItemModel(dataIndex);\n            var lineStyleModel = itemModel.getModel('lineStyle.normal', seriesStyleModel);\n            lineStyle = lineStyleModel.getLineStyle(['color', 'stroke']);\n        }\n\n        line.useStyle(extend(lineStyle, {\n            fill: null,\n            // lineStyle.color have been set to itemVisual in module:echarts/visual/seriesColor.\n            stroke: data.getItemVisual(dataIndex, 'color'),\n            // lineStyle.opacity have been set to itemVisual in parallelVisual.\n            opacity: data.getItemVisual(dataIndex, 'opacity')\n        }));\n\n        line.shape.smooth = smooth;\n    });\n}\n\n// function simpleDiff(oldData, newData, dimensions) {\n//     var oldLen;\n//     if (!oldData\n//         || !oldData.__plProgressive\n//         || (oldLen = oldData.count()) !== newData.count()\n//     ) {\n//         return true;\n//     }\n\n//     var dimLen = dimensions.length;\n//     for (var i = 0; i < oldLen; i++) {\n//         for (var j = 0; j < dimLen; j++) {\n//             if (oldData.get(dimensions[j], i) !== newData.get(dimensions[j], i)) {\n//                 return true;\n//             }\n//         }\n//     }\n\n//     return false;\n// }\n\n// FIXME\n// ?\nfunction isEmptyValue(val, axisType) {\n    return axisType === 'category'\n        ? val == null\n        : (val == null || isNaN(val)); // axisType === 'value'\n}\n\nvar opacityAccessPath$1 = ['lineStyle', 'normal', 'opacity'];\n\nvar parallelVisual = function (ecModel) {\n\n    ecModel.eachSeriesByType('parallel', function (seriesModel) {\n\n        var itemStyleModel = seriesModel.getModel('itemStyle.normal');\n        var lineStyleModel = seriesModel.getModel('lineStyle.normal');\n        var globalColors = ecModel.get('color');\n\n        var color = lineStyleModel.get('color')\n            || itemStyleModel.get('color')\n            || globalColors[seriesModel.seriesIndex % globalColors.length];\n        var inactiveOpacity = seriesModel.get('inactiveOpacity');\n        var activeOpacity = seriesModel.get('activeOpacity');\n        var lineStyle = seriesModel.getModel('lineStyle.normal').getLineStyle();\n\n        var coordSys = seriesModel.coordinateSystem;\n        var data = seriesModel.getData();\n\n        var opacityMap = {\n            normal: lineStyle.opacity,\n            active: activeOpacity,\n            inactive: inactiveOpacity\n        };\n\n        coordSys.eachActiveState(data, function (activeState, dataIndex) {\n            var itemModel = data.getItemModel(dataIndex);\n            var opacity = opacityMap[activeState];\n            if (activeState === 'normal') {\n                var itemOpacity = itemModel.get(opacityAccessPath$1, true);\n                itemOpacity != null && (opacity = itemOpacity);\n            }\n            data.setItemVisual(dataIndex, 'opacity', opacity);\n        });\n\n        data.setVisual('color', color);\n    });\n};\n\nregisterVisual(parallelVisual);\n\n/**\n * @file Get initial data and define sankey view's series model\n * @author Deqing Li(annong035@gmail.com)\n */\n\nvar SankeySeries = SeriesModel.extend({\n\n    type: 'series.sankey',\n\n    layoutInfo: null,\n\n    /**\n     * Init a graph data structure from data in option series\n     *\n     * @param  {Object} option  the object used to config echarts view\n     * @return {module:echarts/data/List} storage initial data\n     */\n    getInitialData: function (option) {\n        var links = option.edges || option.links;\n        var nodes = option.data || option.nodes;\n        if (nodes && links) {\n            var graph = createGraphFromNodeEdge(nodes, links, this, true);\n            return graph.data;\n        }\n    },\n\n    /**\n     * Return the graphic data structure\n     *\n     * @return {module:echarts/data/Graph} graphic data structure\n     */\n    getGraph: function () {\n        return this.getData().graph;\n    },\n\n    /**\n     * Get edge data of graphic data structure\n     *\n     * @return {module:echarts/data/List} data structure of list\n     */\n    getEdgeData: function () {\n        return this.getGraph().edgeData;\n    },\n\n    /**\n     * @override\n     */\n    formatTooltip: function (dataIndex, multipleSeries, dataType) {\n        // dataType === 'node' or empty do not show tooltip by default\n        if (dataType === 'edge') {\n            var params = this.getDataParams(dataIndex, dataType);\n            var rawDataOpt = params.data;\n            var html = rawDataOpt.source + ' -- ' + rawDataOpt.target;\n            if (params.value) {\n                html += ' : ' + params.value;\n            }\n            return encodeHTML(html);\n        }\n\n        return SankeySeries.superCall(this, 'formatTooltip', dataIndex, multipleSeries);\n    },\n\n    defaultOption: {\n        zlevel: 0,\n        z: 2,\n\n        coordinateSystem: 'view',\n\n        layout: null,\n\n        // the position of the whole view\n        left: '5%',\n        top: '5%',\n        right: '20%',\n        bottom: '5%',\n\n        // the dx of the node\n        nodeWidth: 20,\n\n        // the vertical distance between two nodes\n        nodeGap: 8,\n\n        // the number of iterations to change the position of the node\n        layoutIterations: 32,\n\n        label: {\n            normal: {\n                show: true,\n                position: 'right',\n                color: '#000',\n                fontSize: 12\n            },\n            emphasis: {\n                show: true\n            }\n        },\n\n        itemStyle: {\n            normal: {\n                borderWidth: 1,\n                borderColor: '#333'\n            }\n        },\n\n        lineStyle: {\n            normal: {\n                color: '#314656',\n                opacity: 0.2,\n                curveness: 0.5\n            },\n            emphasis: {\n                opacity: 0.6\n            }\n        },\n\n        animationEasing: 'linear',\n\n        animationDuration: 1000\n    }\n\n});\n\n/**\n * @file  The file used to draw sankey view\n * @author  Deqing Li(annong035@gmail.com)\n */\n\nvar SankeyShape = extendShape({\n    shape: {\n        x1: 0, y1: 0,\n        x2: 0, y2: 0,\n        cpx1: 0, cpy1: 0,\n        cpx2: 0, cpy2: 0,\n\n        extent: 0\n    },\n\n    buildPath: function (ctx, shape) {\n        var halfExtent = shape.extent / 2;\n        ctx.moveTo(shape.x1, shape.y1 - halfExtent);\n        ctx.bezierCurveTo(\n            shape.cpx1, shape.cpy1 - halfExtent,\n            shape.cpx2, shape.cpy2 - halfExtent,\n            shape.x2, shape.y2 - halfExtent\n        );\n        ctx.lineTo(shape.x2, shape.y2 + halfExtent);\n        ctx.bezierCurveTo(\n            shape.cpx2, shape.cpy2 + halfExtent,\n            shape.cpx1, shape.cpy1 + halfExtent,\n            shape.x1, shape.y1 + halfExtent\n        );\n        ctx.closePath();\n    }\n});\n\nextendChartView({\n\n    type: 'sankey',\n\n    /**\n     * @private\n     * @type {module:echarts/chart/sankey/SankeySeries}\n     */\n    _model: null,\n\n    render: function (seriesModel, ecModel, api) {\n        var graph = seriesModel.getGraph();\n        var group = this.group;\n        var layoutInfo = seriesModel.layoutInfo;\n        var nodeData = seriesModel.getData();\n        var edgeData = seriesModel.getData('edge');\n\n        this._model = seriesModel;\n\n        group.removeAll();\n\n        group.attr('position', [layoutInfo.x, layoutInfo.y]);\n\n        // generate a bezire Curve for each edge\n        graph.eachEdge(function (edge) {\n            var curve = new SankeyShape();\n\n            curve.dataIndex = edge.dataIndex;\n            curve.seriesIndex = seriesModel.seriesIndex;\n            curve.dataType = 'edge';\n\n            var lineStyleModel = edge.getModel('lineStyle.normal');\n            var curvature = lineStyleModel.get('curveness');\n            var n1Layout = edge.node1.getLayout();\n            var n2Layout = edge.node2.getLayout();\n            var edgeLayout = edge.getLayout();\n\n            curve.shape.extent = Math.max(1, edgeLayout.dy);\n\n            var x1 = n1Layout.x + n1Layout.dx;\n            var y1 = n1Layout.y + edgeLayout.sy + edgeLayout.dy / 2;\n            var x2 = n2Layout.x;\n            var y2 = n2Layout.y + edgeLayout.ty + edgeLayout.dy / 2;\n            var cpx1 = x1 * (1 - curvature) + x2 * curvature;\n            var cpy1 = y1;\n            var cpx2 = x1 * curvature + x2 * (1 - curvature);\n            var cpy2 = y2;\n\n            curve.setShape({\n                x1: x1,\n                y1: y1,\n                x2: x2,\n                y2: y2,\n                cpx1: cpx1,\n                cpy1: cpy1,\n                cpx2: cpx2,\n                cpy2: cpy2\n            });\n\n            curve.setStyle(lineStyleModel.getItemStyle());\n            // Special color, use source node color or target node color\n            switch (curve.style.fill) {\n                case 'source':\n                    curve.style.fill = edge.node1.getVisual('color');\n                    break;\n                case 'target':\n                    curve.style.fill = edge.node2.getVisual('color');\n                    break;\n            }\n\n            setHoverStyle(curve, edge.getModel('lineStyle.emphasis').getItemStyle());\n\n            group.add(curve);\n\n            edgeData.setItemGraphicEl(edge.dataIndex, curve);\n        });\n\n        // generate a rect  for each node\n        graph.eachNode(function (node) {\n            var layout = node.getLayout();\n            var itemModel = node.getModel();\n            var labelModel = itemModel.getModel('label.normal');\n            var labelHoverModel = itemModel.getModel('label.emphasis');\n\n            var rect = new Rect({\n                shape: {\n                    x: layout.x,\n                    y: layout.y,\n                    width: node.getLayout().dx,\n                    height: node.getLayout().dy\n                },\n                style: itemModel.getModel('itemStyle.normal').getItemStyle()\n            });\n\n            var hoverStyle = node.getModel('itemStyle.emphasis').getItemStyle();\n\n            setLabelStyle(\n                rect.style, hoverStyle, labelModel, labelHoverModel,\n                {\n                    labelFetcher: seriesModel,\n                    labelDataIndex: node.dataIndex,\n                    defaultText: node.id,\n                    isRectText: true\n                }\n            );\n\n            rect.setStyle('fill', node.getVisual('color'));\n\n            setHoverStyle(rect, hoverStyle);\n\n            group.add(rect);\n\n            nodeData.setItemGraphicEl(node.dataIndex, rect);\n\n            rect.dataType = 'node';\n        });\n\n        if (!this._data && seriesModel.get('animation')) {\n            group.setClipPath(createGridClipShape$2(group.getBoundingRect(), seriesModel, function () {\n                group.removeClipPath();\n            }));\n        }\n\n        this._data = seriesModel.getData();\n    },\n\n    dispose: function () {}\n});\n\n// add animation to the view\nfunction createGridClipShape$2(rect, seriesModel, cb) {\n    var rectEl = new Rect({\n        shape: {\n            x: rect.x - 10,\n            y: rect.y - 10,\n            width: 0,\n            height: rect.height + 20\n        }\n    });\n    initProps(rectEl, {\n        shape: {\n            width: rect.width + 20,\n            height: rect.height + 20\n        }\n    }, seriesModel, cb);\n\n    return rectEl;\n}\n\n/**\n * nest helper used to group by the array.\n * can specified the keys and sort the keys.\n */\nfunction nest() {\n\n    var keysFunction = [];\n    var sortKeysFunction = [];\n\n    /**\n     * map an Array into the mapObject.\n     * @param {Array} array\n     * @param {number} depth\n     */\n    function map$$1(array, depth) {\n        if (depth >= keysFunction.length) {\n            return array;\n        }\n        var i = -1;\n        var n = array.length;\n        var keyFunction = keysFunction[depth++];\n        var mapObject = {};\n        var valuesByKey = {};\n\n        while (++i < n) {\n            var keyValue = keyFunction(array[i]);\n            var values = valuesByKey[keyValue];\n\n            if (values) {\n                values.push(array[i]);\n            }\n            else {\n                valuesByKey[keyValue] = [array[i]];\n            }\n        }\n\n        each$1(valuesByKey, function (value, key) {\n            mapObject[key] = map$$1(value, depth);\n        });\n\n        return mapObject;\n    }\n\n    /**\n     * transform the Map Object to multidimensional Array\n     * @param {Object} map\n     * @param {number} depth\n     */\n    function entriesMap(mapObject, depth) {\n        if (depth >= keysFunction.length) {\n            return mapObject;\n        }\n        var array = [];\n        var sortKeyFunction = sortKeysFunction[depth++];\n\n        each$1(mapObject, function (value, key) {\n            array.push({\n                key: key, values: entriesMap(value, depth)\n            });\n        });\n\n        if (sortKeyFunction) {\n            return array.sort(function (a, b) {\n                return sortKeyFunction(a.key, b.key);\n            });\n        }\n        else {\n            return array;\n        }\n    }\n\n    return {\n        /**\n         * specified the key to groupby the arrays.\n         * users can specified one more keys.\n         * @param {Function} d\n         */\n        key: function (d) {\n            keysFunction.push(d);\n            return this;\n        },\n\n        /**\n         * specified the comparator to sort the keys\n         * @param {Function} order\n         */\n        sortKeys: function (order) {\n            sortKeysFunction[keysFunction.length - 1] = order;\n            return this;\n        },\n\n        /**\n         * the array to be grouped by.\n         * @param {Array} array\n         */\n        entries: function (array) {\n            return entriesMap(map$$1(array, 0), 0);\n        }\n    };\n}\n\n/**\n * @file The layout algorithm of sankey view\n * @author  Deqing Li(annong035@gmail.com)\n */\n\nvar sankeyLayout = function (ecModel, api, payload) {\n\n    ecModel.eachSeriesByType('sankey', function (seriesModel) {\n\n        var nodeWidth = seriesModel.get('nodeWidth');\n        var nodeGap = seriesModel.get('nodeGap');\n\n        var layoutInfo = getViewRect$3(seriesModel, api);\n\n        seriesModel.layoutInfo = layoutInfo;\n\n        var width = layoutInfo.width;\n        var height = layoutInfo.height;\n\n        var graph = seriesModel.getGraph();\n\n        var nodes = graph.nodes;\n        var edges = graph.edges;\n\n        computeNodeValues(nodes);\n\n        var filteredNodes = filter(nodes, function (node) {\n            return node.getLayout().value === 0;\n        });\n\n        var iterations = filteredNodes.length !== 0\n            ? 0 : seriesModel.get('layoutIterations');\n\n        layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations);\n    });\n};\n\n/**\n * Get the layout position of the whole view\n *\n * @param {module:echarts/model/Series} seriesModel  the model object of sankey series\n * @param {module:echarts/ExtensionAPI} api  provide the API list that the developer can call\n * @return {module:zrender/core/BoundingRect}  size of rect to draw the sankey view\n */\nfunction getViewRect$3(seriesModel, api) {\n    return getLayoutRect(\n        seriesModel.getBoxLayoutParams(), {\n            width: api.getWidth(),\n            height: api.getHeight()\n        }\n    );\n}\n\nfunction layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations) {\n    computeNodeBreadths(nodes, nodeWidth, width);\n    computeNodeDepths(nodes, edges, height, nodeGap, iterations);\n    computeEdgeDepths(nodes);\n}\n\n/**\n * Compute the value of each node by summing the associated edge's value\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n */\nfunction computeNodeValues(nodes) {\n    each$1(nodes, function (node) {\n        var value1 = sum(node.outEdges, getEdgeValue);\n        var value2 = sum(node.inEdges, getEdgeValue);\n        var value = Math.max(value1, value2);\n        node.setLayout({value: value}, true);\n    });\n}\n\n/**\n * Compute the x-position for each node\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param  {number} nodeWidth  the dx of the node\n * @param  {number} width  the whole width of the area to draw the view\n */\nfunction computeNodeBreadths(nodes, nodeWidth, width) {\n    var remainNodes = nodes;\n    var nextNode = null;\n    var x = 0;\n    var kx = 0;\n\n    while (remainNodes.length) {\n        nextNode = [];\n        for (var i = 0, len = remainNodes.length; i < len; i++) {\n            var node = remainNodes[i];\n            node.setLayout({x: x}, true);\n            node.setLayout({dx: nodeWidth}, true);\n            for (var j = 0, lenj = node.outEdges.length; j < lenj; j++) {\n                nextNode.push(node.outEdges[j].node2);\n            }\n        }\n        remainNodes = nextNode;\n        ++x;\n    }\n\n    moveSinksRight(nodes, x);\n    kx = (width - nodeWidth) / (x - 1);\n\n    scaleNodeBreadths(nodes, kx);\n}\n\n/**\n * All the node without outEgdes are assigned maximum x-position and\n *     be aligned in the last column.\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param {number} x  value (x-1) use to assign to node without outEdges\n *     as x-position\n */\nfunction moveSinksRight(nodes, x) {\n    each$1(nodes, function (node) {\n        if (!node.outEdges.length) {\n            node.setLayout({x: x - 1}, true);\n        }\n    });\n}\n\n/**\n * Scale node x-position to the width\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param {number} kx   multiple used to scale nodes\n */\nfunction scaleNodeBreadths(nodes, kx) {\n    each$1(nodes, function (node) {\n        var nodeX = node.getLayout().x * kx;\n        node.setLayout({x: nodeX}, true);\n    });\n}\n\n/**\n * Using Gauss-Seidel iterations method to compute the node depth(y-position)\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param {module:echarts/data/Graph~Edge} edges  edge of sankey view\n * @param {number} height  the whole height of the area to draw the view\n * @param {number} nodeGap  the vertical distance between two nodes\n *     in the same column.\n * @param {number} iterations  the number of iterations for the algorithm\n */\nfunction computeNodeDepths(nodes, edges, height, nodeGap, iterations) {\n    var nodesByBreadth = nest()\n        .key(function (d) {\n            return d.getLayout().x;\n        })\n        .sortKeys(ascending)\n        .entries(nodes)\n        .map(function (d) {\n            return d.values;\n        });\n\n    initializeNodeDepth(nodes, nodesByBreadth, edges, height, nodeGap);\n    resolveCollisions(nodesByBreadth, nodeGap, height);\n\n    for (var alpha = 1; iterations > 0; iterations--) {\n        // 0.99 is a experience parameter, ensure that each iterations of\n        // changes as small as possible.\n        alpha *= 0.99;\n        relaxRightToLeft(nodesByBreadth, alpha);\n        resolveCollisions(nodesByBreadth, nodeGap, height);\n        relaxLeftToRight(nodesByBreadth, alpha);\n        resolveCollisions(nodesByBreadth, nodeGap, height);\n    }\n}\n\n/**\n * Compute the original y-position for each node\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the nodes x-position.\n * @param {module:echarts/data/Graph~Edge} edges  edge of sankey view\n * @param {number} height  the whole height of the area to draw the view\n * @param {number} nodeGap  the vertical distance between two nodes\n */\nfunction initializeNodeDepth(nodes, nodesByBreadth, edges, height, nodeGap) {\n    var kyArray = [];\n    each$1(nodesByBreadth, function (nodes) {\n        var n = nodes.length;\n        var sum = 0;\n        each$1(nodes, function (node) {\n            sum += node.getLayout().value;\n        });\n        var ky = (height - (n - 1) * nodeGap) / sum;\n        kyArray.push(ky);\n    });\n\n    kyArray.sort(function (a, b) {\n        return a - b;\n    });\n    var ky0 = kyArray[0];\n\n    each$1(nodesByBreadth, function (nodes) {\n        each$1(nodes, function (node, i) {\n            node.setLayout({y: i}, true);\n            var nodeDy = node.getLayout().value * ky0;\n            node.setLayout({dy: nodeDy}, true);\n        });\n    });\n\n    each$1(edges, function (edge) {\n        var edgeDy = +edge.getValue() * ky0;\n        edge.setLayout({dy: edgeDy}, true);\n    });\n}\n\n/**\n * Resolve the collision of initialized depth (y-position)\n *\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the nodes x-position.\n * @param {number} nodeGap  the vertical distance between two nodes\n * @param {number} height  the whole height of the area to draw the view\n */\nfunction resolveCollisions(nodesByBreadth, nodeGap, height) {\n    each$1(nodesByBreadth, function (nodes) {\n        var node;\n        var dy;\n        var y0 = 0;\n        var n = nodes.length;\n        var i;\n\n        nodes.sort(ascendingDepth);\n\n        for (i = 0; i < n; i++) {\n            node = nodes[i];\n            dy = y0 - node.getLayout().y;\n            if (dy > 0) {\n                var nodeY = node.getLayout().y + dy;\n                node.setLayout({y: nodeY}, true);\n            }\n            y0 = node.getLayout().y + node.getLayout().dy + nodeGap;\n        }\n\n        // if the bottommost node goes outside the bounds, push it back up\n        dy = y0 - nodeGap - height;\n        if (dy > 0) {\n            var nodeY = node.getLayout().y - dy;\n            node.setLayout({y: nodeY}, true);\n            y0 = node.getLayout().y;\n            for (i = n - 2; i >= 0; --i) {\n                node = nodes[i];\n                dy = node.getLayout().y + node.getLayout().dy + nodeGap - y0;\n                if (dy > 0) {\n                    nodeY = node.getLayout().y - dy;\n                    node.setLayout({y: nodeY}, true);\n                }\n                y0 = node.getLayout().y;\n            }\n        }\n    });\n}\n\n/**\n * Change the y-position of the nodes, except most the right side nodes\n *\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the node x-position.\n * @param {number} alpha  parameter used to adjust the nodes y-position\n */\nfunction relaxRightToLeft(nodesByBreadth, alpha) {\n    each$1(nodesByBreadth.slice().reverse(), function (nodes) {\n        each$1(nodes, function (node) {\n            if (node.outEdges.length) {\n                var y = sum(node.outEdges, weightedTarget) / sum(node.outEdges, getEdgeValue);\n                var nodeY = node.getLayout().y + (y - center$1(node)) * alpha;\n                node.setLayout({y: nodeY}, true);\n            }\n        });\n    });\n}\n\nfunction weightedTarget(edge) {\n    return center$1(edge.node2) * edge.getValue();\n}\n\n/**\n * Change the y-position of the nodes, except most the left side nodes\n *\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the node x-position.\n * @param {number} alpha  parameter used to adjust the nodes y-position\n */\nfunction relaxLeftToRight(nodesByBreadth, alpha) {\n    each$1(nodesByBreadth, function (nodes) {\n        each$1(nodes, function (node) {\n            if (node.inEdges.length) {\n                var y = sum(node.inEdges, weightedSource) / sum(node.inEdges, getEdgeValue);\n                var nodeY = node.getLayout().y + (y - center$1(node)) * alpha;\n                node.setLayout({y: nodeY}, true);\n            }\n        });\n    });\n}\n\nfunction weightedSource(edge) {\n    return center$1(edge.node1) * edge.getValue();\n}\n\n/**\n * Compute the depth(y-position) of each edge\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n */\nfunction computeEdgeDepths(nodes) {\n    each$1(nodes, function (node) {\n        node.outEdges.sort(ascendingTargetDepth);\n        node.inEdges.sort(ascendingSourceDepth);\n    });\n    each$1(nodes, function (node) {\n        var sy = 0;\n        var ty = 0;\n        each$1(node.outEdges, function (edge) {\n            edge.setLayout({sy: sy}, true);\n            sy += edge.getLayout().dy;\n        });\n        each$1(node.inEdges, function (edge) {\n            edge.setLayout({ty: ty}, true);\n            ty += edge.getLayout().dy;\n        });\n    });\n}\n\nfunction ascendingTargetDepth(a, b) {\n    return a.node2.getLayout().y - b.node2.getLayout().y;\n}\n\nfunction ascendingSourceDepth(a, b) {\n    return a.node1.getLayout().y - b.node1.getLayout().y;\n}\n\nfunction sum(array, f) {\n    var sum = 0;\n    var len = array.length;\n    var i = -1;\n    while (++i < len) {\n        var value = +f.call(array, array[i], i);\n        if (!isNaN(value)) {\n            sum += value;\n        }\n    }\n    return sum;\n}\n\nfunction center$1(node) {\n    return node.getLayout().y + node.getLayout().dy / 2;\n}\n\nfunction ascendingDepth(a, b) {\n    return a.getLayout().y - b.getLayout().y;\n}\n\nfunction ascending(a, b) {\n    return a < b ? -1 : a > b ? 1 : a === b ? 0 : NaN;\n}\n\nfunction getEdgeValue(edge) {\n    return edge.getValue();\n}\n\n/**\n * @file Visual encoding for sankey view\n * @author  Deqing Li(annong035@gmail.com)\n */\n\nvar sankeyVisual = function (ecModel, payload) {\n    ecModel.eachSeriesByType('sankey', function (seriesModel) {\n        var graph = seriesModel.getGraph();\n        var nodes = graph.nodes;\n\n        nodes.sort(function (a, b) {\n            return a.getLayout().value - b.getLayout().value;\n        });\n\n        var minValue = nodes[0].getLayout().value;\n        var maxValue = nodes[nodes.length - 1].getLayout().value;\n\n        each$1(nodes, function (node) {\n            var mapping = new VisualMapping({\n                type: 'color',\n                mappingMethod: 'linear',\n                dataExtent: [minValue, maxValue],\n                visual: seriesModel.get('color')\n            });\n\n            var mapValueToColor = mapping.mapValueToVisual(node.getLayout().value);\n            node.setVisual('color', mapValueToColor);\n            // If set itemStyle.normal.color\n            var itemModel = node.getModel();\n            var customColor = itemModel.get('itemStyle.normal.color');\n            if (customColor != null) {\n                node.setVisual('color', customColor);\n            }\n        });\n\n    });\n};\n\nregisterLayout(sankeyLayout);\nregisterVisual(sankeyVisual);\n\n/**\n * @module echarts/chart/helper/Symbol\n */\n\nvar WhiskerPath = Path.extend({\n\n    type: 'whiskerInBox',\n\n    shape: {},\n\n    buildPath: function (ctx, shape) {\n        for (var i in shape) {\n            if (shape.hasOwnProperty(i) && i.indexOf('ends') === 0) {\n                var pts = shape[i];\n                ctx.moveTo(pts[0][0], pts[0][1]);\n                ctx.lineTo(pts[1][0], pts[1][1]);\n            }\n        }\n    }\n});\n\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/WhiskerBox}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Function} styleUpdater\n * @param {boolean} isInit\n * @extends {module:zrender/graphic/Group}\n */\nfunction WhiskerBox(data, idx, styleUpdater, isInit) {\n    Group.call(this);\n\n    /**\n     * @type {number}\n     * @readOnly\n     */\n    this.bodyIndex;\n\n    /**\n     * @type {number}\n     * @readOnly\n     */\n    this.whiskerIndex;\n\n    /**\n     * @type {Function}\n     */\n    this.styleUpdater = styleUpdater;\n\n    this._createContent(data, idx, isInit);\n\n    this.updateData(data, idx, isInit);\n\n    /**\n     * Last series model.\n     * @type {module:echarts/model/Series}\n     */\n    this._seriesModel;\n}\n\nvar whiskerBoxProto = WhiskerBox.prototype;\n\nwhiskerBoxProto._createContent = function (data, idx, isInit) {\n    var itemLayout = data.getItemLayout(idx);\n    var constDim = itemLayout.chartLayout === 'horizontal' ? 1 : 0;\n    var count = 0;\n\n    // Whisker element.\n    this.add(new Polygon({\n        shape: {\n            points: isInit\n                ? transInit(itemLayout.bodyEnds, constDim, itemLayout)\n                : itemLayout.bodyEnds\n        },\n        style: {strokeNoScale: true},\n        z2: 100\n    }));\n    this.bodyIndex = count++;\n\n    // Box element.\n    var whiskerEnds = map(itemLayout.whiskerEnds, function (ends) {\n        return isInit ? transInit(ends, constDim, itemLayout) : ends;\n    });\n    this.add(new WhiskerPath({\n        shape: makeWhiskerEndsShape(whiskerEnds),\n        style: {strokeNoScale: true},\n        z2: 100\n    }));\n    this.whiskerIndex = count++;\n};\n\nfunction transInit(points, dim, itemLayout) {\n    return map(points, function (point) {\n        point = point.slice();\n        point[dim] = itemLayout.initBaseline;\n        return point;\n    });\n}\n\nfunction makeWhiskerEndsShape(whiskerEnds) {\n    // zr animation only support 2-dim array.\n    var shape = {};\n    each$1(whiskerEnds, function (ends, i) {\n        shape['ends' + i] = ends;\n    });\n    return shape;\n}\n\n/**\n * Update symbol properties\n * @param  {module:echarts/data/List} data\n * @param  {number} idx\n */\nwhiskerBoxProto.updateData = function (data, idx, isInit) {\n    var seriesModel = this._seriesModel = data.hostModel;\n    var itemLayout = data.getItemLayout(idx);\n    var updateMethod = graphic[isInit ? 'initProps' : 'updateProps'];\n    // this.childAt(this.bodyIndex).stopAnimation(true);\n    // this.childAt(this.whiskerIndex).stopAnimation(true);\n    updateMethod(\n        this.childAt(this.bodyIndex),\n        {shape: {points: itemLayout.bodyEnds}},\n        seriesModel, idx\n    );\n    updateMethod(\n        this.childAt(this.whiskerIndex),\n        {shape: makeWhiskerEndsShape(itemLayout.whiskerEnds)},\n        seriesModel, idx\n    );\n\n    this.styleUpdater.call(null, this, data, idx);\n};\n\ninherits(WhiskerBox, Group);\n\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/WhiskerBoxDraw\n */\nfunction WhiskerBoxDraw(styleUpdater) {\n    this.group = new Group();\n    this.styleUpdater = styleUpdater;\n}\n\nvar whiskerBoxDrawProto = WhiskerBoxDraw.prototype;\n\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n */\nwhiskerBoxDrawProto.updateData = function (data) {\n    var group = this.group;\n    var oldData = this._data;\n    var styleUpdater = this.styleUpdater;\n\n    data.diff(oldData)\n        .add(function (newIdx) {\n            if (data.hasValue(newIdx)) {\n                var symbolEl = new WhiskerBox(data, newIdx, styleUpdater, true);\n                data.setItemGraphicEl(newIdx, symbolEl);\n                group.add(symbolEl);\n            }\n        })\n        .update(function (newIdx, oldIdx) {\n            var symbolEl = oldData.getItemGraphicEl(oldIdx);\n\n            // Empty data\n            if (!data.hasValue(newIdx)) {\n                group.remove(symbolEl);\n                return;\n            }\n\n            if (!symbolEl) {\n                symbolEl = new WhiskerBox(data, newIdx, styleUpdater);\n            }\n            else {\n                symbolEl.updateData(data, newIdx);\n            }\n\n            // Add back\n            group.add(symbolEl);\n\n            data.setItemGraphicEl(newIdx, symbolEl);\n        })\n        .remove(function (oldIdx) {\n            var el = oldData.getItemGraphicEl(oldIdx);\n            el && group.remove(el);\n        })\n        .execute();\n\n    this._data = data;\n};\n\n/**\n * Remove symbols.\n * @param {module:echarts/data/List} data\n */\nwhiskerBoxDrawProto.remove = function () {\n    var group = this.group;\n    var data = this._data;\n    this._data = null;\n    data && data.eachItemGraphicEl(function (el) {\n        el && group.remove(el);\n    });\n};\n\nvar seriesModelMixin = {\n\n    /**\n     * @private\n     * @type {string}\n     */\n    _baseAxisDim: null,\n\n    /**\n     * @override\n     */\n    getInitialData: function (option, ecModel) {\n        // When both types of xAxis and yAxis are 'value', layout is\n        // needed to be specified by user. Otherwise, layout can be\n        // judged by which axis is category.\n\n        var categories;\n\n        var xAxisModel = ecModel.getComponent('xAxis', this.get('xAxisIndex'));\n        var yAxisModel = ecModel.getComponent('yAxis', this.get('yAxisIndex'));\n        var xAxisType = xAxisModel.get('type');\n        var yAxisType = yAxisModel.get('type');\n        var addOrdinal;\n\n        // FIXME\n        // \n\n        if (xAxisType === 'category') {\n            option.layout = 'horizontal';\n            categories = xAxisModel.getCategories();\n            addOrdinal = true;\n        }\n        else if (yAxisType  === 'category') {\n            option.layout = 'vertical';\n            categories = yAxisModel.getCategories();\n            addOrdinal = true;\n        }\n        else {\n            option.layout = option.layout || 'horizontal';\n        }\n\n        var coordDims = ['x', 'y'];\n        var baseAxisDimIndex = option.layout === 'horizontal' ? 0 : 1;\n        var baseAxisDim = this._baseAxisDim = coordDims[baseAxisDimIndex];\n        var otherAxisDim = coordDims[1 - baseAxisDimIndex];\n        var data = option.data;\n\n        addOrdinal && each$1(data, function (item, index) {\n            if (item.value && isArray(item.value)) {\n                item.value.unshift(index);\n            } else {\n                isArray(item) && item.unshift(index);\n            }\n        });\n\n        var defaultValueDimensions = this.defaultValueDimensions;\n        var dimensions = [{\n            name: baseAxisDim,\n            otherDims: {\n                tooltip: false\n            },\n            dimsDef: ['base']\n        }, {\n            name: otherAxisDim,\n            dimsDef: defaultValueDimensions.slice()\n        }];\n\n        dimensions = completeDimensions(dimensions, data, {\n            encodeDef: this.get('encode'),\n            dimsDef: this.get('dimensions'),\n            // Consider empty data entry.\n            dimCount: defaultValueDimensions.length + 1\n        });\n\n        var list = new List(dimensions, this);\n        list.initData(data, categories ? categories.slice() : null);\n\n        return list;\n    },\n\n    /**\n     * If horizontal, base axis is x, otherwise y.\n     * @override\n     */\n    getBaseAxis: function () {\n        var dim = this._baseAxisDim;\n        return this.ecModel.getComponent(dim + 'Axis', this.get(dim + 'AxisIndex')).axis;\n    }\n\n};\n\nvar viewMixin = {\n\n    init: function () {\n        /**\n         * Old data.\n         * @private\n         * @type {module:echarts/chart/helper/WhiskerBoxDraw}\n         */\n        var whiskerBoxDraw = this._whiskerBoxDraw = new WhiskerBoxDraw(\n            this.getStyleUpdater()\n        );\n        this.group.add(whiskerBoxDraw.group);\n    },\n\n    render: function (seriesModel, ecModel, api) {\n        this._whiskerBoxDraw.updateData(seriesModel.getData());\n    },\n\n    remove: function (ecModel) {\n        this._whiskerBoxDraw.remove();\n    }\n};\n\nvar BoxplotSeries = SeriesModel.extend({\n\n    type: 'series.boxplot',\n\n    dependencies: ['xAxis', 'yAxis', 'grid'],\n\n    // TODO\n    // box width represents group size, so dimension should have 'size'.\n\n    /**\n     * @see <https://en.wikipedia.org/wiki/Box_plot>\n     * The meanings of 'min' and 'max' depend on user,\n     * and echarts do not need to know it.\n     * @readOnly\n     */\n    defaultValueDimensions: ['min', 'Q1', 'median', 'Q3', 'max'],\n\n    /**\n     * @type {Array.<string>}\n     * @readOnly\n     */\n    dimensions: null,\n\n    /**\n     * @override\n     */\n    defaultOption: {\n        zlevel: 0,                  // \n        z: 2,                       // \n        coordinateSystem: 'cartesian2d',\n        legendHoverLink: true,\n\n        hoverAnimation: true,\n\n        // xAxisIndex: 0,\n        // yAxisIndex: 0,\n\n        layout: null,               // 'horizontal' or 'vertical'\n        boxWidth: [7, 50],       // [min, max] can be percent of band width.\n\n        itemStyle: {\n            normal: {\n                color: '#fff',\n                borderWidth: 1\n            },\n            emphasis: {\n                borderWidth: 2,\n                shadowBlur: 5,\n                shadowOffsetX: 2,\n                shadowOffsetY: 2,\n                shadowColor: 'rgba(0,0,0,0.4)'\n            }\n        },\n\n        animationEasing: 'elasticOut',\n        animationDuration: 800\n    }\n});\n\nmixin(BoxplotSeries, seriesModelMixin, true);\n\nvar BoxplotView = Chart.extend({\n\n    type: 'boxplot',\n\n    getStyleUpdater: function () {\n        return updateStyle$1;\n    },\n\n    dispose: noop\n});\n\nmixin(BoxplotView, viewMixin, true);\n\n// Update common properties\nvar normalStyleAccessPath$1 = ['itemStyle', 'normal'];\nvar emphasisStyleAccessPath$1 = ['itemStyle', 'emphasis'];\n\nfunction updateStyle$1(itemGroup, data, idx) {\n    var itemModel = data.getItemModel(idx);\n    var normalItemStyleModel = itemModel.getModel(normalStyleAccessPath$1);\n    var borderColor = data.getItemVisual(idx, 'color');\n\n    // Exclude borderColor.\n    var itemStyle = normalItemStyleModel.getItemStyle(['borderColor']);\n\n    var whiskerEl = itemGroup.childAt(itemGroup.whiskerIndex);\n    whiskerEl.style.set(itemStyle);\n    whiskerEl.style.stroke = borderColor;\n    whiskerEl.dirty();\n\n    var bodyEl = itemGroup.childAt(itemGroup.bodyIndex);\n    bodyEl.style.set(itemStyle);\n    bodyEl.style.stroke = borderColor;\n    bodyEl.dirty();\n\n    var hoverStyle = itemModel.getModel(emphasisStyleAccessPath$1).getItemStyle();\n    setHoverStyle(itemGroup, hoverStyle);\n}\n\nvar borderColorQuery = ['itemStyle', 'normal', 'borderColor'];\n\nvar boxplotVisual = function (ecModel, api) {\n\n    var globalColors = ecModel.get('color');\n\n    ecModel.eachRawSeriesByType('boxplot', function (seriesModel) {\n\n        var defaulColor = globalColors[seriesModel.seriesIndex % globalColors.length];\n        var data = seriesModel.getData();\n\n        data.setVisual({\n            legendSymbol: 'roundRect',\n            // Use name 'color' but not 'borderColor' for legend usage and\n            // visual coding from other component like dataRange.\n            color: seriesModel.get(borderColorQuery) || defaulColor\n        });\n\n        // Only visible series has each data be visual encoded\n        if (!ecModel.isSeriesFiltered(seriesModel)) {\n            data.each(function (idx) {\n                var itemModel = data.getItemModel(idx);\n                data.setItemVisual(\n                    idx,\n                    {color: itemModel.get(borderColorQuery, true)}\n                );\n            });\n        }\n    });\n\n};\n\nvar each$16 = each$1;\n\nvar boxplotLayout = function (ecModel) {\n\n    var groupResult = groupSeriesByAxis(ecModel);\n\n    each$16(groupResult, function (groupItem) {\n        var seriesModels = groupItem.seriesModels;\n\n        if (!seriesModels.length) {\n            return;\n        }\n\n        calculateBase(groupItem);\n\n        each$16(seriesModels, function (seriesModel, idx) {\n            layoutSingleSeries(\n                seriesModel,\n                groupItem.boxOffsetList[idx],\n                groupItem.boxWidthList[idx]\n            );\n        });\n    });\n};\n\n/**\n * Group series by axis.\n */\nfunction groupSeriesByAxis(ecModel) {\n    var result = [];\n    var axisList = [];\n\n    ecModel.eachSeriesByType('boxplot', function (seriesModel) {\n        var baseAxis = seriesModel.getBaseAxis();\n        var idx = indexOf(axisList, baseAxis);\n\n        if (idx < 0) {\n            idx = axisList.length;\n            axisList[idx] = baseAxis;\n            result[idx] = {axis: baseAxis, seriesModels: []};\n        }\n\n        result[idx].seriesModels.push(seriesModel);\n    });\n\n    return result;\n}\n\n/**\n * Calculate offset and box width for each series.\n */\nfunction calculateBase(groupItem) {\n    var extent;\n    var baseAxis = groupItem.axis;\n    var seriesModels = groupItem.seriesModels;\n    var seriesCount = seriesModels.length;\n\n    var boxWidthList = groupItem.boxWidthList = [];\n    var boxOffsetList = groupItem.boxOffsetList = [];\n    var boundList = [];\n\n    var bandWidth;\n    if (baseAxis.type === 'category') {\n        bandWidth = baseAxis.getBandWidth();\n    }\n    else {\n        var maxDataCount = 0;\n        each$16(seriesModels, function (seriesModel) {\n            maxDataCount = Math.max(maxDataCount, seriesModel.getData().count());\n        });\n        extent = baseAxis.getExtent(),\n        Math.abs(extent[1] - extent[0]) / maxDataCount;\n    }\n\n    each$16(seriesModels, function (seriesModel) {\n        var boxWidthBound = seriesModel.get('boxWidth');\n        if (!isArray(boxWidthBound)) {\n            boxWidthBound = [boxWidthBound, boxWidthBound];\n        }\n        boundList.push([\n            parsePercent$1(boxWidthBound[0], bandWidth) || 0,\n            parsePercent$1(boxWidthBound[1], bandWidth) || 0\n        ]);\n    });\n\n    var availableWidth = bandWidth * 0.8 - 2;\n    var boxGap = availableWidth / seriesCount * 0.3;\n    var boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount;\n    var base = boxWidth / 2 - availableWidth / 2;\n\n    each$16(seriesModels, function (seriesModel, idx) {\n        boxOffsetList.push(base);\n        base += boxGap + boxWidth;\n\n        boxWidthList.push(\n            Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1])\n        );\n    });\n}\n\n/**\n * Calculate points location for each series.\n */\nfunction layoutSingleSeries(seriesModel, offset, boxWidth) {\n    var coordSys = seriesModel.coordinateSystem;\n    var data = seriesModel.getData();\n    var halfWidth = boxWidth / 2;\n    var chartLayout = seriesModel.get('layout');\n    var variableDim = chartLayout === 'horizontal' ? 0 : 1;\n    var constDim = 1 - variableDim;\n    var coordDims = ['x', 'y'];\n    var vDims = [];\n    var cDim;\n\n    each$1(data.dimensions, function (dimName) {\n        var dimInfo = data.getDimensionInfo(dimName);\n        var coordDim = dimInfo.coordDim;\n        if (coordDim === coordDims[constDim]) {\n            vDims.push(dimName);\n        }\n        else if (coordDim === coordDims[variableDim]) {\n            cDim = dimName;\n        }\n    });\n\n    if (cDim == null || vDims.length < 5) {\n        return;\n    }\n\n    data.each([cDim].concat(vDims), function () {\n        var args = arguments;\n        var axisDimVal = args[0];\n        var idx = args[vDims.length + 1];\n\n        var median = getPoint(args[3]);\n        var end1 = getPoint(args[1]);\n        var end5 = getPoint(args[5]);\n        var whiskerEnds = [\n            [end1, getPoint(args[2])],\n            [end5, getPoint(args[4])]\n        ];\n        layEndLine(end1);\n        layEndLine(end5);\n        layEndLine(median);\n\n        var bodyEnds = [];\n        addBodyEnd(whiskerEnds[0][1], 0);\n        addBodyEnd(whiskerEnds[1][1], 1);\n\n        data.setItemLayout(idx, {\n            chartLayout: chartLayout,\n            initBaseline: median[constDim],\n            median: median,\n            bodyEnds: bodyEnds,\n            whiskerEnds: whiskerEnds\n        });\n\n        function getPoint(val) {\n            var p = [];\n            p[variableDim] = axisDimVal;\n            p[constDim] = val;\n            var point;\n            if (isNaN(axisDimVal) || isNaN(val)) {\n                point = [NaN, NaN];\n            }\n            else {\n                point = coordSys.dataToPoint(p);\n                point[variableDim] += offset;\n            }\n            return point;\n        }\n\n        function addBodyEnd(point, start) {\n            var point1 = point.slice();\n            var point2 = point.slice();\n            point1[variableDim] += halfWidth;\n            point2[variableDim] -= halfWidth;\n            start\n                ? bodyEnds.push(point1, point2)\n                : bodyEnds.push(point2, point1);\n        }\n\n        function layEndLine(endCenter) {\n            var line = [endCenter.slice(), endCenter.slice()];\n            line[0][variableDim] -= halfWidth;\n            line[1][variableDim] += halfWidth;\n            whiskerEnds.push(line);\n        }\n    });\n}\n\nregisterVisual(boxplotVisual);\nregisterLayout(boxplotLayout);\n\nvar CandlestickSeries = SeriesModel.extend({\n\n    type: 'series.candlestick',\n\n    dependencies: ['xAxis', 'yAxis', 'grid'],\n\n    /**\n     * @readOnly\n     */\n    defaultValueDimensions: ['open', 'close', 'lowest', 'highest'],\n\n    /**\n     * @type {Array.<string>}\n     * @readOnly\n     */\n    dimensions: null,\n\n    /**\n     * @override\n     */\n    defaultOption: {\n        zlevel: 0,                  // \n        z: 2,                       // \n        coordinateSystem: 'cartesian2d',\n        legendHoverLink: true,\n\n        hoverAnimation: true,\n\n        // xAxisIndex: 0,\n        // yAxisIndex: 0,\n\n        layout: null, // 'horizontal' or 'vertical'\n\n        itemStyle: {\n            normal: {\n                color: '#c23531', //  positive\n                color0: '#314656', //  negative     '#c23531', '#314656'\n                borderWidth: 1,\n                // FIXME\n                // ec2lineStyle.color  lineStyle.color0\n                borderColor: '#c23531',\n                borderColor0: '#314656'\n            },\n            emphasis: {\n                borderWidth: 2\n            }\n        },\n\n        barMaxWidth: null,\n        barMinWidth: null,\n        barWidth: null,\n\n        animationUpdate: false,\n        animationEasing: 'linear',\n        animationDuration: 300\n    },\n\n    /**\n     * Get dimension for shadow in dataZoom\n     * @return {string} dimension name\n     */\n    getShadowDim: function () {\n        return 'open';\n    },\n\n    brushSelector: function (dataIndex, data, selectors) {\n        var itemLayout = data.getItemLayout(dataIndex);\n        return selectors.rect(itemLayout.brushRect);\n    }\n\n});\n\nmixin(CandlestickSeries, seriesModelMixin, true);\n\nvar CandlestickView = Chart.extend({\n\n    type: 'candlestick',\n\n    getStyleUpdater: function () {\n        return updateStyle$2;\n    },\n\n    dispose: noop\n});\n\nmixin(CandlestickView, viewMixin, true);\n\n// Update common properties\nvar normalStyleAccessPath$2 = ['itemStyle', 'normal'];\nvar emphasisStyleAccessPath$2 = ['itemStyle', 'emphasis'];\n\nfunction updateStyle$2(itemGroup, data, idx) {\n    var itemModel = data.getItemModel(idx);\n    var normalItemStyleModel = itemModel.getModel(normalStyleAccessPath$2);\n    var color = data.getItemVisual(idx, 'color');\n    var borderColor = data.getItemVisual(idx, 'borderColor') || color;\n\n    // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n    var itemStyle = normalItemStyleModel.getItemStyle(\n        ['color', 'color0', 'borderColor', 'borderColor0']\n    );\n\n    var whiskerEl = itemGroup.childAt(itemGroup.whiskerIndex);\n    whiskerEl.useStyle(itemStyle);\n    whiskerEl.style.stroke = borderColor;\n\n    var bodyEl = itemGroup.childAt(itemGroup.bodyIndex);\n    bodyEl.useStyle(itemStyle);\n    bodyEl.style.fill = color;\n    bodyEl.style.stroke = borderColor;\n\n    var hoverStyle = itemModel.getModel(emphasisStyleAccessPath$2).getItemStyle();\n    setHoverStyle(itemGroup, hoverStyle);\n}\n\nvar preprocessor = function (option) {\n    if (!option || !isArray(option.series)) {\n        return;\n    }\n\n    // Translate 'k' to 'candlestick'.\n    each$1(option.series, function (seriesItem) {\n        if (isObject(seriesItem) && seriesItem.type === 'k') {\n            seriesItem.type = 'candlestick';\n        }\n    });\n};\n\nvar positiveBorderColorQuery = ['itemStyle', 'normal', 'borderColor'];\nvar negativeBorderColorQuery = ['itemStyle', 'normal', 'borderColor0'];\nvar positiveColorQuery = ['itemStyle', 'normal', 'color'];\nvar negativeColorQuery = ['itemStyle', 'normal', 'color0'];\n\nvar candlestickVisual = function (ecModel, api) {\n\n    ecModel.eachRawSeriesByType('candlestick', function (seriesModel) {\n\n        var data = seriesModel.getData();\n\n        data.setVisual({\n            legendSymbol: 'roundRect'\n        });\n\n        // Only visible series has each data be visual encoded\n        if (!ecModel.isSeriesFiltered(seriesModel)) {\n            data.each(function (idx) {\n                var itemModel = data.getItemModel(idx);\n                var sign = data.getItemLayout(idx).sign;\n\n                data.setItemVisual(\n                    idx,\n                    {\n                        color: itemModel.get(\n                            sign > 0 ? positiveColorQuery : negativeColorQuery\n                        ),\n                        borderColor: itemModel.get(\n                            sign > 0 ? positiveBorderColorQuery : negativeBorderColorQuery\n                        )\n                    }\n                );\n            });\n        }\n    });\n\n};\n\nvar retrieve2$1 = retrieve2;\n\nvar candlestickLayout = function (ecModel) {\n\n    ecModel.eachSeriesByType('candlestick', function (seriesModel) {\n\n        var coordSys = seriesModel.coordinateSystem;\n        var data = seriesModel.getData();\n        var candleWidth = calculateCandleWidth(seriesModel, data);\n        var chartLayout = seriesModel.get('layout');\n        var variableDim = chartLayout === 'horizontal' ? 0 : 1;\n        var constDim = 1 - variableDim;\n        var coordDims = ['x', 'y'];\n        var vDims = [];\n        var cDim;\n\n        each$1(data.dimensions, function (dimName) {\n            var dimInfo = data.getDimensionInfo(dimName);\n            var coordDim = dimInfo.coordDim;\n            if (coordDim === coordDims[constDim]) {\n                vDims.push(dimName);\n            }\n            else if (coordDim === coordDims[variableDim]) {\n                cDim = dimName;\n            }\n        });\n\n        if (cDim == null || vDims.length < 4) {\n            return;\n        }\n\n        var dataIndex = 0;\n\n        data.each([cDim].concat(vDims), function () {\n            var args = arguments;\n            var axisDimVal = args[0];\n            var idx = args[vDims.length + 1];\n\n            var openVal = args[1];\n            var closeVal = args[2];\n            var lowestVal = args[3];\n            var highestVal = args[4];\n\n            var ocLow = Math.min(openVal, closeVal);\n            var ocHigh = Math.max(openVal, closeVal);\n\n            var ocLowPoint = getPoint(ocLow);\n            var ocHighPoint = getPoint(ocHigh);\n            var lowestPoint = getPoint(lowestVal);\n            var highestPoint = getPoint(highestVal);\n\n            var whiskerEnds = [\n                [\n                    subPixelOptimizePoint(highestPoint),\n                    subPixelOptimizePoint(ocHighPoint)\n                ],\n                [\n                    subPixelOptimizePoint(lowestPoint),\n                    subPixelOptimizePoint(ocLowPoint)\n                ]\n            ];\n\n            var bodyEnds = [];\n            addBodyEnd(ocHighPoint, 0);\n            addBodyEnd(ocLowPoint, 1);\n\n            var sign;\n            if (openVal > closeVal) {\n                sign = -1;\n            }\n            else if (openVal < closeVal) {\n                sign = 1;\n            }\n            else {\n                // If close === open, compare with close of last record\n                if (dataIndex > 0) {\n                    sign = data.getItemModel(dataIndex - 1).get()[2]\n                        <= closeVal\n                            ? 1\n                            : -1;\n                }\n                else {\n                    // No record of previous, set to be positive\n                    sign = 1;\n                }\n            }\n\n            data.setItemLayout(idx, {\n                chartLayout: chartLayout,\n                sign: sign,\n                initBaseline: openVal > closeVal\n                    ? ocHighPoint[constDim] : ocLowPoint[constDim], // open point.\n                bodyEnds: bodyEnds,\n                whiskerEnds: whiskerEnds,\n                brushRect: makeBrushRect()\n            });\n\n            ++dataIndex;\n\n            function getPoint(val) {\n                var p = [];\n                p[variableDim] = axisDimVal;\n                p[constDim] = val;\n                return (isNaN(axisDimVal) || isNaN(val))\n                    ? [NaN, NaN]\n                    : coordSys.dataToPoint(p);\n            }\n\n            function addBodyEnd(point, start) {\n                var point1 = point.slice();\n                var point2 = point.slice();\n\n                point1[variableDim] = subPixelOptimize(\n                    point1[variableDim] + candleWidth / 2, 1, false\n                );\n                point2[variableDim] = subPixelOptimize(\n                    point2[variableDim] - candleWidth / 2, 1, true\n                );\n\n                start\n                    ? bodyEnds.push(point1, point2)\n                    : bodyEnds.push(point2, point1);\n            }\n\n            function makeBrushRect() {\n                var pmin = getPoint(Math.min(openVal, closeVal, lowestVal, highestVal));\n                var pmax = getPoint(Math.max(openVal, closeVal, lowestVal, highestVal));\n\n                pmin[variableDim] -= candleWidth / 2;\n                pmax[variableDim] -= candleWidth / 2;\n\n                return {\n                    x: pmin[0],\n                    y: pmin[1],\n                    width: constDim ? candleWidth : pmax[0] - pmin[0],\n                    height: constDim ? pmax[1] - pmin[1] : candleWidth\n                };\n            }\n\n            function subPixelOptimizePoint(point) {\n                point[variableDim] = subPixelOptimize(point[variableDim], 1);\n                return point;\n            }\n\n        }, true);\n    });\n};\n\nfunction calculateCandleWidth(seriesModel, data) {\n    var baseAxis = seriesModel.getBaseAxis();\n    var extent;\n\n    var bandWidth = baseAxis.type === 'category'\n        ? baseAxis.getBandWidth()\n        : (\n            extent = baseAxis.getExtent(),\n            Math.abs(extent[1] - extent[0]) / data.count()\n        );\n\n    var barMaxWidth = parsePercent$1(\n        retrieve2$1(seriesModel.get('barMaxWidth'), bandWidth),\n        bandWidth\n    );\n    var barMinWidth = parsePercent$1(\n        retrieve2$1(seriesModel.get('barMinWidth'), 1),\n        bandWidth\n    );\n    var barWidth = seriesModel.get('barWidth');\n    return barWidth != null\n        ? parsePercent$1(barWidth, bandWidth)\n        // Put max outer to ensure bar visible in spite of overlap.\n        : Math.max(Math.min(bandWidth / 2, barMaxWidth), barMinWidth);\n}\n\nregisterPreprocessor(preprocessor);\nregisterVisual(candlestickVisual);\nregisterLayout(candlestickLayout);\n\nSeriesModel.extend({\n\n    type: 'series.effectScatter',\n\n    dependencies: ['grid', 'polar'],\n\n    getInitialData: function (option, ecModel) {\n        var list = createListFromArray(option.data, this, ecModel);\n        return list;\n    },\n\n    brushSelector: 'point',\n\n    defaultOption: {\n        coordinateSystem: 'cartesian2d',\n        zlevel: 0,\n        z: 2,\n        legendHoverLink: true,\n\n        effectType: 'ripple',\n\n        progressive: 0,\n\n        // When to show the effect, option: 'render'|'emphasis'\n        showEffectOn: 'render',\n\n        // Ripple effect config\n        rippleEffect: {\n            period: 4,\n            // Scale of ripple\n            scale: 2.5,\n            // Brush type can be fill or stroke\n            brushType: 'fill'\n        },\n\n        // Cartesian coordinate system\n        // xAxisIndex: 0,\n        // yAxisIndex: 0,\n\n        // Polar coordinate system\n        // polarIndex: 0,\n\n        // Geo coordinate system\n        // geoIndex: 0,\n\n        // symbol: null,        // \n        symbolSize: 10          // symbolSize * 2\n        // symbolRotate: null,  // \n\n        // large: false,\n        // Available when large is true\n        // largeThreshold: 2000,\n\n        // itemStyle: {\n        //     normal: {\n        //         opacity: 1\n        //     }\n        // }\n    }\n\n});\n\n/**\n * Symbol with ripple effect\n * @module echarts/chart/helper/EffectSymbol\n */\n\nvar EFFECT_RIPPLE_NUMBER = 3;\n\nfunction normalizeSymbolSize$1(symbolSize) {\n    if (!isArray(symbolSize)) {\n        symbolSize = [+symbolSize, +symbolSize];\n    }\n    return symbolSize;\n}\n\nfunction updateRipplePath(rippleGroup, effectCfg) {\n    rippleGroup.eachChild(function (ripplePath) {\n        ripplePath.attr({\n            z: effectCfg.z,\n            zlevel: effectCfg.zlevel,\n            style: {\n                stroke: effectCfg.brushType === 'stroke' ? effectCfg.color : null,\n                fill: effectCfg.brushType === 'fill' ? effectCfg.color : null\n            }\n        });\n    });\n}\n/**\n * @constructor\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\nfunction EffectSymbol(data, idx) {\n    Group.call(this);\n\n    var symbol = new SymbolClz$1(data, idx);\n    var rippleGroup = new Group();\n    this.add(symbol);\n    this.add(rippleGroup);\n\n    rippleGroup.beforeUpdate = function () {\n        this.attr(symbol.getScale());\n    };\n    this.updateData(data, idx);\n}\n\nvar effectSymbolProto = EffectSymbol.prototype;\n\neffectSymbolProto.stopEffectAnimation = function () {\n    this.childAt(1).removeAll();\n};\n\neffectSymbolProto.startEffectAnimation = function (effectCfg) {\n    var symbolType = effectCfg.symbolType;\n    var color = effectCfg.color;\n    var rippleGroup = this.childAt(1);\n\n    for (var i = 0; i < EFFECT_RIPPLE_NUMBER; i++) {\n        // var ripplePath = createSymbol(\n        //     symbolType, -0.5, -0.5, 1, 1, color\n        // );\n        // If width/height are set too small (e.g., set to 1) on ios10\n        // and macOS Sierra, a circle stroke become a rect, no matter what\n        // the scale is set. So we set width/height as 2. See #4136.\n        var ripplePath = createSymbol(\n            symbolType, -1, -1, 2, 2, color\n        );\n        ripplePath.attr({\n            style: {\n                strokeNoScale: true\n            },\n            z2: 99,\n            silent: true,\n            scale: [0.5, 0.5]\n        });\n\n        var delay = -i / EFFECT_RIPPLE_NUMBER * effectCfg.period + effectCfg.effectOffset;\n        // TODO Configurable effectCfg.period\n        ripplePath.animate('', true)\n            .when(effectCfg.period, {\n                scale: [effectCfg.rippleScale / 2, effectCfg.rippleScale / 2]\n            })\n            .delay(delay)\n            .start();\n        ripplePath.animateStyle(true)\n            .when(effectCfg.period, {\n                opacity: 0\n            })\n            .delay(delay)\n            .start();\n\n        rippleGroup.add(ripplePath);\n    }\n\n    updateRipplePath(rippleGroup, effectCfg);\n};\n\n/**\n * Update effect symbol\n */\neffectSymbolProto.updateEffectAnimation = function (effectCfg) {\n    var oldEffectCfg = this._effectCfg;\n    var rippleGroup = this.childAt(1);\n\n    // Must reinitialize effect if following configuration changed\n    var DIFFICULT_PROPS = ['symbolType', 'period', 'rippleScale'];\n    for (var i = 0; i < DIFFICULT_PROPS.length; i++) {\n        var propName = DIFFICULT_PROPS[i];\n        if (oldEffectCfg[propName] !== effectCfg[propName]) {\n            this.stopEffectAnimation();\n            this.startEffectAnimation(effectCfg);\n            return;\n        }\n    }\n\n    updateRipplePath(rippleGroup, effectCfg);\n};\n\n/**\n * Highlight symbol\n */\neffectSymbolProto.highlight = function () {\n    this.trigger('emphasis');\n};\n\n/**\n * Downplay symbol\n */\neffectSymbolProto.downplay = function () {\n    this.trigger('normal');\n};\n\n/**\n * Update symbol properties\n * @param  {module:echarts/data/List} data\n * @param  {number} idx\n */\neffectSymbolProto.updateData = function (data, idx) {\n    var seriesModel = data.hostModel;\n\n    this.childAt(0).updateData(data, idx);\n\n    var rippleGroup = this.childAt(1);\n    var itemModel = data.getItemModel(idx);\n    var symbolType = data.getItemVisual(idx, 'symbol');\n    var symbolSize = normalizeSymbolSize$1(data.getItemVisual(idx, 'symbolSize'));\n    var color = data.getItemVisual(idx, 'color');\n\n    rippleGroup.attr('scale', symbolSize);\n\n    rippleGroup.traverse(function (ripplePath) {\n        ripplePath.attr({\n            fill: color\n        });\n    });\n\n    var symbolOffset = itemModel.getShallow('symbolOffset');\n    if (symbolOffset) {\n        var pos = rippleGroup.position;\n        pos[0] = parsePercent$1(symbolOffset[0], symbolSize[0]);\n        pos[1] = parsePercent$1(symbolOffset[1], symbolSize[1]);\n    }\n    rippleGroup.rotation = (itemModel.getShallow('symbolRotate') || 0) * Math.PI / 180 || 0;\n\n    var effectCfg = {};\n\n    effectCfg.showEffectOn = seriesModel.get('showEffectOn');\n    effectCfg.rippleScale = itemModel.get('rippleEffect.scale');\n    effectCfg.brushType = itemModel.get('rippleEffect.brushType');\n    effectCfg.period = itemModel.get('rippleEffect.period') * 1000;\n    effectCfg.effectOffset = idx / data.count();\n    effectCfg.z = itemModel.getShallow('z') || 0;\n    effectCfg.zlevel = itemModel.getShallow('zlevel') || 0;\n    effectCfg.symbolType = symbolType;\n    effectCfg.color = color;\n\n    this.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\n    if (effectCfg.showEffectOn === 'render') {\n        this._effectCfg\n            ? this.updateEffectAnimation(effectCfg)\n            : this.startEffectAnimation(effectCfg);\n\n        this._effectCfg = effectCfg;\n    }\n    else {\n        // Not keep old effect config\n        this._effectCfg = null;\n\n        this.stopEffectAnimation();\n        var symbol = this.childAt(0);\n        var onEmphasis = function () {\n            symbol.highlight();\n            if (effectCfg.showEffectOn !== 'render') {\n                this.startEffectAnimation(effectCfg);\n            }\n        };\n        var onNormal = function () {\n            symbol.downplay();\n            if (effectCfg.showEffectOn !== 'render') {\n                this.stopEffectAnimation();\n            }\n        };\n        this.on('mouseover', onEmphasis, this)\n            .on('mouseout', onNormal, this)\n            .on('emphasis', onEmphasis, this)\n            .on('normal', onNormal, this);\n    }\n\n    this._effectCfg = effectCfg;\n};\n\neffectSymbolProto.fadeOut = function (cb) {\n    this.off('mouseover').off('mouseout').off('emphasis').off('normal');\n    cb && cb();\n};\n\ninherits(EffectSymbol, Group);\n\nextendChartView({\n\n    type: 'effectScatter',\n\n    init: function () {\n        this._symbolDraw = new SymbolDraw(EffectSymbol);\n    },\n\n    render: function (seriesModel, ecModel, api) {\n        var data = seriesModel.getData();\n        var effectSymbolDraw = this._symbolDraw;\n        effectSymbolDraw.updateData(data);\n        this.group.add(effectSymbolDraw.group);\n    },\n\n    updateLayout: function () {\n        this._symbolDraw.updateLayout();\n    },\n\n    remove: function (ecModel, api) {\n        this._symbolDraw && this._symbolDraw.remove(api);\n    },\n\n    dispose: function () {}\n});\n\nregisterVisual(curry(\n    visualSymbol, 'effectScatter', 'circle', null\n));\nregisterLayout(curry(\n    layoutPoints, 'effectScatter'\n));\n\n// Convert [ [{coord: []}, {coord: []}] ]\n// to [ { coords: [[]] } ]\nfunction preprocessOption(seriesOpt) {\n    var data = seriesOpt.data;\n    if (data && data[0] && data[0][0] && data[0][0].coord) {\n        if (__DEV__) {\n            console.warn('Lines data configuration has been changed to'\n                + ' { coords:[[1,2],[2,3]] }');\n        }\n        seriesOpt.data = map(data, function (itemOpt) {\n            var coords = [\n                itemOpt[0].coord, itemOpt[1].coord\n            ];\n            var target = {\n                coords: coords\n            };\n            if (itemOpt[0].name) {\n                target.fromName = itemOpt[0].name;\n            }\n            if (itemOpt[1].name) {\n                target.toName = itemOpt[1].name;\n            }\n            return mergeAll([target, itemOpt[0], itemOpt[1]]);\n        });\n    }\n}\n\nvar LinesSeries = SeriesModel.extend({\n\n    type: 'series.lines',\n\n    dependencies: ['grid', 'polar'],\n\n    visualColorAccessPath: 'lineStyle.normal.color',\n\n    init: function (option) {\n        // Not using preprocessor because mergeOption may not have series.type\n        preprocessOption(option);\n\n        LinesSeries.superApply(this, 'init', arguments);\n    },\n\n    mergeOption: function (option) {\n        preprocessOption(option);\n\n        LinesSeries.superApply(this, 'mergeOption', arguments);\n    },\n\n    getInitialData: function (option, ecModel) {\n        if (__DEV__) {\n            var CoordSys = CoordinateSystemManager.get(option.coordinateSystem);\n            if (!CoordSys) {\n                throw new Error('Unkown coordinate system ' + option.coordinateSystem);\n            }\n        }\n\n        var lineData = new List(['value'], this);\n        lineData.hasItemOption = false;\n        lineData.initData(option.data, [], function (dataItem, dimName, dataIndex, dimIndex) {\n            // dataItem is simply coords\n            if (dataItem instanceof Array) {\n                return NaN;\n            }\n            else {\n                lineData.hasItemOption = true;\n                var value = dataItem.value;\n                if (value != null) {\n                    return value instanceof Array ? value[dimIndex] : value;\n                }\n            }\n        });\n\n        return lineData;\n    },\n\n    formatTooltip: function (dataIndex) {\n        var data = this.getData();\n        var itemModel = data.getItemModel(dataIndex);\n        var name = itemModel.get('name');\n        if (name) {\n            return name;\n        }\n        var fromName = itemModel.get('fromName');\n        var toName = itemModel.get('toName');\n        var html = [];\n        fromName != null && html.push(fromName);\n        toName != null && html.push(toName);\n\n        return encodeHTML(html.join(' > '));\n    },\n\n    defaultOption: {\n        coordinateSystem: 'geo',\n        zlevel: 0,\n        z: 2,\n        legendHoverLink: true,\n\n        hoverAnimation: true,\n        // Cartesian coordinate system\n        xAxisIndex: 0,\n        yAxisIndex: 0,\n\n        symbol: ['none', 'none'],\n        symbolSize: [10, 10],\n        // Geo coordinate system\n        geoIndex: 0,\n\n        effect: {\n            show: false,\n            period: 4,\n            // Animation delay. support callback\n            // delay: 0,\n            // If move with constant speed px/sec\n            // period will be ignored if this property is > 0,\n            constantSpeed: 0,\n            symbol: 'circle',\n            symbolSize: 3,\n            loop: true,\n            // Length of trail, 0 - 1\n            trailLength: 0.2\n            // Same with lineStyle.normal.color\n            // color\n        },\n\n        large: false,\n        // Available when large is true\n        largeThreshold: 2000,\n\n        // If lines are polyline\n        // polyline not support curveness, label, animation\n        polyline: false,\n\n        label: {\n            normal: {\n                show: false,\n                position: 'end'\n                // distance: 5,\n                // formatter: Tooltip.formatter\n            }\n        },\n\n        lineStyle: {\n            normal: {\n                opacity: 0.5\n            }\n        }\n    }\n});\n\n/**\n * Provide effect for line\n * @module echarts/chart/helper/EffectLine\n */\n\n/**\n * @constructor\n * @extends {module:zrender/graphic/Group}\n * @alias {module:echarts/chart/helper/Line}\n */\nfunction EffectLine(lineData, idx, seriesScope) {\n    Group.call(this);\n\n    this.add(this.createLine(lineData, idx, seriesScope));\n\n    this._updateEffectSymbol(lineData, idx);\n}\n\nvar effectLineProto = EffectLine.prototype;\n\neffectLineProto.createLine = function (lineData, idx, seriesScope) {\n    return new Line$1(lineData, idx, seriesScope);\n};\n\neffectLineProto._updateEffectSymbol = function (lineData, idx) {\n    var itemModel = lineData.getItemModel(idx);\n    var effectModel = itemModel.getModel('effect');\n    var size = effectModel.get('symbolSize');\n    var symbolType = effectModel.get('symbol');\n    if (!isArray(size)) {\n        size = [size, size];\n    }\n    var color = effectModel.get('color') || lineData.getItemVisual(idx, 'color');\n    var symbol = this.childAt(1);\n\n    if (this._symbolType !== symbolType) {\n        // Remove previous\n        this.remove(symbol);\n\n        symbol = createSymbol(\n            symbolType, -0.5, -0.5, 1, 1, color\n        );\n        symbol.z2 = 100;\n        symbol.culling = true;\n\n        this.add(symbol);\n    }\n\n    // Symbol may be removed if loop is false\n    if (!symbol) {\n        return;\n    }\n\n    // Shadow color is same with color in default\n    symbol.setStyle('shadowColor', color);\n    symbol.setStyle(effectModel.getItemStyle(['color']));\n\n    symbol.attr('scale', size);\n\n    symbol.setColor(color);\n    symbol.attr('scale', size);\n\n    this._symbolType = symbolType;\n\n    this._updateEffectAnimation(lineData, effectModel, idx);\n};\n\neffectLineProto._updateEffectAnimation = function (lineData, effectModel, idx) {\n\n    var symbol = this.childAt(1);\n    if (!symbol) {\n        return;\n    }\n\n    var self = this;\n\n    var points = lineData.getItemLayout(idx);\n\n    var period = effectModel.get('period') * 1000;\n    var loop = effectModel.get('loop');\n    var constantSpeed = effectModel.get('constantSpeed');\n    var delayExpr = retrieve(effectModel.get('delay'), function (idx) {\n        return idx / lineData.count() * period / 3;\n    });\n    var isDelayFunc = typeof delayExpr === 'function';\n\n    // Ignore when updating\n    symbol.ignore = true;\n\n    this.updateAnimationPoints(symbol, points);\n\n    if (constantSpeed > 0) {\n        period = this.getLineLength(symbol) / constantSpeed * 1000;\n    }\n\n    if (period !== this._period || loop !== this._loop) {\n\n        symbol.stopAnimation();\n\n        var delay = delayExpr;\n        if (isDelayFunc) {\n            delay = delayExpr(idx);\n        }\n        if (symbol.__t > 0) {\n            delay = -period * symbol.__t;\n        }\n        symbol.__t = 0;\n        var animator = symbol.animate('', loop)\n            .when(period, {\n                __t: 1\n            })\n            .delay(delay)\n            .during(function () {\n                self.updateSymbolPosition(symbol);\n            });\n        if (!loop) {\n            animator.done(function () {\n                self.remove(symbol);\n            });\n        }\n        animator.start();\n    }\n\n    this._period = period;\n    this._loop = loop;\n};\n\neffectLineProto.getLineLength = function (symbol) {\n    // Not so accurate\n    return (dist(symbol.__p1, symbol.__cp1)\n        + dist(symbol.__cp1, symbol.__p2));\n};\n\neffectLineProto.updateAnimationPoints = function (symbol, points) {\n    symbol.__p1 = points[0];\n    symbol.__p2 = points[1];\n    symbol.__cp1 = points[2] || [\n        (points[0][0] + points[1][0]) / 2,\n        (points[0][1] + points[1][1]) / 2\n    ];\n};\n\neffectLineProto.updateData = function (lineData, idx, seriesScope) {\n    this.childAt(0).updateData(lineData, idx, seriesScope);\n    this._updateEffectSymbol(lineData, idx);\n};\n\neffectLineProto.updateSymbolPosition = function (symbol) {\n    var p1 = symbol.__p1;\n    var p2 = symbol.__p2;\n    var cp1 = symbol.__cp1;\n    var t = symbol.__t;\n    var pos = symbol.position;\n    var quadraticAt$$1 = quadraticAt;\n    var quadraticDerivativeAt$$1 = quadraticDerivativeAt;\n    pos[0] = quadraticAt$$1(p1[0], cp1[0], p2[0], t);\n    pos[1] = quadraticAt$$1(p1[1], cp1[1], p2[1], t);\n\n    // Tangent\n    var tx = quadraticDerivativeAt$$1(p1[0], cp1[0], p2[0], t);\n    var ty = quadraticDerivativeAt$$1(p1[1], cp1[1], p2[1], t);\n\n    symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;\n\n    symbol.ignore = false;\n};\n\n\neffectLineProto.updateLayout = function (lineData, idx) {\n    this.childAt(0).updateLayout(lineData, idx);\n\n    var effectModel = lineData.getItemModel(idx).getModel('effect');\n    this._updateEffectAnimation(lineData, effectModel, idx);\n};\n\ninherits(EffectLine, Group);\n\n/**\n * @module echarts/chart/helper/Line\n */\n\n/**\n * @constructor\n * @extends {module:zrender/graphic/Group}\n * @alias {module:echarts/chart/helper/Polyline}\n */\nfunction Polyline$2(lineData, idx, seriesScope) {\n    Group.call(this);\n\n    this._createPolyline(lineData, idx, seriesScope);\n}\n\nvar polylineProto = Polyline$2.prototype;\n\npolylineProto._createPolyline = function (lineData, idx, seriesScope) {\n    // var seriesModel = lineData.hostModel;\n    var points = lineData.getItemLayout(idx);\n\n    var line = new Polyline({\n        shape: {\n            points: points\n        }\n    });\n\n    this.add(line);\n\n    this._updateCommonStl(lineData, idx, seriesScope);\n};\n\npolylineProto.updateData = function (lineData, idx, seriesScope) {\n    var seriesModel = lineData.hostModel;\n\n    var line = this.childAt(0);\n    var target = {\n        shape: {\n            points: lineData.getItemLayout(idx)\n        }\n    };\n    updateProps(line, target, seriesModel, idx);\n\n    this._updateCommonStl(lineData, idx, seriesScope);\n};\n\npolylineProto._updateCommonStl = function (lineData, idx, seriesScope) {\n    var line = this.childAt(0);\n    var itemModel = lineData.getItemModel(idx);\n\n    var visualColor = lineData.getItemVisual(idx, 'color');\n\n    var lineStyle = seriesScope && seriesScope.lineStyle;\n    var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;\n\n    if (!seriesScope || lineData.hasItemOption) {\n        lineStyle = itemModel.getModel('lineStyle.normal').getLineStyle();\n        hoverLineStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();\n    }\n    line.useStyle(defaults(\n        {\n            strokeNoScale: true,\n            fill: 'none',\n            stroke: visualColor\n        },\n        lineStyle\n    ));\n    line.hoverStyle = hoverLineStyle;\n\n    setHoverStyle(this);\n};\n\npolylineProto.updateLayout = function (lineData, idx) {\n    var polyline = this.childAt(0);\n    polyline.setShape('points', lineData.getItemLayout(idx));\n};\n\ninherits(Polyline$2, Group);\n\n/**\n * Provide effect for line\n * @module echarts/chart/helper/EffectLine\n */\n\n/**\n * @constructor\n * @extends {module:echarts/chart/helper/EffectLine}\n * @alias {module:echarts/chart/helper/Polyline}\n */\nfunction EffectPolyline(lineData, idx, seriesScope) {\n    EffectLine.call(this, lineData, idx, seriesScope);\n    this._lastFrame = 0;\n    this._lastFramePercent = 0;\n}\n\nvar effectPolylineProto = EffectPolyline.prototype;\n\n// Overwrite\neffectPolylineProto.createLine = function (lineData, idx, seriesScope) {\n    return new Polyline$2(lineData, idx, seriesScope);\n};\n\n// Overwrite\neffectPolylineProto.updateAnimationPoints = function (symbol, points) {\n    this._points = points;\n    var accLenArr = [0];\n    var len$$1 = 0;\n    for (var i = 1; i < points.length; i++) {\n        var p1 = points[i - 1];\n        var p2 = points[i];\n        len$$1 += dist(p1, p2);\n        accLenArr.push(len$$1);\n    }\n    if (len$$1 === 0) {\n        return;\n    }\n\n    for (var i = 0; i < accLenArr.length; i++) {\n        accLenArr[i] /= len$$1;\n    }\n    this._offsets = accLenArr;\n    this._length = len$$1;\n};\n\n// Overwrite\neffectPolylineProto.getLineLength = function (symbol) {\n    return this._length;\n};\n\n// Overwrite\neffectPolylineProto.updateSymbolPosition = function (symbol) {\n    var t = symbol.__t;\n    var points = this._points;\n    var offsets = this._offsets;\n    var len$$1 = points.length;\n\n    if (!offsets) {\n        // Has length 0\n        return;\n    }\n\n    var lastFrame = this._lastFrame;\n    var frame;\n\n    if (t < this._lastFramePercent) {\n        // Start from the next frame\n        // PENDING start from lastFrame ?\n        var start = Math.min(lastFrame + 1, len$$1 - 1);\n        for (frame = start; frame >= 0; frame--) {\n            if (offsets[frame] <= t) {\n                break;\n            }\n        }\n        // PENDING really need to do this ?\n        frame = Math.min(frame, len$$1 - 2);\n    }\n    else {\n        for (var frame = lastFrame; frame < len$$1; frame++) {\n            if (offsets[frame] > t) {\n                break;\n            }\n        }\n        frame = Math.min(frame - 1, len$$1 - 2);\n    }\n\n    lerp(\n        symbol.position, points[frame], points[frame + 1],\n        (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])\n    );\n\n    var tx = points[frame + 1][0] - points[frame][0];\n    var ty = points[frame + 1][1] - points[frame][1];\n    symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;\n\n    this._lastFrame = frame;\n    this._lastFramePercent = t;\n\n    symbol.ignore = false;\n};\n\ninherits(EffectPolyline, EffectLine);\n\n// TODO Batch by color\n\nvar LargeLineShape = extendShape({\n    shape: {\n        polyline: false,\n\n        segs: []\n    },\n\n    buildPath: function (path, shape) {\n        var segs = shape.segs;\n        var isPolyline = shape.polyline;\n\n        for (var i = 0; i < segs.length; i++) {\n            var seg = segs[i];\n            if (isPolyline) {\n                path.moveTo(seg[0][0], seg[0][1]);\n                for (var j = 1; j < seg.length; j++) {\n                    path.lineTo(seg[j][0], seg[j][1]);\n                }\n            }\n            else {\n                path.moveTo(seg[0][0], seg[0][1]);\n                if (seg.length > 2) {\n                    path.quadraticCurveTo(seg[2][0], seg[2][1], seg[1][0], seg[1][1]);\n                }\n                else {\n                    path.lineTo(seg[1][0], seg[1][1]);\n                }\n            }\n        }\n    },\n\n    findDataIndex: function (x, y) {\n        var shape = this.shape;\n        var segs = shape.segs;\n        var isPolyline = shape.polyline;\n        var lineWidth = Math.max(this.style.lineWidth, 1);\n\n        // Not consider transform\n        for (var i = 0; i < segs.length; i++) {\n            var seg = segs[i];\n            if (isPolyline) {\n                for (var j = 1; j < seg.length; j++) {\n                    if (containStroke$1(\n                        seg[j - 1][0], seg[j - 1][1], seg[j][0], seg[j][1], lineWidth, x, y\n                    )) {\n                        return i;\n                    }\n                }\n            }\n            else {\n                if (seg.length > 2) {\n                    if (containStroke$3(\n                        seg[0][0], seg[0][1], seg[2][0], seg[2][1], seg[1][0], seg[1][1], lineWidth, x, y\n                    )) {\n                        return i;\n                    }\n                }\n                else {\n                    if (containStroke$1(\n                        seg[0][0], seg[0][1], seg[1][0], seg[1][1], lineWidth, x, y\n                    )) {\n                        return i;\n                    }\n                }\n            }\n        }\n\n        return -1;\n    }\n});\n\nfunction LargeLineDraw() {\n    this.group = new Group();\n\n    this._lineEl = new LargeLineShape();\n}\n\nvar largeLineProto = LargeLineDraw.prototype;\n\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n */\nlargeLineProto.updateData = function (data) {\n    this.group.removeAll();\n\n    var lineEl = this._lineEl;\n\n    var seriesModel = data.hostModel;\n\n    lineEl.setShape({\n        segs: data.mapArray(data.getItemLayout),\n        polyline: seriesModel.get('polyline')\n    });\n\n    lineEl.useStyle(\n        seriesModel.getModel('lineStyle.normal').getLineStyle()\n    );\n\n    var visualColor = data.getVisual('color');\n    if (visualColor) {\n        lineEl.setStyle('stroke', visualColor);\n    }\n    lineEl.setStyle('fill');\n\n    // Enable tooltip\n    // PENDING May have performance issue when path is extremely large\n    lineEl.seriesIndex = seriesModel.seriesIndex;\n    lineEl.on('mousemove', function (e) {\n        lineEl.dataIndex = null;\n        var dataIndex = lineEl.findDataIndex(e.offsetX, e.offsetY);\n        if (dataIndex > 0) {\n            // Provide dataIndex for tooltip\n            lineEl.dataIndex = dataIndex;\n        }\n    });\n\n    // Add back\n    this.group.add(lineEl);\n};\n\nlargeLineProto.updateLayout = function (seriesModel) {\n    var data = seriesModel.getData();\n    this._lineEl.setShape({\n        segs: data.mapArray(data.getItemLayout)\n    });\n};\n\nlargeLineProto.remove = function () {\n    this.group.removeAll();\n};\n\nextendChartView({\n\n    type: 'lines',\n\n    init: function () {},\n\n    render: function (seriesModel, ecModel, api) {\n        var data = seriesModel.getData();\n        var lineDraw = this._lineDraw;\n\n        var hasEffect = seriesModel.get('effect.show');\n        var isPolyline = seriesModel.get('polyline');\n        var isLarge = seriesModel.get('large') && data.count() >= seriesModel.get('largeThreshold');\n\n        if (__DEV__) {\n            if (hasEffect && isLarge) {\n                console.warn('Large lines not support effect');\n            }\n        }\n        if (hasEffect !== this._hasEffet || isPolyline !== this._isPolyline || isLarge !== this._isLarge) {\n            if (lineDraw) {\n                lineDraw.remove();\n            }\n            lineDraw = this._lineDraw = isLarge\n                ? new LargeLineDraw()\n                : new LineDraw(\n                    isPolyline\n                        ? (hasEffect ? EffectPolyline : Polyline$2)\n                        : (hasEffect ? EffectLine : Line$1)\n                );\n            this._hasEffet = hasEffect;\n            this._isPolyline = isPolyline;\n            this._isLarge = isLarge;\n        }\n\n        var zlevel = seriesModel.get('zlevel');\n        var trailLength = seriesModel.get('effect.trailLength');\n\n        var zr = api.getZr();\n        // Avoid the drag cause ghost shadow\n        // FIXME Better way ?\n        // SVG doesn't support\n        var isSvg = zr.painter.getType() === 'svg';\n        if (!isSvg) {\n            zr.painter.getLayer(zlevel).clear(true);\n        }\n        // Config layer with motion blur\n        if (this._lastZlevel != null && !isSvg) {\n            zr.configLayer(this._lastZlevel, {\n                motionBlur: false\n            });\n        }\n        if (hasEffect && trailLength) {\n            if (__DEV__) {\n                var notInIndividual = false;\n                ecModel.eachSeries(function (otherSeriesModel) {\n                    if (otherSeriesModel !== seriesModel && otherSeriesModel.get('zlevel') === zlevel) {\n                        notInIndividual = true;\n                    }\n                });\n                notInIndividual && console.warn('Lines with trail effect should have an individual zlevel');\n            }\n\n            if (!isSvg) {\n                zr.configLayer(zlevel, {\n                    motionBlur: true,\n                    lastFrameAlpha: Math.max(Math.min(trailLength / 10 + 0.9, 1), 0)\n                });\n            }\n        }\n\n        this.group.add(lineDraw.group);\n\n        lineDraw.updateData(data);\n\n        this._lastZlevel = zlevel;\n    },\n\n    updateLayout: function (seriesModel, ecModel, api) {\n        this._lineDraw.updateLayout(seriesModel);\n        // Not use motion when dragging or zooming\n        var zr = api.getZr();\n        var isSvg = zr.painter.getType() === 'svg';\n        if (!isSvg) {\n            zr.painter.getLayer(this._lastZlevel).clear(true);\n        }\n    },\n\n    remove: function (ecModel, api) {\n        this._lineDraw && this._lineDraw.remove(api, true);\n        // Clear motion when lineDraw is removed\n        var zr = api.getZr();\n        var isSvg = zr.painter.getType() === 'svg';\n        if (!isSvg) {\n            zr.painter.getLayer(this._lastZlevel).clear(true);\n        }\n    },\n\n    dispose: function () {}\n});\n\nvar linesLayout = function (ecModel) {\n    ecModel.eachSeriesByType('lines', function (seriesModel) {\n        var coordSys = seriesModel.coordinateSystem;\n        var lineData = seriesModel.getData();\n\n        // FIXME Use data dimensions ?\n        lineData.each(function (idx) {\n            var itemModel = lineData.getItemModel(idx);\n\n            var coords = (itemModel.option instanceof Array) ?\n                itemModel.option : itemModel.get('coords');\n\n            if (__DEV__) {\n                if (!(coords instanceof Array && coords.length > 0 && coords[0] instanceof Array)) {\n                    throw new Error('Invalid coords ' + JSON.stringify(coords) + '. Lines must have 2d coords array in data item.');\n                }\n            }\n            var pts = [];\n\n            if (seriesModel.get('polyline')) {\n                for (var i = 0; i < coords.length; i++) {\n                    pts.push(coordSys.dataToPoint(coords[i]));\n                }\n            }\n            else {\n                pts[0] = coordSys.dataToPoint(coords[0]);\n                pts[1] = coordSys.dataToPoint(coords[1]);\n\n                var curveness = itemModel.get('lineStyle.normal.curveness');\n                if (+curveness) {\n                    pts[2] = [\n                        (pts[0][0] + pts[1][0]) / 2 - (pts[0][1] - pts[1][1]) * curveness,\n                        (pts[0][1] + pts[1][1]) / 2 - (pts[1][0] - pts[0][0]) * curveness\n                    ];\n                }\n            }\n            lineData.setItemLayout(idx, pts);\n        });\n    });\n};\n\nfunction normalize$2(a) {\n    if (!(a instanceof Array)) {\n        a = [a, a];\n    }\n    return a;\n}\n\nvar linesVisual = function (ecModel) {\n    ecModel.eachSeriesByType('lines', function (seriesModel) {\n        var data = seriesModel.getData();\n        var symbolType = normalize$2(seriesModel.get('symbol'));\n        var symbolSize = normalize$2(seriesModel.get('symbolSize'));\n\n        var opacityQuery = 'lineStyle.normal.opacity'.split('.');\n\n        data.setVisual('fromSymbol', symbolType && symbolType[0]);\n        data.setVisual('toSymbol', symbolType && symbolType[1]);\n        data.setVisual('fromSymbolSize', symbolSize && symbolSize[0]);\n        data.setVisual('toSymbolSize', symbolSize && symbolSize[1]);\n        data.setVisual('opacity', seriesModel.get(opacityQuery));\n\n        data.each(function (idx) {\n            var itemModel = data.getItemModel(idx);\n            var symbolType = normalize$2(itemModel.getShallow('symbol', true));\n            var symbolSize = normalize$2(itemModel.getShallow('symbolSize', true));\n            var opacity = itemModel.get(opacityQuery);\n\n            symbolType[0] && data.setItemVisual(idx, 'fromSymbol', symbolType[0]);\n            symbolType[1] && data.setItemVisual(idx, 'toSymbol', symbolType[1]);\n            symbolSize[0] && data.setItemVisual(idx, 'fromSymbolSize', symbolSize[0]);\n            symbolSize[1] && data.setItemVisual(idx, 'toSymbolSize', symbolSize[1]);\n\n            data.setItemVisual(idx, 'opacity', opacity);\n        });\n    });\n};\n\nregisterLayout(linesLayout);\nregisterVisual(linesVisual);\n\nSeriesModel.extend({\n    type: 'series.heatmap',\n\n    getInitialData: function (option, ecModel) {\n        return createListFromArray(option.data, this, ecModel);\n    },\n\n    defaultOption: {\n\n        // Cartesian2D or geo\n        coordinateSystem: 'cartesian2d',\n\n        zlevel: 0,\n\n        z: 2,\n\n        // Cartesian coordinate system\n        // xAxisIndex: 0,\n        // yAxisIndex: 0,\n\n        // Geo coordinate system\n        geoIndex: 0,\n\n        blurSize: 30,\n\n        pointSize: 20,\n\n        maxOpacity: 1,\n\n        minOpacity: 0\n    }\n});\n\n/**\n * @file defines echarts Heatmap Chart\n * @author Ovilia (me@zhangwenli.com)\n * Inspired by https://github.com/mourner/simpleheat\n *\n * @module\n */\n\nvar GRADIENT_LEVELS = 256;\n\n/**\n * Heatmap Chart\n *\n * @class\n */\nfunction Heatmap() {\n    var canvas = createCanvas();\n    this.canvas = canvas;\n\n    this.blurSize = 30;\n    this.pointSize = 20;\n\n    this.maxOpacity = 1;\n    this.minOpacity = 0;\n\n    this._gradientPixels = {};\n}\n\nHeatmap.prototype = {\n    /**\n     * Renders Heatmap and returns the rendered canvas\n     * @param {Array} data array of data, each has x, y, value\n     * @param {number} width canvas width\n     * @param {number} height canvas height\n     */\n    update: function(data, width, height, normalize, colorFunc, isInRange) {\n        var brush = this._getBrush();\n        var gradientInRange = this._getGradient(data, colorFunc, 'inRange');\n        var gradientOutOfRange = this._getGradient(data, colorFunc, 'outOfRange');\n        var r = this.pointSize + this.blurSize;\n\n        var canvas = this.canvas;\n        var ctx = canvas.getContext('2d');\n        var len = data.length;\n        canvas.width = width;\n        canvas.height = height;\n        for (var i = 0; i < len; ++i) {\n            var p = data[i];\n            var x = p[0];\n            var y = p[1];\n            var value = p[2];\n\n            // calculate alpha using value\n            var alpha = normalize(value);\n\n            // draw with the circle brush with alpha\n            ctx.globalAlpha = alpha;\n            ctx.drawImage(brush, x - r, y - r);\n        }\n\n        if (!canvas.width || !canvas.height) {\n            // Avoid \"Uncaught DOMException: Failed to execute 'getImageData' on\n            // 'CanvasRenderingContext2D': The source height is 0.\"\n            return canvas;\n        }\n\n        // colorize the canvas using alpha value and set with gradient\n        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n        var pixels = imageData.data;\n        var offset = 0;\n        var pixelLen = pixels.length;\n        var minOpacity = this.minOpacity;\n        var maxOpacity = this.maxOpacity;\n        var diffOpacity = maxOpacity - minOpacity;\n\n        while(offset < pixelLen) {\n            var alpha = pixels[offset + 3] / 256;\n            var gradientOffset = Math.floor(alpha * (GRADIENT_LEVELS - 1)) * 4;\n            // Simple optimize to ignore the empty data\n            if (alpha > 0) {\n                var gradient = isInRange(alpha) ? gradientInRange : gradientOutOfRange;\n                // Any alpha > 0 will be mapped to [minOpacity, maxOpacity]\n                alpha > 0 && (alpha = alpha * diffOpacity + minOpacity);\n                pixels[offset++] = gradient[gradientOffset];\n                pixels[offset++] = gradient[gradientOffset + 1];\n                pixels[offset++] = gradient[gradientOffset + 2];\n                pixels[offset++] = gradient[gradientOffset + 3] * alpha * 256;\n            }\n            else {\n                offset += 4;\n            }\n        }\n        ctx.putImageData(imageData, 0, 0);\n\n        return canvas;\n    },\n\n    /**\n     * get canvas of a black circle brush used for canvas to draw later\n     * @private\n     * @returns {Object} circle brush canvas\n     */\n    _getBrush: function() {\n        var brushCanvas = this._brushCanvas || (this._brushCanvas = createCanvas());\n        // set brush size\n        var r = this.pointSize + this.blurSize;\n        var d = r * 2;\n        brushCanvas.width = d;\n        brushCanvas.height = d;\n\n        var ctx = brushCanvas.getContext('2d');\n        ctx.clearRect(0, 0, d, d);\n\n        // in order to render shadow without the distinct circle,\n        // draw the distinct circle in an invisible place,\n        // and use shadowOffset to draw shadow in the center of the canvas\n        ctx.shadowOffsetX = d;\n        ctx.shadowBlur = this.blurSize;\n        // draw the shadow in black, and use alpha and shadow blur to generate\n        // color in color map\n        ctx.shadowColor = '#000';\n\n        // draw circle in the left to the canvas\n        ctx.beginPath();\n        ctx.arc(-r, r, this.pointSize, 0, Math.PI * 2, true);\n        ctx.closePath();\n        ctx.fill();\n        return brushCanvas;\n    },\n\n    /**\n     * get gradient color map\n     * @private\n     */\n    _getGradient: function (data, colorFunc, state) {\n        var gradientPixels = this._gradientPixels;\n        var pixelsSingleState = gradientPixels[state] || (gradientPixels[state] = new Uint8ClampedArray(256 * 4));\n        var color = [0, 0, 0, 0];\n        var off = 0;\n        for (var i = 0; i < 256; i++) {\n            colorFunc[state](i / 255, true, color);\n            pixelsSingleState[off++] = color[0];\n            pixelsSingleState[off++] = color[1];\n            pixelsSingleState[off++] = color[2];\n            pixelsSingleState[off++] = color[3];\n        }\n        return pixelsSingleState;\n    }\n};\n\nfunction getIsInPiecewiseRange(dataExtent, pieceList, selected) {\n    var dataSpan = dataExtent[1] - dataExtent[0];\n    pieceList = map(pieceList, function (piece) {\n        return {\n            interval: [\n                (piece.interval[0] - dataExtent[0]) / dataSpan,\n                (piece.interval[1] - dataExtent[0]) / dataSpan\n            ]\n        };\n    });\n    var len = pieceList.length;\n    var lastIndex = 0;\n\n    return function (val) {\n        // Try to find in the location of the last found\n        for (var i = lastIndex; i < len; i++) {\n            var interval = pieceList[i].interval;\n            if (interval[0] <= val && val <= interval[1]) {\n                lastIndex = i;\n                break;\n            }\n        }\n        if (i === len) { // Not found, back interation\n            for (var i = lastIndex - 1; i >= 0; i--) {\n                var interval = pieceList[i].interval;\n                if (interval[0] <= val && val <= interval[1]) {\n                    lastIndex = i;\n                    break;\n                }\n            }\n        }\n        return i >= 0 && i < len && selected[i];\n    };\n}\n\nfunction getIsInContinuousRange(dataExtent, range) {\n    var dataSpan = dataExtent[1] - dataExtent[0];\n    range = [\n        (range[0] - dataExtent[0]) / dataSpan,\n        (range[1] - dataExtent[0]) / dataSpan\n    ];\n    return function (val) {\n        return val >= range[0] && val <= range[1];\n    };\n}\n\nfunction isGeoCoordSys(coordSys) {\n    var dimensions = coordSys.dimensions;\n    // Not use coorSys.type === 'geo' because coordSys maybe extended\n    return dimensions[0] === 'lng' && dimensions[1] === 'lat';\n}\n\nextendChartView({\n\n    type: 'heatmap',\n\n    render: function (seriesModel, ecModel, api) {\n        var visualMapOfThisSeries;\n        ecModel.eachComponent('visualMap', function (visualMap) {\n            visualMap.eachTargetSeries(function (targetSeries) {\n                if (targetSeries === seriesModel) {\n                    visualMapOfThisSeries = visualMap;\n                }\n            });\n        });\n\n        if (__DEV__) {\n            if (!visualMapOfThisSeries) {\n                throw new Error('Heatmap must use with visualMap');\n            }\n        }\n\n        this.group.removeAll();\n        var coordSys = seriesModel.coordinateSystem;\n        if (coordSys.type === 'cartesian2d' || coordSys.type === 'calendar') {\n            this._renderOnCartesianAndCalendar(coordSys, seriesModel, api);\n        }\n        else if (isGeoCoordSys(coordSys)) {\n            this._renderOnGeo(\n                coordSys, seriesModel, visualMapOfThisSeries, api\n            );\n        }\n    },\n\n    dispose: function () {},\n\n    _renderOnCartesianAndCalendar: function (coordSys, seriesModel, api) {\n\n        if (coordSys.type === 'cartesian2d') {\n            var xAxis = coordSys.getAxis('x');\n            var yAxis = coordSys.getAxis('y');\n\n            if (__DEV__) {\n                if (!(xAxis.type === 'category' && yAxis.type === 'category')) {\n                    throw new Error('Heatmap on cartesian must have two category axes');\n                }\n                if (!(xAxis.onBand && yAxis.onBand)) {\n                    throw new Error('Heatmap on cartesian must have two axes with boundaryGap true');\n                }\n            }\n\n            var width = xAxis.getBandWidth();\n            var height = yAxis.getBandWidth();\n\n        }\n\n        var group = this.group;\n        var data = seriesModel.getData();\n\n        var itemStyleQuery = 'itemStyle.normal';\n        var hoverItemStyleQuery = 'itemStyle.emphasis';\n        var labelQuery = 'label.normal';\n        var hoverLabelQuery = 'label.emphasis';\n        var style = seriesModel.getModel(itemStyleQuery).getItemStyle(['color']);\n        var hoverStl = seriesModel.getModel(hoverItemStyleQuery).getItemStyle();\n        var labelModel = seriesModel.getModel('label.normal');\n        var hoverLabelModel = seriesModel.getModel('label.emphasis');\n        var coordSysType = coordSys.type;\n\n        var dataDims = coordSysType === 'cartesian2d'\n            ? [\n                seriesModel.coordDimToDataDim('x')[0],\n                seriesModel.coordDimToDataDim('y')[0],\n                seriesModel.coordDimToDataDim('value')[0]\n            ]\n            : [\n                seriesModel.coordDimToDataDim('time')[0],\n                seriesModel.coordDimToDataDim('value')[0]\n            ];\n\n        data.each(function (idx) {\n            var rect;\n\n            if (coordSysType === 'cartesian2d') {\n                // Ignore empty data\n                if (isNaN(data.get(dataDims[2], idx))) {\n                    return;\n                }\n\n                var point = coordSys.dataToPoint([\n                    data.get(dataDims[0], idx),\n                    data.get(dataDims[1], idx)\n                ]);\n\n                rect = new Rect({\n                    shape: {\n                        x: point[0] - width / 2,\n                        y: point[1] - height / 2,\n                        width: width,\n                        height: height\n                    },\n                    style: {\n                        fill: data.getItemVisual(idx, 'color'),\n                        opacity: data.getItemVisual(idx, 'opacity')\n                    }\n                });\n            }\n            else {\n                // Ignore empty data\n                if (isNaN(data.get(dataDims[1], idx))) {\n                    return;\n                }\n\n                rect = new Rect({\n                    z2: 1,\n                    shape: coordSys.dataToRect([data.get(dataDims[0], idx)]).contentShape,\n                    style: {\n                        fill: data.getItemVisual(idx, 'color'),\n                        opacity: data.getItemVisual(idx, 'opacity')\n                    }\n                });\n            }\n\n            var itemModel = data.getItemModel(idx);\n\n            // Optimization for large datset\n            if (data.hasItemOption) {\n                style = itemModel.getModel(itemStyleQuery).getItemStyle(['color']);\n                hoverStl = itemModel.getModel(hoverItemStyleQuery).getItemStyle();\n                labelModel = itemModel.getModel(labelQuery);\n                hoverLabelModel = itemModel.getModel(hoverLabelQuery);\n            }\n\n            var rawValue = seriesModel.getRawValue(idx);\n            var defaultText = '-';\n            if (rawValue && rawValue[2] != null) {\n                defaultText = rawValue[2];\n            }\n\n            setLabelStyle(\n                style, hoverStl, labelModel, hoverLabelModel,\n                {\n                    labelFetcher: seriesModel,\n                    labelDataIndex: idx,\n                    defaultText: defaultText,\n                    isRectText: true\n                }\n            );\n\n            rect.setStyle(style);\n            setHoverStyle(rect, data.hasItemOption ? hoverStl : extend({}, hoverStl));\n\n            group.add(rect);\n            data.setItemGraphicEl(idx, rect);\n        });\n    },\n\n    _renderOnGeo: function (geo, seriesModel, visualMapModel, api) {\n        var inRangeVisuals = visualMapModel.targetVisuals.inRange;\n        var outOfRangeVisuals = visualMapModel.targetVisuals.outOfRange;\n        // if (!visualMapping) {\n        //     throw new Error('Data range must have color visuals');\n        // }\n\n        var data = seriesModel.getData();\n        var hmLayer = this._hmLayer || (this._hmLayer || new Heatmap());\n        hmLayer.blurSize = seriesModel.get('blurSize');\n        hmLayer.pointSize = seriesModel.get('pointSize');\n        hmLayer.minOpacity = seriesModel.get('minOpacity');\n        hmLayer.maxOpacity = seriesModel.get('maxOpacity');\n\n        var rect = geo.getViewRect().clone();\n        var roamTransform = geo.getRoamTransform().transform;\n        rect.applyTransform(roamTransform);\n\n        // Clamp on viewport\n        var x = Math.max(rect.x, 0);\n        var y = Math.max(rect.y, 0);\n        var x2 = Math.min(rect.width + rect.x, api.getWidth());\n        var y2 = Math.min(rect.height + rect.y, api.getHeight());\n        var width = x2 - x;\n        var height = y2 - y;\n\n        var points = data.mapArray(['lng', 'lat', 'value'], function (lng, lat, value) {\n            var pt = geo.dataToPoint([lng, lat]);\n            pt[0] -= x;\n            pt[1] -= y;\n            pt.push(value);\n            return pt;\n        });\n\n        var dataExtent = visualMapModel.getExtent();\n        var isInRange = visualMapModel.type === 'visualMap.continuous'\n            ? getIsInContinuousRange(dataExtent, visualMapModel.option.range)\n            : getIsInPiecewiseRange(\n                dataExtent, visualMapModel.getPieceList(), visualMapModel.option.selected\n            );\n\n        hmLayer.update(\n            points, width, height,\n            inRangeVisuals.color.getNormalizer(),\n            {\n                inRange: inRangeVisuals.color.getColorMapper(),\n                outOfRange: outOfRangeVisuals.color.getColorMapper()\n            },\n            isInRange\n        );\n        var img = new ZImage({\n            style: {\n                width: width,\n                height: height,\n                x: x,\n                y: y,\n                image: hmLayer.canvas\n            },\n            silent: true\n        });\n        this.group.add(img);\n    }\n});\n\nvar PictorialBarSeries = BaseBarSeries.extend({\n\n    type: 'series.pictorialBar',\n\n    dependencies: ['grid'],\n\n    defaultOption: {\n        symbol: 'circle',     // Customized bar shape\n        symbolSize: null,     // Can be ['100%', '100%'], null means auto.\n        symbolRotate: null,\n\n        symbolPosition: null, // 'start' or 'end' or 'center', null means auto.\n        symbolOffset: null,\n        symbolMargin: null,   // start margin and end margin. Can be a number or a percent string.\n                                // Auto margin by defualt.\n        symbolRepeat: false,  // false/null/undefined, means no repeat.\n                                // Can be true, means auto calculate repeat times and cut by data.\n                                // Can be a number, specifies repeat times, and do not cut by data.\n                                // Can be 'fixed', means auto calculate repeat times but do not cut by data.\n        symbolRepeatDirection: 'end', // 'end' means from 'start' to 'end'.\n\n        symbolClip: false,\n        symbolBoundingData: null, // Can be 60 or -40 or [-40, 60]\n        symbolPatternSize: 400, // 400 * 400 px\n\n        barGap: '-100%',      // In most case, overlap is needed.\n\n        // z can be set in data item, which is z2 actually.\n\n        // Disable progressive\n        progressive: 0,\n        hoverAnimation: false // Open only when needed.\n    },\n\n    getInitialData: function (option) {\n        // Disable stack.\n        option.stack = null;\n        return PictorialBarSeries.superApply(this, 'getInitialData', arguments);\n    }\n});\n\nvar BAR_BORDER_WIDTH_QUERY$1 = ['itemStyle', 'normal', 'borderWidth'];\n\n// index: +isHorizontal\nvar LAYOUT_ATTRS = [\n    {xy: 'x', wh: 'width', index: 0, posDesc: ['left', 'right']},\n    {xy: 'y', wh: 'height', index: 1, posDesc: ['top', 'bottom']}\n];\n\nvar pathForLineWidth = new Circle();\n\nvar BarView$1 = extendChartView({\n\n    type: 'pictorialBar',\n\n    render: function (seriesModel, ecModel, api) {\n        var group = this.group;\n        var data = seriesModel.getData();\n        var oldData = this._data;\n\n        var cartesian = seriesModel.coordinateSystem;\n        var baseAxis = cartesian.getBaseAxis();\n        var isHorizontal = !!baseAxis.isHorizontal();\n        var coordSysRect = cartesian.grid.getRect();\n\n        var opt = {\n            ecSize: {width: api.getWidth(), height: api.getHeight()},\n            seriesModel: seriesModel,\n            coordSys: cartesian,\n            coordSysExtent: [\n                [coordSysRect.x, coordSysRect.x + coordSysRect.width],\n                [coordSysRect.y, coordSysRect.y + coordSysRect.height]\n            ],\n            isHorizontal: isHorizontal,\n            valueDim: LAYOUT_ATTRS[+isHorizontal],\n            categoryDim: LAYOUT_ATTRS[1 - isHorizontal]\n        };\n\n        data.diff(oldData)\n            .add(function (dataIndex) {\n                if (!data.hasValue(dataIndex)) {\n                    return;\n                }\n\n                var itemModel = getItemModel(data, dataIndex);\n                var symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt);\n\n                var bar = createBar(data, opt, symbolMeta);\n\n                data.setItemGraphicEl(dataIndex, bar);\n                group.add(bar);\n\n                updateCommon$1(bar, opt, symbolMeta);\n            })\n            .update(function (newIndex, oldIndex) {\n                var bar = oldData.getItemGraphicEl(oldIndex);\n\n                if (!data.hasValue(newIndex)) {\n                    group.remove(bar);\n                    return;\n                }\n\n                var itemModel = getItemModel(data, newIndex);\n                var symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt);\n\n                var pictorialShapeStr = getShapeStr(data, symbolMeta);\n                if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) {\n                    group.remove(bar);\n                    data.setItemGraphicEl(newIndex, null);\n                    bar = null;\n                }\n\n                if (bar) {\n                    updateBar(bar, opt, symbolMeta);\n                }\n                else {\n                    bar = createBar(data, opt, symbolMeta, true);\n                }\n\n                data.setItemGraphicEl(newIndex, bar);\n                bar.__pictorialSymbolMeta = symbolMeta;\n                // Add back\n                group.add(bar);\n\n                updateCommon$1(bar, opt, symbolMeta);\n            })\n            .remove(function (dataIndex) {\n                var bar = oldData.getItemGraphicEl(dataIndex);\n                bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar);\n            })\n            .execute();\n\n        this._data = data;\n\n        return this.group;\n    },\n\n    dispose: noop,\n\n    remove: function (ecModel, api) {\n        var group = this.group;\n        var data = this._data;\n        if (ecModel.get('animation')) {\n            if (data) {\n                data.eachItemGraphicEl(function (bar) {\n                    removeBar(data, bar.dataIndex, ecModel, bar);\n                });\n            }\n        }\n        else {\n            group.removeAll();\n        }\n    }\n});\n\n\n// Set or calculate default value about symbol, and calculate layout info.\nfunction getSymbolMeta(data, dataIndex, itemModel, opt) {\n    var layout = data.getItemLayout(dataIndex);\n    var symbolRepeat = itemModel.get('symbolRepeat');\n    var symbolClip = itemModel.get('symbolClip');\n    var symbolPosition = itemModel.get('symbolPosition') || 'start';\n    var symbolRotate = itemModel.get('symbolRotate');\n    var rotation = (symbolRotate || 0) * Math.PI / 180 || 0;\n    var symbolPatternSize = itemModel.get('symbolPatternSize') || 2;\n    var isAnimationEnabled = itemModel.isAnimationEnabled();\n\n    var symbolMeta = {\n        dataIndex: dataIndex,\n        layout: layout,\n        itemModel: itemModel,\n        symbolType: data.getItemVisual(dataIndex, 'symbol') || 'circle',\n        color: data.getItemVisual(dataIndex, 'color'),\n        symbolClip: symbolClip,\n        symbolRepeat: symbolRepeat,\n        symbolRepeatDirection: itemModel.get('symbolRepeatDirection'),\n        symbolPatternSize: symbolPatternSize,\n        rotation: rotation,\n        animationModel: isAnimationEnabled ? itemModel : null,\n        hoverAnimation: isAnimationEnabled && itemModel.get('hoverAnimation'),\n        z2: itemModel.getShallow('z', true) || 0\n    };\n\n    prepareBarLength(itemModel, symbolRepeat, layout, opt, symbolMeta);\n\n    prepareSymbolSize(\n        data, dataIndex, layout, symbolRepeat, symbolClip, symbolMeta.boundingLength,\n        symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta\n    );\n\n    prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta);\n\n    var symbolSize = symbolMeta.symbolSize;\n    var symbolOffset = itemModel.get('symbolOffset');\n    if (isArray(symbolOffset)) {\n        symbolOffset = [\n            parsePercent$1(symbolOffset[0], symbolSize[0]),\n            parsePercent$1(symbolOffset[1], symbolSize[1])\n        ];\n    }\n\n    prepareLayoutInfo(\n        itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset,\n        symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength,\n        opt, symbolMeta\n    );\n\n    return symbolMeta;\n}\n\n// bar length can be negative.\nfunction prepareBarLength(itemModel, symbolRepeat, layout, opt, output) {\n    var valueDim = opt.valueDim;\n    var symbolBoundingData = itemModel.get('symbolBoundingData');\n    var valueAxis = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());\n    var zeroPx = valueAxis.toGlobalCoord(valueAxis.dataToCoord(0));\n    var pxSignIdx = 1 - +(layout[valueDim.wh] <= 0);\n    var boundingLength;\n\n    if (isArray(symbolBoundingData)) {\n        var symbolBoundingExtent = [\n            convertToCoordOnAxis(valueAxis, symbolBoundingData[0]) - zeroPx,\n            convertToCoordOnAxis(valueAxis, symbolBoundingData[1]) - zeroPx\n        ];\n        symbolBoundingExtent[1] < symbolBoundingExtent[0] && (symbolBoundingExtent.reverse());\n        boundingLength = symbolBoundingExtent[pxSignIdx];\n    }\n    else if (symbolBoundingData != null) {\n        boundingLength = convertToCoordOnAxis(valueAxis, symbolBoundingData) - zeroPx;\n    }\n    else if (symbolRepeat) {\n        boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx;\n    }\n    else {\n        boundingLength = layout[valueDim.wh];\n    }\n\n    output.boundingLength = boundingLength;\n\n    if (symbolRepeat) {\n        output.repeatCutLength = layout[valueDim.wh];\n    }\n\n    output.pxSign = boundingLength > 0 ? 1 : boundingLength < 0 ? -1 : 0;\n}\n\nfunction convertToCoordOnAxis(axis, value) {\n    return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)));\n}\n\n// Support ['100%', '100%']\nfunction prepareSymbolSize(\n    data, dataIndex, layout, symbolRepeat, symbolClip, boundingLength,\n    pxSign, symbolPatternSize, opt, output\n) {\n    var valueDim = opt.valueDim;\n    var categoryDim = opt.categoryDim;\n    var categorySize = Math.abs(layout[categoryDim.wh]);\n\n    var symbolSize = data.getItemVisual(dataIndex, 'symbolSize');\n    if (isArray(symbolSize)) {\n        symbolSize = symbolSize.slice();\n    }\n    else {\n        if (symbolSize == null) {\n            symbolSize = '100%';\n        }\n        symbolSize = [symbolSize, symbolSize];\n    }\n\n    // Note: percentage symbolSize (like '100%') do not consider lineWidth, because it is\n    // to complicated to calculate real percent value if considering scaled lineWidth.\n    // So the actual size will bigger than layout size if lineWidth is bigger than zero,\n    // which can be tolerated in pictorial chart.\n\n    symbolSize[categoryDim.index] = parsePercent$1(\n        symbolSize[categoryDim.index],\n        categorySize\n    );\n    symbolSize[valueDim.index] = parsePercent$1(\n        symbolSize[valueDim.index],\n        symbolRepeat ? categorySize : Math.abs(boundingLength)\n    );\n\n    output.symbolSize = symbolSize;\n\n    // If x or y is less than zero, show reversed shape.\n    var symbolScale = output.symbolScale = [\n        symbolSize[0] / symbolPatternSize,\n        symbolSize[1] / symbolPatternSize\n    ];\n    // Follow convention, 'right' and 'top' is the normal scale.\n    symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign;\n}\n\nfunction prepareLineWidth(itemModel, symbolScale, rotation, opt, output) {\n    // In symbols are drawn with scale, so do not need to care about the case that width\n    // or height are too small. But symbol use strokeNoScale, where acture lineWidth should\n    // be calculated.\n    var valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY$1) || 0;\n\n    if (valueLineWidth) {\n        pathForLineWidth.attr({\n            scale: symbolScale.slice(),\n            rotation: rotation\n        });\n        pathForLineWidth.updateTransform();\n        valueLineWidth /= pathForLineWidth.getLineScale();\n        valueLineWidth *= symbolScale[opt.valueDim.index];\n    }\n\n    output.valueLineWidth = valueLineWidth;\n}\n\nfunction prepareLayoutInfo(\n    itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset,\n    symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, output\n) {\n    var categoryDim = opt.categoryDim;\n    var valueDim = opt.valueDim;\n    var pxSign = output.pxSign;\n\n    var unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0);\n    var pathLen = unitLength;\n\n    // Note: rotation will not effect the layout of symbols, because user may\n    // want symbols to rotate on its center, which should not be translated\n    // when rotating.\n\n    if (symbolRepeat) {\n        var absBoundingLength = Math.abs(boundingLength);\n\n        var symbolMargin = retrieve(itemModel.get('symbolMargin'), '15%') + '';\n        var hasEndGap = false;\n        if (symbolMargin.lastIndexOf('!') === symbolMargin.length - 1) {\n            hasEndGap = true;\n            symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1);\n        }\n        symbolMargin = parsePercent$1(symbolMargin, symbolSize[valueDim.index]);\n\n        var uLenWithMargin = Math.max(unitLength + symbolMargin * 2, 0);\n\n        // When symbol margin is less than 0, margin at both ends will be subtracted\n        // to ensure that all of the symbols will not be overflow the given area.\n        var endFix = hasEndGap ? 0 : symbolMargin * 2;\n\n        // Both final repeatTimes and final symbolMargin area calculated based on\n        // boundingLength.\n        var repeatSpecified = isNumeric(symbolRepeat);\n        var repeatTimes = repeatSpecified\n            ? symbolRepeat\n            : toIntTimes((absBoundingLength + endFix) / uLenWithMargin);\n\n        // Adjust calculate margin, to ensure each symbol is displayed\n        // entirely in the given layout area.\n        var mDiff = absBoundingLength - repeatTimes * unitLength;\n        symbolMargin = mDiff / 2 / (hasEndGap ? repeatTimes : repeatTimes - 1);\n        uLenWithMargin = unitLength + symbolMargin * 2;\n        endFix = hasEndGap ? 0 : symbolMargin * 2;\n\n        // Update repeatTimes when not all symbol will be shown.\n        if (!repeatSpecified && symbolRepeat !== 'fixed') {\n            repeatTimes = repeatCutLength\n                ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin)\n                : 0;\n        }\n\n        pathLen = repeatTimes * uLenWithMargin - endFix;\n        output.repeatTimes = repeatTimes;\n        output.symbolMargin = symbolMargin;\n    }\n\n    var sizeFix = pxSign * (pathLen / 2);\n    var pathPosition = output.pathPosition = [];\n    pathPosition[categoryDim.index] = layout[categoryDim.wh] / 2;\n    pathPosition[valueDim.index] = symbolPosition === 'start'\n        ? sizeFix\n        : symbolPosition === 'end'\n        ? boundingLength - sizeFix\n        : boundingLength / 2; // 'center'\n    if (symbolOffset) {\n        pathPosition[0] += symbolOffset[0];\n        pathPosition[1] += symbolOffset[1];\n    }\n\n    var bundlePosition = output.bundlePosition = [];\n    bundlePosition[categoryDim.index] = layout[categoryDim.xy];\n    bundlePosition[valueDim.index] = layout[valueDim.xy];\n\n    var barRectShape = output.barRectShape = extend({}, layout);\n    barRectShape[valueDim.wh] = pxSign * Math.max(\n        Math.abs(layout[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix)\n    );\n    barRectShape[categoryDim.wh] = layout[categoryDim.wh];\n\n    var clipShape = output.clipShape = {};\n    // Consider that symbol may be overflow layout rect.\n    clipShape[categoryDim.xy] = -layout[categoryDim.xy];\n    clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh];\n    clipShape[valueDim.xy] = 0;\n    clipShape[valueDim.wh] = layout[valueDim.wh];\n}\n\nfunction createPath(symbolMeta) {\n    var symbolPatternSize = symbolMeta.symbolPatternSize;\n    var path = createSymbol(\n        // Consider texture img, make a big size.\n        symbolMeta.symbolType,\n        -symbolPatternSize / 2,\n        -symbolPatternSize / 2,\n        symbolPatternSize,\n        symbolPatternSize,\n        symbolMeta.color\n    );\n    path.attr({\n        culling: true\n    });\n    path.type !== 'image' && path.setStyle({\n        strokeNoScale: true\n    });\n\n    return path;\n}\n\nfunction createOrUpdateRepeatSymbols(bar, opt, symbolMeta, isUpdate) {\n    var bundle = bar.__pictorialBundle;\n    var symbolSize = symbolMeta.symbolSize;\n    var valueLineWidth = symbolMeta.valueLineWidth;\n    var pathPosition = symbolMeta.pathPosition;\n    var valueDim = opt.valueDim;\n    var repeatTimes = symbolMeta.repeatTimes || 0;\n\n    var index = 0;\n    var unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2;\n\n    eachPath(bar, function (path) {\n        path.__pictorialAnimationIndex = index;\n        path.__pictorialRepeatTimes = repeatTimes;\n        if (index < repeatTimes) {\n            updateAttr(path, null, makeTarget(index), symbolMeta, isUpdate);\n        }\n        else {\n            updateAttr(path, null, {scale: [0, 0]}, symbolMeta, isUpdate, function () {\n                bundle.remove(path);\n            });\n        }\n\n        updateHoverAnimation(path, symbolMeta);\n\n        index++;\n    });\n\n    for (; index < repeatTimes; index++) {\n        var path = createPath(symbolMeta);\n        path.__pictorialAnimationIndex = index;\n        path.__pictorialRepeatTimes = repeatTimes;\n        bundle.add(path);\n\n        var target = makeTarget(index);\n\n        updateAttr(\n            path,\n            {\n                position: target.position,\n                scale: [0, 0]\n            },\n            {\n                scale: target.scale,\n                rotation: target.rotation\n            },\n            symbolMeta,\n            isUpdate\n        );\n\n        // FIXME\n        // If all emphasis/normal through action.\n        path\n            .on('mouseover', onMouseOver)\n            .on('mouseout', onMouseOut);\n\n        updateHoverAnimation(path, symbolMeta);\n    }\n\n    function makeTarget(index) {\n        var position = pathPosition.slice();\n        // (start && pxSign > 0) || (end && pxSign < 0): i = repeatTimes - index\n        // Otherwise: i = index;\n        var pxSign = symbolMeta.pxSign;\n        var i = index;\n        if (symbolMeta.symbolRepeatDirection === 'start' ? pxSign > 0 : pxSign < 0) {\n            i = repeatTimes - 1 - index;\n        }\n        position[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index];\n\n        return {\n            position: position,\n            scale: symbolMeta.symbolScale.slice(),\n            rotation: symbolMeta.rotation\n        };\n    }\n\n    function onMouseOver() {\n        eachPath(bar, function (path) {\n            path.trigger('emphasis');\n        });\n    }\n\n    function onMouseOut() {\n        eachPath(bar, function (path) {\n            path.trigger('normal');\n        });\n    }\n}\n\nfunction createOrUpdateSingleSymbol(bar, opt, symbolMeta, isUpdate) {\n    var bundle = bar.__pictorialBundle;\n    var mainPath = bar.__pictorialMainPath;\n\n    if (!mainPath) {\n        mainPath = bar.__pictorialMainPath = createPath(symbolMeta);\n        bundle.add(mainPath);\n\n        updateAttr(\n            mainPath,\n            {\n                position: symbolMeta.pathPosition.slice(),\n                scale: [0, 0],\n                rotation: symbolMeta.rotation\n            },\n            {\n                scale: symbolMeta.symbolScale.slice()\n            },\n            symbolMeta,\n            isUpdate\n        );\n\n        mainPath\n            .on('mouseover', onMouseOver)\n            .on('mouseout', onMouseOut);\n    }\n    else {\n        updateAttr(\n            mainPath,\n            null,\n            {\n                position: symbolMeta.pathPosition.slice(),\n                scale: symbolMeta.symbolScale.slice(),\n                rotation: symbolMeta.rotation\n            },\n            symbolMeta,\n            isUpdate\n        );\n    }\n\n    updateHoverAnimation(mainPath, symbolMeta);\n\n    function onMouseOver() {\n        this.trigger('emphasis');\n    }\n\n    function onMouseOut() {\n        this.trigger('normal');\n    }\n}\n\n// bar rect is used for label.\nfunction createOrUpdateBarRect(bar, symbolMeta, isUpdate) {\n    var rectShape = extend({}, symbolMeta.barRectShape);\n\n    var barRect = bar.__pictorialBarRect;\n    if (!barRect) {\n        barRect = bar.__pictorialBarRect = new Rect({\n            z2: 2,\n            shape: rectShape,\n            silent: true,\n            style: {\n                stroke: 'transparent',\n                fill: 'transparent',\n                lineWidth: 0\n            }\n        });\n\n        bar.add(barRect);\n    }\n    else {\n        updateAttr(barRect, null, {shape: rectShape}, symbolMeta, isUpdate);\n    }\n}\n\nfunction createOrUpdateClip(bar, opt, symbolMeta, isUpdate) {\n    // If not clip, symbol will be remove and rebuilt.\n    if (symbolMeta.symbolClip) {\n        var clipPath = bar.__pictorialClipPath;\n        var clipShape = extend({}, symbolMeta.clipShape);\n        var valueDim = opt.valueDim;\n        var animationModel = symbolMeta.animationModel;\n        var dataIndex = symbolMeta.dataIndex;\n\n        if (clipPath) {\n            updateProps(\n                clipPath, {shape: clipShape}, animationModel, dataIndex\n            );\n        }\n        else {\n            clipShape[valueDim.wh] = 0;\n            clipPath = new Rect({shape: clipShape});\n            bar.__pictorialBundle.setClipPath(clipPath);\n            bar.__pictorialClipPath = clipPath;\n\n            var target = {};\n            target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh];\n\n            graphic[isUpdate ? 'updateProps' : 'initProps'](\n                clipPath, {shape: target}, animationModel, dataIndex\n            );\n        }\n    }\n}\n\nfunction getItemModel(data, dataIndex) {\n    var itemModel = data.getItemModel(dataIndex);\n    itemModel.getAnimationDelayParams = getAnimationDelayParams;\n    itemModel.isAnimationEnabled = isAnimationEnabled;\n    return itemModel;\n}\n\nfunction getAnimationDelayParams(path) {\n    // The order is the same as the z-order, see `symbolRepeatDiretion`.\n    return {\n        index: path.__pictorialAnimationIndex,\n        count: path.__pictorialRepeatTimes\n    };\n}\n\nfunction isAnimationEnabled() {\n    // `animation` prop can be set on itemModel in pictorial bar chart.\n    return this.parentModel.isAnimationEnabled() && !!this.getShallow('animation');\n}\n\nfunction updateHoverAnimation(path, symbolMeta) {\n    path.off('emphasis').off('normal');\n\n    var scale = symbolMeta.symbolScale.slice();\n\n    symbolMeta.hoverAnimation && path\n        .on('emphasis', function() {\n            this.animateTo({\n                scale: [scale[0] * 1.1, scale[1] * 1.1]\n            }, 400, 'elasticOut');\n        })\n        .on('normal', function() {\n            this.animateTo({\n                scale: scale.slice()\n            }, 400, 'elasticOut');\n        });\n}\n\nfunction createBar(data, opt, symbolMeta, isUpdate) {\n    // bar is the main element for each data.\n    var bar = new Group();\n    // bundle is used for location and clip.\n    var bundle = new Group();\n    bar.add(bundle);\n    bar.__pictorialBundle = bundle;\n    bundle.attr('position', symbolMeta.bundlePosition.slice());\n\n    if (symbolMeta.symbolRepeat) {\n        createOrUpdateRepeatSymbols(bar, opt, symbolMeta);\n    }\n    else {\n        createOrUpdateSingleSymbol(bar, opt, symbolMeta);\n    }\n\n    createOrUpdateBarRect(bar, symbolMeta, isUpdate);\n\n    createOrUpdateClip(bar, opt, symbolMeta, isUpdate);\n\n    bar.__pictorialShapeStr = getShapeStr(data, symbolMeta);\n    bar.__pictorialSymbolMeta = symbolMeta;\n\n    return bar;\n}\n\nfunction updateBar(bar, opt, symbolMeta) {\n    var animationModel = symbolMeta.animationModel;\n    var dataIndex = symbolMeta.dataIndex;\n    var bundle = bar.__pictorialBundle;\n\n    updateProps(\n        bundle, {position: symbolMeta.bundlePosition.slice()}, animationModel, dataIndex\n    );\n\n    if (symbolMeta.symbolRepeat) {\n        createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true);\n    }\n    else {\n        createOrUpdateSingleSymbol(bar, opt, symbolMeta, true);\n    }\n\n    createOrUpdateBarRect(bar, symbolMeta, true);\n\n    createOrUpdateClip(bar, opt, symbolMeta, true);\n}\n\nfunction removeBar(data, dataIndex, animationModel, bar) {\n    // Not show text when animating\n    var labelRect = bar.__pictorialBarRect;\n    labelRect && (labelRect.style.text = null);\n\n    var pathes = [];\n    eachPath(bar, function (path) {\n        pathes.push(path);\n    });\n    bar.__pictorialMainPath && pathes.push(bar.__pictorialMainPath);\n\n    // I do not find proper remove animation for clip yet.\n    bar.__pictorialClipPath && (animationModel = null);\n\n    each$1(pathes, function (path) {\n        updateProps(\n            path, {scale: [0, 0]}, animationModel, dataIndex,\n            function () {\n                bar.parent && bar.parent.remove(bar);\n            }\n        );\n    });\n\n    data.setItemGraphicEl(dataIndex, null);\n}\n\nfunction getShapeStr(data, symbolMeta) {\n    return [\n        data.getItemVisual(symbolMeta.dataIndex, 'symbol') || 'none',\n        !!symbolMeta.symbolRepeat,\n        !!symbolMeta.symbolClip\n    ].join(':');\n}\n\nfunction eachPath(bar, cb, context) {\n    // Do not use Group#eachChild, because it do not support remove.\n    each$1(bar.__pictorialBundle.children(), function (el) {\n        el !== bar.__pictorialBarRect && cb.call(context, el);\n    });\n}\n\nfunction updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {\n    immediateAttrs && el.attr(immediateAttrs);\n    // when symbolCip used, only clip path has init animation, otherwise it would be weird effect.\n    if (symbolMeta.symbolClip && !isUpdate) {\n        animationAttrs && el.attr(animationAttrs);\n    }\n    else {\n        animationAttrs && graphic[isUpdate ? 'updateProps' : 'initProps'](\n            el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb\n        );\n    }\n}\n\nfunction updateCommon$1(bar, opt, symbolMeta) {\n    var color = symbolMeta.color;\n    var dataIndex = symbolMeta.dataIndex;\n    var itemModel = symbolMeta.itemModel;\n    // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n    var normalStyle = itemModel.getModel('itemStyle.normal').getItemStyle(['color']);\n    var hoverStyle = itemModel.getModel('itemStyle.emphasis').getItemStyle();\n    var cursorStyle = itemModel.getShallow('cursor');\n\n    eachPath(bar, function (path) {\n        // PENDING setColor should be before setStyle!!!\n        path.setColor(color);\n        path.setStyle(defaults(\n            {\n                fill: color,\n                opacity: symbolMeta.opacity\n            },\n            normalStyle\n        ));\n        setHoverStyle(path, hoverStyle);\n\n        cursorStyle && (path.cursor = cursorStyle);\n        path.z2 = symbolMeta.z2;\n    });\n\n    var barRectHoverStyle = {};\n    var barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)];\n    var barRect = bar.__pictorialBarRect;\n\n    setLabel(\n        barRect.style, barRectHoverStyle, itemModel,\n        color, opt.seriesModel, dataIndex, barPositionOutside\n    );\n\n    setHoverStyle(barRect, barRectHoverStyle);\n}\n\nfunction toIntTimes(times) {\n    var roundedTimes = Math.round(times);\n    // Escapse accurate error\n    return Math.abs(times - roundedTimes) < 1e-4\n        ? roundedTimes\n        : Math.ceil(times);\n}\n\n// In case developer forget to include grid component\nregisterLayout(curry(\n    barLayoutGrid, 'pictorialBar'\n));\nregisterVisual(curry(\n    visualSymbol, 'pictorialBar', 'roundRect', null\n));\n\n/**\n * @constructor  module:echarts/coord/single/SingleAxis\n * @extends {module:echarts/coord/Axis}\n * @param {string} dim\n * @param {*} scale\n * @param {Array.<number>} coordExtent\n * @param {string} axisType\n * @param {string} position\n */\nvar SingleAxis = function (dim, scale, coordExtent, axisType, position) {\n\n    Axis.call(this, dim, scale, coordExtent);\n\n    /**\n     * Axis type\n     * - 'category'\n     * - 'value'\n     * - 'time'\n     * - 'log'\n     * @type {string}\n     */\n    this.type = axisType || 'value';\n\n    /**\n     * Axis position\n     *  - 'top'\n     *  - 'bottom'\n     *  - 'left'\n     *  - 'right'\n     *  @type {string}\n     */\n    this.position = position || 'bottom';\n\n    /**\n     * Axis orient\n     *  - 'horizontal'\n     *  - 'vertical'\n     * @type {[type]}\n     */\n    this.orient = null;\n\n    /**\n     * @type {number}\n     */\n    this._labelInterval = null;\n\n};\n\nSingleAxis.prototype = {\n\n    constructor: SingleAxis,\n\n    /**\n     * Axis model\n     * @type {module:echarts/coord/single/AxisModel}\n     */\n    model: null,\n\n    /**\n     * Judge the orient of the axis.\n     * @return {boolean}\n     */\n    isHorizontal: function () {\n        var position = this.position;\n        return position === 'top' || position === 'bottom';\n\n    },\n\n    /**\n     * @override\n     */\n    pointToData: function (point, clamp) {\n        return this.coordinateSystem.pointToData(point, clamp)[0];\n    },\n\n    /**\n     * Convert the local coord(processed by dataToCoord())\n     * to global coord(concrete pixel coord).\n     * designated by module:echarts/coord/single/Single.\n     * @type {Function}\n     */\n    toGlobalCoord: null,\n\n    /**\n     * Convert the global coord to local coord.\n     * designated by module:echarts/coord/single/Single.\n     * @type {Function}\n     */\n    toLocalCoord: null\n\n};\n\ninherits(SingleAxis, Axis);\n\n/**\n * Single coordinates system.\n */\n\n/**\n * Create a single coordinates system.\n *\n * @param {module:echarts/coord/single/AxisModel} axisModel\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n */\nfunction Single(axisModel, ecModel, api) {\n\n    /**\n     * @type {string}\n     * @readOnly\n     */\n    this.dimension = 'single';\n\n    /**\n     * Add it just for draw tooltip.\n     *\n     * @type {Array.<string>}\n     * @readOnly\n     */\n    this.dimensions = ['single'];\n\n    /**\n     * @private\n     * @type {module:echarts/coord/single/SingleAxis}.\n     */\n    this._axis = null;\n\n    /**\n     * @private\n     * @type {module:zrender/core/BoundingRect}\n     */\n    this._rect;\n\n    this._init(axisModel, ecModel, api);\n\n    /**\n     * @type {module:echarts/coord/single/AxisModel}\n     */\n    this.model = axisModel;\n}\n\nSingle.prototype = {\n\n    type: 'singleAxis',\n\n    axisPointerEnabled: true,\n\n    constructor: Single,\n\n    /**\n     * Initialize single coordinate system.\n     *\n     * @param  {module:echarts/coord/single/AxisModel} axisModel\n     * @param  {module:echarts/model/Global} ecModel\n     * @param  {module:echarts/ExtensionAPI} api\n     * @private\n     */\n    _init: function (axisModel, ecModel, api) {\n\n        var dim = this.dimension;\n\n        var axis = new SingleAxis(\n            dim,\n            createScaleByModel(axisModel),\n            [0, 0],\n            axisModel.get('type'),\n            axisModel.get('position')\n        );\n\n        var isCategory = axis.type === 'category';\n        axis.onBand = isCategory && axisModel.get('boundaryGap');\n        axis.inverse = axisModel.get('inverse');\n        axis.orient = axisModel.get('orient');\n\n        axisModel.axis = axis;\n        axis.model = axisModel;\n        axis.coordinateSystem = this;\n        this._axis = axis;\n    },\n\n    /**\n     * Update axis scale after data processed\n     * @param  {module:echarts/model/Global} ecModel\n     * @param  {module:echarts/ExtensionAPI} api\n     */\n    update: function (ecModel, api) {\n        ecModel.eachSeries(function (seriesModel) {\n            if (seriesModel.coordinateSystem === this) {\n                var data = seriesModel.getData();\n                var dim = this.dimension;\n                this._axis.scale.unionExtentFromData(\n                    data, seriesModel.coordDimToDataDim(dim)\n                );\n                niceScaleExtent(this._axis.scale, this._axis.model);\n            }\n        }, this);\n    },\n\n    /**\n     * Resize the single coordinate system.\n     *\n     * @param  {module:echarts/coord/single/AxisModel} axisModel\n     * @param  {module:echarts/ExtensionAPI} api\n     */\n    resize: function (axisModel, api) {\n        this._rect = getLayoutRect(\n            {\n                left: axisModel.get('left'),\n                top: axisModel.get('top'),\n                right: axisModel.get('right'),\n                bottom: axisModel.get('bottom'),\n                width: axisModel.get('width'),\n                height: axisModel.get('height')\n            },\n            {\n                width: api.getWidth(),\n                height: api.getHeight()\n            }\n        );\n\n        this._adjustAxis();\n    },\n\n    /**\n     * @return {module:zrender/core/BoundingRect}\n     */\n    getRect: function () {\n        return this._rect;\n    },\n\n    /**\n     * @private\n     */\n    _adjustAxis: function () {\n\n        var rect = this._rect;\n        var axis = this._axis;\n\n        var isHorizontal = axis.isHorizontal();\n        var extent = isHorizontal ? [0, rect.width] : [0, rect.height];\n        var idx =  axis.reverse ? 1 : 0;\n\n        axis.setExtent(extent[idx], extent[1 - idx]);\n\n        this._updateAxisTransform(axis, isHorizontal ? rect.x : rect.y);\n\n    },\n\n    /**\n     * @param  {module:echarts/coord/single/SingleAxis} axis\n     * @param  {number} coordBase\n     */\n    _updateAxisTransform: function (axis, coordBase) {\n\n        var axisExtent = axis.getExtent();\n        var extentSum = axisExtent[0] + axisExtent[1];\n        var isHorizontal = axis.isHorizontal();\n\n        axis.toGlobalCoord = isHorizontal\n            ? function (coord) {\n                return coord + coordBase;\n            }\n            : function (coord) {\n                return extentSum - coord + coordBase;\n            };\n\n        axis.toLocalCoord = isHorizontal\n            ? function (coord) {\n                return coord - coordBase;\n            }\n            : function (coord) {\n                return extentSum - coord + coordBase;\n            };\n    },\n\n    /**\n     * Get axis.\n     *\n     * @return {module:echarts/coord/single/SingleAxis}\n     */\n    getAxis: function () {\n        return this._axis;\n    },\n\n    /**\n     * Get axis, add it just for draw tooltip.\n     *\n     * @return {[type]} [description]\n     */\n    getBaseAxis: function () {\n        return this._axis;\n    },\n\n    /**\n     * @return {Array.<module:echarts/coord/Axis>}\n     */\n    getAxes: function () {\n        return [this._axis];\n    },\n\n    /**\n     * @return {Object} {baseAxes: [], otherAxes: []}\n     */\n    getTooltipAxes: function () {\n        return {baseAxes: [this.getAxis()]};\n    },\n\n    /**\n     * If contain point.\n     *\n     * @param  {Array.<number>} point\n     * @return {boolean}\n     */\n    containPoint: function (point) {\n        var rect = this.getRect();\n        var axis = this.getAxis();\n        var orient = axis.orient;\n        if (orient === 'horizontal') {\n            return axis.contain(axis.toLocalCoord(point[0]))\n            && (point[1] >= rect.y && point[1] <= (rect.y + rect.height));\n        }\n        else {\n            return axis.contain(axis.toLocalCoord(point[1]))\n            && (point[0] >= rect.y && point[0] <= (rect.y + rect.height));\n        }\n    },\n\n    /**\n     * @param {Array.<number>} point\n     * @return {Array.<number>}\n     */\n    pointToData: function (point) {\n        var axis = this.getAxis();\n        return [axis.coordToData(axis.toLocalCoord(\n            point[axis.orient === 'horizontal' ? 0 : 1]\n        ))];\n    },\n\n    /**\n     * Convert the series data to concrete point.\n     *\n     * @param  {number|Array.<number>} val\n     * @return {Array.<number>}\n     */\n    dataToPoint: function (val) {\n        var axis = this.getAxis();\n        var rect = this.getRect();\n        var pt = [];\n        var idx = axis.orient === 'horizontal' ? 0 : 1;\n\n        if (val instanceof Array) {\n            val = val[0];\n        }\n\n        pt[idx] = axis.toGlobalCoord(axis.dataToCoord(+val));\n        pt[1 - idx] = idx === 0 ? (rect.y + rect.height / 2) : (rect.x + rect.width / 2);\n        return pt;\n    }\n\n};\n\n/**\n * Single coordinate system creator.\n */\n\n/**\n * Create single coordinate system and inject it into seriesModel.\n *\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n * @return {Array.<module:echarts/coord/single/Single>}\n */\nfunction create$3(ecModel, api) {\n    var singles = [];\n\n    ecModel.eachComponent('singleAxis', function(axisModel, idx) {\n\n        var single = new Single(axisModel, ecModel, api);\n        single.name = 'single_' + idx;\n        single.resize(axisModel, api);\n        axisModel.coordinateSystem = single;\n        singles.push(single);\n\n    });\n\n    ecModel.eachSeries(function (seriesModel) {\n        if (seriesModel.get('coordinateSystem') === 'singleAxis') {\n            var singleAxisModel = ecModel.queryComponents({\n                mainType: 'singleAxis',\n                index: seriesModel.get('singleAxisIndex'),\n                id: seriesModel.get('singleAxisId')\n            })[0];\n            seriesModel.coordinateSystem = singleAxisModel && singleAxisModel.coordinateSystem;\n        }\n    });\n\n    return singles;\n}\n\nCoordinateSystemManager.register('single', {\n    create: create$3,\n    dimensions: Single.prototype.dimensions\n});\n\n/**\n * @param {Object} opt {labelInside}\n * @return {Object} {\n *  position, rotation, labelDirection, labelOffset,\n *  tickDirection, labelRotate, labelInterval, z2\n * }\n */\nfunction layout$1 (axisModel, opt) {\n    opt = opt || {};\n    var single = axisModel.coordinateSystem;\n    var axis = axisModel.axis;\n    var layout = {};\n\n    var axisPosition = axis.position;\n    var orient = axis.orient;\n\n    var rect = single.getRect();\n    var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n\n    var positionMap = {\n        horizontal: {top: rectBound[2], bottom: rectBound[3]},\n        vertical: {left: rectBound[0], right: rectBound[1]}\n    };\n\n    layout.position = [\n        orient === 'vertical'\n            ? positionMap.vertical[axisPosition]\n            : rectBound[0],\n        orient === 'horizontal'\n            ? positionMap.horizontal[axisPosition]\n            : rectBound[3]\n    ];\n\n    var r = {horizontal: 0, vertical: 1};\n    layout.rotation = Math.PI / 2 * r[orient];\n\n    var directionMap = {top: -1, bottom: 1, right: 1, left: -1};\n\n    layout.labelDirection = layout.tickDirection\n        = layout.nameDirection\n        = directionMap[axisPosition];\n\n    if (axisModel.get('axisTick.inside')) {\n        layout.tickDirection = -layout.tickDirection;\n    }\n\n    if (retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {\n        layout.labelDirection = -layout.labelDirection;\n    }\n\n    var labelRotation = opt.rotate;\n    labelRotation == null && (labelRotation = axisModel.get('axisLabel.rotate'));\n    layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n\n    layout.labelInterval = axis.getLabelInterval();\n\n    layout.z2 = 1;\n\n    return layout;\n}\n\nvar getInterval$2 = AxisBuilder.getInterval;\nvar ifIgnoreOnTick$2 = AxisBuilder.ifIgnoreOnTick;\n\nvar axisBuilderAttrs$2 = [\n    'axisLine', 'axisTickLabel', 'axisName'\n];\n\nvar selfBuilderAttr = 'splitLine';\n\nvar SingleAxisView = AxisView.extend({\n\n    type: 'singleAxis',\n\n    axisPointerClass: 'SingleAxisPointer',\n\n    render: function (axisModel, ecModel, api, payload) {\n\n        var group = this.group;\n\n        group.removeAll();\n\n        var layout =  layout$1(axisModel);\n\n        var axisBuilder = new AxisBuilder(axisModel, layout);\n\n        each$1(axisBuilderAttrs$2, axisBuilder.add, axisBuilder);\n\n        group.add(axisBuilder.getGroup());\n\n        if (axisModel.get(selfBuilderAttr + '.show')) {\n            this['_' + selfBuilderAttr](axisModel, layout.labelInterval);\n        }\n\n        SingleAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n    },\n\n    _splitLine: function(axisModel, labelInterval) {\n        var axis = axisModel.axis;\n\n        if (axis.scale.isBlank()) {\n            return;\n        }\n\n        var splitLineModel = axisModel.getModel('splitLine');\n        var lineStyleModel = splitLineModel.getModel('lineStyle');\n        var lineWidth = lineStyleModel.get('width');\n        var lineColors = lineStyleModel.get('color');\n        var lineInterval = getInterval$2(splitLineModel, labelInterval);\n\n        lineColors = lineColors instanceof Array ? lineColors : [lineColors];\n\n        var gridRect = axisModel.coordinateSystem.getRect();\n        var isHorizontal = axis.isHorizontal();\n\n        var splitLines = [];\n        var lineCount = 0;\n\n        var ticksCoords = axis.getTicksCoords();\n\n        var p1 = [];\n        var p2 = [];\n\n        var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n        var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n        for (var i = 0; i < ticksCoords.length; ++i) {\n            if (ifIgnoreOnTick$2(\n                axis, i, lineInterval, ticksCoords.length,\n                showMinLabel, showMaxLabel\n            )) {\n                continue;\n            }\n            var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n            if (isHorizontal) {\n                p1[0] = tickCoord;\n                p1[1] = gridRect.y;\n                p2[0] = tickCoord;\n                p2[1] = gridRect.y + gridRect.height;\n            }\n            else {\n                p1[0] = gridRect.x;\n                p1[1] = tickCoord;\n                p2[0] = gridRect.x + gridRect.width;\n                p2[1] = tickCoord;\n            }\n            var colorIndex = (lineCount++) % lineColors.length;\n            splitLines[colorIndex] = splitLines[colorIndex] || [];\n            splitLines[colorIndex].push(new Line(\n                subPixelOptimizeLine({\n                    shape: {\n                        x1: p1[0],\n                        y1: p1[1],\n                        x2: p2[0],\n                        y2: p2[1]\n                    },\n                    style: {\n                        lineWidth: lineWidth\n                    },\n                    silent: true\n                })));\n        }\n\n        for (var i = 0; i < splitLines.length; ++i) {\n            this.group.add(mergePath(splitLines[i], {\n                style: {\n                    stroke: lineColors[i % lineColors.length],\n                    lineDash: lineStyleModel.getLineDash(lineWidth),\n                    lineWidth: lineWidth\n                },\n                silent: true\n            }));\n        }\n    }\n});\n\nvar AxisModel$4 = ComponentModel.extend({\n\n    type: 'singleAxis',\n\n    layoutMode: 'box',\n\n    /**\n     * @type {module:echarts/coord/single/SingleAxis}\n     */\n    axis: null,\n\n    /**\n     * @type {module:echarts/coord/single/Single}\n     */\n    coordinateSystem: null,\n\n    /**\n     * @override\n     */\n    getCoordSysModel: function () {\n        return this;\n    }\n\n});\n\nvar defaultOption$2 = {\n\n    left: '5%',\n    top: '5%',\n    right: '5%',\n    bottom: '5%',\n\n    type: 'value',\n\n    position: 'bottom',\n\n    orient: 'horizontal',\n\n    axisLine: {\n        show: true,\n        lineStyle: {\n            width: 2,\n            type: 'solid'\n        }\n    },\n\n    // Single coordinate system and single axis is the,\n    // which is used as the parent tooltip model.\n    // same model, so we set default tooltip show as true.\n    tooltip: {\n        show: true\n    },\n\n    axisTick: {\n        show: true,\n        length: 6,\n        lineStyle: {\n            width: 2\n        }\n    },\n\n    axisLabel: {\n        show: true,\n        interval: 'auto'\n    },\n\n    splitLine: {\n        show: true,\n        lineStyle: {\n            type: 'dashed',\n            opacity: 0.2\n        }\n    }\n};\n\nfunction getAxisType$2(axisName, option) {\n    return option.type || (option.data ? 'category' : 'value');\n}\n\nmerge(AxisModel$4.prototype, axisModelCommonMixin);\n\naxisModelCreator('single', AxisModel$4, getAxisType$2, defaultOption$2);\n\n/**\n * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}\n * @param {module:echarts/model/Global} ecModel\n * @return {Object} {point: [x, y], el: ...} point Will not be null.\n */\nvar findPointFromSeries = function (finder, ecModel) {\n    var point = [];\n    var seriesIndex = finder.seriesIndex;\n    var seriesModel;\n    if (seriesIndex == null || !(\n        seriesModel = ecModel.getSeriesByIndex(seriesIndex)\n    )) {\n        return {point: []};\n    }\n\n    var data = seriesModel.getData();\n    var dataIndex = queryDataIndex(data, finder);\n    if (dataIndex == null || isArray(dataIndex)) {\n        return {point: []};\n    }\n\n    var el = data.getItemGraphicEl(dataIndex);\n    var coordSys = seriesModel.coordinateSystem;\n\n    if (seriesModel.getTooltipPosition) {\n        point = seriesModel.getTooltipPosition(dataIndex) || [];\n    }\n    else if (coordSys && coordSys.dataToPoint) {\n        point = coordSys.dataToPoint(\n            data.getValues(\n                map(coordSys.dimensions, function (dim) {\n                    return seriesModel.coordDimToDataDim(dim)[0];\n                }), dataIndex, true\n            )\n        ) || [];\n    }\n    else if (el) {\n        // Use graphic bounding rect\n        var rect = el.getBoundingRect().clone();\n        rect.applyTransform(el.transform);\n        point = [\n            rect.x + rect.width / 2,\n            rect.y + rect.height / 2\n        ];\n    }\n\n    return {point: point, el: el};\n};\n\nvar each$17 = each$1;\nvar curry$3 = curry;\nvar get$2 = makeGetter();\n\n/**\n * Basic logic: check all axis, if they do not demand show/highlight,\n * then hide/downplay them.\n *\n * @param {Object} coordSysAxesInfo\n * @param {Object} payload\n * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'\n * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to\n *              trigger axisPointer and tooltip.\n * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to\n *              trigger axisPointer and tooltip.\n * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.\n * @param {Object} [payload.dataIndex] finder, restrict target axes.\n * @param {Object} [payload.axesInfo] finder, restrict target axes.\n *        [{\n *          axisDim: 'x'|'y'|'angle'|...,\n *          axisIndex: ...,\n *          value: ...\n *        }, ...]\n * @param {Function} [payload.dispatchAction]\n * @param {Object} [payload.tooltipOption]\n * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,\n *        which can be specified in dispatchAction\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n * @return {Object} content of event obj for echarts.connect.\n */\nvar axisTrigger = function (payload, ecModel, api) {\n    var currTrigger = payload.currTrigger;\n    var point = [payload.x, payload.y];\n    var finder = payload;\n    var dispatchAction = payload.dispatchAction || bind(api.dispatchAction, api);\n    var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n    // Pending\n    // See #6121. But we are not able to reproduce it yet.\n    if (!coordSysAxesInfo) {\n        return;\n    }\n\n    if (illegalPoint(point)) {\n        // Used in the default behavior of `connection`: use the sample seriesIndex\n        // and dataIndex. And also used in the tooltipView trigger.\n        point = findPointFromSeries({\n            seriesIndex: finder.seriesIndex,\n            // Do not use dataIndexInside from other ec instance.\n            // FIXME: auto detect it?\n            dataIndex: finder.dataIndex\n        }, ecModel).point;\n    }\n    var isIllegalPoint = illegalPoint(point);\n\n    // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).\n    // Notice: In this case, it is difficult to get the `point` (which is necessary to show\n    // tooltip, so if point is not given, we just use the point found by sample seriesIndex\n    // and dataIndex.\n    var inputAxesInfo = finder.axesInfo;\n\n    var axesInfo = coordSysAxesInfo.axesInfo;\n    var shouldHide = currTrigger === 'leave' || illegalPoint(point);\n    var outputFinder = {};\n\n    var showValueMap = {};\n    var dataByCoordSys = {list: [], map: {}};\n    var updaters = {\n        showPointer: curry$3(showPointer, showValueMap),\n        showTooltip: curry$3(showTooltip, dataByCoordSys)\n    };\n\n    // Process for triggered axes.\n    each$17(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {\n        // If a point given, it must be contained by the coordinate system.\n        var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);\n\n        each$17(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {\n            var axis = axisInfo.axis;\n            var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);\n            // If no inputAxesInfo, no axis is restricted.\n            if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {\n                var val = inputAxisInfo && inputAxisInfo.value;\n                if (val == null && !isIllegalPoint) {\n                    val = axis.pointToData(point);\n                }\n                val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);\n            }\n        });\n    });\n\n    // Process for linked axes.\n    var linkTriggers = {};\n    each$17(axesInfo, function (tarAxisInfo, tarKey) {\n        var linkGroup = tarAxisInfo.linkGroup;\n\n        // If axis has been triggered in the previous stage, it should not be triggered by link.\n        if (linkGroup && !showValueMap[tarKey]) {\n            each$17(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {\n                var srcValItem = showValueMap[srcKey];\n                // If srcValItem exist, source axis is triggered, so link to target axis.\n                if (srcAxisInfo !== tarAxisInfo && srcValItem) {\n                    var val = srcValItem.value;\n                    linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(\n                        val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo)\n                    )));\n                    linkTriggers[tarAxisInfo.key] = val;\n                }\n            });\n        }\n    });\n    each$17(linkTriggers, function (val, tarKey) {\n        processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);\n    });\n\n    updateModelActually(showValueMap, axesInfo, outputFinder);\n    dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);\n    dispatchHighDownActually(axesInfo, dispatchAction, api);\n\n    return outputFinder;\n};\n\nfunction processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {\n    var axis = axisInfo.axis;\n\n    if (axis.scale.isBlank() || !axis.containData(newValue)) {\n        return;\n    }\n\n    if (!axisInfo.involveSeries) {\n        updaters.showPointer(axisInfo, newValue);\n        return;\n    }\n\n    // Heavy calculation. So put it after axis.containData checking.\n    var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);\n    var payloadBatch = payloadInfo.payloadBatch;\n    var snapToValue = payloadInfo.snapToValue;\n\n    // Fill content of event obj for echarts.connect.\n    // By defualt use the first involved series data as a sample to connect.\n    if (payloadBatch[0] && outputFinder.seriesIndex == null) {\n        extend(outputFinder, payloadBatch[0]);\n    }\n\n    // If no linkSource input, this process is for collecting link\n    // target, where snap should not be accepted.\n    if (!dontSnap && axisInfo.snap) {\n        if (axis.containData(snapToValue) && snapToValue != null) {\n            newValue = snapToValue;\n        }\n    }\n\n    updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder);\n    // Tooltip should always be snapToValue, otherwise there will be\n    // incorrect \"axis value ~ series value\" mapping displayed in tooltip.\n    updaters.showTooltip(axisInfo, payloadInfo, snapToValue);\n}\n\nfunction buildPayloadsBySeries(value, axisInfo) {\n    var axis = axisInfo.axis;\n    var dim = axis.dim;\n    var snapToValue = value;\n    var payloadBatch = [];\n    var minDist = Number.MAX_VALUE;\n    var minDiff = -1;\n\n    each$17(axisInfo.seriesModels, function (series, idx) {\n        var dataDim = series.coordDimToDataDim(dim);\n        var seriesNestestValue;\n        var dataIndices;\n\n        if (series.getAxisTooltipData) {\n            var result = series.getAxisTooltipData(dataDim, value, axis);\n            dataIndices = result.dataIndices;\n            seriesNestestValue = result.nestestValue;\n        }\n        else {\n            dataIndices = series.getData().indicesOfNearest(\n                dataDim[0],\n                value,\n                // Add a threshold to avoid find the wrong dataIndex\n                // when data length is not same.\n                false, axis.type === 'category' ? 0.5 : null\n            );\n            if (!dataIndices.length) {\n                return;\n            }\n            seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);\n        }\n\n        if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {\n            return;\n        }\n\n        var diff = value - seriesNestestValue;\n        var dist = Math.abs(diff);\n        // Consider category case\n        if (dist <= minDist) {\n            if (dist < minDist || (diff >= 0 && minDiff < 0)) {\n                minDist = dist;\n                minDiff = diff;\n                snapToValue = seriesNestestValue;\n                payloadBatch.length = 0;\n            }\n            each$17(dataIndices, function (dataIndex) {\n                payloadBatch.push({\n                    seriesIndex: series.seriesIndex,\n                    dataIndexInside: dataIndex,\n                    dataIndex: series.getData().getRawIndex(dataIndex)\n                });\n            });\n        }\n    });\n\n    return {\n        payloadBatch: payloadBatch,\n        snapToValue: snapToValue\n    };\n}\n\nfunction showPointer(showValueMap, axisInfo, value, payloadBatch) {\n    showValueMap[axisInfo.key] = {value: value, payloadBatch: payloadBatch};\n}\n\nfunction showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {\n    var payloadBatch = payloadInfo.payloadBatch;\n    var axis = axisInfo.axis;\n    var axisModel = axis.model;\n    var axisPointerModel = axisInfo.axisPointerModel;\n\n    // If no data, do not create anything in dataByCoordSys,\n    // whose length will be used to judge whether dispatch action.\n    if (!axisInfo.triggerTooltip || !payloadBatch.length) {\n        return;\n    }\n\n    var coordSysModel = axisInfo.coordSys.model;\n    var coordSysKey = makeKey(coordSysModel);\n    var coordSysItem = dataByCoordSys.map[coordSysKey];\n    if (!coordSysItem) {\n        coordSysItem = dataByCoordSys.map[coordSysKey] = {\n            coordSysId: coordSysModel.id,\n            coordSysIndex: coordSysModel.componentIndex,\n            coordSysType: coordSysModel.type,\n            coordSysMainType: coordSysModel.mainType,\n            dataByAxis: []\n        };\n        dataByCoordSys.list.push(coordSysItem);\n    }\n\n    coordSysItem.dataByAxis.push({\n        axisDim: axis.dim,\n        axisIndex: axisModel.componentIndex,\n        axisType: axisModel.type,\n        axisId: axisModel.id,\n        value: value,\n        // Caustion: viewHelper.getValueLabel is actually on \"view stage\", which\n        // depends that all models have been updated. So it should not be performed\n        // here. Considering axisPointerModel used here is volatile, which is hard\n        // to be retrieve in TooltipView, we prepare parameters here.\n        valueLabelOpt: {\n            precision: axisPointerModel.get('label.precision'),\n            formatter: axisPointerModel.get('label.formatter')\n        },\n        seriesDataIndices: payloadBatch.slice()\n    });\n}\n\nfunction updateModelActually(showValueMap, axesInfo, outputFinder) {\n    var outputAxesInfo = outputFinder.axesInfo = [];\n    // Basic logic: If no 'show' required, 'hide' this axisPointer.\n    each$17(axesInfo, function (axisInfo, key) {\n        var option = axisInfo.axisPointerModel.option;\n        var valItem = showValueMap[key];\n\n        if (valItem) {\n            !axisInfo.useHandle && (option.status = 'show');\n            option.value = valItem.value;\n            // For label formatter param and highlight.\n            option.seriesDataIndices = (valItem.payloadBatch || []).slice();\n        }\n        // When always show (e.g., handle used), remain\n        // original value and status.\n        else {\n            // If hide, value still need to be set, consider\n            // click legend to toggle axis blank.\n            !axisInfo.useHandle && (option.status = 'hide');\n        }\n\n        // If status is 'hide', should be no info in payload.\n        option.status === 'show' && outputAxesInfo.push({\n            axisDim: axisInfo.axis.dim,\n            axisIndex: axisInfo.axis.model.componentIndex,\n            value: option.value\n        });\n    });\n}\n\nfunction dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {\n    // Basic logic: If no showTip required, hideTip will be dispatched.\n    if (illegalPoint(point) || !dataByCoordSys.list.length) {\n        dispatchAction({type: 'hideTip'});\n        return;\n    }\n\n    // In most case only one axis (or event one series is used). It is\n    // convinient to fetch payload.seriesIndex and payload.dataIndex\n    // dirtectly. So put the first seriesIndex and dataIndex of the first\n    // axis on the payload.\n    var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};\n\n    dispatchAction({\n        type: 'showTip',\n        escapeConnect: true,\n        x: point[0],\n        y: point[1],\n        tooltipOption: payload.tooltipOption,\n        position: payload.position,\n        dataIndexInside: sampleItem.dataIndexInside,\n        dataIndex: sampleItem.dataIndex,\n        seriesIndex: sampleItem.seriesIndex,\n        dataByCoordSys: dataByCoordSys.list\n    });\n}\n\nfunction dispatchHighDownActually(axesInfo, dispatchAction, api) {\n    // FIXME\n    // highlight status modification shoule be a stage of main process?\n    // (Consider confilct (e.g., legend and axisPointer) and setOption)\n\n    var zr = api.getZr();\n    var highDownKey = 'axisPointerLastHighlights';\n    var lastHighlights = get$2(zr)[highDownKey] || {};\n    var newHighlights = get$2(zr)[highDownKey] = {};\n\n    // Update highlight/downplay status according to axisPointer model.\n    // Build hash map and remove duplicate incidentally.\n    each$17(axesInfo, function (axisInfo, key) {\n        var option = axisInfo.axisPointerModel.option;\n        option.status === 'show' && each$17(option.seriesDataIndices, function (batchItem) {\n            var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;\n            newHighlights[key] = batchItem;\n        });\n    });\n\n    // Diff.\n    var toHighlight = [];\n    var toDownplay = [];\n    each$1(lastHighlights, function (batchItem, key) {\n        !newHighlights[key] && toDownplay.push(batchItem);\n    });\n    each$1(newHighlights, function (batchItem, key) {\n        !lastHighlights[key] && toHighlight.push(batchItem);\n    });\n\n    toDownplay.length && api.dispatchAction({\n        type: 'downplay', escapeConnect: true, batch: toDownplay\n    });\n    toHighlight.length && api.dispatchAction({\n        type: 'highlight', escapeConnect: true, batch: toHighlight\n    });\n}\n\nfunction findInputAxisInfo(inputAxesInfo, axisInfo) {\n    for (var i = 0; i < (inputAxesInfo || []).length; i++) {\n        var inputAxisInfo = inputAxesInfo[i];\n        if (axisInfo.axis.dim === inputAxisInfo.axisDim\n            && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex\n        ) {\n            return inputAxisInfo;\n        }\n    }\n}\n\nfunction makeMapperParam(axisInfo) {\n    var axisModel = axisInfo.axis.model;\n    var item = {};\n    var dim = item.axisDim = axisInfo.axis.dim;\n    item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;\n    item.axisName = item[dim + 'AxisName'] = axisModel.name;\n    item.axisId = item[dim + 'AxisId'] = axisModel.id;\n    return item;\n}\n\nfunction illegalPoint(point) {\n    return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);\n}\n\nvar AxisPointerModel = extendComponentModel({\n\n    type: 'axisPointer',\n\n    coordSysAxesInfo: null,\n\n    defaultOption: {\n        // 'auto' means that show when triggered by tooltip or handle.\n        show: 'auto',\n        // 'click' | 'mousemove' | 'none'\n        triggerOn: null, // set default in AxisPonterView.js\n\n        zlevel: 0,\n        z: 50,\n\n        type: 'line',\n        // axispointer triggered by tootip determine snap automatically,\n        // see `modelHelper`.\n        snap: false,\n        triggerTooltip: true,\n\n        value: null,\n        status: null, // Init value depends on whether handle is used.\n\n        // [group0, group1, ...]\n        // Each group can be: {\n        //      mapper: function () {},\n        //      singleTooltip: 'multiple',  // 'multiple' or 'single'\n        //      xAxisId: ...,\n        //      yAxisName: ...,\n        //      angleAxisIndex: ...\n        // }\n        // mapper: can be ignored.\n        //      input: {axisInfo, value}\n        //      output: {axisInfo, value}\n        link: [],\n\n        // Do not set 'auto' here, otherwise global animation: false\n        // will not effect at this axispointer.\n        animation: null,\n        animationDurationUpdate: 200,\n\n        lineStyle: {\n            color: '#aaa',\n            width: 1,\n            type: 'solid'\n        },\n\n        shadowStyle: {\n            color: 'rgba(150,150,150,0.3)'\n        },\n\n        label: {\n            show: true,\n            formatter: null, // string | Function\n            precision: 'auto', // Or a number like 0, 1, 2 ...\n            margin: 3,\n            color: '#fff',\n            padding: [5, 7, 5, 7],\n            backgroundColor: 'auto', // default: axis line color\n            borderColor: null,\n            borderWidth: 0,\n            shadowBlur: 3,\n            shadowColor: '#aaa'\n            // Considering applicability, common style should\n            // better not have shadowOffset.\n            // shadowOffsetX: 0,\n            // shadowOffsetY: 2\n        },\n\n        handle: {\n            show: false,\n            icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z', // jshint ignore:line\n            size: 45,\n            // handle margin is from symbol center to axis, which is stable when circular move.\n            margin: 50,\n            // color: '#1b8bbd'\n            // color: '#2f4554'\n            color: '#333',\n            shadowBlur: 3,\n            shadowColor: '#aaa',\n            shadowOffsetX: 0,\n            shadowOffsetY: 2,\n\n            // For mobile performance\n            throttle: 40\n        }\n    }\n\n});\n\nvar get$3 = makeGetter();\nvar each$18 = each$1;\n\n/**\n * @param {string} key\n * @param {module:echarts/ExtensionAPI} api\n * @param {Function} handler\n *      param: {string} currTrigger\n *      param: {Array.<number>} point\n */\nfunction register(key, api, handler) {\n    if (env$1.node) {\n        return;\n    }\n\n    var zr = api.getZr();\n    get$3(zr).records || (get$3(zr).records = {});\n\n    initGlobalListeners(zr, api);\n\n    var record = get$3(zr).records[key] || (get$3(zr).records[key] = {});\n    record.handler = handler;\n}\n\nfunction initGlobalListeners(zr, api) {\n    if (get$3(zr).initialized) {\n        return;\n    }\n\n    get$3(zr).initialized = true;\n\n    useHandler('click', curry(doEnter, 'click'));\n    useHandler('mousemove', curry(doEnter, 'mousemove'));\n    // useHandler('mouseout', onLeave);\n    useHandler('globalout', onLeave);\n\n    function useHandler(eventType, cb) {\n        zr.on(eventType, function (e) {\n            var dis = makeDispatchAction(api);\n\n            each$18(get$3(zr).records, function (record) {\n                record && cb(record, e, dis.dispatchAction);\n            });\n\n            dispatchTooltipFinally(dis.pendings, api);\n        });\n    }\n}\n\nfunction dispatchTooltipFinally(pendings, api) {\n    var showLen = pendings.showTip.length;\n    var hideLen = pendings.hideTip.length;\n\n    var actuallyPayload;\n    if (showLen) {\n        actuallyPayload = pendings.showTip[showLen - 1];\n    }\n    else if (hideLen) {\n        actuallyPayload = pendings.hideTip[hideLen - 1];\n    }\n    if (actuallyPayload) {\n        actuallyPayload.dispatchAction = null;\n        api.dispatchAction(actuallyPayload);\n    }\n}\n\nfunction onLeave(record, e, dispatchAction) {\n    record.handler('leave', null, dispatchAction);\n}\n\nfunction doEnter(currTrigger, record, e, dispatchAction) {\n    record.handler(currTrigger, e, dispatchAction);\n}\n\nfunction makeDispatchAction(api) {\n    var pendings = {\n        showTip: [],\n        hideTip: []\n    };\n    // FIXME\n    // better approach?\n    // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\n    // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\n    // So we have to add \"final stage\" to merge those dispatched actions.\n    var dispatchAction = function (payload) {\n        var pendingList = pendings[payload.type];\n        if (pendingList) {\n            pendingList.push(payload);\n        }\n        else {\n            payload.dispatchAction = dispatchAction;\n            api.dispatchAction(payload);\n        }\n    };\n\n    return {\n        dispatchAction: dispatchAction,\n        pendings: pendings\n    };\n}\n\n/**\n * @param {string} key\n * @param {module:echarts/ExtensionAPI} api\n */\nfunction unregister(key, api) {\n    if (env$1.node) {\n        return;\n    }\n    var zr = api.getZr();\n    var record = (get$3(zr).records || {})[key];\n    if (record) {\n        get$3(zr).records[key] = null;\n    }\n}\n\nvar AxisPointerView = extendComponentView({\n\n    type: 'axisPointer',\n\n    render: function (globalAxisPointerModel, ecModel, api) {\n        var globalTooltipModel = ecModel.getComponent('tooltip');\n        var triggerOn = globalAxisPointerModel.get('triggerOn')\n            || (globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click');\n\n        // Register global listener in AxisPointerView to enable\n        // AxisPointerView to be independent to Tooltip.\n        register(\n            'axisPointer',\n            api,\n            function (currTrigger, e, dispatchAction) {\n                // If 'none', it is not controlled by mouse totally.\n                if (triggerOn !== 'none'\n                    && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)\n                ) {\n                    dispatchAction({\n                        type: 'updateAxisPointer',\n                        currTrigger: currTrigger,\n                        x: e && e.offsetX,\n                        y: e && e.offsetY\n                    });\n                }\n            }\n        );\n    },\n\n    /**\n     * @override\n     */\n    remove: function (ecModel, api) {\n        unregister(api.getZr(), 'axisPointer');\n        AxisPointerView.superApply(this._model, 'remove', arguments);\n    },\n\n    /**\n     * @override\n     */\n    dispose: function (ecModel, api) {\n        unregister('axisPointer', api);\n        AxisPointerView.superApply(this._model, 'dispose', arguments);\n    }\n\n});\n\nvar get$4 = makeGetter();\nvar clone$3 = clone;\nvar bind$2 = bind;\n\n/**\n * Base axis pointer class in 2D.\n * Implemenents {module:echarts/component/axis/IAxisPointer}.\n */\nfunction BaseAxisPointer () {\n}\n\nBaseAxisPointer.prototype = {\n\n    /**\n     * @private\n     */\n    _group: null,\n\n    /**\n     * @private\n     */\n    _lastGraphicKey: null,\n\n    /**\n     * @private\n     */\n    _handle: null,\n\n    /**\n     * @private\n     */\n    _dragging: false,\n\n    /**\n     * @private\n     */\n    _lastValue: null,\n\n    /**\n     * @private\n     */\n    _lastStatus: null,\n\n    /**\n     * @private\n     */\n    _payloadInfo: null,\n\n    /**\n     * In px, arbitrary value. Do not set too small,\n     * no animation is ok for most cases.\n     * @protected\n     */\n    animationThreshold: 15,\n\n    /**\n     * @implement\n     */\n    render: function (axisModel, axisPointerModel, api, forceRender) {\n        var value = axisPointerModel.get('value');\n        var status = axisPointerModel.get('status');\n\n        // Bind them to `this`, not in closure, otherwise they will not\n        // be replaced when user calling setOption in not merge mode.\n        this._axisModel = axisModel;\n        this._axisPointerModel = axisPointerModel;\n        this._api = api;\n\n        // Optimize: `render` will be called repeatly during mouse move.\n        // So it is power consuming if performing `render` each time,\n        // especially on mobile device.\n        if (!forceRender\n            && this._lastValue === value\n            && this._lastStatus === status\n        ) {\n            return;\n        }\n        this._lastValue = value;\n        this._lastStatus = status;\n\n        var group = this._group;\n        var handle = this._handle;\n\n        if (!status || status === 'hide') {\n            // Do not clear here, for animation better.\n            group && group.hide();\n            handle && handle.hide();\n            return;\n        }\n        group && group.show();\n        handle && handle.show();\n\n        // Otherwise status is 'show'\n        var elOption = {};\n        this.makeElOption(elOption, value, axisModel, axisPointerModel, api);\n\n        // Enable change axis pointer type.\n        var graphicKey = elOption.graphicKey;\n        if (graphicKey !== this._lastGraphicKey) {\n            this.clear(api);\n        }\n        this._lastGraphicKey = graphicKey;\n\n        var moveAnimation = this._moveAnimation =\n            this.determineAnimation(axisModel, axisPointerModel);\n\n        if (!group) {\n            group = this._group = new Group();\n            this.createPointerEl(group, elOption, axisModel, axisPointerModel);\n            this.createLabelEl(group, elOption, axisModel, axisPointerModel);\n            api.getZr().add(group);\n        }\n        else {\n            var doUpdateProps = curry(updateProps$1, axisPointerModel, moveAnimation);\n            this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);\n            this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);\n        }\n\n        updateMandatoryProps(group, axisPointerModel, true);\n\n        this._renderHandle(value);\n    },\n\n    /**\n     * @implement\n     */\n    remove: function (api) {\n        this.clear(api);\n    },\n\n    /**\n     * @implement\n     */\n    dispose: function (api) {\n        this.clear(api);\n    },\n\n    /**\n     * @protected\n     */\n    determineAnimation: function (axisModel, axisPointerModel) {\n        var animation = axisPointerModel.get('animation');\n        var axis = axisModel.axis;\n        var isCategoryAxis = axis.type === 'category';\n        var useSnap = axisPointerModel.get('snap');\n\n        // Value axis without snap always do not snap.\n        if (!useSnap && !isCategoryAxis) {\n            return false;\n        }\n\n        if (animation === 'auto' || animation == null) {\n            var animationThreshold = this.animationThreshold;\n            if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {\n                return true;\n            }\n\n            // It is important to auto animation when snap used. Consider if there is\n            // a dataZoom, animation will be disabled when too many points exist, while\n            // it will be enabled for better visual effect when little points exist.\n            if (useSnap) {\n                var seriesDataCount = getAxisInfo(axisModel).seriesDataCount;\n                var axisExtent = axis.getExtent();\n                // Approximate band width\n                return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;\n            }\n\n            return false;\n        }\n\n        return animation === true;\n    },\n\n    /**\n     * add {pointer, label, graphicKey} to elOption\n     * @protected\n     */\n    makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n        // Shoule be implemenented by sub-class.\n    },\n\n    /**\n     * @protected\n     */\n    createPointerEl: function (group, elOption, axisModel, axisPointerModel) {\n        var pointerOption = elOption.pointer;\n        if (pointerOption) {\n            var pointerEl = get$4(group).pointerEl = new graphic[pointerOption.type](\n                clone$3(elOption.pointer)\n            );\n            group.add(pointerEl);\n        }\n    },\n\n    /**\n     * @protected\n     */\n    createLabelEl: function (group, elOption, axisModel, axisPointerModel) {\n        if (elOption.label) {\n            var labelEl = get$4(group).labelEl = new Rect(\n                clone$3(elOption.label)\n            );\n\n            group.add(labelEl);\n            updateLabelShowHide(labelEl, axisPointerModel);\n        }\n    },\n\n    /**\n     * @protected\n     */\n    updatePointerEl: function (group, elOption, updateProps$$1) {\n        var pointerEl = get$4(group).pointerEl;\n        if (pointerEl) {\n            pointerEl.setStyle(elOption.pointer.style);\n            updateProps$$1(pointerEl, {shape: elOption.pointer.shape});\n        }\n    },\n\n    /**\n     * @protected\n     */\n    updateLabelEl: function (group, elOption, updateProps$$1, axisPointerModel) {\n        var labelEl = get$4(group).labelEl;\n        if (labelEl) {\n            labelEl.setStyle(elOption.label.style);\n            updateProps$$1(labelEl, {\n                // Consider text length change in vertical axis, animation should\n                // be used on shape, otherwise the effect will be weird.\n                shape: elOption.label.shape,\n                position: elOption.label.position\n            });\n\n            updateLabelShowHide(labelEl, axisPointerModel);\n        }\n    },\n\n    /**\n     * @private\n     */\n    _renderHandle: function (value) {\n        if (this._dragging || !this.updateHandleTransform) {\n            return;\n        }\n\n        var axisPointerModel = this._axisPointerModel;\n        var zr = this._api.getZr();\n        var handle = this._handle;\n        var handleModel = axisPointerModel.getModel('handle');\n\n        var status = axisPointerModel.get('status');\n        if (!handleModel.get('show') || !status || status === 'hide') {\n            handle && zr.remove(handle);\n            this._handle = null;\n            return;\n        }\n\n        var isInit;\n        if (!this._handle) {\n            isInit = true;\n            handle = this._handle = createIcon(\n                handleModel.get('icon'),\n                {\n                    cursor: 'move',\n                    draggable: true,\n                    onmousemove: function (e) {\n                        // Fot mobile devicem, prevent screen slider on the button.\n                        stop(e.event);\n                    },\n                    onmousedown: bind$2(this._onHandleDragMove, this, 0, 0),\n                    drift: bind$2(this._onHandleDragMove, this),\n                    ondragend: bind$2(this._onHandleDragEnd, this)\n                }\n            );\n            zr.add(handle);\n        }\n\n        updateMandatoryProps(handle, axisPointerModel, false);\n\n        // update style\n        var includeStyles = [\n            'color', 'borderColor', 'borderWidth', 'opacity',\n            'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'\n        ];\n        handle.setStyle(handleModel.getItemStyle(null, includeStyles));\n\n        // update position\n        var handleSize = handleModel.get('size');\n        if (!isArray(handleSize)) {\n            handleSize = [handleSize, handleSize];\n        }\n        handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);\n\n        createOrUpdate(\n            this,\n            '_doDispatchAxisPointer',\n            handleModel.get('throttle') || 0,\n            'fixRate'\n        );\n\n        this._moveHandleToValue(value, isInit);\n    },\n\n    /**\n     * @private\n     */\n    _moveHandleToValue: function (value, isInit) {\n        updateProps$1(\n            this._axisPointerModel,\n            !isInit && this._moveAnimation,\n            this._handle,\n            getHandleTransProps(this.getHandleTransform(\n                value, this._axisModel, this._axisPointerModel\n            ))\n        );\n    },\n\n    /**\n     * @private\n     */\n    _onHandleDragMove: function (dx, dy) {\n        var handle = this._handle;\n        if (!handle) {\n            return;\n        }\n\n        this._dragging = true;\n\n        // Persistent for throttle.\n        var trans = this.updateHandleTransform(\n            getHandleTransProps(handle),\n            [dx, dy],\n            this._axisModel,\n            this._axisPointerModel\n        );\n        this._payloadInfo = trans;\n\n        handle.stopAnimation();\n        handle.attr(getHandleTransProps(trans));\n        get$4(handle).lastProp = null;\n\n        this._doDispatchAxisPointer();\n    },\n\n    /**\n     * Throttled method.\n     * @private\n     */\n    _doDispatchAxisPointer: function () {\n        var handle = this._handle;\n        if (!handle) {\n            return;\n        }\n\n        var payloadInfo = this._payloadInfo;\n        var axisModel = this._axisModel;\n        this._api.dispatchAction({\n            type: 'updateAxisPointer',\n            x: payloadInfo.cursorPoint[0],\n            y: payloadInfo.cursorPoint[1],\n            tooltipOption: payloadInfo.tooltipOption,\n            axesInfo: [{\n                axisDim: axisModel.axis.dim,\n                axisIndex: axisModel.componentIndex\n            }]\n        });\n    },\n\n    /**\n     * @private\n     */\n    _onHandleDragEnd: function (moveAnimation) {\n        this._dragging = false;\n        var handle = this._handle;\n        if (!handle) {\n            return;\n        }\n\n        var value = this._axisPointerModel.get('value');\n        // Consider snap or categroy axis, handle may be not consistent with\n        // axisPointer. So move handle to align the exact value position when\n        // drag ended.\n        this._moveHandleToValue(value);\n\n        // For the effect: tooltip will be shown when finger holding on handle\n        // button, and will be hidden after finger left handle button.\n        this._api.dispatchAction({\n            type: 'hideTip'\n        });\n    },\n\n    /**\n     * Should be implemenented by sub-class if support `handle`.\n     * @protected\n     * @param {number} value\n     * @param {module:echarts/model/Model} axisModel\n     * @param {module:echarts/model/Model} axisPointerModel\n     * @return {Object} {position: [x, y], rotation: 0}\n     */\n    getHandleTransform: null,\n\n    /**\n     * * Should be implemenented by sub-class if support `handle`.\n     * @protected\n     * @param {Object} transform {position, rotation}\n     * @param {Array.<number>} delta [dx, dy]\n     * @param {module:echarts/model/Model} axisModel\n     * @param {module:echarts/model/Model} axisPointerModel\n     * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}\n     */\n    updateHandleTransform: null,\n\n    /**\n     * @private\n     */\n    clear: function (api) {\n        this._lastValue = null;\n        this._lastStatus = null;\n\n        var zr = api.getZr();\n        var group = this._group;\n        var handle = this._handle;\n        if (zr && group) {\n            this._lastGraphicKey = null;\n            group && zr.remove(group);\n            handle && zr.remove(handle);\n            this._group = null;\n            this._handle = null;\n            this._payloadInfo = null;\n        }\n    },\n\n    /**\n     * @protected\n     */\n    doClear: function () {\n        // Implemented by sub-class if necessary.\n    },\n\n    /**\n     * @protected\n     * @param {Array.<number>} xy\n     * @param {Array.<number>} wh\n     * @param {number} [xDimIndex=0] or 1\n     */\n    buildLabel: function (xy, wh, xDimIndex) {\n        xDimIndex = xDimIndex || 0;\n        return {\n            x: xy[xDimIndex],\n            y: xy[1 - xDimIndex],\n            width: wh[xDimIndex],\n            height: wh[1 - xDimIndex]\n        };\n    }\n};\n\nBaseAxisPointer.prototype.constructor = BaseAxisPointer;\n\n\nfunction updateProps$1(animationModel, moveAnimation, el, props) {\n    // Animation optimize.\n    if (!propsEqual(get$4(el).lastProp, props)) {\n        get$4(el).lastProp = props;\n        moveAnimation\n            ? updateProps(el, props, animationModel)\n            : (el.stopAnimation(), el.attr(props));\n    }\n}\n\nfunction propsEqual(lastProps, newProps) {\n    if (isObject(lastProps) && isObject(newProps)) {\n        var equals = true;\n        each$1(newProps, function (item, key) {\n            equals = equals && propsEqual(lastProps[key], item);\n        });\n        return !!equals;\n    }\n    else {\n        return lastProps === newProps;\n    }\n}\n\nfunction updateLabelShowHide(labelEl, axisPointerModel) {\n    labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();\n}\n\nfunction getHandleTransProps(trans) {\n    return {\n        position: trans.position.slice(),\n        rotation: trans.rotation || 0\n    };\n}\n\nfunction updateMandatoryProps(group, axisPointerModel, silent) {\n    var z = axisPointerModel.get('z');\n    var zlevel = axisPointerModel.get('zlevel');\n\n    group && group.traverse(function (el) {\n        if (el.type !== 'group') {\n            z != null && (el.z = z);\n            zlevel != null && (el.zlevel = zlevel);\n            el.silent = silent;\n        }\n    });\n}\n\nenableClassExtend(BaseAxisPointer);\n\n/**\n * @param {module:echarts/model/Model} axisPointerModel\n */\nfunction buildElStyle(axisPointerModel) {\n    var axisPointerType = axisPointerModel.get('type');\n    var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n    var style;\n    if (axisPointerType === 'line') {\n        style = styleModel.getLineStyle();\n        style.fill = null;\n    }\n    else if (axisPointerType === 'shadow') {\n        style = styleModel.getAreaStyle();\n        style.stroke = null;\n    }\n    return style;\n}\n\n/**\n * @param {Function} labelPos {align, verticalAlign, position}\n */\nfunction buildLabelElOption(\n    elOption, axisModel, axisPointerModel, api, labelPos\n) {\n    var value = axisPointerModel.get('value');\n    var text = getValueLabel(\n        value, axisModel.axis, axisModel.ecModel,\n        axisPointerModel.get('seriesDataIndices'),\n        {\n            precision: axisPointerModel.get('label.precision'),\n            formatter: axisPointerModel.get('label.formatter')\n        }\n    );\n    var labelModel = axisPointerModel.getModel('label');\n    var paddings = normalizeCssArray$1(labelModel.get('padding') || 0);\n\n    var font = labelModel.getFont();\n    var textRect = getBoundingRect(text, font);\n\n    var position = labelPos.position;\n    var width = textRect.width + paddings[1] + paddings[3];\n    var height = textRect.height + paddings[0] + paddings[2];\n\n    // Adjust by align.\n    var align = labelPos.align;\n    align === 'right' && (position[0] -= width);\n    align === 'center' && (position[0] -= width / 2);\n    var verticalAlign = labelPos.verticalAlign;\n    verticalAlign === 'bottom' && (position[1] -= height);\n    verticalAlign === 'middle' && (position[1] -= height / 2);\n\n    // Not overflow ec container\n    confineInContainer(position, width, height, api);\n\n    var bgColor = labelModel.get('backgroundColor');\n    if (!bgColor || bgColor === 'auto') {\n        bgColor = axisModel.get('axisLine.lineStyle.color');\n    }\n\n    elOption.label = {\n        shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},\n        position: position.slice(),\n        // TODO: rich\n        style: {\n            text: text,\n            textFont: font,\n            textFill: labelModel.getTextColor(),\n            textPosition: 'inside',\n            fill: bgColor,\n            stroke: labelModel.get('borderColor') || 'transparent',\n            lineWidth: labelModel.get('borderWidth') || 0,\n            shadowBlur: labelModel.get('shadowBlur'),\n            shadowColor: labelModel.get('shadowColor'),\n            shadowOffsetX: labelModel.get('shadowOffsetX'),\n            shadowOffsetY: labelModel.get('shadowOffsetY')\n        },\n        // Lable should be over axisPointer.\n        z2: 10\n    };\n}\n\n// Do not overflow ec container\nfunction confineInContainer(position, width, height, api) {\n    var viewWidth = api.getWidth();\n    var viewHeight = api.getHeight();\n    position[0] = Math.min(position[0] + width, viewWidth) - width;\n    position[1] = Math.min(position[1] + height, viewHeight) - height;\n    position[0] = Math.max(position[0], 0);\n    position[1] = Math.max(position[1], 0);\n}\n\n/**\n * @param {number} value\n * @param {module:echarts/coord/Axis} axis\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} opt\n * @param {Array.<Object>} seriesDataIndices\n * @param {number|string} opt.precision 'auto' or a number\n * @param {string|Function} opt.formatter label formatter\n */\nfunction getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {\n    var text = axis.scale.getLabel(\n        // If `precision` is set, width can be fixed (like '12.00500'), which\n        // helps to debounce when when moving label.\n        value, {precision: opt.precision}\n    );\n    var formatter = opt.formatter;\n\n    if (formatter) {\n        var params = {\n            value: getAxisRawValue(axis, value),\n            seriesData: []\n        };\n        each$1(seriesDataIndices, function (idxItem) {\n            var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n            var dataIndex = idxItem.dataIndexInside;\n            var dataParams = series && series.getDataParams(dataIndex);\n            dataParams && params.seriesData.push(dataParams);\n        });\n\n        if (isString(formatter)) {\n            text = formatter.replace('{value}', text);\n        }\n        else if (isFunction(formatter)) {\n            text = formatter(params);\n        }\n    }\n\n    return text;\n}\n\n/**\n * @param {module:echarts/coord/Axis} axis\n * @param {number} value\n * @param {Object} layoutInfo {\n *  rotation, position, labelOffset, labelDirection, labelMargin\n * }\n */\nfunction getTransformedPosition (axis, value, layoutInfo) {\n    var transform = create$1();\n    rotate(transform, transform, layoutInfo.rotation);\n    translate(transform, transform, layoutInfo.position);\n\n    return applyTransform$1([\n        axis.dataToCoord(value),\n        (layoutInfo.labelOffset || 0)\n            + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)\n    ], transform);\n}\n\nfunction buildCartesianSingleLabelElOption(\n    value, elOption, layoutInfo, axisModel, axisPointerModel, api\n) {\n    var textLayout = AxisBuilder.innerTextLayout(\n        layoutInfo.rotation, 0, layoutInfo.labelDirection\n    );\n    layoutInfo.labelMargin = axisPointerModel.get('label.margin');\n    buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n        position: getTransformedPosition(axisModel.axis, value, layoutInfo),\n        align: textLayout.textAlign,\n        verticalAlign: textLayout.textVerticalAlign\n    });\n}\n\n/**\n * @param {Array.<number>} p1\n * @param {Array.<number>} p2\n * @param {number} [xDimIndex=0] or 1\n */\nfunction makeLineShape(p1, p2, xDimIndex) {\n    xDimIndex = xDimIndex || 0;\n    return {\n        x1: p1[xDimIndex],\n        y1: p1[1 - xDimIndex],\n        x2: p2[xDimIndex],\n        y2: p2[1 - xDimIndex]\n    };\n}\n\n/**\n * @param {Array.<number>} xy\n * @param {Array.<number>} wh\n * @param {number} [xDimIndex=0] or 1\n */\nfunction makeRectShape(xy, wh, xDimIndex) {\n    xDimIndex = xDimIndex || 0;\n    return {\n        x: xy[xDimIndex],\n        y: xy[1 - xDimIndex],\n        width: wh[xDimIndex],\n        height: wh[1 - xDimIndex]\n    };\n}\n\nfunction makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n    return {\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: r,\n        startAngle: startAngle,\n        endAngle: endAngle,\n        clockwise: true\n    };\n}\n\nvar CartesianAxisPointer = BaseAxisPointer.extend({\n\n    /**\n     * @override\n     */\n    makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n        var axis = axisModel.axis;\n        var grid = axis.grid;\n        var axisPointerType = axisPointerModel.get('type');\n        var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n        var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));\n\n        if (axisPointerType && axisPointerType !== 'none') {\n            var elStyle = buildElStyle(axisPointerModel);\n            var pointerOption = pointerShapeBuilder[axisPointerType](\n                axis, pixelValue, otherExtent, elStyle\n            );\n            pointerOption.style = elStyle;\n            elOption.graphicKey = pointerOption.type;\n            elOption.pointer = pointerOption;\n        }\n\n        var layoutInfo = layout(grid.model, axisModel);\n        buildCartesianSingleLabelElOption(\n            value, elOption, layoutInfo, axisModel, axisPointerModel, api\n        );\n    },\n\n    /**\n     * @override\n     */\n    getHandleTransform: function (value, axisModel, axisPointerModel) {\n        var layoutInfo = layout(axisModel.axis.grid.model, axisModel, {\n            labelInside: false\n        });\n        layoutInfo.labelMargin = axisPointerModel.get('handle.margin');\n        return {\n            position: getTransformedPosition(axisModel.axis, value, layoutInfo),\n            rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n        };\n    },\n\n    /**\n     * @override\n     */\n    updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {\n        var axis = axisModel.axis;\n        var grid = axis.grid;\n        var axisExtent = axis.getGlobalExtent(true);\n        var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n        var dimIndex = axis.dim === 'x' ? 0 : 1;\n\n        var currPosition = transform.position;\n        currPosition[dimIndex] += delta[dimIndex];\n        currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n        currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n\n        var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n        var cursorPoint = [cursorOtherValue, cursorOtherValue];\n        cursorPoint[dimIndex] = currPosition[dimIndex];\n\n        // Make tooltip do not overlap axisPointer and in the middle of the grid.\n        var tooltipOptions = [{verticalAlign: 'middle'}, {align: 'center'}];\n\n        return {\n            position: currPosition,\n            rotation: transform.rotation,\n            cursorPoint: cursorPoint,\n            tooltipOption: tooltipOptions[dimIndex]\n        };\n    }\n\n});\n\nfunction getCartesian(grid, axis) {\n    var opt = {};\n    opt[axis.dim + 'AxisIndex'] = axis.index;\n    return grid.getCartesian(opt);\n}\n\nvar pointerShapeBuilder = {\n\n    line: function (axis, pixelValue, otherExtent, elStyle) {\n        var targetShape = makeLineShape(\n            [pixelValue, otherExtent[0]],\n            [pixelValue, otherExtent[1]],\n            getAxisDimIndex(axis)\n        );\n        subPixelOptimizeLine({\n            shape: targetShape,\n            style: elStyle\n        });\n        return {\n            type: 'Line',\n            shape: targetShape\n        };\n    },\n\n    shadow: function (axis, pixelValue, otherExtent, elStyle) {\n        var bandWidth = axis.getBandWidth();\n        var span = otherExtent[1] - otherExtent[0];\n        return {\n            type: 'Rect',\n            shape: makeRectShape(\n                [pixelValue - bandWidth / 2, otherExtent[0]],\n                [bandWidth, span],\n                getAxisDimIndex(axis)\n            )\n        };\n    }\n};\n\nfunction getAxisDimIndex(axis) {\n    return axis.dim === 'x' ? 0 : 1;\n}\n\nAxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);\n\n// CartesianAxisPointer is not supposed to be required here. But consider\n// echarts.simple.js and online build tooltip, which only require gridSimple,\n// CartesianAxisPointer should be able to required somewhere.\nregisterPreprocessor(function (option) {\n    // Always has a global axisPointerModel for default setting.\n    if (option) {\n        (!option.axisPointer || option.axisPointer.length === 0)\n            && (option.axisPointer = {});\n\n        var link = option.axisPointer.link;\n        // Normalize to array to avoid object mergin. But if link\n        // is not set, remain null/undefined, otherwise it will\n        // override existent link setting.\n        if (link && !isArray(link)) {\n            option.axisPointer.link = [link];\n        }\n    }\n});\n\n// This process should proformed after coordinate systems created\n// and series data processed. So put it on statistic processing stage.\nregisterProcessor(PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {\n    // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n    // allAxesInfo should be updated when setOption performed.\n    ecModel.getComponent('axisPointer').coordSysAxesInfo\n        = collect(ecModel, api);\n});\n\n// Broadcast to all views.\nregisterAction({\n    type: 'updateAxisPointer',\n    event: 'updateAxisPointer',\n    update: ':updateAxisPointer'\n}, axisTrigger);\n\nvar XY = ['x', 'y'];\nvar WH = ['width', 'height'];\n\nvar SingleAxisPointer = BaseAxisPointer.extend({\n\n    /**\n     * @override\n     */\n    makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n        var axis = axisModel.axis;\n        var coordSys = axis.coordinateSystem;\n        var otherExtent = getGlobalExtent(coordSys, 1 - getPointDimIndex(axis));\n        var pixelValue = coordSys.dataToPoint(value)[0];\n\n        var axisPointerType = axisPointerModel.get('type');\n        if (axisPointerType && axisPointerType !== 'none') {\n            var elStyle = buildElStyle(axisPointerModel);\n            var pointerOption = pointerShapeBuilder$1[axisPointerType](\n                axis, pixelValue, otherExtent, elStyle\n            );\n            pointerOption.style = elStyle;\n\n            elOption.graphicKey = pointerOption.type;\n            elOption.pointer = pointerOption;\n        }\n\n        var layoutInfo = layout$1(axisModel);\n        buildCartesianSingleLabelElOption(\n            value, elOption, layoutInfo, axisModel, axisPointerModel, api\n        );\n    },\n\n    /**\n     * @override\n     */\n    getHandleTransform: function (value, axisModel, axisPointerModel) {\n        var layoutInfo = layout$1(axisModel, {labelInside: false});\n        layoutInfo.labelMargin = axisPointerModel.get('handle.margin');\n        return {\n            position: getTransformedPosition(axisModel.axis, value, layoutInfo),\n            rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n        };\n    },\n\n    /**\n     * @override\n     */\n    updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {\n        var axis = axisModel.axis;\n        var coordSys = axis.coordinateSystem;\n        var dimIndex = getPointDimIndex(axis);\n        var axisExtent = getGlobalExtent(coordSys, dimIndex);\n        var currPosition = transform.position;\n        currPosition[dimIndex] += delta[dimIndex];\n        currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n        currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n        var otherExtent = getGlobalExtent(coordSys, 1 - dimIndex);\n        var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n        var cursorPoint = [cursorOtherValue, cursorOtherValue];\n        cursorPoint[dimIndex] = currPosition[dimIndex];\n\n        return {\n            position: currPosition,\n            rotation: transform.rotation,\n            cursorPoint: cursorPoint,\n            tooltipOption: {\n                verticalAlign: 'middle'\n            }\n        };\n    }\n});\n\nvar pointerShapeBuilder$1 = {\n\n    line: function (axis, pixelValue, otherExtent, elStyle) {\n        var targetShape = makeLineShape(\n            [pixelValue, otherExtent[0]],\n            [pixelValue, otherExtent[1]],\n            getPointDimIndex(axis)\n        );\n        subPixelOptimizeLine({\n            shape: targetShape,\n            style: elStyle\n        });\n        return {\n            type: 'Line',\n            shape: targetShape\n        };\n    },\n\n    shadow: function (axis, pixelValue, otherExtent, elStyle) {\n        var bandWidth = axis.getBandWidth();\n        var span = otherExtent[1] - otherExtent[0];\n        return {\n            type: 'Rect',\n            shape: makeRectShape(\n                [pixelValue - bandWidth / 2, otherExtent[0]],\n                [bandWidth, span],\n                getPointDimIndex(axis)\n            )\n        };\n    }\n};\n\nfunction getPointDimIndex(axis) {\n    return axis.isHorizontal() ? 0 : 1;\n}\n\nfunction getGlobalExtent(coordSys, dimIndex) {\n    var rect = coordSys.getRect();\n    return [rect[XY[dimIndex]], rect[XY[dimIndex]] + rect[WH[dimIndex]]];\n}\n\nAxisView.registerAxisPointerClass('SingleAxisPointer', SingleAxisPointer);\n\nextendComponentView({\n    type: 'single'\n});\n\n/**\n * @file  Define the themeRiver view's series model\n * @author Deqing Li(annong035@gmail.com)\n */\n\nvar DATA_NAME_INDEX = 2;\n\nvar ThemeRiverSeries = SeriesModel.extend({\n\n    type: 'series.themeRiver',\n\n    dependencies: ['singleAxis'],\n\n    /**\n     * @readOnly\n     * @type {module:zrender/core/util#HashMap}\n     */\n    nameMap: null,\n\n    /**\n     * @override\n     */\n    init: function (option) {\n        ThemeRiverSeries.superApply(this, 'init', arguments);\n\n        // Put this function here is for the sake of consistency of code style.\n        // Enable legend selection for each data item\n        // Use a function instead of direct access because data reference may changed\n        this.legendDataProvider = function () {\n            return this.getRawData();\n        };\n    },\n\n    /**\n     * If there is no value of a certain point in the time for some event,set it value to 0.\n     *\n     * @param {Array} data  initial data in the option\n     * @return {Array}\n     */\n    fixData: function (data) {\n        var rawDataLength = data.length;\n\n        // grouped data by name\n        var dataByName = nest()\n            .key(function (dataItem) {\n                return dataItem[2];\n            })\n            .entries(data);\n\n        // data group in each layer\n        var layData = map(dataByName, function (d) {\n            return {\n                name: d.key,\n                dataList: d.values\n            };\n        });\n\n        var layerNum = layData.length;\n        var largestLayer = -1;\n        var index = -1;\n        for (var i = 0; i < layerNum; ++i) {\n            var len = layData[i].dataList.length;\n            if (len > largestLayer) {\n                largestLayer = len;\n                index = i;\n            }\n        }\n\n        for (var k = 0; k < layerNum; ++k) {\n            if (k === index) {\n                continue;\n            }\n            var name = layData[k].name;\n            for (var j = 0; j < largestLayer; ++j) {\n                var timeValue = layData[index].dataList[j][0];\n                var length = layData[k].dataList.length;\n                var keyIndex = -1;\n                for (var l = 0; l < length; ++l) {\n                    var value = layData[k].dataList[l][0];\n                    if (value === timeValue) {\n                        keyIndex = l;\n                        break;\n                    }\n                }\n                if (keyIndex === -1) {\n                    data[rawDataLength] = [];\n                    data[rawDataLength][0] = timeValue;\n                    data[rawDataLength][1] = 0;\n                    data[rawDataLength][2] = name;\n                    rawDataLength++;\n\n                }\n            }\n        }\n        return data;\n    },\n\n    /**\n     * @override\n     * @param  {Object} option  the initial option that user gived\n     * @param  {module:echarts/model/Model} ecModel  the model object for themeRiver option\n     * @return {module:echarts/data/List}\n     */\n    getInitialData: function (option, ecModel) {\n\n        var dimensions = [];\n\n        var singleAxisModel = ecModel.queryComponents({\n            mainType: 'singleAxis',\n            index: this.get('singleAxisIndex'),\n            id: this.get('singleAxisId')\n        })[0];\n\n        var axisType = singleAxisModel.get('type');\n\n        dimensions = [\n            {\n                name: 'time',\n                // FIXME common?\n                type: axisType === 'category'\n                    ? 'ordinal'\n                    : axisType === 'time'\n                    ? 'time'\n                    : 'float'\n            },\n            {\n                name: 'value',\n                type: 'float'\n            },\n            {\n                name: 'name',\n                type: 'ordinal'\n            }\n        ];\n\n        // filter the data item with the value of label is undefined\n        var filterData = filter(option.data, function (dataItem) {\n            return dataItem[2] !== undefined;\n        });\n\n        var data = this.fixData(filterData || []);\n        var nameList = [];\n        var nameMap = this.nameMap = createHashMap();\n        var count = 0;\n\n        for (var i = 0; i < data.length; ++i) {\n            nameList.push(data[i][DATA_NAME_INDEX]);\n            if (!nameMap.get(data[i][DATA_NAME_INDEX])) {\n                nameMap.set(data[i][DATA_NAME_INDEX], count);\n                count++;\n            }\n        }\n\n        dimensions = completeDimensions(dimensions, data);\n\n        var list = new List(dimensions, this);\n\n        list.initData(data, nameList);\n\n        return list;\n    },\n\n    /**\n     * Used by single coordinate\n     *\n     * @param {string} axisDim  the dimension for single coordinate\n     * @return {Array.<string> } specified dimensions on the axis.\n     */\n    coordDimToDataDim: function (axisDim) {\n        return ['time'];\n    },\n\n    /**\n     * The raw data is divided into multiple layers and each layer\n     *     has same name.\n     *\n     * @return {Array.<Array.<number>>}\n     */\n    getLayerSeries: function () {\n        var data = this.getData();\n        var lenCount = data.count();\n        var indexArr = [];\n\n        for (var i = 0; i < lenCount; ++i) {\n            indexArr[i] = i;\n        }\n        // data group by name\n        var dataByName = nest()\n            .key(function (index) {\n                return data.get('name', index);\n            })\n            .entries(indexArr);\n\n        var layerSeries = map(dataByName, function (d) {\n            return {\n                name: d.key,\n                indices: d.values\n            };\n        });\n\n        for (var j = 0; j < layerSeries.length; ++j) {\n            layerSeries[j].indices.sort(comparer);\n        }\n\n        function comparer(index1, index2) {\n            return data.get('time', index1) - data.get('time', index2);\n        }\n\n        return layerSeries;\n    },\n\n    /**\n     * Get data indices for show tooltip content\n     *\n     * @param {Array.<string>|string} dim  single coordinate dimension\n     * @param {number} value axis value\n     * @param {module:echarts/coord/single/SingleAxis} baseAxis  single Axis used\n     *     the themeRiver.\n     * @return {Object} {dataIndices, nestestValue}\n     */\n    getAxisTooltipData: function (dim, value, baseAxis) {\n        if (!isArray(dim)) {\n            dim = dim ? [dim] : [];\n        }\n\n        var data = this.getData();\n        var layerSeries = this.getLayerSeries();\n        var indices = [];\n        var layerNum = layerSeries.length;\n        var nestestValue;\n\n        for (var i = 0; i < layerNum; ++i) {\n            var minDist = Number.MAX_VALUE;\n            var nearestIdx = -1;\n            var pointNum = layerSeries[i].indices.length;\n            for (var j = 0; j < pointNum; ++j) {\n                var theValue = data.get(dim[0], layerSeries[i].indices[j]);\n                var dist = Math.abs(theValue - value);\n                if (dist <= minDist) {\n                    nestestValue = theValue;\n                    minDist = dist;\n                    nearestIdx = layerSeries[i].indices[j];\n                }\n            }\n            indices.push(nearestIdx);\n        }\n\n        return {dataIndices: indices, nestestValue: nestestValue};\n    },\n\n    /**\n     * @override\n     * @param {number} dataIndex  index of data\n     */\n    formatTooltip: function (dataIndex) {\n        var data = this.getData();\n        var htmlName = data.get('name', dataIndex);\n        var htmlValue = data.get('value', dataIndex);\n        if (isNaN(htmlValue) || htmlValue == null) {\n            htmlValue = '-';\n        }\n        return encodeHTML(htmlName + ' : ' + htmlValue);\n    },\n\n    defaultOption: {\n        zlevel: 0,\n        z: 2,\n\n        coordinateSystem: 'singleAxis',\n\n        // gap in axis's orthogonal orientation\n        boundaryGap: ['10%', '10%'],\n\n        // legendHoverLink: true,\n\n        singleAxisIndex: 0,\n\n        animationEasing: 'linear',\n\n        label: {\n            normal: {\n                margin: 4,\n                textAlign: 'right',\n                show: true,\n                position: 'left',\n                color: '#000',\n                fontSize: 11\n            },\n            emphasis: {\n                show: true\n            }\n        }\n    }\n});\n\n/**\n * @file  The file used to draw themeRiver view\n * @author  Deqing Li(annong035@gmail.com)\n */\n\nextendChartView({\n\n    type: 'themeRiver',\n\n    init: function () {\n        this._layers = [];\n    },\n\n    render: function (seriesModel, ecModel, api) {\n        var data = seriesModel.getData();\n\n        var group = this.group;\n\n        var layerSeries = seriesModel.getLayerSeries();\n\n        var layoutInfo = data.getLayout('layoutInfo');\n        var rect = layoutInfo.rect;\n        var boundaryGap = layoutInfo.boundaryGap;\n\n        group.attr('position', [0, rect.y + boundaryGap[0]]);\n\n        function keyGetter(item) {\n            return item.name;\n        }\n        var dataDiffer = new DataDiffer(\n            this._layersSeries || [], layerSeries,\n            keyGetter, keyGetter\n        );\n\n        var newLayersGroups = {};\n\n        dataDiffer\n            .add(bind(process, this, 'add'))\n            .update(bind(process, this, 'update'))\n            .remove(bind(process, this, 'remove'))\n            .execute();\n\n        function process(status, idx, oldIdx) {\n            var oldLayersGroups = this._layers;\n            if (status === 'remove') {\n                group.remove(oldLayersGroups[idx]);\n                return;\n            }\n            var points0 = [];\n            var points1 = [];\n            var color;\n            var indices = layerSeries[idx].indices;\n            for (var j = 0; j < indices.length; j++) {\n                var layout = data.getItemLayout(indices[j]);\n                var x = layout.x;\n                var y0 = layout.y0;\n                var y = layout.y;\n\n                points0.push([x, y0]);\n                points1.push([x, y0 + y]);\n\n                color = data.getItemVisual(indices[j], 'color');\n            }\n\n            var polygon;\n            var text;\n            var textLayout = data.getItemLayout(indices[0]);\n            var itemModel = data.getItemModel(indices[j - 1]);\n            var labelModel = itemModel.getModel('label.normal');\n            var margin = labelModel.get('margin');\n            if (status === 'add') {\n                var layerGroup = newLayersGroups[idx] = new Group();\n                polygon = new Polygon$1({\n                    shape: {\n                        points: points0,\n                        stackedOnPoints: points1,\n                        smooth: 0.4,\n                        stackedOnSmooth: 0.4,\n                        smoothConstraint: false\n                    },\n                    z2: 0\n                });\n                text = new Text({\n                    style: {\n                        x: textLayout.x - margin,\n                        y: textLayout.y0 + textLayout.y / 2\n                    }\n                });\n                layerGroup.add(polygon);\n                layerGroup.add(text);\n                group.add(layerGroup);\n\n                polygon.setClipPath(createGridClipShape$3(polygon.getBoundingRect(), seriesModel, function () {\n                    polygon.removeClipPath();\n                }));\n            }\n            else {\n                var layerGroup = oldLayersGroups[oldIdx];\n                polygon = layerGroup.childAt(0);\n                text = layerGroup.childAt(1);\n                group.add(layerGroup);\n\n                newLayersGroups[idx] = layerGroup;\n\n                updateProps(polygon, {\n                    shape: {\n                        points: points0,\n                        stackedOnPoints: points1\n                    }\n                }, seriesModel);\n\n                updateProps(text, {\n                    style: {\n                        x: textLayout.x - margin,\n                        y: textLayout.y0 + textLayout.y / 2\n                    }\n                }, seriesModel);\n            }\n\n            var hoverItemStyleModel = itemModel.getModel('itemStyle.emphasis');\n            var itemStyleModel = itemModel.getModel('itemStyle.normal');\n\n            setTextStyle(text.style, labelModel, {\n                text: labelModel.get('show')\n                    ? seriesModel.getFormattedLabel(indices[j - 1], 'normal')\n                        || data.getName(indices[j - 1])\n                    : null,\n                textVerticalAlign: 'middle'\n            });\n\n            polygon.setStyle(extend({\n                fill: color\n            }, itemStyleModel.getItemStyle(['color'])));\n\n            setHoverStyle(polygon, hoverItemStyleModel.getItemStyle());\n        }\n\n        this._layersSeries = layerSeries;\n        this._layers = newLayersGroups;\n    },\n\n    dispose: function () {}\n});\n\n// add animation to the view\nfunction createGridClipShape$3(rect, seriesModel, cb) {\n    var rectEl = new Rect({\n        shape: {\n            x: rect.x - 10,\n            y: rect.y - 10,\n            width: 0,\n            height: rect.height + 20\n        }\n    });\n    initProps(rectEl, {\n        shape: {\n            width: rect.width + 20,\n            height: rect.height + 20\n        }\n    }, seriesModel, cb);\n\n    return rectEl;\n}\n\n/**\n * @file  Using layout algorithm transform the raw data to layout information.\n * @author Deqing Li(annong035@gmail.com)\n */\n\nvar themeRiverLayout = function (ecModel, api) {\n\n    ecModel.eachSeriesByType('themeRiver', function (seriesModel) {\n\n        var data = seriesModel.getData();\n\n        var single = seriesModel.coordinateSystem;\n\n        var layoutInfo = {};\n\n        // use the axis boundingRect for view\n        var rect = single.getRect();\n\n        layoutInfo.rect = rect;\n\n        var boundaryGap = seriesModel.get('boundaryGap');\n\n        var axis = single.getAxis();\n\n        layoutInfo.boundaryGap = boundaryGap;\n\n        if (axis.orient === 'horizontal') {\n            boundaryGap[0] = parsePercent$1(boundaryGap[0], rect.height);\n            boundaryGap[1] = parsePercent$1(boundaryGap[1], rect.height);\n            var height = rect.height - boundaryGap[0] - boundaryGap[1];\n            themeRiverLayout$1(data, seriesModel, height);\n        }\n        else {\n            boundaryGap[0] = parsePercent$1(boundaryGap[0], rect.width);\n            boundaryGap[1] = parsePercent$1(boundaryGap[1], rect.width);\n            var width = rect.width - boundaryGap[0] - boundaryGap[1];\n            themeRiverLayout$1(data, seriesModel, width);\n        }\n\n        data.setLayout('layoutInfo', layoutInfo);\n    });\n};\n\n/**\n * The layout information about themeriver\n *\n * @param {module:echarts/data/List} data  data in the series\n * @param {module:echarts/model/Series} seriesModel  the model object of themeRiver series\n * @param {number} height  value used to compute every series height\n */\nfunction themeRiverLayout$1(data, seriesModel, height) {\n    if (!data.count()) {\n        return;\n    }\n    var coordSys = seriesModel.coordinateSystem;\n    // the data in each layer are organized into a series.\n    var layerSeries = seriesModel.getLayerSeries();\n\n    // the points in each layer.\n    var layerPoints = map(layerSeries, function (singleLayer) {\n        return map(singleLayer.indices, function (idx) {\n            var pt = coordSys.dataToPoint(data.get('time', idx));\n            pt[1] = data.get('value', idx);\n            return pt;\n        });\n    });\n\n    var base = computeBaseline(layerPoints);\n    var baseLine = base.y0;\n    var ky = height / base.max;\n\n    // set layout information for each item.\n    var n = layerSeries.length;\n    var m = layerSeries[0].indices.length;\n    var baseY0;\n    for (var j = 0; j < m; ++j) {\n        baseY0 = baseLine[j] * ky;\n        data.setItemLayout(layerSeries[0].indices[j], {\n            layerIndex: 0,\n            x: layerPoints[0][j][0],\n            y0: baseY0,\n            y: layerPoints[0][j][1] * ky\n        });\n        for (var i = 1; i < n; ++i) {\n            baseY0 += layerPoints[i - 1][j][1] * ky;\n            data.setItemLayout(layerSeries[i].indices[j], {\n                layerIndex: i,\n                x: layerPoints[i][j][0],\n                y0: baseY0,\n                y: layerPoints[i][j][1] * ky\n            });\n        }\n    }\n}\n\n/**\n * Compute the baseLine of the rawdata\n * Inspired by Lee Byron's paper Stacked Graphs - Geometry & Aesthetics\n *\n * @param  {Array.<Array>} data  the points in each layer\n * @return {Object}\n */\nfunction computeBaseline(data) {\n    var layerNum = data.length;\n    var pointNum = data[0].length;\n    var sums = [];\n    var y0 = [];\n    var max = 0;\n    var temp;\n    var base = {};\n\n    for (var i = 0; i < pointNum; ++i) {\n        for (var j = 0, temp = 0; j < layerNum; ++j) {\n            temp += data[j][i][1];\n        }\n        if (temp > max) {\n            max = temp;\n        }\n        sums.push(temp);\n    }\n\n    for (var k = 0; k < pointNum; ++k) {\n        y0[k] = (max - sums[k]) / 2;\n    }\n    max = 0;\n\n    for (var l = 0; l < pointNum; ++l) {\n        var sum = sums[l] + y0[l];\n        if (sum > max) {\n            max = sum;\n        }\n    }\n    base.y0 = y0;\n    base.max = max;\n\n    return base;\n}\n\n/**\n * @file Visual encoding for themeRiver view\n * @author  Deqing Li(annong035@gmail.com)\n */\n\nvar themeRiverVisual = function (ecModel) {\n    ecModel.eachSeriesByType('themeRiver', function (seriesModel) {\n        var data = seriesModel.getData();\n        var rawData = seriesModel.getRawData();\n        var colorList = seriesModel.get('color');\n        var idxMap = createHashMap();\n\n        data.each(function (idx) {\n            idxMap.set(data.getRawIndex(idx), idx);\n        });\n\n        rawData.each(function (rawIndex) {\n            var name = rawData.getName(rawIndex);\n            var color = colorList[(seriesModel.nameMap.get(name) - 1) % colorList.length];\n\n            rawData.setItemVisual(rawIndex, 'color', color);\n\n            var idx = idxMap.get(rawIndex);\n\n            if (idx != null) {\n                data.setItemVisual(idx, 'color', color);\n            }\n        });\n    });\n};\n\nregisterLayout(themeRiverLayout);\nregisterVisual(themeRiverVisual);\nregisterProcessor(curry(dataFilter, 'themeRiver'));\n\nfunction dataToCoordSize(dataSize, dataItem) {\n    // dataItem is necessary in log axis.\n    dataItem = dataItem || [0, 0];\n    return map(['x', 'y'], function (dim, dimIdx) {\n        var axis = this.getAxis(dim);\n        var val = dataItem[dimIdx];\n        var halfSize = dataSize[dimIdx] / 2;\n        return axis.type === 'category'\n            ? axis.getBandWidth()\n            : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));\n    }, this);\n}\n\nvar prepareCartesian2d = function (coordSys) {\n    var rect = coordSys.grid.getRect();\n    return {\n        coordSys: {\n            // The name exposed to user is always 'cartesian2d' but not 'grid'.\n            type: 'cartesian2d',\n            x: rect.x,\n            y: rect.y,\n            width: rect.width,\n            height: rect.height\n        },\n        api: {\n            coord: bind(coordSys.dataToPoint, coordSys),\n            size: bind(dataToCoordSize, coordSys)\n        }\n    };\n};\n\nfunction dataToCoordSize$1(dataSize, dataItem) {\n    dataItem = dataItem || [0, 0];\n    return map([0, 1], function (dimIdx) {\n        var val = dataItem[dimIdx];\n        var halfSize = dataSize[dimIdx] / 2;\n        var p1 = [];\n        var p2 = [];\n        p1[dimIdx] = val - halfSize;\n        p2[dimIdx] = val + halfSize;\n        p1[1 - dimIdx] = p2[1 - dimIdx] = dataItem[1 - dimIdx];\n        return Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx]);\n    }, this);\n}\n\nvar prepareGeo = function (coordSys) {\n    var rect = coordSys.getBoundingRect();\n    return {\n        coordSys: {\n            type: 'geo',\n            x: rect.x,\n            y: rect.y,\n            width: rect.width,\n            height: rect.height\n        },\n        api: {\n            coord: bind(coordSys.dataToPoint, coordSys),\n            size: bind(dataToCoordSize$1, coordSys)\n        }\n    };\n};\n\nfunction dataToCoordSize$2(dataSize, dataItem) {\n    // dataItem is necessary in log axis.\n    var axis = this.getAxis();\n    var val = dataItem instanceof Array ? dataItem[0] : dataItem;\n    var halfSize = (dataSize instanceof Array ? dataSize[0] : dataSize) / 2;\n    return axis.type === 'category'\n        ? axis.getBandWidth()\n        : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));\n}\n\nvar prepareSingleAxis = function (coordSys) {\n    var rect = coordSys.getRect();\n\n    return {\n        coordSys: {\n            type: 'singleAxis',\n            x: rect.x,\n            y: rect.y,\n            width: rect.width,\n            height: rect.height\n        },\n        api: {\n            coord: bind(coordSys.dataToPoint, coordSys),\n            size: bind(dataToCoordSize$2, coordSys)\n        }\n    };\n};\n\nfunction dataToCoordSize$3(dataSize, dataItem) {\n    // dataItem is necessary in log axis.\n    return map(['Radius', 'Angle'], function (dim, dimIdx) {\n        var axis = this['get' + dim + 'Axis']();\n        var val = dataItem[dimIdx];\n        var halfSize = dataSize[dimIdx] / 2;\n        var method = 'dataTo' + dim;\n\n        var result = axis.type === 'category'\n            ? axis.getBandWidth()\n            : Math.abs(axis[method](val - halfSize) - axis[method](val + halfSize));\n\n        if (dim === 'Angle') {\n            result = result * Math.PI / 180;\n        }\n\n        return result;\n\n    }, this);\n}\n\nvar preparePolar = function (coordSys) {\n    var radiusAxis = coordSys.getRadiusAxis();\n    var angleAxis = coordSys.getAngleAxis();\n    var radius = radiusAxis.getExtent();\n    radius[0] > radius[1] && radius.reverse();\n\n    return {\n        coordSys: {\n            type: 'polar',\n            cx: coordSys.cx,\n            cy: coordSys.cy,\n            r: radius[1],\n            r0: radius[0]\n        },\n        api: {\n            coord: bind(function (data) {\n                var radius = radiusAxis.dataToRadius(data[0]);\n                var angle = angleAxis.dataToAngle(data[1]);\n                var coord = coordSys.coordToPoint([radius, angle]);\n                coord.push(radius, angle * Math.PI / 180);\n                return coord;\n            }),\n            size: bind(dataToCoordSize$3, coordSys)\n        }\n    };\n};\n\nvar prepareCalendar = function (coordSys) {\n    var rect = coordSys.getRect();\n    var rangeInfo = coordSys.getRangeInfo();\n\n    return {\n        coordSys: {\n            type: 'calendar',\n            x: rect.x,\n            y: rect.y,\n            width: rect.width,\n            height: rect.height,\n            cellWidth: coordSys.getCellWidth(),\n            cellHeight: coordSys.getCellHeight(),\n            rangeInfo: {\n                start: rangeInfo.start,\n                end: rangeInfo.end,\n                weeks: rangeInfo.weeks,\n                dayCount: rangeInfo.allDay\n            }\n        },\n        api: {\n            coord: bind(coordSys.dataToPoint, coordSys)\n        }\n    };\n};\n\nvar ITEM_STYLE_NORMAL_PATH = ['itemStyle', 'normal'];\nvar ITEM_STYLE_EMPHASIS_PATH = ['itemStyle', 'emphasis'];\nvar LABEL_NORMAL = ['label', 'normal'];\nvar LABEL_EMPHASIS = ['label', 'emphasis'];\n// Use prefix to avoid index to be the same as el.name,\n// which will cause weird udpate animation.\nvar GROUP_DIFF_PREFIX = 'e\\0\\0';\n\n/**\n * To reduce total package size of each coordinate systems, the modules `prepareCustom`\n * of each coordinate systems are not required by each coordinate systems directly, but\n * required by the module `custom`.\n *\n * prepareInfoForCustomSeries {Function}: optional\n *     @return {Object} {coordSys: {...}, api: {\n *         coord: function (data, clamp) {}, // return point in global.\n *         size: function (dataSize, dataItem) {} // return size of each axis in coordSys.\n *     }}\n */\nvar prepareCustoms = {\n    cartesian2d: prepareCartesian2d,\n    geo: prepareGeo,\n    singleAxis: prepareSingleAxis,\n    polar: preparePolar,\n    calendar: prepareCalendar\n};\n\n// ------\n// Model\n// ------\n\nextendSeriesModel({\n\n    type: 'series.custom',\n\n    dependencies: ['grid', 'polar', 'geo', 'singleAxis', 'calendar'],\n\n    defaultOption: {\n        coordinateSystem: 'cartesian2d', // Can be set as 'none'\n        zlevel: 0,\n        z: 2,\n        legendHoverLink: true\n\n        // Cartesian coordinate system\n        // xAxisIndex: 0,\n        // yAxisIndex: 0,\n\n        // Polar coordinate system\n        // polarIndex: 0,\n\n        // Geo coordinate system\n        // geoIndex: 0,\n\n        // label: {}\n        // itemStyle: {}\n    },\n\n    getInitialData: function (option, ecModel) {\n        return createListFromArray(option.data, this, ecModel);\n    }\n});\n\n// -----\n// View\n// -----\n\nextendChartView({\n\n    type: 'custom',\n\n    /**\n     * @private\n     * @type {module:echarts/data/List}\n     */\n    _data: null,\n\n    /**\n     * @override\n     */\n    render: function (customSeries, ecModel, api) {\n        var oldData = this._data;\n        var data = customSeries.getData();\n        var group = this.group;\n        var renderItem = makeRenderItem(customSeries, data, ecModel, api);\n\n        data.diff(oldData)\n            .add(function (newIdx) {\n                data.hasValue(newIdx) && createOrUpdate$1(\n                    null, newIdx, renderItem(newIdx), customSeries, group, data\n                );\n            })\n            .update(function (newIdx, oldIdx) {\n                var el = oldData.getItemGraphicEl(oldIdx);\n                data.hasValue(newIdx)\n                    ? createOrUpdate$1(\n                        el, newIdx, renderItem(newIdx), customSeries, group, data\n                    )\n                    : (el && group.remove(el));\n            })\n            .remove(function (oldIdx) {\n                var el = oldData.getItemGraphicEl(oldIdx);\n                el && group.remove(el);\n            })\n            .execute();\n\n        this._data = data;\n    },\n\n    /**\n     * @override\n     */\n    dispose: noop\n});\n\n\nfunction createEl(elOption) {\n    var graphicType = elOption.type;\n    var el;\n\n    if (graphicType === 'path') {\n        var shape = elOption.shape;\n        el = makePath(\n            shape.pathData,\n            null,\n            {\n                x: shape.x || 0,\n                y: shape.y || 0,\n                width: shape.width || 0,\n                height: shape.height || 0\n            },\n            'center'\n        );\n        el.__customPathData = elOption.pathData;\n    }\n    else if (graphicType === 'image') {\n        el = new ZImage({\n        });\n        el.__customImagePath = elOption.style.image;\n    }\n    else if (graphicType === 'text') {\n        el = new Text({\n        });\n        el.__customText = elOption.style.text;\n    }\n    else {\n        var Clz = graphic[graphicType.charAt(0).toUpperCase() + graphicType.slice(1)];\n\n        if (__DEV__) {\n            assert(Clz, 'graphic type \"' + graphicType + '\" can not be found.');\n        }\n\n        el = new Clz();\n    }\n\n    el.__customGraphicType = graphicType;\n    el.name = elOption.name;\n\n    return el;\n}\n\nfunction updateEl(el, dataIndex, elOption, animatableModel, data, isInit) {\n    var targetProps = {};\n    var elOptionStyle = elOption.style || {};\n\n    elOption.shape && (targetProps.shape = clone(elOption.shape));\n    elOption.position && (targetProps.position = elOption.position.slice());\n    elOption.scale && (targetProps.scale = elOption.scale.slice());\n    elOption.origin && (targetProps.origin = elOption.origin.slice());\n    elOption.rotation && (targetProps.rotation = elOption.rotation);\n\n    if (el.type === 'image' && elOption.style) {\n        var targetStyle = targetProps.style = {};\n        each$1(['x', 'y', 'width', 'height'], function (prop) {\n            prepareStyleTransition(prop, targetStyle, elOptionStyle, el.style, isInit);\n        });\n    }\n\n    if (el.type === 'text' && elOption.style) {\n        var targetStyle = targetProps.style = {};\n        each$1(['x', 'y'], function (prop) {\n            prepareStyleTransition(prop, targetStyle, elOptionStyle, el.style, isInit);\n        });\n        // Compatible with previous: both support\n        // textFill and fill, textStroke and stroke in 'text' element.\n        !elOptionStyle.hasOwnProperty('textFill') && elOptionStyle.fill && (\n            elOptionStyle.textFill = elOptionStyle.fill\n        );\n        !elOptionStyle.hasOwnProperty('textStroke') && elOptionStyle.stroke && (\n            elOptionStyle.textStroke = elOptionStyle.stroke\n        );\n    }\n\n    if (el.type !== 'group') {\n        el.useStyle(elOptionStyle);\n\n        // Init animation.\n        if (isInit) {\n            el.style.opacity = 0;\n            var targetOpacity = elOptionStyle.opacity;\n            targetOpacity == null && (targetOpacity = 1);\n            initProps(el, {style: {opacity: targetOpacity}}, animatableModel, dataIndex);\n        }\n    }\n\n    if (isInit) {\n        el.attr(targetProps);\n    }\n    else {\n        updateProps(el, targetProps, animatableModel, dataIndex);\n    }\n\n    // z2 must not be null/undefined, otherwise sort error may occur.\n    el.attr({z2: elOption.z2 || 0, silent: elOption.silent});\n\n    elOption.styleEmphasis !== false && setHoverStyle(el, elOption.styleEmphasis);\n}\n\nfunction prepareStyleTransition(prop, targetStyle, elOptionStyle, oldElStyle, isInit) {\n    if (elOptionStyle[prop] != null && !isInit) {\n        targetStyle[prop] = elOptionStyle[prop];\n        elOptionStyle[prop] = oldElStyle[prop];\n    }\n}\n\nfunction makeRenderItem(customSeries, data, ecModel, api) {\n    var renderItem = customSeries.get('renderItem');\n    var coordSys = customSeries.coordinateSystem;\n    var prepareResult = {};\n\n    if (coordSys) {\n        if (__DEV__) {\n            assert(renderItem, 'series.render is required.');\n            assert(\n                coordSys.prepareCustoms || prepareCustoms[coordSys.type],\n                'This coordSys does not support custom series.'\n            );\n        }\n\n        prepareResult = coordSys.prepareCustoms\n            ? coordSys.prepareCustoms()\n            : prepareCustoms[coordSys.type](coordSys);\n    }\n\n    var userAPI = defaults({\n        getWidth: api.getWidth,\n        getHeight: api.getHeight,\n        getZr: api.getZr,\n        getDevicePixelRatio: api.getDevicePixelRatio,\n        value: value,\n        style: style,\n        styleEmphasis: styleEmphasis,\n        visual: visual,\n        barLayout: barLayout,\n        currentSeriesIndices: currentSeriesIndices,\n        font: font\n    }, prepareResult.api || {});\n\n    var userParams = {\n        context: {},\n        seriesId: customSeries.id,\n        seriesName: customSeries.name,\n        seriesIndex: customSeries.seriesIndex,\n        coordSys: prepareResult.coordSys,\n        dataInsideLength: data.count(),\n        encode: wrapEncodeDef(customSeries.getData())\n    };\n\n    // Do not support call `api` asynchronously without dataIndexInside input.\n    var currDataIndexInside;\n    var currDirty = true;\n    var currItemModel;\n    var currLabelNormalModel;\n    var currLabelEmphasisModel;\n    var currLabelValueDim;\n    var currVisualColor;\n\n    return function (dataIndexInside) {\n        currDataIndexInside = dataIndexInside;\n        currDirty = true;\n        return renderItem && renderItem(\n            defaults({\n                dataIndexInside: dataIndexInside,\n                dataIndex: data.getRawIndex(dataIndexInside)\n            }, userParams),\n            userAPI\n        ) || {};\n    };\n\n    // Do not update cache until api called.\n    function updateCache(dataIndexInside) {\n        dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n        if (currDirty) {\n            currItemModel = data.getItemModel(dataIndexInside);\n            currLabelNormalModel = currItemModel.getModel(LABEL_NORMAL);\n            currLabelEmphasisModel = currItemModel.getModel(LABEL_EMPHASIS);\n            currLabelValueDim = findLabelValueDim(data);\n            currVisualColor = data.getItemVisual(dataIndexInside, 'color');\n\n            currDirty = false;\n        }\n    }\n\n    /**\n     * @public\n     * @param {number|string} dim\n     * @param {number} [dataIndexInside=currDataIndexInside]\n     * @return {number|string} value\n     */\n    function value(dim, dataIndexInside) {\n        dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n        return data.get(data.getDimension(dim || 0), dataIndexInside);\n    }\n\n    /**\n     * By default, `visual` is applied to style (to support visualMap).\n     * `visual.color` is applied at `fill`. If user want apply visual.color on `stroke`,\n     * it can be implemented as:\n     * `api.style({stroke: api.visual('color'), fill: null})`;\n     * @public\n     * @param {Object} [extra]\n     * @param {number} [dataIndexInside=currDataIndexInside]\n     */\n    function style(extra, dataIndexInside) {\n        dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n        updateCache(dataIndexInside);\n\n        var itemStyle = currItemModel.getModel(ITEM_STYLE_NORMAL_PATH).getItemStyle();\n\n        currVisualColor != null && (itemStyle.fill = currVisualColor);\n        var opacity = data.getItemVisual(dataIndexInside, 'opacity');\n        opacity != null && (itemStyle.opacity = opacity);\n\n        if (currLabelValueDim != null) {\n            setTextStyle(itemStyle, currLabelNormalModel, null, {\n                autoColor: currVisualColor,\n                isRectText: true\n            });\n\n            itemStyle.text = currLabelNormalModel.getShallow('show')\n                ? retrieve2(\n                    customSeries.getFormattedLabel(dataIndexInside, 'normal'),\n                    data.get(currLabelValueDim, dataIndexInside)\n                )\n                : null;\n        }\n\n        extra && extend(itemStyle, extra);\n        return itemStyle;\n    }\n\n    /**\n     * @public\n     * @param {Object} [extra]\n     * @param {number} [dataIndexInside=currDataIndexInside]\n     */\n    function styleEmphasis(extra, dataIndexInside) {\n        dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n        updateCache(dataIndexInside);\n\n        var itemStyle = currItemModel.getModel(ITEM_STYLE_EMPHASIS_PATH).getItemStyle();\n\n        if (currLabelValueDim != null) {\n            setTextStyle(itemStyle, currLabelEmphasisModel, null, {\n                isRectText: true\n            }, true);\n\n            itemStyle.text = currLabelEmphasisModel.getShallow('show')\n                ? retrieve3(\n                    customSeries.getFormattedLabel(dataIndexInside, 'emphasis'),\n                    customSeries.getFormattedLabel(dataIndexInside, 'normal'),\n                    data.get(currLabelValueDim, dataIndexInside)\n                )\n                : null;\n        }\n\n        extra && extend(itemStyle, extra);\n        return itemStyle;\n    }\n\n    /**\n     * @public\n     * @param {string} visualType\n     * @param {number} [dataIndexInside=currDataIndexInside]\n     */\n    function visual(visualType, dataIndexInside) {\n        dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n        return data.getItemVisual(dataIndexInside, visualType);\n    }\n\n    /**\n     * @public\n     * @param {number} opt.count Positive interger.\n     * @param {number} [opt.barWidth]\n     * @param {number} [opt.barMaxWidth]\n     * @param {number} [opt.barGap]\n     * @param {number} [opt.barCategoryGap]\n     * @return {Object} {width, offset, offsetCenter} is not support, return undefined.\n     */\n    function barLayout(opt) {\n        if (coordSys.getBaseAxis) {\n            var baseAxis = coordSys.getBaseAxis();\n            return barLayoutGrid.getLayoutOnAxis(defaults({axis: baseAxis}, opt), api);\n        }\n    }\n\n    /**\n     * @public\n     * @return {Array.<number>}\n     */\n    function currentSeriesIndices() {\n        return ecModel.getCurrentSeriesIndices();\n    }\n\n    /**\n     * @public\n     * @param {Object} opt\n     * @param {string} [opt.fontStyle]\n     * @param {number} [opt.fontWeight]\n     * @param {number} [opt.fontSize]\n     * @param {string} [opt.fontFamily]\n     * @return {string} font string\n     */\n    function font(opt) {\n        return getFont(opt, ecModel);\n    }\n}\n\nfunction wrapEncodeDef(data) {\n    var encodeDef = {};\n    each$1(data.dimensions, function (dimName, dataDimIndex) {\n        var dimInfo = data.getDimensionInfo(dimName);\n        if (!dimInfo.isExtraCoord) {\n            var coordDim = dimInfo.coordDim;\n            var dataDims = encodeDef[coordDim] = encodeDef[coordDim] || [];\n            dataDims[dimInfo.coordDimIndex] = dataDimIndex;\n        }\n    });\n    return encodeDef;\n}\n\nfunction createOrUpdate$1(el, dataIndex, elOption, animatableModel, group, data) {\n    el = doCreateOrUpdate(el, dataIndex, elOption, animatableModel, group, data);\n    el && data.setItemGraphicEl(dataIndex, el);\n}\n\nfunction doCreateOrUpdate(el, dataIndex, elOption, animatableModel, group, data) {\n    var elOptionType = elOption.type;\n    if (el\n        && elOptionType !== el.__customGraphicType\n        && (elOptionType !== 'path' || elOption.pathData !== el.__customPathData)\n        && (elOptionType !== 'image' || elOption.style.image !== el.__customImagePath)\n        && (elOptionType !== 'text' || elOption.style.text !== el.__customText)\n    ) {\n        group.remove(el);\n        el = null;\n    }\n\n    // `elOption.type` is undefined when `renderItem` returns nothing.\n    if (elOptionType == null) {\n        return;\n    }\n\n    var isInit = !el;\n    !el && (el = createEl(elOption));\n    updateEl(el, dataIndex, elOption, animatableModel, data, isInit);\n\n    if (elOptionType === 'group') {\n        var oldChildren = el.children() || [];\n        var newChildren = elOption.children || [];\n\n        if (elOption.diffChildrenByName) {\n            // lower performance.\n            diffGroupChildren({\n                oldChildren: oldChildren,\n                newChildren: newChildren,\n                dataIndex: dataIndex,\n                animatableModel: animatableModel,\n                group: el,\n                data: data\n            });\n        }\n        else {\n            // better performance.\n            var index = 0;\n            for (; index < newChildren.length; index++) {\n                doCreateOrUpdate(\n                    el.childAt(index),\n                    dataIndex,\n                    newChildren[index],\n                    animatableModel,\n                    el,\n                    data\n                );\n            }\n            for (; index < oldChildren.length; index++) {\n                oldChildren[index] && el.remove(oldChildren[index]);\n            }\n        }\n    }\n\n    group.add(el);\n\n    return el;\n}\n\nfunction diffGroupChildren(context) {\n    (new DataDiffer(\n        context.oldChildren,\n        context.newChildren,\n        getKey,\n        getKey,\n        context\n    ))\n        .add(processAddUpdate)\n        .update(processAddUpdate)\n        .remove(processRemove)\n        .execute();\n}\n\nfunction getKey(item, idx) {\n    var name = item && item.name;\n    return name != null ? name : GROUP_DIFF_PREFIX + idx;\n}\n\nfunction processAddUpdate(newIndex, oldIndex) {\n    var context = this.context;\n    var childOption = newIndex != null ? context.newChildren[newIndex] : null;\n    var child = oldIndex != null ? context.oldChildren[oldIndex] : null;\n\n    doCreateOrUpdate(\n        child,\n        context.dataIndex,\n        childOption,\n        context.animatableModel,\n        context.group,\n        context.data\n    );\n}\n\nfunction processRemove(oldIndex) {\n    var context = this.context;\n    var child = context.oldChildren[oldIndex];\n    child && context.group.remove(child);\n}\n\n// -------------\n// Preprocessor\n// -------------\n\nregisterPreprocessor(function (option) {\n    var graphicOption = option.graphic;\n\n    // Convert\n    // {graphic: [{left: 10, type: 'circle'}, ...]}\n    // or\n    // {graphic: {left: 10, type: 'circle'}}\n    // to\n    // {graphic: [{elements: [{left: 10, type: 'circle'}, ...]}]}\n    if (isArray(graphicOption)) {\n        if (!graphicOption[0] || !graphicOption[0].elements) {\n            option.graphic = [{elements: graphicOption}];\n        }\n        else {\n            // Only one graphic instance can be instantiated. (We dont\n            // want that too many views are created in echarts._viewMap)\n            option.graphic = [option.graphic[0]];\n        }\n    }\n    else if (graphicOption && !graphicOption.elements) {\n        option.graphic = [{elements: [graphicOption]}];\n    }\n});\n\n// ------\n// Model\n// ------\n\nvar GraphicModel = extendComponentModel({\n\n    type: 'graphic',\n\n    defaultOption: {\n\n        // Extra properties for each elements:\n        //\n        // left/right/top/bottom: (like 12, '22%', 'center', default undefined)\n        //      If left/rigth is set, shape.x/shape.cx/position will not be used.\n        //      If top/bottom is set, shape.y/shape.cy/position will not be used.\n        //      This mechanism is useful when you want to position a group/element\n        //      against the right side or the center of this container.\n        //\n        // width/height: (can only be pixel value, default 0)\n        //      Only be used to specify contianer(group) size, if needed. And\n        //      can not be percentage value (like '33%'). See the reason in the\n        //      layout algorithm below.\n        //\n        // bounding: (enum: 'all' (default) | 'raw')\n        //      Specify how to calculate boundingRect when locating.\n        //      'all': Get uioned and transformed boundingRect\n        //          from both itself and its descendants.\n        //          This mode simplies confining a group of elements in the bounding\n        //          of their ancester container (e.g., using 'right: 0').\n        //      'raw': Only use the boundingRect of itself and before transformed.\n        //          This mode is similar to css behavior, which is useful when you\n        //          want an element to be able to overflow its container. (Consider\n        //          a rotated circle needs to be located in a corner.)\n\n        // Note: elements is always behind its ancestors in this elements array.\n        elements: [],\n        parentId: null\n    },\n\n    /**\n     * Save el options for the sake of the performance (only update modified graphics).\n     * The order is the same as those in option. (ancesters -> descendants)\n     *\n     * @private\n     * @type {Array.<Object>}\n     */\n    _elOptionsToUpdate: null,\n\n    /**\n     * @override\n     */\n    mergeOption: function (option) {\n        // Prevent default merge to elements\n        var elements = this.option.elements;\n        this.option.elements = null;\n\n        GraphicModel.superApply(this, 'mergeOption', arguments);\n\n        this.option.elements = elements;\n    },\n\n    /**\n     * @override\n     */\n    optionUpdated: function (newOption, isInit) {\n        var thisOption = this.option;\n        var newList = (isInit ? thisOption : newOption).elements;\n        var existList = thisOption.elements = isInit ? [] : thisOption.elements;\n\n        var flattenedList = [];\n        this._flatten(newList, flattenedList);\n\n        var mappingResult = mappingToExists(existList, flattenedList);\n        makeIdAndName(mappingResult);\n\n        // Clear elOptionsToUpdate\n        var elOptionsToUpdate = this._elOptionsToUpdate = [];\n\n        each$1(mappingResult, function (resultItem, index) {\n            var newElOption = resultItem.option;\n\n            if (__DEV__) {\n                assert(\n                    isObject(newElOption) || resultItem.exist,\n                    'Empty graphic option definition'\n                );\n            }\n\n            if (!newElOption) {\n                return;\n            }\n\n            elOptionsToUpdate.push(newElOption);\n\n            setKeyInfoToNewElOption(resultItem, newElOption);\n\n            mergeNewElOptionToExist(existList, index, newElOption);\n\n            setLayoutInfoToExist(existList[index], newElOption);\n\n        }, this);\n\n        // Clean\n        for (var i = existList.length - 1; i >= 0; i--) {\n            if (existList[i] == null) {\n                existList.splice(i, 1);\n            }\n            else {\n                // $action should be volatile, otherwise option gotten from\n                // `getOption` will contain unexpected $action.\n                delete existList[i].$action;\n            }\n        }\n    },\n\n    /**\n     * Convert\n     * [{\n     *  type: 'group',\n     *  id: 'xx',\n     *  children: [{type: 'circle'}, {type: 'polygon'}]\n     * }]\n     * to\n     * [\n     *  {type: 'group', id: 'xx'},\n     *  {type: 'circle', parentId: 'xx'},\n     *  {type: 'polygon', parentId: 'xx'}\n     * ]\n     *\n     * @private\n     * @param {Array.<Object>} optionList option list\n     * @param {Array.<Object>} result result of flatten\n     * @param {Object} parentOption parent option\n     */\n    _flatten: function (optionList, result, parentOption) {\n        each$1(optionList, function (option) {\n            if (!option) {\n                return;\n            }\n\n            if (parentOption) {\n                option.parentOption = parentOption;\n            }\n\n            result.push(option);\n\n            var children = option.children;\n            if (option.type === 'group' && children) {\n                this._flatten(children, result, option);\n            }\n            // Deleting for JSON output, and for not affecting group creation.\n            delete option.children;\n        }, this);\n    },\n\n    // FIXME\n    // Pass to view using payload? setOption has a payload?\n    useElOptionsToUpdate: function () {\n        var els = this._elOptionsToUpdate;\n        // Clear to avoid render duplicately when zooming.\n        this._elOptionsToUpdate = null;\n        return els;\n    }\n});\n\n// -----\n// View\n// -----\n\nextendComponentView({\n\n    type: 'graphic',\n\n    /**\n     * @override\n     */\n    init: function (ecModel, api) {\n\n        /**\n         * @private\n         * @type {module:zrender/core/util.HashMap}\n         */\n        this._elMap = createHashMap();\n\n        /**\n         * @private\n         * @type {module:echarts/graphic/GraphicModel}\n         */\n        this._lastGraphicModel;\n    },\n\n    /**\n     * @override\n     */\n    render: function (graphicModel, ecModel, api) {\n\n        // Having leveraged between use cases and algorithm complexity, a very\n        // simple layout mechanism is used:\n        // The size(width/height) can be determined by itself or its parent (not\n        // implemented yet), but can not by its children. (Top-down travel)\n        // The location(x/y) can be determined by the bounding rect of itself\n        // (can including its descendants or not) and the size of its parent.\n        // (Bottom-up travel)\n\n        // When `chart.clear()` or `chart.setOption({...}, true)` with the same id,\n        // view will be reused.\n        if (graphicModel !== this._lastGraphicModel) {\n            this._clear();\n        }\n        this._lastGraphicModel = graphicModel;\n\n        this._updateElements(graphicModel, api);\n        this._relocate(graphicModel, api);\n    },\n\n    /**\n     * Update graphic elements.\n     *\n     * @private\n     * @param {Object} graphicModel graphic model\n     * @param {module:echarts/ExtensionAPI} api extension API\n     */\n    _updateElements: function (graphicModel, api) {\n        var elOptionsToUpdate = graphicModel.useElOptionsToUpdate();\n\n        if (!elOptionsToUpdate) {\n            return;\n        }\n\n        var elMap = this._elMap;\n        var rootGroup = this.group;\n\n        // Top-down tranverse to assign graphic settings to each elements.\n        each$1(elOptionsToUpdate, function (elOption) {\n            var $action = elOption.$action;\n            var id = elOption.id;\n            var existEl = elMap.get(id);\n            var parentId = elOption.parentId;\n            var targetElParent = parentId != null ? elMap.get(parentId) : rootGroup;\n\n            if (elOption.type === 'text') {\n                var elOptionStyle = elOption.style;\n\n                // In top/bottom mode, textVerticalAlign should not be used, which cause\n                // inaccurately locating.\n                if (elOption.hv && elOption.hv[1]) {\n                    elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = null;\n                }\n\n                // Compatible with previous setting: both support fill and textFill,\n                // stroke and textStroke.\n                !elOptionStyle.hasOwnProperty('textFill') && elOptionStyle.fill && (\n                    elOptionStyle.textFill = elOptionStyle.fill\n                );\n                !elOptionStyle.hasOwnProperty('textStroke') && elOptionStyle.stroke && (\n                    elOptionStyle.textStroke = elOptionStyle.stroke\n                );\n            }\n\n            // Remove unnecessary props to avoid potential problems.\n            var elOptionCleaned = getCleanedElOption(elOption);\n\n            // For simple, do not support parent change, otherwise reorder is needed.\n            if (__DEV__) {\n                existEl && assert(\n                    targetElParent === existEl.parent,\n                    'Changing parent is not supported.'\n                );\n            }\n\n            if (!$action || $action === 'merge') {\n                existEl\n                    ? existEl.attr(elOptionCleaned)\n                    : createEl$1(id, targetElParent, elOptionCleaned, elMap);\n            }\n            else if ($action === 'replace') {\n                removeEl(existEl, elMap);\n                createEl$1(id, targetElParent, elOptionCleaned, elMap);\n            }\n            else if ($action === 'remove') {\n                removeEl(existEl, elMap);\n            }\n\n            var el = elMap.get(id);\n            if (el) {\n                el.__ecGraphicWidth = elOption.width;\n                el.__ecGraphicHeight = elOption.height;\n            }\n        });\n    },\n\n    /**\n     * Locate graphic elements.\n     *\n     * @private\n     * @param {Object} graphicModel graphic model\n     * @param {module:echarts/ExtensionAPI} api extension API\n     */\n    _relocate: function (graphicModel, api) {\n        var elOptions = graphicModel.option.elements;\n        var rootGroup = this.group;\n        var elMap = this._elMap;\n\n        // Bottom-up tranvese all elements (consider ec resize) to locate elements.\n        for (var i = elOptions.length - 1; i >= 0; i--) {\n            var elOption = elOptions[i];\n            var el = elMap.get(elOption.id);\n\n            if (!el) {\n                continue;\n            }\n\n            var parentEl = el.parent;\n            var containerInfo = parentEl === rootGroup\n                ? {\n                    width: api.getWidth(),\n                    height: api.getHeight()\n                }\n                : { // Like 'position:absolut' in css, default 0.\n                    width: parentEl.__ecGraphicWidth || 0,\n                    height: parentEl.__ecGraphicHeight || 0\n                };\n\n            positionElement(\n                el, elOption, containerInfo, null,\n                {hv: elOption.hv, boundingMode: elOption.bounding}\n            );\n        }\n    },\n\n    /**\n     * Clear all elements.\n     *\n     * @private\n     */\n    _clear: function () {\n        var elMap = this._elMap;\n        elMap.each(function (el) {\n            removeEl(el, elMap);\n        });\n        this._elMap = createHashMap();\n    },\n\n    /**\n     * @override\n     */\n    dispose: function () {\n        this._clear();\n    }\n});\n\nfunction createEl$1(id, targetElParent, elOption, elMap) {\n    var graphicType = elOption.type;\n\n    if (__DEV__) {\n        assert(graphicType, 'graphic type MUST be set');\n    }\n\n    var Clz = graphic[graphicType.charAt(0).toUpperCase() + graphicType.slice(1)];\n\n    if (__DEV__) {\n        assert(Clz, 'graphic type can not be found');\n    }\n\n    var el = new Clz(elOption);\n    targetElParent.add(el);\n    elMap.set(id, el);\n    el.__ecGraphicId = id;\n}\n\nfunction removeEl(existEl, elMap) {\n    var existElParent = existEl && existEl.parent;\n    if (existElParent) {\n        existEl.type === 'group' && existEl.traverse(function (el) {\n            removeEl(el, elMap);\n        });\n        elMap.removeKey(existEl.__ecGraphicId);\n        existElParent.remove(existEl);\n    }\n}\n\n// Remove unnecessary props to avoid potential problems.\nfunction getCleanedElOption(elOption) {\n    elOption = extend({}, elOption);\n    each$1(\n        ['id', 'parentId', '$action', 'hv', 'bounding'].concat(LOCATION_PARAMS),\n        function (name) {\n            delete elOption[name];\n        }\n    );\n    return elOption;\n}\n\nfunction isSetLoc(obj, props) {\n    var isSet;\n    each$1(props, function (prop) {\n        obj[prop] != null && obj[prop] !== 'auto' && (isSet = true);\n    });\n    return isSet;\n}\n\nfunction setKeyInfoToNewElOption(resultItem, newElOption) {\n    var existElOption = resultItem.exist;\n\n    // Set id and type after id assigned.\n    newElOption.id = resultItem.keyInfo.id;\n    !newElOption.type && existElOption && (newElOption.type = existElOption.type);\n\n    // Set parent id if not specified\n    if (newElOption.parentId == null) {\n        var newElParentOption = newElOption.parentOption;\n        if (newElParentOption) {\n            newElOption.parentId = newElParentOption.id;\n        }\n        else if (existElOption) {\n            newElOption.parentId = existElOption.parentId;\n        }\n    }\n\n    // Clear\n    newElOption.parentOption = null;\n}\n\nfunction mergeNewElOptionToExist(existList, index, newElOption) {\n    // Update existing options, for `getOption` feature.\n    var newElOptCopy = extend({}, newElOption);\n    var existElOption = existList[index];\n\n    var $action = newElOption.$action || 'merge';\n    if ($action === 'merge') {\n        if (existElOption) {\n\n            if (__DEV__) {\n                var newType = newElOption.type;\n                assert(\n                    !newType || existElOption.type === newType,\n                    'Please set $action: \"replace\" to change `type`'\n                );\n            }\n\n            // We can ensure that newElOptCopy and existElOption are not\n            // the same object, so `merge` will not change newElOptCopy.\n            merge(existElOption, newElOptCopy, true);\n            // Rigid body, use ignoreSize.\n            mergeLayoutParam(existElOption, newElOptCopy, {ignoreSize: true});\n            // Will be used in render.\n            copyLayoutParams(newElOption, existElOption);\n        }\n        else {\n            existList[index] = newElOptCopy;\n        }\n    }\n    else if ($action === 'replace') {\n        existList[index] = newElOptCopy;\n    }\n    else if ($action === 'remove') {\n        // null will be cleaned later.\n        existElOption && (existList[index] = null);\n    }\n}\n\nfunction setLayoutInfoToExist(existItem, newElOption) {\n    if (!existItem) {\n        return;\n    }\n    existItem.hv = newElOption.hv = [\n        // Rigid body, dont care `width`.\n        isSetLoc(newElOption, ['left', 'right']),\n        // Rigid body, dont care `height`.\n        isSetLoc(newElOption, ['top', 'bottom'])\n    ];\n    // Give default group size. Otherwise layout error may occur.\n    if (existItem.type === 'group') {\n        existItem.width == null && (existItem.width = newElOption.width = 0);\n        existItem.height == null && (existItem.height = newElOption.height = 0);\n    }\n}\n\nvar LegendModel = extendComponentModel({\n\n    type: 'legend.plain',\n\n    dependencies: ['series'],\n\n    layoutMode: {\n        type: 'box',\n        // legend.width/height are maxWidth/maxHeight actually,\n        // whereas realy width/height is calculated by its content.\n        // (Setting {left: 10, right: 10} does not make sense).\n        // So consider the case:\n        // `setOption({legend: {left: 10});`\n        // then `setOption({legend: {right: 10});`\n        // The previous `left` should be cleared by setting `ignoreSize`.\n        ignoreSize: true\n    },\n\n    init: function (option, parentModel, ecModel) {\n        this.mergeDefaultAndTheme(option, ecModel);\n\n        option.selected = option.selected || {};\n    },\n\n    mergeOption: function (option) {\n        LegendModel.superCall(this, 'mergeOption', option);\n    },\n\n    optionUpdated: function () {\n        this._updateData(this.ecModel);\n\n        var legendData = this._data;\n\n        // If selectedMode is single, try to select one\n        if (legendData[0] && this.get('selectedMode') === 'single') {\n            var hasSelected = false;\n            // If has any selected in option.selected\n            for (var i = 0; i < legendData.length; i++) {\n                var name = legendData[i].get('name');\n                if (this.isSelected(name)) {\n                    // Force to unselect others\n                    this.select(name);\n                    hasSelected = true;\n                    break;\n                }\n            }\n            // Try select the first if selectedMode is single\n            !hasSelected && this.select(legendData[0].get('name'));\n        }\n    },\n\n    _updateData: function (ecModel) {\n        var legendData = map(this.get('data') || [], function (dataItem) {\n            // Can be string or number\n            if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n                dataItem = {\n                    name: dataItem\n                };\n            }\n            return new Model(dataItem, this, this.ecModel);\n        }, this);\n        this._data = legendData;\n\n        var availableNames = map(ecModel.getSeries(), function (series) {\n            return series.name;\n        });\n        ecModel.eachSeries(function (seriesModel) {\n            if (seriesModel.legendDataProvider) {\n                var data = seriesModel.legendDataProvider();\n                availableNames = availableNames.concat(data.mapArray(data.getName));\n            }\n        });\n        /**\n         * @type {Array.<string>}\n         * @private\n         */\n        this._availableNames = availableNames;\n    },\n\n    /**\n     * @return {Array.<module:echarts/model/Model>}\n     */\n    getData: function () {\n        return this._data;\n    },\n\n    /**\n     * @param {string} name\n     */\n    select: function (name) {\n        var selected = this.option.selected;\n        var selectedMode = this.get('selectedMode');\n        if (selectedMode === 'single') {\n            var data = this._data;\n            each$1(data, function (dataItem) {\n                selected[dataItem.get('name')] = false;\n            });\n        }\n        selected[name] = true;\n    },\n\n    /**\n     * @param {string} name\n     */\n    unSelect: function (name) {\n        if (this.get('selectedMode') !== 'single') {\n            this.option.selected[name] = false;\n        }\n    },\n\n    /**\n     * @param {string} name\n     */\n    toggleSelected: function (name) {\n        var selected = this.option.selected;\n        // Default is true\n        if (!selected.hasOwnProperty(name)) {\n            selected[name] = true;\n        }\n        this[selected[name] ? 'unSelect' : 'select'](name);\n    },\n\n    /**\n     * @param {string} name\n     */\n    isSelected: function (name) {\n        var selected = this.option.selected;\n        return !(selected.hasOwnProperty(name) && !selected[name])\n            && indexOf(this._availableNames, name) >= 0;\n    },\n\n    defaultOption: {\n        // \n        zlevel: 0,\n        // \n        z: 4,\n        show: true,\n\n        // \n        // 'horizontal' | 'vertical'\n        orient: 'horizontal',\n\n        left: 'center',\n        // right: 'center',\n\n        top: 0,\n        // bottom: null,\n\n        // \n        // 'auto' | 'left' | 'right'\n        //  'auto',  x \n        align: 'auto',\n\n        backgroundColor: 'rgba(0,0,0,0)',\n        // \n        borderColor: '#ccc',\n        borderRadius: 0,\n        // px0\n        borderWidth: 0,\n        // px5\n        // css\n        padding: 5,\n        // itempx10\n        // \n        itemGap: 10,\n        // \n        itemWidth: 25,\n        // \n        itemHeight: 14,\n\n        // \n        inactiveColor: '#ccc',\n\n        textStyle: {\n            // \n            color: '#333'\n        },\n        // formatter: '',\n        // \n        selectedMode: true,\n        // LEGEND.SELECTED\n        // selected: null,\n        // legend.dataitem\n        // data: [],\n\n        // Tooltip \n        tooltip: {\n            show: false\n        }\n    }\n});\n\nfunction legendSelectActionHandler(methodName, payload, ecModel) {\n    var selectedMap = {};\n    var isToggleSelect = methodName === 'toggleSelected';\n    var isSelected;\n    // Update all legend components\n    ecModel.eachComponent('legend', function (legendModel) {\n        if (isToggleSelect && isSelected != null) {\n            // Force other legend has same selected status\n            // Or the first is toggled to true and other are toggled to false\n            // In the case one legend has some item unSelected in option. And if other legend\n            // doesn't has the item, they will assume it is selected.\n            legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n        }\n        else {\n            legendModel[methodName](payload.name);\n            isSelected = legendModel.isSelected(payload.name);\n        }\n        var legendData = legendModel.getData();\n        each$1(legendData, function (model) {\n            var name = model.get('name');\n            // Wrap element\n            if (name === '\\n' || name === '') {\n                return;\n            }\n            var isItemSelected = legendModel.isSelected(name);\n            if (selectedMap.hasOwnProperty(name)) {\n                // Unselected if any legend is unselected\n                selectedMap[name] = selectedMap[name] && isItemSelected;\n            }\n            else {\n                selectedMap[name] = isItemSelected;\n            }\n        });\n    });\n    // Return the event explicitly\n    return {\n        name: payload.name,\n        selected: selectedMap\n    };\n}\n/**\n * @event legendToggleSelect\n * @type {Object}\n * @property {string} type 'legendToggleSelect'\n * @property {string} [from]\n * @property {string} name Series name or data item name\n */\nregisterAction(\n    'legendToggleSelect', 'legendselectchanged',\n    curry(legendSelectActionHandler, 'toggleSelected')\n);\n\n/**\n * @event legendSelect\n * @type {Object}\n * @property {string} type 'legendSelect'\n * @property {string} name Series name or data item name\n */\nregisterAction(\n    'legendSelect', 'legendselected',\n    curry(legendSelectActionHandler, 'select')\n);\n\n/**\n * @event legendUnSelect\n * @type {Object}\n * @property {string} type 'legendUnSelect'\n * @property {string} name Series name or data item name\n */\nregisterAction(\n    'legendUnSelect', 'legendunselected',\n    curry(legendSelectActionHandler, 'unSelect')\n);\n\n/**\n * Layout list like component.\n * It will box layout each items in group of component and then position the whole group in the viewport\n * @param {module:zrender/group/Group} group\n * @param {module:echarts/model/Component} componentModel\n * @param {module:echarts/ExtensionAPI}\n */\nfunction layout$2(group, componentModel, api) {\n    var boxLayoutParams = componentModel.getBoxLayoutParams();\n    var padding = componentModel.get('padding');\n    var viewportSize = {width: api.getWidth(), height: api.getHeight()};\n\n    var rect = getLayoutRect(\n        boxLayoutParams,\n        viewportSize,\n        padding\n    );\n\n    box(\n        componentModel.get('orient'),\n        group,\n        componentModel.get('itemGap'),\n        rect.width,\n        rect.height\n    );\n\n    positionElement(\n        group,\n        boxLayoutParams,\n        viewportSize,\n        padding\n    );\n}\n\nfunction makeBackground(rect, componentModel) {\n    var padding = normalizeCssArray$1(\n        componentModel.get('padding')\n    );\n    var style = componentModel.getItemStyle(['color', 'opacity']);\n    style.fill = componentModel.get('backgroundColor');\n    var rect = new Rect({\n        shape: {\n            x: rect.x - padding[3],\n            y: rect.y - padding[0],\n            width: rect.width + padding[1] + padding[3],\n            height: rect.height + padding[0] + padding[2],\n            r: componentModel.get('borderRadius')\n        },\n        style: style,\n        silent: true,\n        z2: -1\n    });\n    // FIXME\n    // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n    // and background rect when setting like `left: 0`, `top: 0`.\n    // graphic.subPixelOptimizeRect(rect);\n\n    return rect;\n}\n\nvar curry$4 = curry;\nvar each$19 = each$1;\nvar Group$3 = Group;\n\nvar LegendView = extendComponentView({\n\n    type: 'legend.plain',\n\n    newlineDisabled: false,\n\n    /**\n     * @override\n     */\n    init: function () {\n\n        /**\n         * @private\n         * @type {module:zrender/container/Group}\n         */\n        this.group.add(this._contentGroup = new Group$3());\n\n        /**\n         * @private\n         * @type {module:zrender/Element}\n         */\n        this._backgroundEl;\n    },\n\n    /**\n     * @protected\n     */\n    getContentGroup: function () {\n        return this._contentGroup;\n    },\n\n    /**\n     * @override\n     */\n    render: function (legendModel, ecModel, api) {\n\n        this.resetInner();\n\n        if (!legendModel.get('show', true)) {\n            return;\n        }\n\n        var itemAlign = legendModel.get('align');\n        if (!itemAlign || itemAlign === 'auto') {\n            itemAlign = (\n                legendModel.get('left') === 'right'\n                && legendModel.get('orient') === 'vertical'\n            ) ? 'right' : 'left';\n        }\n\n        this.renderInner(itemAlign, legendModel, ecModel, api);\n\n        // Perform layout.\n        var positionInfo = legendModel.getBoxLayoutParams();\n        var viewportSize = {width: api.getWidth(), height: api.getHeight()};\n        var padding = legendModel.get('padding');\n\n        var maxSize = getLayoutRect(positionInfo, viewportSize, padding);\n        var mainRect = this.layoutInner(legendModel, itemAlign, maxSize);\n\n        // Place mainGroup, based on the calculated `mainRect`.\n        var layoutRect = getLayoutRect(\n            defaults({width: mainRect.width, height: mainRect.height}, positionInfo),\n            viewportSize,\n            padding\n        );\n        this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]);\n\n        // Render background after group is layout.\n        this.group.add(\n            this._backgroundEl = makeBackground(mainRect, legendModel)\n        );\n    },\n\n    /**\n     * @protected\n     */\n    resetInner: function () {\n        this.getContentGroup().removeAll();\n        this._backgroundEl && this.group.remove(this._backgroundEl);\n    },\n\n    /**\n     * @protected\n     */\n    renderInner: function (itemAlign, legendModel, ecModel, api) {\n        var contentGroup = this.getContentGroup();\n        var legendDrawnMap = createHashMap();\n        var selectMode = legendModel.get('selectedMode');\n\n        each$19(legendModel.getData(), function (itemModel, dataIndex) {\n            var name = itemModel.get('name');\n\n            // Use empty string or \\n as a newline string\n            if (!this.newlineDisabled && (name === '' || name === '\\n')) {\n                contentGroup.add(new Group$3({\n                    newline: true\n                }));\n                return;\n            }\n\n            var seriesModel = ecModel.getSeriesByName(name)[0];\n\n            if (legendDrawnMap.get(name)) {\n                // Have been drawed\n                return;\n            }\n\n            // Series legend\n            if (seriesModel) {\n                var data = seriesModel.getData();\n                var color = data.getVisual('color');\n\n                // If color is a callback function\n                if (typeof color === 'function') {\n                    // Use the first data\n                    color = color(seriesModel.getDataParams(0));\n                }\n\n                // Using rect symbol defaultly\n                var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n                var symbolType = data.getVisual('symbol');\n\n                var itemGroup = this._createItem(\n                    name, dataIndex, itemModel, legendModel,\n                    legendSymbolType, symbolType,\n                    itemAlign, color,\n                    selectMode\n                );\n\n                itemGroup.on('click', curry$4(dispatchSelectAction, name, api))\n                    .on('mouseover', curry$4(dispatchHighlightAction, seriesModel, null, api))\n                    .on('mouseout', curry$4(dispatchDownplayAction, seriesModel, null, api));\n\n                legendDrawnMap.set(name, true);\n            }\n            else {\n                // Data legend of pie, funnel\n                ecModel.eachRawSeries(function (seriesModel) {\n                    // In case multiple series has same data name\n                    if (legendDrawnMap.get(name)) {\n                        return;\n                    }\n                    if (seriesModel.legendDataProvider) {\n                        var data = seriesModel.legendDataProvider();\n                        var idx = data.indexOfName(name);\n                        if (idx < 0) {\n                            return;\n                        }\n\n                        var color = data.getItemVisual(idx, 'color');\n\n                        var legendSymbolType = 'roundRect';\n\n                        var itemGroup = this._createItem(\n                            name, dataIndex, itemModel, legendModel,\n                            legendSymbolType, null,\n                            itemAlign, color,\n                            selectMode\n                        );\n\n                        itemGroup.on('click', curry$4(dispatchSelectAction, name, api))\n                            // FIXME Should not specify the series name\n                            .on('mouseover', curry$4(dispatchHighlightAction, seriesModel, name, api))\n                            .on('mouseout', curry$4(dispatchDownplayAction, seriesModel, name, api));\n\n                        legendDrawnMap.set(name, true);\n                    }\n                }, this);\n            }\n\n            if (__DEV__) {\n                if (!legendDrawnMap.get(name)) {\n                    console.warn(name + ' series not exists. Legend data should be same with series name or data name.');\n                }\n            }\n        }, this);\n    },\n\n    _createItem: function (\n        name, dataIndex, itemModel, legendModel,\n        legendSymbolType, symbolType,\n        itemAlign, color, selectMode\n    ) {\n        var itemWidth = legendModel.get('itemWidth');\n        var itemHeight = legendModel.get('itemHeight');\n        var inactiveColor = legendModel.get('inactiveColor');\n\n        var isSelected = legendModel.isSelected(name);\n        var itemGroup = new Group$3();\n\n        var textStyleModel = itemModel.getModel('textStyle');\n\n        var itemIcon = itemModel.get('icon');\n\n        var tooltipModel = itemModel.getModel('tooltip');\n        var legendGlobalTooltipModel = tooltipModel.parentModel;\n\n        // Use user given icon first\n        legendSymbolType = itemIcon || legendSymbolType;\n        itemGroup.add(createSymbol(\n            legendSymbolType,\n            0,\n            0,\n            itemWidth,\n            itemHeight,\n            isSelected ? color : inactiveColor,\n            true\n        ));\n\n        // Compose symbols\n        // PENDING\n        if (!itemIcon && symbolType\n            // At least show one symbol, can't be all none\n            && ((symbolType !== legendSymbolType) || symbolType == 'none')\n        ) {\n            var size = itemHeight * 0.8;\n            if (symbolType === 'none') {\n                symbolType = 'circle';\n            }\n            // Put symbol in the center\n            itemGroup.add(createSymbol(\n                symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size,\n                isSelected ? color : inactiveColor\n            ));\n        }\n\n        var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n        var textAlign = itemAlign;\n\n        var formatter = legendModel.get('formatter');\n        var content = name;\n        if (typeof formatter === 'string' && formatter) {\n            content = formatter.replace('{name}', name != null ? name : '');\n        }\n        else if (typeof formatter === 'function') {\n            content = formatter(name);\n        }\n\n        itemGroup.add(new Text({\n            style: setTextStyle({}, textStyleModel, {\n                text: content,\n                x: textX,\n                y: itemHeight / 2,\n                textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n                textAlign: textAlign,\n                textVerticalAlign: 'middle'\n            })\n        }));\n\n        // Add a invisible rect to increase the area of mouse hover\n        var hitRect = new Rect({\n            shape: itemGroup.getBoundingRect(),\n            invisible: true,\n            tooltip: tooltipModel.get('show') ? extend({\n                content: name,\n                // Defaul formatter\n                formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n                    return name;\n                },\n                formatterParams: {\n                    componentType: 'legend',\n                    legendIndex: legendModel.componentIndex,\n                    name: name,\n                    $vars: ['name']\n                }\n            }, tooltipModel.option) : null\n        });\n        itemGroup.add(hitRect);\n\n        itemGroup.eachChild(function (child) {\n            child.silent = true;\n        });\n\n        hitRect.silent = !selectMode;\n\n        this.getContentGroup().add(itemGroup);\n\n        setHoverStyle(itemGroup);\n\n        itemGroup.__legendDataIndex = dataIndex;\n\n        return itemGroup;\n    },\n\n    /**\n     * @protected\n     */\n    layoutInner: function (legendModel, itemAlign, maxSize) {\n        var contentGroup = this.getContentGroup();\n\n        // Place items in contentGroup.\n        box(\n            legendModel.get('orient'),\n            contentGroup,\n            legendModel.get('itemGap'),\n            maxSize.width,\n            maxSize.height\n        );\n\n        var contentRect = contentGroup.getBoundingRect();\n        contentGroup.attr('position', [-contentRect.x, -contentRect.y]);\n\n        return this.group.getBoundingRect();\n    }\n\n});\n\nfunction dispatchSelectAction(name, api) {\n    api.dispatchAction({\n        type: 'legendToggleSelect',\n        name: name\n    });\n}\n\nfunction dispatchHighlightAction(seriesModel, dataName, api) {\n    // If element hover will move to a hoverLayer.\n    var el = api.getZr().storage.getDisplayList()[0];\n    if (!(el && el.useHoverLayer)) {\n        seriesModel.get('legendHoverLink') && api.dispatchAction({\n            type: 'highlight',\n            seriesName: seriesModel.name,\n            name: dataName\n        });\n    }\n}\n\nfunction dispatchDownplayAction(seriesModel, dataName, api) {\n    // If element hover will move to a hoverLayer.\n    var el = api.getZr().storage.getDisplayList()[0];\n    if (!(el && el.useHoverLayer)) {\n        seriesModel.get('legendHoverLink') && api.dispatchAction({\n            type: 'downplay',\n            seriesName: seriesModel.name,\n            name: dataName\n        });\n    }\n}\n\nvar legendFilter = function (ecModel) {\n\n    var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n    });\n    if (legendModels && legendModels.length) {\n        ecModel.filterSeries(function (series) {\n            // If in any legend component the status is not selected.\n            // Because in legend series is assumed selected when it is not in the legend data.\n            for (var i = 0; i < legendModels.length; i++) {\n                if (!legendModels[i].isSelected(series.name)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n\n};\n\n// Do not contain scrollable legend, for sake of file size.\n\n// Series Filter\nregisterProcessor(legendFilter);\n\nComponentModel.registerSubTypeDefaulter('legend', function () {\n    // Default 'plain' when no type specified.\n    return 'plain';\n});\n\nvar ScrollableLegendModel = LegendModel.extend({\n\n    type: 'legend.scroll',\n\n    /**\n     * @param {number} scrollDataIndex\n     */\n    setScrollDataIndex: function (scrollDataIndex) {\n        this.option.scrollDataIndex = scrollDataIndex;\n    },\n\n    defaultOption: {\n        scrollDataIndex: 0,\n        pageButtonItemGap: 5,\n        pageButtonGap: null,\n        pageButtonPosition: 'end', // 'start' or 'end'\n        pageFormatter: '{current}/{total}', // If null/undefined, do not show page.\n        pageIcons: {\n            horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],\n            vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z']\n        },\n        pageIconColor: '#2f4554',\n        pageIconInactiveColor: '#aaa',\n        pageIconSize: 15, // Can be [10, 3], which represents [width, height]\n        pageTextStyle: {\n            color: '#333'\n        },\n\n        animationDurationUpdate: 800\n    },\n\n    /**\n     * @override\n     */\n    init: function (option, parentModel, ecModel, extraOpt) {\n        var inputPositionParams = getLayoutParams(option);\n\n        ScrollableLegendModel.superCall(this, 'init', option, parentModel, ecModel, extraOpt);\n\n        mergeAndNormalizeLayoutParams(this, option, inputPositionParams);\n    },\n\n    /**\n     * @override\n     */\n    mergeOption: function (option, extraOpt) {\n        ScrollableLegendModel.superCall(this, 'mergeOption', option, extraOpt);\n\n        mergeAndNormalizeLayoutParams(this, this.option, option);\n    },\n\n    getOrient: function () {\n        return this.get('orient') === 'vertical'\n            ? {index: 1, name: 'vertical'}\n            : {index: 0, name: 'horizontal'};\n    }\n\n});\n\n// Do not `ignoreSize` to enable setting {left: 10, right: 10}.\nfunction mergeAndNormalizeLayoutParams(legendModel, target, raw) {\n    var orient = legendModel.getOrient();\n    var ignoreSize = [1, 1];\n    ignoreSize[orient.index] = 0;\n    mergeLayoutParam(target, raw, {\n        type: 'box', ignoreSize: ignoreSize\n    });\n}\n\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\n\nvar Group$4 = Group;\n\nvar WH$1 = ['width', 'height'];\nvar XY$1 = ['x', 'y'];\n\nvar ScrollableLegendView = LegendView.extend({\n\n    type: 'legend.scroll',\n\n    newlineDisabled: true,\n\n    init: function () {\n\n        ScrollableLegendView.superCall(this, 'init');\n\n        /**\n         * @private\n         * @type {number} For `scroll`.\n         */\n        this._currentIndex = 0;\n\n        /**\n         * @private\n         * @type {module:zrender/container/Group}\n         */\n        this.group.add(this._containerGroup = new Group$4());\n        this._containerGroup.add(this.getContentGroup());\n\n        /**\n         * @private\n         * @type {module:zrender/container/Group}\n         */\n        this.group.add(this._controllerGroup = new Group$4());\n\n        /**\n         *\n         * @private\n         */\n        this._showController;\n    },\n\n    /**\n     * @override\n     */\n    resetInner: function () {\n        ScrollableLegendView.superCall(this, 'resetInner');\n\n        this._controllerGroup.removeAll();\n        this._containerGroup.removeClipPath();\n        this._containerGroup.__rectSize = null;\n    },\n\n    /**\n     * @override\n     */\n    renderInner: function (itemAlign, legendModel, ecModel, api) {\n        var me = this;\n\n        // Render content items.\n        ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api);\n\n        var controllerGroup = this._controllerGroup;\n\n        var pageIconSize = legendModel.get('pageIconSize', true);\n        if (!isArray(pageIconSize)) {\n            pageIconSize = [pageIconSize, pageIconSize];\n        }\n\n        createPageButton('pagePrev', 0);\n\n        var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n        controllerGroup.add(new Text({\n            name: 'pageText',\n            style: {\n                textFill: pageTextStyleModel.getTextColor(),\n                font: pageTextStyleModel.getFont(),\n                textVerticalAlign: 'middle',\n                textAlign: 'center'\n            },\n            silent: true\n        }));\n\n        createPageButton('pageNext', 1);\n\n        function createPageButton(name, iconIdx) {\n            var pageDataIndexName = name + 'DataIndex';\n            var icon = createIcon(\n                legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx],\n                {\n                    // Buttons will be created in each render, so we do not need\n                    // to worry about avoiding using legendModel kept in scope.\n                    onclick: bind(\n                        me._pageGo, me, pageDataIndexName, legendModel, api\n                    )\n                },\n                {\n                    x: -pageIconSize[0] / 2,\n                    y: -pageIconSize[1] / 2,\n                    width: pageIconSize[0],\n                    height: pageIconSize[1]\n                }\n            );\n            icon.name = name;\n            controllerGroup.add(icon);\n        }\n    },\n\n    /**\n     * @override\n     */\n    layoutInner: function (legendModel, itemAlign, maxSize) {\n        var contentGroup = this.getContentGroup();\n        var containerGroup = this._containerGroup;\n        var controllerGroup = this._controllerGroup;\n\n        var orientIdx = legendModel.getOrient().index;\n        var wh = WH$1[orientIdx];\n        var hw = WH$1[1 - orientIdx];\n        var yx = XY$1[1 - orientIdx];\n\n        // Place items in contentGroup.\n        box(\n            legendModel.get('orient'),\n            contentGroup,\n            legendModel.get('itemGap'),\n            !orientIdx ? null : maxSize.width,\n            orientIdx ? null : maxSize.height\n        );\n\n        box(\n            // Buttons in controller are layout always horizontally.\n            'horizontal',\n            controllerGroup,\n            legendModel.get('pageButtonItemGap', true)\n        );\n\n        var contentRect = contentGroup.getBoundingRect();\n        var controllerRect = controllerGroup.getBoundingRect();\n        var showController = this._showController = contentRect[wh] > maxSize[wh];\n\n        var contentPos = [-contentRect.x, -contentRect.y];\n        // Remain contentPos when scroll animation perfroming.\n        contentPos[orientIdx] = contentGroup.position[orientIdx];\n\n        // Layout container group based on 0.\n        var containerPos = [0, 0];\n        var controllerPos = [-controllerRect.x, -controllerRect.y];\n        var pageButtonGap = retrieve2(\n            legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)\n        );\n\n        // Place containerGroup and controllerGroup and contentGroup.\n        if (showController) {\n            var pageButtonPosition = legendModel.get('pageButtonPosition', true);\n            // controller is on the right / bottom.\n            if (pageButtonPosition === 'end') {\n                controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n            }\n            // controller is on the left / top.\n            else {\n                containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n            }\n        }\n\n        // Always align controller to content as 'middle'.\n        controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n\n        contentGroup.attr('position', contentPos);\n        containerGroup.attr('position', containerPos);\n        controllerGroup.attr('position', controllerPos);\n\n        // Calculate `mainRect` and set `clipPath`.\n        // mainRect should not be calculated by `this.group.getBoundingRect()`\n        // for sake of the overflow.\n        var mainRect = this.group.getBoundingRect();\n        var mainRect = {x: 0, y: 0};\n        // Consider content may be overflow (should be clipped).\n        mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n        mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]);\n        // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n        mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n\n        containerGroup.__rectSize = maxSize[wh];\n        if (showController) {\n            var clipShape = {x: 0, y: 0};\n            clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n            clipShape[hw] = mainRect[hw];\n            containerGroup.setClipPath(new Rect({shape: clipShape}));\n            // Consider content may be larger than container, container rect\n            // can not be obtained from `containerGroup.getBoundingRect()`.\n            containerGroup.__rectSize = clipShape[wh];\n        }\n        else {\n            // Do not remove or ignore controller. Keep them set as place holders.\n            controllerGroup.eachChild(function (child) {\n                child.attr({invisible: true, silent: true});\n            });\n        }\n\n        // Content translate animation.\n        var pageInfo = this._getPageInfo(legendModel);\n        pageInfo.pageIndex != null && updateProps(\n            contentGroup,\n            {position: pageInfo.contentPosition},\n            // When switch from \"show controller\" to \"not show controller\", view should be\n            // updated immediately without animation, otherwise causes weird efffect.\n            showController ? legendModel : false\n        );\n\n        this._updatePageInfoView(legendModel, pageInfo);\n\n        return mainRect;\n    },\n\n    _pageGo: function (to, legendModel, api) {\n        var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n        scrollDataIndex != null && api.dispatchAction({\n            type: 'legendScroll',\n            scrollDataIndex: scrollDataIndex,\n            legendId: legendModel.id\n        });\n    },\n\n    _updatePageInfoView: function (legendModel, pageInfo) {\n        var controllerGroup = this._controllerGroup;\n\n        each$1(['pagePrev', 'pageNext'], function (name) {\n            var canJump = pageInfo[name + 'DataIndex'] != null;\n            var icon = controllerGroup.childOfName(name);\n            if (icon) {\n                icon.setStyle(\n                    'fill',\n                    canJump\n                        ? legendModel.get('pageIconColor', true)\n                        : legendModel.get('pageIconInactiveColor', true)\n                );\n                icon.cursor = canJump ? 'pointer' : 'default';\n            }\n        });\n\n        var pageText = controllerGroup.childOfName('pageText');\n        var pageFormatter = legendModel.get('pageFormatter');\n        var pageIndex = pageInfo.pageIndex;\n        var current = pageIndex != null ? pageIndex + 1 : 0;\n        var total = pageInfo.pageCount;\n\n        pageText && pageFormatter && pageText.setStyle(\n            'text',\n            isString(pageFormatter)\n                ? pageFormatter.replace('{current}', current).replace('{total}', total)\n                : pageFormatter({current: current, total: total})\n        );\n    },\n\n    /**\n     * @param {module:echarts/model/Model} legendModel\n     * @return {Object} {\n     *  contentPosition: Array.<number>, null when data item not found.\n     *  pageIndex: number, null when data item not found.\n     *  pageCount: number, always be a number, can be 0.\n     *  pagePrevDataIndex: number, null when no next page.\n     *  pageNextDataIndex: number, null when no previous page.\n     * }\n     */\n    _getPageInfo: function (legendModel) {\n        // Align left or top by the current dataIndex.\n        var currDataIndex = legendModel.get('scrollDataIndex', true);\n        var contentGroup = this.getContentGroup();\n        var contentRect = contentGroup.getBoundingRect();\n        var containerRectSize = this._containerGroup.__rectSize;\n\n        var orientIdx = legendModel.getOrient().index;\n        var wh = WH$1[orientIdx];\n        var hw = WH$1[1 - orientIdx];\n        var xy = XY$1[orientIdx];\n        var contentPos = contentGroup.position.slice();\n\n        var pageIndex;\n        var pagePrevDataIndex;\n        var pageNextDataIndex;\n\n        var targetItemGroup;\n        if (this._showController) {\n            contentGroup.eachChild(function (child) {\n                if (child.__legendDataIndex === currDataIndex) {\n                    targetItemGroup = child;\n                }\n            });\n        }\n        else {\n            targetItemGroup = contentGroup.childAt(0);\n        }\n\n        var pageCount = containerRectSize ? Math.ceil(contentRect[wh] / containerRectSize) : 0;\n\n        if (targetItemGroup) {\n            var itemRect = targetItemGroup.getBoundingRect();\n            var itemLoc = targetItemGroup.position[orientIdx] + itemRect[xy];\n            contentPos[orientIdx] = -itemLoc - contentRect[xy];\n            pageIndex = Math.floor(\n                pageCount * (itemLoc + itemRect[xy] + containerRectSize / 2) / contentRect[wh]\n            );\n            pageIndex = (contentRect[wh] && pageCount)\n                ? Math.max(0, Math.min(pageCount - 1, pageIndex))\n                : -1;\n\n            var winRect = {x: 0, y: 0};\n            winRect[wh] = containerRectSize;\n            winRect[hw] = contentRect[hw];\n            winRect[xy] = -contentPos[orientIdx] - contentRect[xy];\n\n            var startIdx;\n            var children = contentGroup.children();\n\n            contentGroup.eachChild(function (child, index) {\n                var itemRect = getItemRect(child);\n\n                if (itemRect.intersect(winRect)) {\n                    startIdx == null && (startIdx = index);\n                    // It is user-friendly that the last item shown in the\n                    // current window is shown at the begining of next window.\n                    pageNextDataIndex = child.__legendDataIndex;\n                }\n\n                // If the last item is shown entirely, no next page.\n                if (index === children.length - 1\n                    && itemRect[xy] + itemRect[wh] <= winRect[xy] + winRect[wh]\n                ) {\n                    pageNextDataIndex = null;\n                }\n            });\n\n            // Always align based on the left/top most item, so the left/top most\n            // item in the previous window is needed to be found here.\n            if (startIdx != null) {\n                var startItem = children[startIdx];\n                var startRect = getItemRect(startItem);\n                winRect[xy] = startRect[xy] + startRect[wh] - winRect[wh];\n\n                // If the first item is shown entirely, no previous page.\n                if (startIdx <= 0 && startRect[xy] >= winRect[xy]) {\n                    pagePrevDataIndex = null;\n                }\n                else {\n                    while (startIdx > 0 && getItemRect(children[startIdx - 1]).intersect(winRect)) {\n                        startIdx--;\n                    }\n                    pagePrevDataIndex = children[startIdx].__legendDataIndex;\n                }\n            }\n        }\n\n        return {\n            contentPosition: contentPos,\n            pageIndex: pageIndex,\n            pageCount: pageCount,\n            pagePrevDataIndex: pagePrevDataIndex,\n            pageNextDataIndex: pageNextDataIndex\n        };\n\n        function getItemRect(el) {\n            var itemRect = el.getBoundingRect().clone();\n            itemRect[xy] += el.position[orientIdx];\n            return itemRect;\n        }\n    }\n\n});\n\n/**\n * @event legendScroll\n * @type {Object}\n * @property {string} type 'legendScroll'\n * @property {string} scrollDataIndex\n */\nregisterAction(\n    'legendScroll', 'legendscroll',\n    function (payload, ecModel) {\n        var scrollDataIndex = payload.scrollDataIndex;\n\n        scrollDataIndex != null && ecModel.eachComponent(\n            {mainType: 'legend', subType: 'scroll', query: payload},\n            function (legendModel) {\n                legendModel.setScrollDataIndex(scrollDataIndex);\n            }\n        );\n    }\n);\n\n/**\n * Legend component entry file8\n */\n\nextendComponentModel({\n\n    type: 'tooltip',\n\n    dependencies: ['axisPointer'],\n\n    defaultOption: {\n        zlevel: 0,\n\n        z: 8,\n\n        show: true,\n\n        // tooltip\n        showContent: true,\n\n        // 'trigger' only works on coordinate system.\n        // 'item' | 'axis' | 'none'\n        trigger: 'item',\n\n        // 'click' | 'mousemove' | 'none'\n        triggerOn: 'mousemove|click',\n\n        alwaysShowContent: false,\n\n        displayMode: 'single', // 'single' | 'multipleByCoordSys'\n\n        //  {Array} | {Function}\n        // position: null\n        // Consider triggered from axisPointer handle, verticalAlign should be 'middle'\n        // align: null,\n        // verticalAlign: null,\n\n        //  content  viewRect  false \n        confine: false,\n\n        // {string}Template  {Function}\n        // formatter: null\n\n        showDelay: 0,\n\n        // ms\n        hideDelay: 100,\n\n        // s\n        transitionDuration: 0.4,\n\n        enterable: false,\n\n        // 0.7\n        backgroundColor: 'rgba(50,50,50,0.7)',\n\n        // \n        borderColor: '#333',\n\n        // px4\n        borderRadius: 4,\n\n        // px0\n        borderWidth: 0,\n\n        // px5\n        // css\n        padding: 5,\n\n        // Extra css text\n        extraCssText: '',\n\n        // \n        axisPointer: {\n            // \n            // 'line' | 'shadow' | 'cross'\n            type: 'line',\n\n            // type  line  tooltip line \n            //  'x' | 'y' | 'angle' | 'radius' | 'auto'\n            //  'auto' cateogry  x \n            //  angle \n            axis: 'auto',\n\n            animation: 'auto',\n            animationDurationUpdate: 200,\n            animationEasingUpdate: 'exponentialOut',\n\n            crossStyle: {\n                color: '#999',\n                width: 1,\n                type: 'dashed',\n\n                // TODO formatter\n                textStyle: {}\n            }\n\n            // lineStyle and shadowStyle should not be specified here,\n            // otherwise it will always override those styles on option.axisPointer.\n        },\n        textStyle: {\n            color: '#fff',\n            fontSize: 14\n        }\n    }\n});\n\nvar each$21 = each$1;\nvar toCamelCase$1 = toCamelCase;\n\nvar vendors = ['', '-webkit-', '-moz-', '-o-'];\n\nvar gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\n/**\n * @param {number} duration\n * @return {string}\n * @inner\n */\nfunction assembleTransition(duration) {\n    var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n    var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\n                        + 'top ' + duration + 's ' + transitionCurve;\n    return map(vendors, function (vendorPrefix) {\n        return vendorPrefix + 'transition:' + transitionText;\n    }).join(';');\n}\n\n/**\n * @param {Object} textStyle\n * @return {string}\n * @inner\n */\nfunction assembleFont(textStyleModel) {\n    var cssText = [];\n\n    var fontSize = textStyleModel.get('fontSize');\n    var color = textStyleModel.getTextColor();\n\n    color && cssText.push('color:' + color);\n\n    cssText.push('font:' + textStyleModel.getFont());\n\n    fontSize &&\n        cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n\n    each$21(['decoration', 'align'], function (name) {\n        var val = textStyleModel.get(name);\n        val && cssText.push('text-' + name + ':' + val);\n    });\n\n    return cssText.join(';');\n}\n\n/**\n * @param {Object} tooltipModel\n * @return {string}\n * @inner\n */\nfunction assembleCssText(tooltipModel) {\n\n    var cssText = [];\n\n    var transitionDuration = tooltipModel.get('transitionDuration');\n    var backgroundColor = tooltipModel.get('backgroundColor');\n    var textStyleModel = tooltipModel.getModel('textStyle');\n    var padding = tooltipModel.get('padding');\n\n    // Animation transition. Do not animate when transitionDuration is 0.\n    transitionDuration &&\n        cssText.push(assembleTransition(transitionDuration));\n\n    if (backgroundColor) {\n        if (env$1.canvasSupported) {\n            cssText.push('background-Color:' + backgroundColor);\n        }\n        else {\n            // for ie\n            cssText.push(\n                'background-Color:#' + toHex(backgroundColor)\n            );\n            cssText.push('filter:alpha(opacity=70)');\n        }\n    }\n\n    // Border style\n    each$21(['width', 'color', 'radius'], function (name) {\n        var borderName = 'border-' + name;\n        var camelCase = toCamelCase$1(borderName);\n        var val = tooltipModel.get(camelCase);\n        val != null &&\n            cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n    });\n\n    // Text style\n    cssText.push(assembleFont(textStyleModel));\n\n    // Padding\n    if (padding != null) {\n        cssText.push('padding:' + normalizeCssArray$1(padding).join('px ') + 'px');\n    }\n\n    return cssText.join(';') + ';';\n}\n\n/**\n * @alias module:echarts/component/tooltip/TooltipContent\n * @constructor\n */\nfunction TooltipContent(container, api) {\n    var el = document.createElement('div');\n    var zr = this._zr = api.getZr();\n\n    this.el = el;\n\n    this._x = api.getWidth() / 2;\n    this._y = api.getHeight() / 2;\n\n    container.appendChild(el);\n\n    this._container = container;\n\n    this._show = false;\n\n    /**\n     * @private\n     */\n    this._hideTimeout;\n\n    var self = this;\n    el.onmouseenter = function () {\n        // clear the timeout in hideLater and keep showing tooltip\n        if (self._enterable) {\n            clearTimeout(self._hideTimeout);\n            self._show = true;\n        }\n        self._inContent = true;\n    };\n    el.onmousemove = function (e) {\n        e = e || window.event;\n        if (!self._enterable) {\n            // Try trigger zrender event to avoid mouse\n            // in and out shape too frequently\n            var handler = zr.handler;\n            normalizeEvent(container, e, true);\n            handler.dispatch('mousemove', e);\n        }\n    };\n    el.onmouseleave = function () {\n        if (self._enterable) {\n            if (self._show) {\n                self.hideLater(self._hideDelay);\n            }\n        }\n        self._inContent = false;\n    };\n}\n\nTooltipContent.prototype = {\n\n    constructor: TooltipContent,\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _enterable: true,\n\n    /**\n     * Update when tooltip is rendered\n     */\n    update: function () {\n        // FIXME\n        // Move this logic to ec main?\n        var container = this._container;\n        var stl = container.currentStyle\n            || document.defaultView.getComputedStyle(container);\n        var domStyle = container.style;\n        if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n            domStyle.position = 'relative';\n        }\n        // Hide the tooltip\n        // PENDING\n        // this.hide();\n    },\n\n    show: function (tooltipModel) {\n        clearTimeout(this._hideTimeout);\n        var el = this.el;\n\n        el.style.cssText = gCssText + assembleCssText(tooltipModel)\n            // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n            + ';left:' + this._x + 'px;top:' + this._y + 'px;'\n            + (tooltipModel.get('extraCssText') || '');\n\n        el.style.display = el.innerHTML ?  'block' : 'none';\n\n        this._show = true;\n    },\n\n    setContent: function (content) {\n        this.el.innerHTML = content == null ? '' : content;\n    },\n\n    setEnterable: function (enterable) {\n        this._enterable = enterable;\n    },\n\n    getSize: function () {\n        var el = this.el;\n        return [el.clientWidth, el.clientHeight];\n    },\n\n    moveTo: function (x, y) {\n        // xy should be based on canvas root. But tooltipContent is\n        // the sibling of canvas root. So padding of ec container\n        // should be considered here.\n        var zr = this._zr;\n        var viewportRootOffset;\n        if (zr && zr.painter && (viewportRootOffset = zr.painter.getViewportRootOffset())) {\n            x += viewportRootOffset.offsetLeft;\n            y += viewportRootOffset.offsetTop;\n        }\n\n        var style = this.el.style;\n        style.left = x + 'px';\n        style.top = y + 'px';\n\n        this._x = x;\n        this._y = y;\n    },\n\n    hide: function () {\n        this.el.style.display = 'none';\n        this._show = false;\n    },\n\n    hideLater: function (time) {\n        if (this._show && !(this._inContent && this._enterable)) {\n            if (time) {\n                this._hideDelay = time;\n                // Set show false to avoid invoke hideLater mutiple times\n                this._show = false;\n                this._hideTimeout = setTimeout(bind(this.hide, this), time);\n            }\n            else {\n                this.hide();\n            }\n        }\n    },\n\n    isShow: function () {\n        return this._show;\n    }\n};\n\nvar bind$3 = bind;\nvar each$20 = each$1;\nvar parsePercent$2 = parsePercent$1;\n\nvar proxyRect = new Rect({\n    shape: {x: -1, y: -1, width: 2, height: 2}\n});\n\nextendComponentView({\n\n    type: 'tooltip',\n\n    init: function (ecModel, api) {\n        if (env$1.node) {\n            return;\n        }\n        var tooltipContent = new TooltipContent(api.getDom(), api);\n        this._tooltipContent = tooltipContent;\n    },\n\n    render: function (tooltipModel, ecModel, api) {\n        if (env$1.node) {\n            return;\n        }\n\n        // Reset\n        this.group.removeAll();\n\n        /**\n         * @private\n         * @type {module:echarts/component/tooltip/TooltipModel}\n         */\n        this._tooltipModel = tooltipModel;\n\n        /**\n         * @private\n         * @type {module:echarts/model/Global}\n         */\n        this._ecModel = ecModel;\n\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n\n        /**\n         * Should be cleaned when render.\n         * @private\n         * @type {Array.<Array.<Object>>}\n         */\n        this._lastDataByCoordSys = null;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n\n        var tooltipContent = this._tooltipContent;\n        tooltipContent.update();\n        tooltipContent.setEnterable(tooltipModel.get('enterable'));\n\n        this._initGlobalListener();\n\n        this._keepShow();\n    },\n\n    _initGlobalListener: function () {\n        var tooltipModel = this._tooltipModel;\n        var triggerOn = tooltipModel.get('triggerOn');\n\n        register(\n            'itemTooltip',\n            this._api,\n            bind$3(function (currTrigger, e, dispatchAction) {\n                // If 'none', it is not controlled by mouse totally.\n                if (triggerOn !== 'none') {\n                    if (triggerOn.indexOf(currTrigger) >= 0) {\n                        this._tryShow(e, dispatchAction);\n                    }\n                    else if (currTrigger === 'leave') {\n                        this._hide(dispatchAction);\n                    }\n                }\n            }, this)\n        );\n    },\n\n    _keepShow: function () {\n        var tooltipModel = this._tooltipModel;\n        var ecModel = this._ecModel;\n        var api = this._api;\n\n        // Try to keep the tooltip show when refreshing\n        if (this._lastX != null\n            && this._lastY != null\n            // When user is willing to control tooltip totally using API,\n            // self.manuallyShowTip({x, y}) might cause tooltip hide,\n            // which is not expected.\n            && tooltipModel.get('triggerOn') !== 'none'\n        ) {\n            var self = this;\n            clearTimeout(this._refreshUpdateTimeout);\n            this._refreshUpdateTimeout = setTimeout(function () {\n                // Show tip next tick after other charts are rendered\n                // In case highlight action has wrong result\n                // FIXME\n                self.manuallyShowTip(tooltipModel, ecModel, api, {\n                    x: self._lastX,\n                    y: self._lastY\n                });\n            });\n        }\n    },\n\n    /**\n     * Show tip manually by\n     * dispatchAction({\n     *     type: 'showTip',\n     *     x: 10,\n     *     y: 10\n     * });\n     * Or\n     * dispatchAction({\n     *      type: 'showTip',\n     *      seriesIndex: 0,\n     *      dataIndex or dataIndexInside or name\n     * });\n     *\n     *  TODO Batch\n     */\n    manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n        if (payload.from === this.uid || env$1.node) {\n            return;\n        }\n\n        var dispatchAction = makeDispatchAction$1(payload, api);\n\n        // Reset ticket\n        this._ticket = '';\n\n        // When triggered from axisPointer.\n        var dataByCoordSys = payload.dataByCoordSys;\n\n        if (payload.tooltip && payload.x != null && payload.y != null) {\n            var el = proxyRect;\n            el.position = [payload.x, payload.y];\n            el.update();\n            el.tooltip = payload.tooltip;\n            // Manually show tooltip while view is not using zrender elements.\n            this._tryShow({\n                offsetX: payload.x,\n                offsetY: payload.y,\n                target: el\n            }, dispatchAction);\n        }\n        else if (dataByCoordSys) {\n            this._tryShow({\n                offsetX: payload.x,\n                offsetY: payload.y,\n                position: payload.position,\n                event: {},\n                dataByCoordSys: payload.dataByCoordSys,\n                tooltipOption: payload.tooltipOption\n            }, dispatchAction);\n        }\n        else if (payload.seriesIndex != null) {\n\n            if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {\n                return;\n            }\n\n            var pointInfo = findPointFromSeries(payload, ecModel);\n            var cx = pointInfo.point[0];\n            var cy = pointInfo.point[1];\n            if (cx != null && cy != null) {\n                this._tryShow({\n                    offsetX: cx,\n                    offsetY: cy,\n                    position: payload.position,\n                    target: pointInfo.el,\n                    event: {}\n                }, dispatchAction);\n            }\n        }\n        else if (payload.x != null && payload.y != null) {\n            // FIXME\n            // should wrap dispatchAction like `axisPointer/globalListener` ?\n            api.dispatchAction({\n                type: 'updateAxisPointer',\n                x: payload.x,\n                y: payload.y\n            });\n\n            this._tryShow({\n                offsetX: payload.x,\n                offsetY: payload.y,\n                position: payload.position,\n                target: api.getZr().findHover(payload.x, payload.y).target,\n                event: {}\n            }, dispatchAction);\n        }\n    },\n\n    manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n        var tooltipContent = this._tooltipContent;\n\n        if (!this._alwaysShowContent) {\n            tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n        }\n\n        this._lastX = this._lastY = null;\n\n        if (payload.from !== this.uid) {\n            this._hide(makeDispatchAction$1(payload, api));\n        }\n    },\n\n    // Be compatible with previous design, that is, when tooltip.type is 'axis' and\n    // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer\n    // and tooltip.\n    _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {\n        var seriesIndex = payload.seriesIndex;\n        var dataIndex = payload.dataIndex;\n        var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n        if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {\n            return;\n        }\n\n        var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n        if (!seriesModel) {\n            return;\n        }\n\n        var data = seriesModel.getData();\n        var tooltipModel = buildTooltipModel([\n            data.getItemModel(dataIndex),\n            seriesModel,\n            (seriesModel.coordinateSystem || {}).model,\n            tooltipModel\n        ]);\n\n        if (tooltipModel.get('trigger') !== 'axis') {\n            return;\n        }\n\n        api.dispatchAction({\n            type: 'updateAxisPointer',\n            seriesIndex: seriesIndex,\n            dataIndex: dataIndex,\n            position: payload.position\n        });\n\n        return true;\n    },\n\n    _tryShow: function (e, dispatchAction) {\n        var el = e.target;\n        var tooltipModel = this._tooltipModel;\n\n        if (!tooltipModel) {\n            return;\n        }\n\n        // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n        this._lastX = e.offsetX;\n        this._lastY = e.offsetY;\n\n        var dataByCoordSys = e.dataByCoordSys;\n        if (dataByCoordSys && dataByCoordSys.length) {\n            this._showAxisTooltip(dataByCoordSys, e);\n        }\n        // Always show item tooltip if mouse is on the element with dataIndex\n        else if (el && el.dataIndex != null) {\n            this._lastDataByCoordSys = null;\n            this._showSeriesItemTooltip(e, el, dispatchAction);\n        }\n        // Tooltip provided directly. Like legend.\n        else if (el && el.tooltip) {\n            this._lastDataByCoordSys = null;\n            this._showComponentItemTooltip(e, el, dispatchAction);\n        }\n        else {\n            this._lastDataByCoordSys = null;\n            this._hide(dispatchAction);\n        }\n    },\n\n    _showOrMove: function (tooltipModel, cb) {\n        // showDelay is used in this case: tooltip.enterable is set\n        // as true. User intent to move mouse into tooltip and click\n        // something. `showDelay` makes it easyer to enter the content\n        // but tooltip do not move immediately.\n        var delay = tooltipModel.get('showDelay');\n        cb = bind(cb, this);\n        clearTimeout(this._showTimout);\n        delay > 0\n            ? (this._showTimout = setTimeout(cb, delay))\n            : cb();\n    },\n\n    _showAxisTooltip: function (dataByCoordSys, e) {\n        var ecModel = this._ecModel;\n        var globalTooltipModel = this._tooltipModel;\n        var point = [e.offsetX, e.offsetY];\n        var singleDefaultHTML = [];\n        var singleParamsList = [];\n        var singleTooltipModel = buildTooltipModel([\n            e.tooltipOption,\n            globalTooltipModel\n        ]);\n\n        each$20(dataByCoordSys, function (itemCoordSys) {\n            // var coordParamList = [];\n            // var coordDefaultHTML = [];\n            // var coordTooltipModel = buildTooltipModel([\n            //     e.tooltipOption,\n            //     itemCoordSys.tooltipOption,\n            //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),\n            //     globalTooltipModel\n            // ]);\n            // var displayMode = coordTooltipModel.get('displayMode');\n            // var paramsList = displayMode === 'single' ? singleParamsList : [];\n\n            each$20(itemCoordSys.dataByAxis, function (item) {\n                var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);\n                var axisValue = item.value;\n                var seriesDefaultHTML = [];\n\n                if (!axisModel || axisValue == null) {\n                    return;\n                }\n\n                var valueLabel = getValueLabel(\n                    axisValue, axisModel.axis, ecModel,\n                    item.seriesDataIndices,\n                    item.valueLabelOpt\n                );\n\n                each$1(item.seriesDataIndices, function (idxItem) {\n                    var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n                    var dataIndex = idxItem.dataIndexInside;\n                    var dataParams = series && series.getDataParams(dataIndex);\n                    dataParams.axisDim = item.axisDim;\n                    dataParams.axisIndex = item.axisIndex;\n                    dataParams.axisType = item.axisType;\n                    dataParams.axisId = item.axisId;\n                    dataParams.axisValue = getAxisRawValue(axisModel.axis, axisValue);\n                    dataParams.axisValueLabel = valueLabel;\n\n                    if (dataParams) {\n                        singleParamsList.push(dataParams);\n                        seriesDefaultHTML.push(series.formatTooltip(dataIndex, true));\n                    }\n                });\n\n                // Default tooltip content\n                // FIXME\n                // (1) shold be the first data which has name?\n                // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n                var firstLine = valueLabel;\n                singleDefaultHTML.push(\n                    (firstLine ? encodeHTML(firstLine) + '<br />' : '')\n                    + seriesDefaultHTML.join('<br />')\n                );\n            });\n        }, this);\n\n        // In most case, the second axis is shown upper than the first one.\n        singleDefaultHTML.reverse();\n        singleDefaultHTML = singleDefaultHTML.join('<br /><br />');\n\n        var positionExpr = e.position;\n        this._showOrMove(singleTooltipModel, function () {\n            if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {\n                this._updatePosition(\n                    singleTooltipModel,\n                    positionExpr,\n                    point[0], point[1],\n                    this._tooltipContent,\n                    singleParamsList\n                );\n            }\n            else {\n                this._showTooltipContent(\n                    singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(),\n                    point[0], point[1], positionExpr\n                );\n            }\n        });\n\n        // Do not trigger events here, because this branch only be entered\n        // from dispatchAction.\n    },\n\n    _showSeriesItemTooltip: function (e, el, dispatchAction) {\n        var ecModel = this._ecModel;\n        // Use dataModel in element if possible\n        // Used when mouseover on a element like markPoint or edge\n        // In which case, the data is not main data in series.\n        var seriesIndex = el.seriesIndex;\n        var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\n        // For example, graph link.\n        var dataModel = el.dataModel || seriesModel;\n        var dataIndex = el.dataIndex;\n        var dataType = el.dataType;\n        var data = dataModel.getData();\n\n        var tooltipModel = buildTooltipModel([\n            data.getItemModel(dataIndex),\n            dataModel,\n            seriesModel && (seriesModel.coordinateSystem || {}).model,\n            this._tooltipModel\n        ]);\n\n        var tooltipTrigger = tooltipModel.get('trigger');\n        if (tooltipTrigger != null && tooltipTrigger !== 'item') {\n            return;\n        }\n\n        var params = dataModel.getDataParams(dataIndex, dataType);\n        var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType);\n        var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;\n\n        this._showOrMove(tooltipModel, function () {\n            this._showTooltipContent(\n                tooltipModel, defaultHtml, params, asyncTicket,\n                e.offsetX, e.offsetY, e.position, e.target\n            );\n        });\n\n        // FIXME\n        // duplicated showtip if manuallyShowTip is called from dispatchAction.\n        dispatchAction({\n            type: 'showTip',\n            dataIndexInside: dataIndex,\n            dataIndex: data.getRawIndex(dataIndex),\n            seriesIndex: seriesIndex,\n            from: this.uid\n        });\n    },\n\n    _showComponentItemTooltip: function (e, el, dispatchAction) {\n        var tooltipOpt = el.tooltip;\n        if (typeof tooltipOpt === 'string') {\n            var content = tooltipOpt;\n            tooltipOpt = {\n                content: content,\n                // Fixed formatter\n                formatter: content\n            };\n        }\n        var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);\n        var defaultHtml = subTooltipModel.get('content');\n        var asyncTicket = Math.random();\n\n        // Do not check whether `trigger` is 'none' here, because `trigger`\n        // only works on cooridinate system. In fact, we have not found case\n        // that requires setting `trigger` nothing on component yet.\n\n        this._showOrMove(subTooltipModel, function () {\n            this._showTooltipContent(\n                subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\n                asyncTicket, e.offsetX, e.offsetY, e.position, el\n            );\n        });\n\n        // If not dispatch showTip, tip may be hide triggered by axis.\n        dispatchAction({\n            type: 'showTip',\n            from: this.uid\n        });\n    },\n\n    _showTooltipContent: function (\n        tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el\n    ) {\n        // Reset ticket\n        this._ticket = '';\n\n        if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\n            return;\n        }\n\n        var tooltipContent = this._tooltipContent;\n\n        var formatter = tooltipModel.get('formatter');\n        positionExpr = positionExpr || tooltipModel.get('position');\n        var html = defaultHtml;\n\n        if (formatter && typeof formatter === 'string') {\n            html = formatTpl(formatter, params, true);\n        }\n        else if (typeof formatter === 'function') {\n            var callback = bind$3(function (cbTicket, html) {\n                if (cbTicket === this._ticket) {\n                    tooltipContent.setContent(html);\n                    this._updatePosition(\n                        tooltipModel, positionExpr, x, y, tooltipContent, params, el\n                    );\n                }\n            }, this);\n            this._ticket = asyncTicket;\n            html = formatter(params, asyncTicket, callback);\n        }\n\n        tooltipContent.setContent(html);\n        tooltipContent.show(tooltipModel);\n\n        this._updatePosition(\n            tooltipModel, positionExpr, x, y, tooltipContent, params, el\n        );\n    },\n\n    /**\n     * @param  {string|Function|Array.<number>|Object} positionExpr\n     * @param  {number} x Mouse x\n     * @param  {number} y Mouse y\n     * @param  {boolean} confine Whether confine tooltip content in view rect.\n     * @param  {Object|<Array.<Object>} params\n     * @param  {module:zrender/Element} el target element\n     * @param  {module:echarts/ExtensionAPI} api\n     * @return {Array.<number>}\n     */\n    _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {\n        var viewWidth = this._api.getWidth();\n        var viewHeight = this._api.getHeight();\n        positionExpr = positionExpr || tooltipModel.get('position');\n\n        var contentSize = content.getSize();\n        var align = tooltipModel.get('align');\n        var vAlign = tooltipModel.get('verticalAlign');\n        var rect = el && el.getBoundingRect().clone();\n        el && rect.applyTransform(el.transform);\n\n        if (typeof positionExpr === 'function') {\n            // Callback of position can be an array or a string specify the position\n            positionExpr = positionExpr([x, y], params, content.el, rect, {\n                viewSize: [viewWidth, viewHeight],\n                contentSize: contentSize.slice()\n            });\n        }\n\n        if (isArray(positionExpr)) {\n            x = parsePercent$2(positionExpr[0], viewWidth);\n            y = parsePercent$2(positionExpr[1], viewHeight);\n        }\n        else if (isObject(positionExpr)) {\n            positionExpr.width = contentSize[0];\n            positionExpr.height = contentSize[1];\n            var layoutRect = getLayoutRect(\n                positionExpr, {width: viewWidth, height: viewHeight}\n            );\n            x = layoutRect.x;\n            y = layoutRect.y;\n            align = null;\n            // When positionExpr is left/top/right/bottom,\n            // align and verticalAlign will not work.\n            vAlign = null;\n        }\n        // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n        else if (typeof positionExpr === 'string' && el) {\n            var pos = calcTooltipPosition(\n                positionExpr, rect, contentSize\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n        else {\n            var pos = refixTooltipPosition(\n                x, y, content.el, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n\n        align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\n        vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\n\n        if (tooltipModel.get('confine')) {\n            var pos = confineTooltipPosition(\n                x, y, content.el, viewWidth, viewHeight\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n\n        content.moveTo(x, y);\n    },\n\n    // FIXME\n    // Should we remove this but leave this to user?\n    _updateContentNotChangedOnAxis: function (dataByCoordSys) {\n        var lastCoordSys = this._lastDataByCoordSys;\n        var contentNotChanged = !!lastCoordSys\n            && lastCoordSys.length === dataByCoordSys.length;\n\n        contentNotChanged && each$20(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {\n            var lastDataByAxis = lastItemCoordSys.dataByAxis || {};\n            var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};\n            var thisDataByAxis = thisItemCoordSys.dataByAxis || [];\n            contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;\n\n            contentNotChanged && each$20(lastDataByAxis, function (lastItem, indexAxis) {\n                var thisItem = thisDataByAxis[indexAxis] || {};\n                var lastIndices = lastItem.seriesDataIndices || [];\n                var newIndices = thisItem.seriesDataIndices || [];\n\n                contentNotChanged &=\n                    lastItem.value === thisItem.value\n                    && lastItem.axisType === thisItem.axisType\n                    && lastItem.axisId === thisItem.axisId\n                    && lastIndices.length === newIndices.length;\n\n                contentNotChanged && each$20(lastIndices, function (lastIdxItem, j) {\n                    var newIdxItem = newIndices[j];\n                    contentNotChanged &=\n                        lastIdxItem.seriesIndex === newIdxItem.seriesIndex\n                        && lastIdxItem.dataIndex === newIdxItem.dataIndex;\n                });\n            });\n        });\n\n        this._lastDataByCoordSys = dataByCoordSys;\n\n        return !!contentNotChanged;\n    },\n\n    _hide: function (dispatchAction) {\n        // Do not directly hideLater here, because this behavior may be prevented\n        // in dispatchAction when showTip is dispatched.\n\n        // FIXME\n        // duplicated hideTip if manuallyHideTip is called from dispatchAction.\n        this._lastDataByCoordSys = null;\n        dispatchAction({\n            type: 'hideTip',\n            from: this.uid\n        });\n    },\n\n    dispose: function (ecModel, api) {\n        if (env$1.node) {\n            return;\n        }\n        this._tooltipContent.hide();\n        unregister('itemTooltip', api);\n    }\n});\n\n\n/**\n * @param {Array.<Object|module:echarts/model/Model>} modelCascade\n * From top to bottom. (the last one should be globalTooltipModel);\n */\nfunction buildTooltipModel(modelCascade) {\n    var resultModel = modelCascade.pop();\n    while (modelCascade.length) {\n        var tooltipOpt = modelCascade.pop();\n        if (tooltipOpt) {\n            if (tooltipOpt instanceof Model) {\n                tooltipOpt = tooltipOpt.get('tooltip', true);\n            }\n            // In each data item tooltip can be simply write:\n            // {\n            //  value: 10,\n            //  tooltip: 'Something you need to know'\n            // }\n            if (typeof tooltipOpt === 'string') {\n                tooltipOpt = {formatter: tooltipOpt};\n            }\n            resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);\n        }\n    }\n    return resultModel;\n}\n\nfunction makeDispatchAction$1(payload, api) {\n    return payload.dispatchAction || bind(api.dispatchAction, api);\n}\n\nfunction refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {\n    var size = getOuterSize(el);\n    var width = size.width;\n    var height = size.height;\n\n    if (gapH != null) {\n        if (x + width + gapH > viewWidth) {\n            x -= width + gapH;\n        }\n        else {\n            x += gapH;\n        }\n    }\n    if (gapV != null) {\n        if (y + height + gapV > viewHeight) {\n            y -= height + gapV;\n        }\n        else {\n            y += gapV;\n        }\n    }\n    return [x, y];\n}\n\nfunction confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n    var size = getOuterSize(el);\n    var width = size.width;\n    var height = size.height;\n\n    x = Math.min(x + width, viewWidth) - width;\n    y = Math.min(y + height, viewHeight) - height;\n    x = Math.max(x, 0);\n    y = Math.max(y, 0);\n\n    return [x, y];\n}\n\nfunction getOuterSize(el) {\n    var width = el.clientWidth;\n    var height = el.clientHeight;\n\n    // Consider browser compatibility.\n    // IE8 does not support getComputedStyle.\n    if (document.defaultView && document.defaultView.getComputedStyle) {\n        var stl = document.defaultView.getComputedStyle(el);\n        if (stl) {\n            width += parseInt(stl.paddingLeft, 10) + parseInt(stl.paddingRight, 10)\n                + parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);\n            height += parseInt(stl.paddingTop, 10) + parseInt(stl.paddingBottom, 10)\n                + parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);\n        }\n    }\n\n    return {width: width, height: height};\n}\n\nfunction calcTooltipPosition(position, rect, contentSize) {\n    var domWidth = contentSize[0];\n    var domHeight = contentSize[1];\n    var gap = 5;\n    var x = 0;\n    var y = 0;\n    var rectWidth = rect.width;\n    var rectHeight = rect.height;\n    switch (position) {\n        case 'inside':\n            x = rect.x + rectWidth / 2 - domWidth / 2;\n            y = rect.y + rectHeight / 2 - domHeight / 2;\n            break;\n        case 'top':\n            x = rect.x + rectWidth / 2 - domWidth / 2;\n            y = rect.y - domHeight - gap;\n            break;\n        case 'bottom':\n            x = rect.x + rectWidth / 2 - domWidth / 2;\n            y = rect.y + rectHeight + gap;\n            break;\n        case 'left':\n            x = rect.x - domWidth - gap;\n            y = rect.y + rectHeight / 2 - domHeight / 2;\n            break;\n        case 'right':\n            x = rect.x + rectWidth + gap;\n            y = rect.y + rectHeight / 2 - domHeight / 2;\n    }\n    return [x, y];\n}\n\nfunction isCenterAlign(align) {\n    return align === 'center' || align === 'middle';\n}\n\n// FIXME Better way to pack data in graphic element\n\n/**\n * @action\n * @property {string} type\n * @property {number} seriesIndex\n * @property {number} dataIndex\n * @property {number} [x]\n * @property {number} [y]\n */\nregisterAction(\n    {\n        type: 'showTip',\n        event: 'showTip',\n        update: 'tooltip:manuallyShowTip'\n    },\n    // noop\n    function () {}\n);\n\nregisterAction(\n    {\n        type: 'hideTip',\n        event: 'hideTip',\n        update: 'tooltip:manuallyHideTip'\n    },\n    // noop\n    function () {}\n);\n\nfunction getSeriesStackId$1(seriesModel) {\n    return seriesModel.get('stack')\n        || '__ec_stack_' + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey$1(axis) {\n    return axis.dim;\n}\n\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n */\nfunction barLayoutPolar(seriesType, ecModel, api) {\n\n    var width = api.getWidth();\n    var height = api.getHeight();\n\n    var lastStackCoords = {};\n    var lastStackCoordsOrigin = {};\n\n    var barWidthAndOffset = calRadialBar(\n        filter(\n            ecModel.getSeriesByType(seriesType),\n            function (seriesModel) {\n                return !ecModel.isSeriesFiltered(seriesModel)\n                    && seriesModel.coordinateSystem\n                    && seriesModel.coordinateSystem.type === 'polar';\n            }\n        )\n    );\n\n    ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        // Check series coordinate, do layout for polar only\n        if (seriesModel.coordinateSystem.type !== 'polar') {\n            return;\n        }\n\n        var data = seriesModel.getData();\n        var polar = seriesModel.coordinateSystem;\n        var angleAxis = polar.getAngleAxis();\n        var baseAxis = polar.getBaseAxis();\n\n        var stackId = getSeriesStackId$1(seriesModel);\n        var columnLayoutInfo\n            = barWidthAndOffset[getAxisKey$1(baseAxis)][stackId];\n        var columnOffset = columnLayoutInfo.offset;\n        var columnWidth = columnLayoutInfo.width;\n        var valueAxis = polar.getOtherAxis(baseAxis);\n\n        var center = seriesModel.get('center') || ['50%', '50%'];\n        var cx = parsePercent$1(center[0], width);\n        var cy = parsePercent$1(center[1], height);\n\n        var barMinHeight = seriesModel.get('barMinHeight') || 0;\n        var barMinAngle = seriesModel.get('barMinAngle') || 0;\n\n        var valueAxisStart = valueAxis.getExtent()[0];\n        var valueMax = valueAxis.model.get('max');\n        var valueMin = valueAxis.model.get('min');\n\n        var coordDims = [\n            seriesModel.coordDimToDataDim('radius')[0],\n            seriesModel.coordDimToDataDim('angle')[0]\n        ];\n        var coords = data.mapArray(coordDims, function (radius, angle) {\n            return polar.dataToPoint([radius, angle]);\n        }, true);\n\n        lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n        lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n        data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0], function (value, idx) {\n            if (isNaN(value)) {\n                return;\n            }\n\n            if (!lastStackCoords[stackId][idx]) {\n                lastStackCoords[stackId][idx] = {\n                    p: valueAxisStart, // Positive stack\n                    n: valueAxisStart  // Negative stack\n                };\n                lastStackCoordsOrigin[stackId][idx] = {\n                    p: valueAxisStart, // Positive stack\n                    n: valueAxisStart  // Negative stack\n                };\n            }\n            var sign = value >= 0 ? 'p' : 'n';\n            var coord = polar.pointToCoord(coords[idx]);\n\n            var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n            var r0;\n            var r;\n            var startAngle;\n            var endAngle;\n\n            if (valueAxis.dim === 'radius') {\n                // radial sector\n                r0 = lastCoordOrigin;\n                r = coord[0];\n                startAngle = (-coord[1] + columnOffset) * Math.PI / 180;\n                endAngle = startAngle + columnWidth * Math.PI / 180;\n\n                if (Math.abs(r) < barMinHeight) {\n                    r = r0 + (r < 0 ? -1 : 1) * barMinHeight;\n                }\n\n                lastStackCoordsOrigin[stackId][idx][sign] = r;\n            }\n            else {\n                // tangential sector\n                r0 = coord[0] + columnOffset;\n                r = r0 + columnWidth;\n\n                // clamp data if min or max is defined for valueAxis\n                if (valueMax != null) {\n                    value = Math.min(value, valueMax);\n                }\n                if (valueMin != null) {\n                    value = Math.max(value, valueMin);\n                }\n\n                var angle = angleAxis.dataToAngle(value);\n                if (Math.abs(angle - lastCoordOrigin) < barMinAngle) {\n                    angle = lastCoordOrigin - (value < 0 ? -1 : 1)\n                        * barMinAngle;\n                }\n\n                startAngle = -lastCoordOrigin * Math.PI / 180;\n                endAngle = -angle * Math.PI / 180;\n\n                // if the previous stack is at the end of the ring,\n                // add a round to differentiate it from origin\n                var extent = angleAxis.getExtent();\n                var stackCoord = angle;\n                if (stackCoord === extent[0] && value > 0) {\n                    stackCoord = extent[1];\n                }\n                else if (stackCoord === extent[1] && value < 0) {\n                    stackCoord = extent[0];\n                }\n                lastStackCoordsOrigin[stackId][idx][sign] = stackCoord;\n            }\n\n            data.setItemLayout(idx, {\n                cx: cx,\n                cy: cy,\n                r0: r0,\n                r: r,\n                startAngle: startAngle,\n                endAngle: endAngle\n            });\n\n        }, true);\n\n    }, this);\n\n}\n\n/**\n * Calculate bar width and offset for radial bar charts\n */\nfunction calRadialBar(barSeries, api) {\n    // Columns info on each category axis. Key is polar name\n    var columnsMap = {};\n\n    each$1(barSeries, function (seriesModel, idx) {\n        var data = seriesModel.getData();\n        var polar = seriesModel.coordinateSystem;\n\n        var baseAxis = polar.getBaseAxis();\n\n        var axisExtent = baseAxis.getExtent();\n        var bandWidth = baseAxis.type === 'category'\n            ? baseAxis.getBandWidth()\n            : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count());\n\n        var columnsOnAxis = columnsMap[getAxisKey$1(baseAxis)] || {\n            bandWidth: bandWidth,\n            remainedWidth: bandWidth,\n            autoWidthCount: 0,\n            categoryGap: '20%',\n            gap: '30%',\n            stacks: {}\n        };\n        var stacks = columnsOnAxis.stacks;\n        columnsMap[getAxisKey$1(baseAxis)] = columnsOnAxis;\n\n        var stackId = getSeriesStackId$1(seriesModel);\n\n        if (!stacks[stackId]) {\n            columnsOnAxis.autoWidthCount++;\n        }\n        stacks[stackId] = stacks[stackId] || {\n            width: 0,\n            maxWidth: 0\n        };\n\n        var barWidth = parsePercent$1(\n            seriesModel.get('barWidth'),\n            bandWidth\n        );\n        var barMaxWidth = parsePercent$1(\n            seriesModel.get('barMaxWidth'),\n            bandWidth\n        );\n        var barGap = seriesModel.get('barGap');\n        var barCategoryGap = seriesModel.get('barCategoryGap');\n\n        if (barWidth && !stacks[stackId].width) {\n            barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n            stacks[stackId].width = barWidth;\n            columnsOnAxis.remainedWidth -= barWidth;\n        }\n\n        barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n        (barGap != null) && (columnsOnAxis.gap = barGap);\n        (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap);\n    });\n\n\n    var result = {};\n\n    each$1(columnsMap, function (columnsOnAxis, coordSysName) {\n\n        result[coordSysName] = {};\n\n        var stacks = columnsOnAxis.stacks;\n        var bandWidth = columnsOnAxis.bandWidth;\n        var categoryGap = parsePercent$1(columnsOnAxis.categoryGap, bandWidth);\n        var barGapPercent = parsePercent$1(columnsOnAxis.gap, 1);\n\n        var remainedWidth = columnsOnAxis.remainedWidth;\n        var autoWidthCount = columnsOnAxis.autoWidthCount;\n        var autoWidth = (remainedWidth - categoryGap)\n            / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n        autoWidth = Math.max(autoWidth, 0);\n\n        // Find if any auto calculated bar exceeded maxBarWidth\n        each$1(stacks, function (column, stack) {\n            var maxWidth = column.maxWidth;\n            if (maxWidth && maxWidth < autoWidth) {\n                maxWidth = Math.min(maxWidth, remainedWidth);\n                if (column.width) {\n                    maxWidth = Math.min(maxWidth, column.width);\n                }\n                remainedWidth -= maxWidth;\n                column.width = maxWidth;\n                autoWidthCount--;\n            }\n        });\n\n        // Recalculate width again\n        autoWidth = (remainedWidth - categoryGap)\n            / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n        autoWidth = Math.max(autoWidth, 0);\n\n        var widthSum = 0;\n        var lastColumn;\n        each$1(stacks, function (column, idx) {\n            if (!column.width) {\n                column.width = autoWidth;\n            }\n            lastColumn = column;\n            widthSum += column.width * (1 + barGapPercent);\n        });\n        if (lastColumn) {\n            widthSum -= lastColumn.width * barGapPercent;\n        }\n\n        var offset = -widthSum / 2;\n        each$1(stacks, function (column, stackId) {\n            result[coordSysName][stackId] = result[coordSysName][stackId] || {\n                offset: offset,\n                width: column.width\n            };\n\n            offset += column.width * (1 + barGapPercent);\n        });\n    });\n\n    return result;\n}\n\nfunction RadiusAxis(scale, radiusExtent) {\n\n    Axis.call(this, 'radius', scale, radiusExtent);\n\n    /**\n     * Axis type\n     *  - 'category'\n     *  - 'value'\n     *  - 'time'\n     *  - 'log'\n     * @type {string}\n     */\n    this.type = 'category';\n}\n\nRadiusAxis.prototype = {\n\n    constructor: RadiusAxis,\n\n    /**\n     * @override\n     */\n    pointToData: function (point, clamp) {\n        return this.polar.pointToData(point, clamp)[this.dim === 'radius' ? 0 : 1];\n    },\n\n    dataToRadius: Axis.prototype.dataToCoord,\n\n    radiusToData: Axis.prototype.coordToData\n};\n\ninherits(RadiusAxis, Axis);\n\nfunction AngleAxis(scale, angleExtent) {\n\n    angleExtent = angleExtent || [0, 360];\n\n    Axis.call(this, 'angle', scale, angleExtent);\n\n    /**\n     * Axis type\n     *  - 'category'\n     *  - 'value'\n     *  - 'time'\n     *  - 'log'\n     * @type {string}\n     */\n    this.type = 'category';\n}\n\nAngleAxis.prototype = {\n\n    constructor: AngleAxis,\n\n    /**\n     * @override\n     */\n    pointToData: function (point, clamp) {\n        return this.polar.pointToData(point, clamp)[this.dim === 'radius' ? 0 : 1];\n    },\n\n    dataToAngle: Axis.prototype.dataToCoord,\n\n    angleToData: Axis.prototype.coordToData\n};\n\ninherits(AngleAxis, Axis);\n\n/**\n * @module echarts/coord/polar/Polar\n */\n\n/**\n * @alias {module:echarts/coord/polar/Polar}\n * @constructor\n * @param {string} name\n */\nvar Polar = function (name) {\n\n    /**\n     * @type {string}\n     */\n    this.name = name || '';\n\n    /**\n     * x of polar center\n     * @type {number}\n     */\n    this.cx = 0;\n\n    /**\n     * y of polar center\n     * @type {number}\n     */\n    this.cy = 0;\n\n    /**\n     * @type {module:echarts/coord/polar/RadiusAxis}\n     * @private\n     */\n    this._radiusAxis = new RadiusAxis();\n\n    /**\n     * @type {module:echarts/coord/polar/AngleAxis}\n     * @private\n     */\n    this._angleAxis = new AngleAxis();\n\n    this._radiusAxis.polar = this._angleAxis.polar = this;\n};\n\nPolar.prototype = {\n\n    type: 'polar',\n\n    axisPointerEnabled: true,\n\n    constructor: Polar,\n\n    /**\n     * @param {Array.<string>}\n     * @readOnly\n     */\n    dimensions: ['radius', 'angle'],\n\n    /**\n     * @type {module:echarts/coord/PolarModel}\n     */\n    model: null,\n\n    /**\n     * If contain coord\n     * @param {Array.<number>} point\n     * @return {boolean}\n     */\n    containPoint: function (point) {\n        var coord = this.pointToCoord(point);\n        return this._radiusAxis.contain(coord[0])\n            && this._angleAxis.contain(coord[1]);\n    },\n\n    /**\n     * If contain data\n     * @param {Array.<number>} data\n     * @return {boolean}\n     */\n    containData: function (data) {\n        return this._radiusAxis.containData(data[0])\n            && this._angleAxis.containData(data[1]);\n    },\n\n    /**\n     * @param {string} dim\n     * @return {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}\n     */\n    getAxis: function (dim) {\n        return this['_' + dim + 'Axis'];\n    },\n\n    /**\n     * @return {Array.<module:echarts/coord/Axis>}\n     */\n    getAxes: function () {\n        return [this._radiusAxis, this._angleAxis];\n    },\n\n    /**\n     * Get axes by type of scale\n     * @param {string} scaleType\n     * @return {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}\n     */\n    getAxesByScale: function (scaleType) {\n        var axes = [];\n        var angleAxis = this._angleAxis;\n        var radiusAxis = this._radiusAxis;\n        angleAxis.scale.type === scaleType && axes.push(angleAxis);\n        radiusAxis.scale.type === scaleType && axes.push(radiusAxis);\n\n        return axes;\n    },\n\n    /**\n     * @return {module:echarts/coord/polar/AngleAxis}\n     */\n    getAngleAxis: function () {\n        return this._angleAxis;\n    },\n\n    /**\n     * @return {module:echarts/coord/polar/RadiusAxis}\n     */\n    getRadiusAxis: function () {\n        return this._radiusAxis;\n    },\n\n    /**\n     * @param {module:echarts/coord/polar/Axis}\n     * @return {module:echarts/coord/polar/Axis}\n     */\n    getOtherAxis: function (axis) {\n        var angleAxis = this._angleAxis;\n        return axis === angleAxis ? this._radiusAxis : angleAxis;\n    },\n\n    /**\n     * Base axis will be used on stacking.\n     *\n     * @return {module:echarts/coord/polar/Axis}\n     */\n    getBaseAxis: function () {\n        return this.getAxesByScale('ordinal')[0]\n            || this.getAxesByScale('time')[0]\n            || this.getAngleAxis();\n    },\n\n    /**\n     * @param {string} [dim] 'radius' or 'angle' or 'auto' or null/undefined\n     * @return {Object} {baseAxes: [], otherAxes: []}\n     */\n    getTooltipAxes: function (dim) {\n        var baseAxis = (dim != null && dim !== 'auto')\n            ? this.getAxis(dim) : this.getBaseAxis();\n        return {\n            baseAxes: [baseAxis],\n            otherAxes: [this.getOtherAxis(baseAxis)]\n        };\n    },\n\n    /**\n     * Convert a single data item to (x, y) point.\n     * Parameter data is an array which the first element is radius and the second is angle\n     * @param {Array.<number>} data\n     * @param {boolean} [clamp=false]\n     * @return {Array.<number>}\n     */\n    dataToPoint: function (data, clamp) {\n        return this.coordToPoint([\n            this._radiusAxis.dataToRadius(data[0], clamp),\n            this._angleAxis.dataToAngle(data[1], clamp)\n        ]);\n    },\n\n    /**\n     * Convert a (x, y) point to data\n     * @param {Array.<number>} point\n     * @param {boolean} [clamp=false]\n     * @return {Array.<number>}\n     */\n    pointToData: function (point, clamp) {\n        var coord = this.pointToCoord(point);\n        return [\n            this._radiusAxis.radiusToData(coord[0], clamp),\n            this._angleAxis.angleToData(coord[1], clamp)\n        ];\n    },\n\n    /**\n     * Convert a (x, y) point to (radius, angle) coord\n     * @param {Array.<number>} point\n     * @return {Array.<number>}\n     */\n    pointToCoord: function (point) {\n        var dx = point[0] - this.cx;\n        var dy = point[1] - this.cy;\n        var angleAxis = this.getAngleAxis();\n        var extent = angleAxis.getExtent();\n        var minAngle = Math.min(extent[0], extent[1]);\n        var maxAngle = Math.max(extent[0], extent[1]);\n        // Fix fixed extent in polarCreator\n        // FIXME\n        angleAxis.inverse\n            ? (minAngle = maxAngle - 360)\n            : (maxAngle = minAngle + 360);\n\n        var radius = Math.sqrt(dx * dx + dy * dy);\n        dx /= radius;\n        dy /= radius;\n\n        var radian = Math.atan2(-dy, dx) / Math.PI * 180;\n\n        // move to angleExtent\n        var dir = radian < minAngle ? 1 : -1;\n        while (radian < minAngle || radian > maxAngle) {\n            radian += dir * 360;\n        }\n\n        return [radius, radian];\n    },\n\n    /**\n     * Convert a (radius, angle) coord to (x, y) point\n     * @param {Array.<number>} coord\n     * @return {Array.<number>}\n     */\n    coordToPoint: function (coord) {\n        var radius = coord[0];\n        var radian = coord[1] / 180 * Math.PI;\n        var x = Math.cos(radian) * radius + this.cx;\n        // Inverse the y\n        var y = -Math.sin(radian) * radius + this.cy;\n\n        return [x, y];\n    }\n\n};\n\nvar PolarAxisModel = ComponentModel.extend({\n\n    type: 'polarAxis',\n\n    /**\n     * @type {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}\n     */\n    axis: null,\n\n    /**\n     * @override\n     */\n    getCoordSysModel: function () {\n        return this.ecModel.queryComponents({\n            mainType: 'polar',\n            index: this.option.polarIndex,\n            id: this.option.polarId\n        })[0];\n    }\n\n});\n\nmerge(PolarAxisModel.prototype, axisModelCommonMixin);\n\nvar polarAxisDefaultExtendedOption = {\n    angle: {\n        // polarIndex: 0,\n        // polarId: '',\n\n        startAngle: 90,\n\n        clockwise: true,\n\n        splitNumber: 12,\n\n        axisLabel: {\n            rotate: false\n        }\n    },\n    radius: {\n        // polarIndex: 0,\n        // polarId: '',\n\n        splitNumber: 5\n    }\n};\n\nfunction getAxisType$3(axisDim, option) {\n    // Default axis with data is category axis\n    return option.type || (option.data ? 'category' : 'value');\n}\n\naxisModelCreator('angle', PolarAxisModel, getAxisType$3, polarAxisDefaultExtendedOption.angle);\naxisModelCreator('radius', PolarAxisModel, getAxisType$3, polarAxisDefaultExtendedOption.radius);\n\nextendComponentModel({\n\n    type: 'polar',\n\n    dependencies: ['polarAxis', 'angleAxis'],\n\n    /**\n     * @type {module:echarts/coord/polar/Polar}\n     */\n    coordinateSystem: null,\n\n    /**\n     * @param {string} axisType\n     * @return {module:echarts/coord/polar/AxisModel}\n     */\n    findAxisModel: function (axisType) {\n        var foundAxisModel;\n        var ecModel = this.ecModel;\n\n        ecModel.eachComponent(axisType, function (axisModel) {\n            if (axisModel.getCoordSysModel() === this) {\n                foundAxisModel = axisModel;\n            }\n        }, this);\n        return foundAxisModel;\n    },\n\n    defaultOption: {\n\n        zlevel: 0,\n\n        z: 0,\n\n        center: ['50%', '50%'],\n\n        radius: '80%'\n    }\n});\n\n// TODO Axis scale\n\n//  PolarModel \n/**\n * Resize method bound to the polar\n * @param {module:echarts/coord/polar/PolarModel} polarModel\n * @param {module:echarts/ExtensionAPI} api\n */\nfunction resizePolar(polar, polarModel, api) {\n    var center = polarModel.get('center');\n    var width = api.getWidth();\n    var height = api.getHeight();\n\n    polar.cx = parsePercent$1(center[0], width);\n    polar.cy = parsePercent$1(center[1], height);\n\n    var radiusAxis = polar.getRadiusAxis();\n    var size = Math.min(width, height) / 2;\n    var radius = parsePercent$1(polarModel.get('radius'), size);\n    radiusAxis.inverse\n        ? radiusAxis.setExtent(radius, 0)\n        : radiusAxis.setExtent(0, radius);\n}\n\n/**\n * Update polar\n */\nfunction updatePolarScale(ecModel, api) {\n    var polar = this;\n    var angleAxis = polar.getAngleAxis();\n    var radiusAxis = polar.getRadiusAxis();\n    // Reset scale\n    angleAxis.scale.setExtent(Infinity, -Infinity);\n    radiusAxis.scale.setExtent(Infinity, -Infinity);\n\n    ecModel.eachSeries(function (seriesModel) {\n        if (seriesModel.coordinateSystem === polar) {\n            var data = seriesModel.getData();\n            radiusAxis.scale.unionExtentFromData(data, 'radius');\n            angleAxis.scale.unionExtentFromData(data, 'angle');\n        }\n    });\n\n    niceScaleExtent(angleAxis.scale, angleAxis.model);\n    niceScaleExtent(radiusAxis.scale, radiusAxis.model);\n\n    // Fix extent of category angle axis\n    if (angleAxis.type === 'category' && !angleAxis.onBand) {\n        var extent = angleAxis.getExtent();\n        var diff = 360 / angleAxis.scale.count();\n        angleAxis.inverse ? (extent[1] += diff) : (extent[1] -= diff);\n        angleAxis.setExtent(extent[0], extent[1]);\n    }\n}\n\n/**\n * Set common axis properties\n * @param {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}\n * @param {module:echarts/coord/polar/AxisModel}\n * @inner\n */\nfunction setAxis(axis, axisModel) {\n    axis.type = axisModel.get('type');\n    axis.scale = createScaleByModel(axisModel);\n    axis.onBand = axisModel.get('boundaryGap') && axis.type === 'category';\n    axis.inverse = axisModel.get('inverse');\n\n    if (axisModel.mainType === 'angleAxis') {\n        axis.inverse ^= axisModel.get('clockwise');\n        var startAngle = axisModel.get('startAngle');\n        axis.setExtent(startAngle, startAngle + (axis.inverse ? -360 : 360));\n    }\n\n    // Inject axis instance\n    axisModel.axis = axis;\n    axis.model = axisModel;\n}\n\n\nvar polarCreator = {\n\n    dimensions: Polar.prototype.dimensions,\n\n    create: function (ecModel, api) {\n        var polarList = [];\n        ecModel.eachComponent('polar', function (polarModel, idx) {\n            var polar = new Polar(idx);\n            // Inject resize and update method\n            polar.update = updatePolarScale;\n\n            var radiusAxis = polar.getRadiusAxis();\n            var angleAxis = polar.getAngleAxis();\n\n            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n\n            setAxis(radiusAxis, radiusAxisModel);\n            setAxis(angleAxis, angleAxisModel);\n\n            resizePolar(polar, polarModel, api);\n\n            polarList.push(polar);\n\n            polarModel.coordinateSystem = polar;\n            polar.model = polarModel;\n        });\n        // Inject coordinateSystem to series\n        ecModel.eachSeries(function (seriesModel) {\n            if (seriesModel.get('coordinateSystem') === 'polar') {\n                var polarModel = ecModel.queryComponents({\n                    mainType: 'polar',\n                    index: seriesModel.get('polarIndex'),\n                    id: seriesModel.get('polarId')\n                })[0];\n\n                if (__DEV__) {\n                    if (!polarModel) {\n                        throw new Error(\n                            'Polar \"' + retrieve(\n                                seriesModel.get('polarIndex'),\n                                seriesModel.get('polarId'),\n                                0\n                            ) + '\" not found'\n                        );\n                    }\n                }\n                seriesModel.coordinateSystem = polarModel.coordinateSystem;\n            }\n        });\n\n        return polarList;\n    }\n};\n\nCoordinateSystemManager.register('polar', polarCreator);\n\nvar elementList$1 = ['axisLine', 'axisLabel', 'axisTick', 'splitLine', 'splitArea'];\n\nfunction getAxisLineShape(polar, rExtent, angle) {\n    rExtent[1] > rExtent[0] && (rExtent = rExtent.slice().reverse());\n    var start = polar.coordToPoint([rExtent[0], angle]);\n    var end = polar.coordToPoint([rExtent[1], angle]);\n\n    return {\n        x1: start[0],\n        y1: start[1],\n        x2: end[0],\n        y2: end[1]\n    };\n}\n\nfunction getRadiusIdx(polar) {\n    var radiusAxis = polar.getRadiusAxis();\n    return radiusAxis.inverse ? 0 : 1;\n}\n\nAxisView.extend({\n\n    type: 'angleAxis',\n\n    axisPointerClass: 'PolarAxisPointer',\n\n    render: function (angleAxisModel, ecModel) {\n        this.group.removeAll();\n        if (!angleAxisModel.get('show')) {\n            return;\n        }\n\n        var angleAxis = angleAxisModel.axis;\n        var polar = angleAxis.polar;\n        var radiusExtent = polar.getRadiusAxis().getExtent();\n        var ticksAngles = angleAxis.getTicksCoords();\n\n        if (angleAxis.type !== 'category') {\n            // Remove the last tick which will overlap the first tick\n            ticksAngles.pop();\n        }\n\n        each$1(elementList$1, function (name) {\n            if (angleAxisModel.get(name +'.show')\n                && (!angleAxis.scale.isBlank() || name === 'axisLine')\n            ) {\n                this['_' + name](angleAxisModel, polar, ticksAngles, radiusExtent);\n            }\n        }, this);\n    },\n\n    /**\n     * @private\n     */\n    _axisLine: function (angleAxisModel, polar, ticksAngles, radiusExtent) {\n        var lineStyleModel = angleAxisModel.getModel('axisLine.lineStyle');\n\n        var circle = new Circle({\n            shape: {\n                cx: polar.cx,\n                cy: polar.cy,\n                r: radiusExtent[getRadiusIdx(polar)]\n            },\n            style: lineStyleModel.getLineStyle(),\n            z2: 1,\n            silent: true\n        });\n        circle.style.fill = null;\n\n        this.group.add(circle);\n    },\n\n    /**\n     * @private\n     */\n    _axisTick: function (angleAxisModel, polar, ticksAngles, radiusExtent) {\n        var tickModel = angleAxisModel.getModel('axisTick');\n\n        var tickLen = (tickModel.get('inside') ? -1 : 1) * tickModel.get('length');\n        var radius = radiusExtent[getRadiusIdx(polar)];\n\n        var lines = map(ticksAngles, function (tickAngle) {\n            return new Line({\n                shape: getAxisLineShape(polar, [radius, radius + tickLen], tickAngle)\n            });\n        });\n        this.group.add(mergePath(\n            lines, {\n                style: defaults(\n                    tickModel.getModel('lineStyle').getLineStyle(),\n                    {\n                        stroke: angleAxisModel.get('axisLine.lineStyle.color')\n                    }\n                )\n            }\n        ));\n    },\n\n    /**\n     * @private\n     */\n    _axisLabel: function (angleAxisModel, polar, ticksAngles, radiusExtent) {\n        var axis = angleAxisModel.axis;\n\n        var categoryData = angleAxisModel.get('data');\n\n        var labelModel = angleAxisModel.getModel('axisLabel');\n        var labels = angleAxisModel.getFormattedLabels();\n\n        var labelMargin = labelModel.get('margin');\n        var labelsAngles = axis.getLabelsCoords();\n\n        // Use length of ticksAngles because it may remove the last tick to avoid overlapping\n        for (var i = 0; i < ticksAngles.length; i++) {\n            var r = radiusExtent[getRadiusIdx(polar)];\n            var p = polar.coordToPoint([r + labelMargin, labelsAngles[i]]);\n            var cx = polar.cx;\n            var cy = polar.cy;\n\n            var labelTextAlign = Math.abs(p[0] - cx) / r < 0.3\n                ? 'center' : (p[0] > cx ? 'left' : 'right');\n            var labelTextVerticalAlign = Math.abs(p[1] - cy) / r < 0.3\n                ? 'middle' : (p[1] > cy ? 'top' : 'bottom');\n\n            if (categoryData && categoryData[i] && categoryData[i].textStyle) {\n                labelModel = new Model(categoryData[i].textStyle, labelModel, labelModel.ecModel);\n            }\n\n            var textEl = new Text({silent: true});\n            this.group.add(textEl);\n            setTextStyle(textEl.style, labelModel, {\n                x: p[0],\n                y: p[1],\n                textFill: labelModel.getTextColor() || angleAxisModel.get('axisLine.lineStyle.color'),\n                text: labels[i],\n                textAlign: labelTextAlign,\n                textVerticalAlign: labelTextVerticalAlign\n            });\n        }\n    },\n\n    /**\n     * @private\n     */\n    _splitLine: function (angleAxisModel, polar, ticksAngles, radiusExtent) {\n        var splitLineModel = angleAxisModel.getModel('splitLine');\n        var lineStyleModel = splitLineModel.getModel('lineStyle');\n        var lineColors = lineStyleModel.get('color');\n        var lineCount = 0;\n\n        lineColors = lineColors instanceof Array ? lineColors : [lineColors];\n\n        var splitLines = [];\n\n        for (var i = 0; i < ticksAngles.length; i++) {\n            var colorIndex = (lineCount++) % lineColors.length;\n            splitLines[colorIndex] = splitLines[colorIndex] || [];\n            splitLines[colorIndex].push(new Line({\n                shape: getAxisLineShape(polar, radiusExtent, ticksAngles[i])\n            }));\n        }\n\n        // Simple optimization\n        // Batching the lines if color are the same\n        for (var i = 0; i < splitLines.length; i++) {\n            this.group.add(mergePath(splitLines[i], {\n                style: defaults({\n                    stroke: lineColors[i % lineColors.length]\n                }, lineStyleModel.getLineStyle()),\n                silent: true,\n                z: angleAxisModel.get('z')\n            }));\n        }\n    },\n\n    /**\n     * @private\n     */\n    _splitArea: function (angleAxisModel, polar, ticksAngles, radiusExtent) {\n\n        var splitAreaModel = angleAxisModel.getModel('splitArea');\n        var areaStyleModel = splitAreaModel.getModel('areaStyle');\n        var areaColors = areaStyleModel.get('color');\n        var lineCount = 0;\n\n        areaColors = areaColors instanceof Array ? areaColors : [areaColors];\n\n        var splitAreas = [];\n\n        var RADIAN = Math.PI / 180;\n        var prevAngle = -ticksAngles[0] * RADIAN;\n        var r0 = Math.min(radiusExtent[0], radiusExtent[1]);\n        var r1 = Math.max(radiusExtent[0], radiusExtent[1]);\n\n        var clockwise = angleAxisModel.get('clockwise');\n\n        for (var i = 1; i < ticksAngles.length; i++) {\n            var colorIndex = (lineCount++) % areaColors.length;\n            splitAreas[colorIndex] = splitAreas[colorIndex] || [];\n            splitAreas[colorIndex].push(new Sector({\n                shape: {\n                    cx: polar.cx,\n                    cy: polar.cy,\n                    r0: r0,\n                    r: r1,\n                    startAngle: prevAngle,\n                    endAngle: -ticksAngles[i] * RADIAN,\n                    clockwise: clockwise\n                },\n                silent: true\n            }));\n            prevAngle = -ticksAngles[i] * RADIAN;\n        }\n\n        // Simple optimization\n        // Batching the lines if color are the same\n        for (var i = 0; i < splitAreas.length; i++) {\n            this.group.add(mergePath(splitAreas[i], {\n                style: defaults({\n                    fill: areaColors[i % areaColors.length]\n                }, areaStyleModel.getAreaStyle()),\n                silent: true\n            }));\n        }\n    }\n});\n\nvar axisBuilderAttrs$3 = [\n    'axisLine', 'axisTickLabel', 'axisName'\n];\nvar selfBuilderAttrs$1 = [\n    'splitLine', 'splitArea'\n];\n\nAxisView.extend({\n\n    type: 'radiusAxis',\n\n    axisPointerClass: 'PolarAxisPointer',\n\n    render: function (radiusAxisModel, ecModel) {\n        this.group.removeAll();\n        if (!radiusAxisModel.get('show')) {\n            return;\n        }\n        var radiusAxis = radiusAxisModel.axis;\n        var polar = radiusAxis.polar;\n        var angleAxis = polar.getAngleAxis();\n        var ticksCoords = radiusAxis.getTicksCoords();\n        var axisAngle = angleAxis.getExtent()[0];\n        var radiusExtent = radiusAxis.getExtent();\n\n        var layout = layoutAxis(polar, radiusAxisModel, axisAngle);\n        var axisBuilder = new AxisBuilder(radiusAxisModel, layout);\n        each$1(axisBuilderAttrs$3, axisBuilder.add, axisBuilder);\n        this.group.add(axisBuilder.getGroup());\n\n        each$1(selfBuilderAttrs$1, function (name) {\n            if (radiusAxisModel.get(name +'.show') && !radiusAxis.scale.isBlank()) {\n                this['_' + name](radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords);\n            }\n        }, this);\n    },\n\n    /**\n     * @private\n     */\n    _splitLine: function (radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {\n        var splitLineModel = radiusAxisModel.getModel('splitLine');\n        var lineStyleModel = splitLineModel.getModel('lineStyle');\n        var lineColors = lineStyleModel.get('color');\n        var lineCount = 0;\n\n        lineColors = lineColors instanceof Array ? lineColors : [lineColors];\n\n        var splitLines = [];\n\n        for (var i = 0; i < ticksCoords.length; i++) {\n            var colorIndex = (lineCount++) % lineColors.length;\n            splitLines[colorIndex] = splitLines[colorIndex] || [];\n            splitLines[colorIndex].push(new Circle({\n                shape: {\n                    cx: polar.cx,\n                    cy: polar.cy,\n                    r: ticksCoords[i]\n                },\n                silent: true\n            }));\n        }\n\n        // Simple optimization\n        // Batching the lines if color are the same\n        for (var i = 0; i < splitLines.length; i++) {\n            this.group.add(mergePath(splitLines[i], {\n                style: defaults({\n                    stroke: lineColors[i % lineColors.length],\n                    fill: null\n                }, lineStyleModel.getLineStyle()),\n                silent: true\n            }));\n        }\n    },\n\n    /**\n     * @private\n     */\n    _splitArea: function (radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {\n\n        var splitAreaModel = radiusAxisModel.getModel('splitArea');\n        var areaStyleModel = splitAreaModel.getModel('areaStyle');\n        var areaColors = areaStyleModel.get('color');\n        var lineCount = 0;\n\n        areaColors = areaColors instanceof Array ? areaColors : [areaColors];\n\n        var splitAreas = [];\n\n        var prevRadius = ticksCoords[0];\n        for (var i = 1; i < ticksCoords.length; i++) {\n            var colorIndex = (lineCount++) % areaColors.length;\n            splitAreas[colorIndex] = splitAreas[colorIndex] || [];\n            splitAreas[colorIndex].push(new Sector({\n                shape: {\n                    cx: polar.cx,\n                    cy: polar.cy,\n                    r0: prevRadius,\n                    r: ticksCoords[i],\n                    startAngle: 0,\n                    endAngle: Math.PI * 2\n                },\n                silent: true\n            }));\n            prevRadius = ticksCoords[i];\n        }\n\n        // Simple optimization\n        // Batching the lines if color are the same\n        for (var i = 0; i < splitAreas.length; i++) {\n            this.group.add(mergePath(splitAreas[i], {\n                style: defaults({\n                    fill: areaColors[i % areaColors.length]\n                }, areaStyleModel.getAreaStyle()),\n                silent: true\n            }));\n        }\n    }\n});\n\n/**\n * @inner\n */\nfunction layoutAxis(polar, radiusAxisModel, axisAngle) {\n    return {\n        position: [polar.cx, polar.cy],\n        rotation: axisAngle / 180 * Math.PI,\n        labelDirection: -1,\n        tickDirection: -1,\n        nameDirection: 1,\n        labelRotate: radiusAxisModel.getModel('axisLabel').get('rotate'),\n        // Over splitLine and splitArea\n        z2: 1\n    };\n}\n\nvar PolarAxisPointer = BaseAxisPointer.extend({\n\n    /**\n     * @override\n     */\n    makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n        var axis = axisModel.axis;\n\n        if (axis.dim === 'angle') {\n            this.animationThreshold = Math.PI / 18;\n        }\n\n        var polar = axis.polar;\n        var otherAxis = polar.getOtherAxis(axis);\n        var otherExtent = otherAxis.getExtent();\n\n        var coordValue;\n        coordValue = axis['dataTo' + capitalFirst(axis.dim)](value);\n\n        var axisPointerType = axisPointerModel.get('type');\n        if (axisPointerType && axisPointerType !== 'none') {\n            var elStyle = buildElStyle(axisPointerModel);\n            var pointerOption = pointerShapeBuilder$2[axisPointerType](\n                axis, polar, coordValue, otherExtent, elStyle\n            );\n            pointerOption.style = elStyle;\n            elOption.graphicKey = pointerOption.type;\n            elOption.pointer = pointerOption;\n        }\n\n        var labelMargin = axisPointerModel.get('label.margin');\n        var labelPos = getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin);\n        buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos);\n    }\n\n    // Do not support handle, utill any user requires it.\n\n});\n\nfunction getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin) {\n    var axis = axisModel.axis;\n    var coord = axis.dataToCoord(value);\n    var axisAngle = polar.getAngleAxis().getExtent()[0];\n    axisAngle = axisAngle / 180 * Math.PI;\n    var radiusExtent = polar.getRadiusAxis().getExtent();\n    var position;\n    var align;\n    var verticalAlign;\n\n    if (axis.dim === 'radius') {\n        var transform = create$1();\n        rotate(transform, transform, axisAngle);\n        translate(transform, transform, [polar.cx, polar.cy]);\n        position = applyTransform$1([coord, -labelMargin], transform);\n\n        var labelRotation = axisModel.getModel('axisLabel').get('rotate') || 0;\n        var labelLayout = AxisBuilder.innerTextLayout(\n            axisAngle, labelRotation * Math.PI / 180, -1\n        );\n        align = labelLayout.textAlign;\n        verticalAlign = labelLayout.textVerticalAlign;\n    }\n    else { // angle axis\n        var r = radiusExtent[1];\n        position = polar.coordToPoint([r + labelMargin, coord]);\n        var cx = polar.cx;\n        var cy = polar.cy;\n        align = Math.abs(position[0] - cx) / r < 0.3\n            ? 'center' : (position[0] > cx ? 'left' : 'right');\n        verticalAlign = Math.abs(position[1] - cy) / r < 0.3\n            ? 'middle' : (position[1] > cy ? 'top' : 'bottom');\n    }\n\n    return {\n        position: position,\n        align: align,\n        verticalAlign: verticalAlign\n    };\n}\n\n\nvar pointerShapeBuilder$2 = {\n\n    line: function (axis, polar, coordValue, otherExtent, elStyle) {\n        return axis.dim === 'angle'\n            ? {\n                type: 'Line',\n                shape: makeLineShape(\n                    polar.coordToPoint([otherExtent[0], coordValue]),\n                    polar.coordToPoint([otherExtent[1], coordValue])\n                )\n            }\n            : {\n                type: 'Circle',\n                shape: {\n                    cx: polar.cx,\n                    cy: polar.cy,\n                    r: coordValue\n                }\n            };\n    },\n\n    shadow: function (axis, polar, coordValue, otherExtent, elStyle) {\n        var bandWidth = axis.getBandWidth();\n        var radian = Math.PI / 180;\n\n        return axis.dim === 'angle'\n            ? {\n                type: 'Sector',\n                shape: makeSectorShape(\n                    polar.cx, polar.cy,\n                    otherExtent[0], otherExtent[1],\n                    // In ECharts y is negative if angle is positive\n                    (-coordValue - bandWidth / 2) * radian,\n                    (-coordValue + bandWidth / 2) * radian\n                )\n            }\n            : {\n                type: 'Sector',\n                shape: makeSectorShape(\n                    polar.cx, polar.cy,\n                    coordValue - bandWidth / 2,\n                    coordValue + bandWidth / 2,\n                    0, Math.PI * 2\n                )\n            };\n    }\n};\n\nAxisView.registerAxisPointerClass('PolarAxisPointer', PolarAxisPointer);\n\n// For reducing size of echarts.min, barLayoutPolar is required by polar.\nregisterLayout(curry(barLayoutPolar, 'bar'));\n\n// Polar view\nextendComponentView({\n    type: 'polar'\n});\n\nvar GeoModel = ComponentModel.extend({\n\n    type: 'geo',\n\n    /**\n     * @type {module:echarts/coord/geo/Geo}\n     */\n    coordinateSystem: null,\n\n    layoutMode: 'box',\n\n    init: function (option) {\n        ComponentModel.prototype.init.apply(this, arguments);\n\n        // Default label emphasis `show`\n        defaultEmphasis(option.label, ['show']);\n    },\n\n    optionUpdated: function () {\n        var option = this.option;\n        var self = this;\n\n        option.regions = geoCreator.getFilledRegions(option.regions, option.map, option.nameMap);\n\n        this._optionModelMap = reduce(option.regions || [], function (optionModelMap, regionOpt) {\n            if (regionOpt.name) {\n                optionModelMap.set(regionOpt.name, new Model(regionOpt, self));\n            }\n            return optionModelMap;\n        }, createHashMap());\n\n        this.updateSelectedMap(option.regions);\n    },\n\n    defaultOption: {\n\n        zlevel: 0,\n\n        z: 0,\n\n        show: true,\n\n        left: 'center',\n\n        top: 'center',\n\n\n        // width:,\n        // height:,\n        // right\n        // bottom\n\n        // Aspect is width / height. Inited to be geoJson bbox aspect\n        // This parameter is used for scale this aspect\n        aspectScale: 0.75,\n\n        ///// Layout with center and size\n        // If you wan't to put map in a fixed size box with right aspect ratio\n        // This two properties may more conveninet\n        // layoutCenter: [50%, 50%]\n        // layoutSize: 100\n\n\n        silent: false,\n\n        // Map type\n        map: '',\n\n        // Define left-top, right-bottom coords to control view\n        // For example, [ [180, 90], [-180, -90] ]\n        boundingCoords: null,\n\n        // Default on center of map\n        center: null,\n\n        zoom: 1,\n\n        scaleLimit: null,\n\n        // selectedMode: false\n\n        label: {\n            normal: {\n                show: false,\n                color: '#000'\n            },\n            emphasis: {\n                show: true,\n                color: 'rgb(100,0,0)'\n            }\n        },\n\n        itemStyle: {\n            normal: {\n                // color: ,\n                borderWidth: 0.5,\n                borderColor: '#444',\n                color: '#eee'\n            },\n            emphasis: {                 // \n                color: 'rgba(255,215,0,0.8)'\n            }\n        },\n\n        regions: []\n    },\n\n    /**\n     * Get model of region\n     * @param  {string} name\n     * @return {module:echarts/model/Model}\n     */\n    getRegionModel: function (name) {\n        return this._optionModelMap.get(name) || new Model(null, this, this.ecModel);\n    },\n\n    /**\n     * Format label\n     * @param {string} name Region name\n     * @param {string} [status='normal'] 'normal' or 'emphasis'\n     * @return {string}\n     */\n    getFormattedLabel: function (name, status) {\n        var regionModel = this.getRegionModel(name);\n        var formatter = regionModel.get('label.' + status + '.formatter');\n        var params = {\n            name: name\n        };\n        if (typeof formatter === 'function') {\n            params.status = status;\n            return formatter(params);\n        }\n        else if (typeof formatter === 'string') {\n            return formatter.replace('{a}', name != null ? name : '');\n        }\n    },\n\n    setZoom: function (zoom) {\n        this.option.zoom = zoom;\n    },\n\n    setCenter: function (center) {\n        this.option.center = center;\n    }\n});\n\nmixin(GeoModel, selectableMixin);\n\nextendComponentView({\n\n    type: 'geo',\n\n    init: function (ecModel, api) {\n        var mapDraw = new MapDraw(api, true);\n        this._mapDraw = mapDraw;\n\n        this.group.add(mapDraw.group);\n    },\n\n    render: function (geoModel, ecModel, api, payload) {\n        // Not render if it is an toggleSelect action from self\n        if (payload && payload.type === 'geoToggleSelect'\n            && payload.from === this.uid\n        ) {\n            return;\n        }\n\n        var mapDraw = this._mapDraw;\n        if (geoModel.get('show')) {\n            mapDraw.draw(geoModel, ecModel, api, this, payload);\n        }\n        else {\n            this._mapDraw.group.removeAll();\n        }\n\n        this.group.silent = geoModel.get('silent');\n    },\n\n    dispose: function () {\n        this._mapDraw && this._mapDraw.remove();\n    }\n\n});\n\nfunction makeAction(method, actionInfo) {\n    actionInfo.update = 'updateView';\n    registerAction(actionInfo, function (payload, ecModel) {\n        var selected = {};\n\n        ecModel.eachComponent(\n            { mainType: 'geo', query: payload},\n            function (geoModel) {\n                geoModel[method](payload.name);\n                var geo = geoModel.coordinateSystem;\n                each$1(geo.regions, function (region) {\n                    selected[region.name] = geoModel.isSelected(region.name) || false;\n                });\n            }\n        );\n\n        return {\n            selected: selected,\n            name: payload.name\n        };\n    });\n}\n\nmakeAction('toggleSelected', {\n    type: 'geoToggleSelect',\n    event: 'geoselectchanged'\n});\nmakeAction('select', {\n    type: 'geoSelect',\n    event: 'geoselected'\n});\nmakeAction('unSelect', {\n    type: 'geoUnSelect',\n    event: 'geounselected'\n});\n\nvar DEFAULT_TOOLBOX_BTNS = ['rect', 'polygon', 'keep', 'clear'];\n\nvar preprocessor$1 = function (option, isNew) {\n    var brushComponents = option && option.brush;\n    if (!isArray(brushComponents)) {\n        brushComponents = brushComponents ? [brushComponents] : [];\n    }\n\n    if (!brushComponents.length) {\n        return;\n    }\n\n    var brushComponentSpecifiedBtns = [];\n\n    each$1(brushComponents, function (brushOpt) {\n        var tbs = brushOpt.hasOwnProperty('toolbox')\n            ? brushOpt.toolbox : [];\n\n        if (tbs instanceof Array) {\n            brushComponentSpecifiedBtns = brushComponentSpecifiedBtns.concat(tbs);\n        }\n    });\n\n    var toolbox = option && option.toolbox;\n\n    if (isArray(toolbox)) {\n        toolbox = toolbox[0];\n    }\n    if (!toolbox) {\n        toolbox = {feature: {}};\n        option.toolbox = [toolbox];\n    }\n\n    var toolboxFeature = (toolbox.feature || (toolbox.feature = {}));\n    var toolboxBrush = toolboxFeature.brush || (toolboxFeature.brush = {});\n    var brushTypes = toolboxBrush.type || (toolboxBrush.type = []);\n\n    brushTypes.push.apply(brushTypes, brushComponentSpecifiedBtns);\n\n    removeDuplicate(brushTypes);\n\n    if (isNew && !brushTypes.length) {\n        brushTypes.push.apply(brushTypes, DEFAULT_TOOLBOX_BTNS);\n    }\n};\n\nfunction removeDuplicate(arr) {\n    var map$$1 = {};\n    each$1(arr, function (val) {\n        map$$1[val] = 1;\n    });\n    arr.length = 0;\n    each$1(map$$1, function (flag, val) {\n        arr.push(val);\n    });\n}\n\n/**\n * @file Visual solution, for consistent option specification.\n */\n\nvar each$22 = each$1;\n\nfunction hasKeys(obj) {\n    if (obj) {\n        for (var name in obj){\n            if (obj.hasOwnProperty(name)) {\n                return true;\n            }\n        }\n    }\n}\n\n/**\n * @param {Object} option\n * @param {Array.<string>} stateList\n * @param {Function} [supplementVisualOption]\n * @return {Object} visualMappings <state, <visualType, module:echarts/visual/VisualMapping>>\n */\nfunction createVisualMappings(option, stateList, supplementVisualOption) {\n    var visualMappings = {};\n\n    each$22(stateList, function (state) {\n        var mappings = visualMappings[state] = createMappings();\n\n        each$22(option[state], function (visualData, visualType) {\n            if (!VisualMapping.isValidType(visualType)) {\n                return;\n            }\n            var mappingOption = {\n                type: visualType,\n                visual: visualData\n            };\n            supplementVisualOption && supplementVisualOption(mappingOption, state);\n            mappings[visualType] = new VisualMapping(mappingOption);\n\n            // Prepare a alpha for opacity, for some case that opacity\n            // is not supported, such as rendering using gradient color.\n            if (visualType === 'opacity') {\n                mappingOption = clone(mappingOption);\n                mappingOption.type = 'colorAlpha';\n                mappings.__hidden.__alphaForOpacity = new VisualMapping(mappingOption);\n            }\n        });\n    });\n\n    return visualMappings;\n\n    function createMappings() {\n        var Creater = function () {};\n        // Make sure hidden fields will not be visited by\n        // object iteration (with hasOwnProperty checking).\n        Creater.prototype.__hidden = Creater.prototype;\n        var obj = new Creater();\n        return obj;\n    }\n}\n\n/**\n * @param {Object} thisOption\n * @param {Object} newOption\n * @param {Array.<string>} keys\n */\nfunction replaceVisualOption(thisOption, newOption, keys) {\n    // Visual attributes merge is not supported, otherwise it\n    // brings overcomplicated merge logic. See #2853. So if\n    // newOption has anyone of these keys, all of these keys\n    // will be reset. Otherwise, all keys remain.\n    var has;\n    each$1(keys, function (key) {\n        if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {\n            has = true;\n        }\n    });\n    has && each$1(keys, function (key) {\n        if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {\n            thisOption[key] = clone(newOption[key]);\n        }\n        else {\n            delete thisOption[key];\n        }\n    });\n}\n\n/**\n * @param {Array.<string>} stateList\n * @param {Object} visualMappings <state, Object.<visualType, module:echarts/visual/VisualMapping>>\n * @param {module:echarts/data/List} list\n * @param {Function} getValueState param: valueOrIndex, return: state.\n * @param {object} [scope] Scope for getValueState\n * @param {string} [dimension] Concrete dimension, if used.\n */\nfunction applyVisual(stateList, visualMappings, data, getValueState, scope, dimension) {\n    var visualTypesMap = {};\n    each$1(stateList, function (state) {\n        var visualTypes = VisualMapping.prepareVisualTypes(visualMappings[state]);\n        visualTypesMap[state] = visualTypes;\n    });\n\n    var dataIndex;\n\n    function getVisual(key) {\n        return data.getItemVisual(dataIndex, key);\n    }\n\n    function setVisual(key, value) {\n        data.setItemVisual(dataIndex, key, value);\n    }\n\n    if (dimension == null) {\n        data.each(eachItem, true);\n    }\n    else {\n        data.each([dimension], eachItem, true);\n    }\n\n    function eachItem(valueOrIndex, index) {\n        dataIndex = dimension == null ? valueOrIndex : index;\n\n        var rawDataItem = data.getRawDataItem(dataIndex);\n        // Consider performance\n        if (rawDataItem && rawDataItem.visualMap === false) {\n            return;\n        }\n\n        var valueState = getValueState.call(scope, valueOrIndex);\n        var mappings = visualMappings[valueState];\n        var visualTypes = visualTypesMap[valueState];\n\n        for (var i = 0, len = visualTypes.length; i < len; i++) {\n            var type = visualTypes[i];\n            mappings[type] && mappings[type].applyVisual(\n                valueOrIndex, getVisual, setVisual\n            );\n        }\n    }\n}\n\n// Key of the first level is brushType: `line`, `rect`, `polygon`.\n// Key of the second level is chart element type: `point`, `rect`.\n// See moudule:echarts/component/helper/BrushController\n// function param:\n//      {Object} itemLayout fetch from data.getItemLayout(dataIndex)\n//      {Object} selectors {point: selector, rect: selector, ...}\n//      {Object} area {range: [[], [], ..], boudingRect}\n// function return:\n//      {boolean} Whether in the given brush.\nvar selector = {\n    lineX: getLineSelectors(0),\n    lineY: getLineSelectors(1),\n    rect: {\n        point: function (itemLayout, selectors, area) {\n            return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]);\n        },\n        rect: function (itemLayout, selectors, area) {\n            return itemLayout && area.boundingRect.intersect(itemLayout);\n        }\n    },\n    polygon: {\n        point: function (itemLayout, selectors, area) {\n            return itemLayout\n                && area.boundingRect.contain(itemLayout[0], itemLayout[1])\n                && contain$1(area.range, itemLayout[0], itemLayout[1]);\n        },\n        rect: function (itemLayout, selectors, area) {\n            var points = area.range;\n\n            if (!itemLayout || points.length <= 1) {\n                return false;\n            }\n\n            var x = itemLayout.x;\n            var y = itemLayout.y;\n            var width = itemLayout.width;\n            var height = itemLayout.height;\n            var p = points[0];\n\n            if (contain$1(points, x, y)\n                || contain$1(points, x + width, y)\n                || contain$1(points, x, y + height)\n                || contain$1(points, x + width, y + height)\n                || BoundingRect.create(itemLayout).contain(p[0], p[1])\n                || lineIntersectPolygon(x, y, x + width, y, points)\n                || lineIntersectPolygon(x, y, x, y + height, points)\n                || lineIntersectPolygon(x + width, y, x + width, y + height, points)\n                || lineIntersectPolygon(x, y + height, x + width, y + height, points)\n            ) {\n                return true;\n            }\n        }\n    }\n};\n\nfunction getLineSelectors(xyIndex) {\n    var xy = ['x', 'y'];\n    var wh = ['width', 'height'];\n\n    return {\n        point: function (itemLayout, selectors, area) {\n            if (itemLayout) {\n                var range = area.range;\n                var p = itemLayout[xyIndex];\n                return inLineRange(p, range);\n            }\n        },\n        rect: function (itemLayout, selectors, area) {\n            if (itemLayout) {\n                var range = area.range;\n                var layoutRange = [\n                    itemLayout[xy[xyIndex]],\n                    itemLayout[xy[xyIndex]] + itemLayout[wh[xyIndex]]\n                ];\n                layoutRange[1] < layoutRange[0] && layoutRange.reverse();\n                return inLineRange(layoutRange[0], range)\n                    || inLineRange(layoutRange[1], range)\n                    || inLineRange(range[0], layoutRange)\n                    || inLineRange(range[1], layoutRange);\n            }\n        }\n    };\n}\n\nfunction inLineRange(p, range) {\n    return range[0] <= p && p <= range[1];\n}\n\nfunction lineIntersectPolygon(lx, ly, l2x, l2y, points) {\n    for (var i = 0, p2 = points[points.length - 1]; i < points.length; i++) {\n        var p = points[i];\n        if (lineIntersect(lx, ly, l2x, l2y, p[0], p[1], p2[0], p2[1])) {\n            return true;\n        }\n        p2 = p;\n    }\n}\n\n// Code from <http://blog.csdn.net/rickliuxiao/article/details/6259322> with some fix.\n// See <https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection>\nfunction lineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n    var delta = determinant(a2x - a1x, b1x - b2x, a2y - a1y, b1y - b2y);\n    if (nearZero(delta)) { // parallel\n        return false;\n    }\n    var namenda = determinant(b1x - a1x, b1x - b2x, b1y - a1y, b1y - b2y) / delta;\n    if (namenda < 0 || namenda > 1) {\n        return false;\n    }\n    var miu = determinant(a2x - a1x, b1x - a1x, a2y - a1y, b1y - a1y) / delta;\n    if (miu < 0 || miu > 1) {\n        return false;\n    }\n    return true;\n}\n\nfunction nearZero(val) {\n    return val <= (1e-6) && val >= -(1e-6);\n}\n\nfunction determinant(v1, v2, v3, v4) {\n    return v1 * v4 - v2 * v3;\n}\n\nvar each$23 = each$1;\nvar indexOf$2 = indexOf;\nvar curry$5 = curry;\n\nvar COORD_CONVERTS = ['dataToPoint', 'pointToData'];\n\n// FIXME\n// how to genarialize to more coordinate systems.\nvar INCLUDE_FINDER_MAIN_TYPES = [\n    'grid', 'xAxis', 'yAxis', 'geo', 'graph',\n    'polar', 'radiusAxis', 'angleAxis', 'bmap'\n];\n\n/**\n * [option in constructor]:\n * {\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n * }\n *\n *\n * [targetInfo]:\n *\n * There can be multiple axes in a single targetInfo. Consider the case\n * of `grid` component, a targetInfo represents a grid which contains one or more\n * cartesian and one or more axes. And consider the case of parallel system,\n * which has multiple axes in a coordinate system.\n * Can be {\n *     panelId: ...,\n *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,\n *     coordSyses: all cartesians.\n *     gridModel: <grid component>\n *     xAxes: correspond to coordSyses on index\n *     yAxes: correspond to coordSyses on index\n * }\n * or {\n *     panelId: ...,\n *     coordSys: <geo coord sys>\n *     coordSyses: [<geo coord sys>]\n *     geoModel: <geo component>\n * }\n *\n *\n * [panelOpt]:\n *\n * Make from targetInfo. Input to BrushController.\n * {\n *     panelId: ...,\n *     rect: ...\n * }\n *\n *\n * [area]:\n *\n * Generated by BrushController or user input.\n * {\n *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.\n *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n *     range: pixel range.\n *     coordRange: representitive coord range (the first one of coordRanges).\n *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.\n * }\n */\n\n/**\n * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid\n *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} [opt]\n * @param {Array.<string>} [opt.include] include coordinate system types.\n */\nfunction BrushTargetManager(option, ecModel, opt) {\n    /**\n     * @private\n     * @type {Array.<Object>}\n     */\n    var targetInfoList = this._targetInfoList = [];\n    var info = {};\n    var foundCpts = parseFinder$1(ecModel, option);\n\n    each$23(targetInfoBuilders, function (builder, type) {\n        if (!opt || !opt.include || indexOf$2(opt.include, type) >= 0) {\n            builder(foundCpts, targetInfoList, info);\n        }\n    });\n}\n\nvar proto = BrushTargetManager.prototype;\n\nproto.setOutputRanges = function (areas, ecModel) {\n    this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n        (area.coordRanges || (area.coordRanges = [])).push(coordRange);\n        // area.coordRange is the first of area.coordRanges\n        if (!area.coordRange) {\n            area.coordRange = coordRange;\n            // In 'category' axis, coord to pixel is not reversible, so we can not\n            // rebuild range by coordRange accrately, which may bring trouble when\n            // brushing only one item. So we use __rangeOffset to rebuilding range\n            // by coordRange. And this it only used in brush component so it is no\n            // need to be adapted to coordRanges.\n            var result = coordConvert[area.brushType](0, coordSys, coordRange);\n            area.__rangeOffset = {\n                offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n                xyMinMax: result.xyMinMax\n            };\n        }\n    });\n};\n\nproto.matchOutputRanges = function (areas, ecModel, cb) {\n    each$23(areas, function (area) {\n        var targetInfo = this.findTargetInfo(area, ecModel);\n\n        if (targetInfo && targetInfo !== true) {\n            each$1(\n                targetInfo.coordSyses,\n                function (coordSys) {\n                    var result = coordConvert[area.brushType](1, coordSys, area.range);\n                    cb(area, result.values, coordSys, ecModel);\n                }\n            );\n        }\n    }, this);\n};\n\nproto.setInputRanges = function (areas, ecModel) {\n    each$23(areas, function (area) {\n        var targetInfo = this.findTargetInfo(area, ecModel);\n\n        if (__DEV__) {\n            assert(\n                !targetInfo || targetInfo === true || area.coordRange,\n                'coordRange must be specified when coord index specified.'\n            );\n            assert(\n                !targetInfo || targetInfo !== true || area.range,\n                'range must be specified in global brush.'\n            );\n        }\n\n        area.range = area.range || [];\n\n        // convert coordRange to global range and set panelId.\n        if (targetInfo && targetInfo !== true) {\n            area.panelId = targetInfo.panelId;\n            // (1) area.range shoule always be calculate from coordRange but does\n            // not keep its original value, for the sake of the dataZoom scenario,\n            // where area.coordRange remains unchanged but area.range may be changed.\n            // (2) Only support converting one coordRange to pixel range in brush\n            // component. So do not consider `coordRanges`.\n            // (3) About __rangeOffset, see comment above.\n            var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n            var rangeOffset = area.__rangeOffset;\n            area.range = rangeOffset\n                ? diffProcessor[area.brushType](\n                    result.values,\n                    rangeOffset.offset,\n                    getScales(result.xyMinMax, rangeOffset.xyMinMax)\n                )\n                : result.values;\n        }\n    }, this);\n};\n\nproto.makePanelOpts = function (api, getDefaultBrushType) {\n    return map(this._targetInfoList, function (targetInfo) {\n        var rect = targetInfo.getPanelRect();\n        return {\n            panelId: targetInfo.panelId,\n            defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),\n            clipPath: makeRectPanelClipPath(rect),\n            isTargetByCursor: makeRectIsTargetByCursor(\n                rect, api, targetInfo.coordSysModel\n            ),\n            getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect)\n        };\n    });\n};\n\nproto.controlSeries = function (area, seriesModel, ecModel) {\n    // Check whether area is bound in coord, and series do not belong to that coord.\n    // If do not do this check, some brush (like lineX) will controll all axes.\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    return targetInfo === true || (\n        targetInfo && indexOf$2(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0\n    );\n};\n\n/**\n * If return Object, a coord found.\n * If reutrn true, global found.\n * Otherwise nothing found.\n *\n * @param {Object} area\n * @param {Array} targetInfoList\n * @return {Object|boolean}\n */\nproto.findTargetInfo = function (area, ecModel) {\n    var targetInfoList = this._targetInfoList;\n    var foundCpts = parseFinder$1(ecModel, area);\n\n    for (var i = 0; i < targetInfoList.length; i++) {\n        var targetInfo = targetInfoList[i];\n        var areaPanelId = area.panelId;\n        if (areaPanelId) {\n            if (targetInfo.panelId === areaPanelId) {\n                return targetInfo;\n            }\n        }\n        else {\n            for (var i = 0; i < targetInfoMatchers.length; i++) {\n                if (targetInfoMatchers[i](foundCpts, targetInfo)) {\n                    return targetInfo;\n                }\n            }\n        }\n    }\n\n    return true;\n};\n\nfunction formatMinMax(minMax) {\n    minMax[0] > minMax[1] && minMax.reverse();\n    return minMax;\n}\n\nfunction parseFinder$1(ecModel, option) {\n    return parseFinder(\n        ecModel, option, {includeMainTypes: INCLUDE_FINDER_MAIN_TYPES}\n    );\n}\n\nvar targetInfoBuilders = {\n\n    grid: function (foundCpts, targetInfoList) {\n        var xAxisModels = foundCpts.xAxisModels;\n        var yAxisModels = foundCpts.yAxisModels;\n        var gridModels = foundCpts.gridModels;\n        // Remove duplicated.\n        var gridModelMap = createHashMap();\n        var xAxesHas = {};\n        var yAxesHas = {};\n\n        if (!xAxisModels && !yAxisModels && !gridModels) {\n            return;\n        }\n\n        each$23(xAxisModels, function (axisModel) {\n            var gridModel = axisModel.axis.grid.model;\n            gridModelMap.set(gridModel.id, gridModel);\n            xAxesHas[gridModel.id] = true;\n        });\n        each$23(yAxisModels, function (axisModel) {\n            var gridModel = axisModel.axis.grid.model;\n            gridModelMap.set(gridModel.id, gridModel);\n            yAxesHas[gridModel.id] = true;\n        });\n        each$23(gridModels, function (gridModel) {\n            gridModelMap.set(gridModel.id, gridModel);\n            xAxesHas[gridModel.id] = true;\n            yAxesHas[gridModel.id] = true;\n        });\n\n        gridModelMap.each(function (gridModel) {\n            var grid = gridModel.coordinateSystem;\n            var cartesians = [];\n\n            each$23(grid.getCartesians(), function (cartesian, index) {\n                if (indexOf$2(xAxisModels, cartesian.getAxis('x').model) >= 0\n                    || indexOf$2(yAxisModels, cartesian.getAxis('y').model) >= 0\n                ) {\n                    cartesians.push(cartesian);\n                }\n            });\n            targetInfoList.push({\n                panelId: 'grid--' + gridModel.id,\n                gridModel: gridModel,\n                coordSysModel: gridModel,\n                // Use the first one as the representitive coordSys.\n                coordSys: cartesians[0],\n                coordSyses: cartesians,\n                getPanelRect: panelRectBuilder.grid,\n                xAxisDeclared: xAxesHas[gridModel.id],\n                yAxisDeclared: yAxesHas[gridModel.id]\n            });\n        });\n    },\n\n    geo: function (foundCpts, targetInfoList) {\n        each$23(foundCpts.geoModels, function (geoModel) {\n            var coordSys = geoModel.coordinateSystem;\n            targetInfoList.push({\n                panelId: 'geo--' + geoModel.id,\n                geoModel: geoModel,\n                coordSysModel: geoModel,\n                coordSys: coordSys,\n                coordSyses: [coordSys],\n                getPanelRect: panelRectBuilder.geo\n            });\n        });\n    }\n};\n\nvar targetInfoMatchers = [\n\n    // grid\n    function (foundCpts, targetInfo) {\n        var xAxisModel = foundCpts.xAxisModel;\n        var yAxisModel = foundCpts.yAxisModel;\n        var gridModel = foundCpts.gridModel;\n\n        !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n        !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n\n        return gridModel && gridModel === targetInfo.gridModel;\n    },\n\n    // geo\n    function (foundCpts, targetInfo) {\n        var geoModel = foundCpts.geoModel;\n        return geoModel && geoModel === targetInfo.geoModel;\n    }\n];\n\nvar panelRectBuilder = {\n\n    grid: function () {\n        // grid is not Transformable.\n        return this.coordSys.grid.getRect().clone();\n    },\n\n    geo: function () {\n        var coordSys = this.coordSys;\n        var rect = coordSys.getBoundingRect().clone();\n        // geo roam and zoom transform\n        rect.applyTransform(getTransform(coordSys));\n        return rect;\n    }\n};\n\nvar coordConvert = {\n\n    lineX: curry$5(axisConvert, 0),\n\n    lineY: curry$5(axisConvert, 1),\n\n    rect: function (to, coordSys, rangeOrCoordRange) {\n        var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);\n        var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);\n        var values = [\n            formatMinMax([xminymin[0], xmaxymax[0]]),\n            formatMinMax([xminymin[1], xmaxymax[1]])\n        ];\n        return {values: values, xyMinMax: values};\n    },\n\n    polygon: function (to, coordSys, rangeOrCoordRange) {\n        var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n        var values = map(rangeOrCoordRange, function (item) {\n            var p = coordSys[COORD_CONVERTS[to]](item);\n            xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n            xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n            xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n            xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n            return p;\n        });\n        return {values: values, xyMinMax: xyMinMax};\n    }\n};\n\nfunction axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n    if (__DEV__) {\n        assert(\n            coordSys.type === 'cartesian2d',\n            'lineX/lineY brush is available only in cartesian2d.'\n        );\n    }\n\n    var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n    var values = formatMinMax(map([0, 1], function (i) {\n        return to\n            ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]))\n            : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n    }));\n    var xyMinMax = [];\n    xyMinMax[axisNameIndex] = values;\n    xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n\n    return {values: values, xyMinMax: xyMinMax};\n}\n\nvar diffProcessor = {\n    lineX: curry$5(axisDiffProcessor, 0),\n\n    lineY: curry$5(axisDiffProcessor, 1),\n\n    rect: function (values, refer, scales) {\n        return [\n            [values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]],\n            [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]\n        ];\n    },\n\n    polygon: function (values, refer, scales) {\n        return map(values, function (item, idx) {\n            return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n        });\n    }\n};\n\nfunction axisDiffProcessor(axisNameIndex, values, refer, scales) {\n    return [\n        values[0] - scales[axisNameIndex] * refer[0],\n        values[1] - scales[axisNameIndex] * refer[1]\n    ];\n}\n\n// We have to process scale caused by dataZoom manually,\n// although it might be not accurate.\nfunction getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n    var sizeCurr = getSize(xyMinMaxCurr);\n    var sizeOrigin = getSize(xyMinMaxOrigin);\n    var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n    isNaN(scales[0]) && (scales[0] = 1);\n    isNaN(scales[1]) && (scales[1] = 1);\n    return scales;\n}\n\nfunction getSize(xyMinMax) {\n    return xyMinMax\n        ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]]\n        : [NaN, NaN];\n}\n\nvar STATE_LIST = ['inBrush', 'outOfBrush'];\nvar DISPATCH_METHOD = '__ecBrushSelect';\nvar DISPATCH_FLAG = '__ecInBrushSelectEvent';\nvar PRIORITY_BRUSH = PRIORITY.VISUAL.BRUSH;\n\n/**\n * Layout for visual, the priority higher than other layout, and before brush visual.\n */\nregisterLayout(PRIORITY_BRUSH, function (ecModel, api, payload) {\n    ecModel.eachComponent({mainType: 'brush'}, function (brushModel) {\n\n        payload && payload.type === 'takeGlobalCursor' && brushModel.setBrushOption(\n            payload.key === 'brush' ? payload.brushOption : {brushType: false}\n        );\n\n        var brushTargetManager = brushModel.brushTargetManager = new BrushTargetManager(brushModel.option, ecModel);\n\n        brushTargetManager.setInputRanges(brushModel.areas, ecModel);\n    });\n});\n\n/**\n * Register the visual encoding if this modules required.\n */\nregisterVisual(PRIORITY_BRUSH, function (ecModel, api, payload) {\n\n    var brushSelected = [];\n    var throttleType;\n    var throttleDelay;\n\n    ecModel.eachComponent({mainType: 'brush'}, function (brushModel, brushIndex) {\n\n        var thisBrushSelected = {\n            brushId: brushModel.id,\n            brushIndex: brushIndex,\n            brushName: brushModel.name,\n            areas: clone(brushModel.areas),\n            selected: []\n        };\n        // Every brush component exists in event params, convenient\n        // for user to find by index.\n        brushSelected.push(thisBrushSelected);\n\n        var brushOption = brushModel.option;\n        var brushLink = brushOption.brushLink;\n        var linkedSeriesMap = [];\n        var selectedDataIndexForLink = [];\n        var rangeInfoBySeries = [];\n        var hasBrushExists = 0;\n\n        if (!brushIndex) { // Only the first throttle setting works.\n            throttleType = brushOption.throttleType;\n            throttleDelay = brushOption.throttleDelay;\n        }\n\n        // Add boundingRect and selectors to range.\n        var areas = map(brushModel.areas, function (area) {\n            return bindSelector(\n                defaults(\n                    {boundingRect: boundingRectBuilders[area.brushType](area)},\n                    area\n                )\n            );\n        });\n\n        var visualMappings = createVisualMappings(\n            brushModel.option, STATE_LIST, function (mappingOption) {\n                mappingOption.mappingMethod = 'fixed';\n            }\n        );\n\n        isArray(brushLink) && each$1(brushLink, function (seriesIndex) {\n            linkedSeriesMap[seriesIndex] = 1;\n        });\n\n        function linkOthers(seriesIndex) {\n            return brushLink === 'all' || linkedSeriesMap[seriesIndex];\n        }\n\n        // If no supported brush or no brush on the series,\n        // all visuals should be in original state.\n        function brushed(rangeInfoList) {\n            return !!rangeInfoList.length;\n        }\n\n        /**\n         * Logic for each series: (If the logic has to be modified one day, do it carefully!)\n         *\n         * ( brushed  && hasBrushExist  && linkOthers  ) => StepA: record,  StepB: visualByRecord.\n         *   !brushed    hasBrushExist                             nothing,        visualByRecord.\n         *                !hasBrushExist                                              nothing.\n         * ( !brushed  && hasBrushExist  && linkOthers  ) => StepA:  nothing,  StepB: visualByRecord.\n         *                !hasBrushExist                                              nothing.\n         * ( brushed  &&                     !linkOthers ) => StepA:  nothing,  StepB: visualByCheck.\n         *   !brushed                                                                  nothing.\n         * ( !brushed  &&                     !linkOthers ) => StepA:  nothing,  StepB:  nothing.\n         */\n\n        // Step A\n        ecModel.eachSeries(function (seriesModel, seriesIndex) {\n            var rangeInfoList = rangeInfoBySeries[seriesIndex] = [];\n\n            seriesModel.subType === 'parallel'\n                ? stepAParallel(seriesModel, seriesIndex, rangeInfoList)\n                : stepAOthers(seriesModel, seriesIndex, rangeInfoList);\n        });\n\n        function stepAParallel(seriesModel, seriesIndex) {\n            var coordSys = seriesModel.coordinateSystem;\n            hasBrushExists |= coordSys.hasAxisBrushed();\n\n            linkOthers(seriesIndex) && coordSys.eachActiveState(\n                seriesModel.getData(),\n                function (activeState, dataIndex) {\n                    activeState === 'active' && (selectedDataIndexForLink[dataIndex] = 1);\n                }\n            );\n        }\n\n        function stepAOthers(seriesModel, seriesIndex, rangeInfoList) {\n            var selectorsByBrushType = getSelectorsByBrushType(seriesModel);\n            if (!selectorsByBrushType || brushModelNotControll(brushModel, seriesIndex)) {\n                return;\n            }\n\n            each$1(areas, function (area) {\n                selectorsByBrushType[area.brushType]\n                    && brushModel.brushTargetManager.controlSeries(area, seriesModel, ecModel)\n                    && rangeInfoList.push(area);\n                hasBrushExists |= brushed(rangeInfoList);\n            });\n\n            if (linkOthers(seriesIndex) && brushed(rangeInfoList)) {\n                var data = seriesModel.getData();\n                data.each(function (dataIndex) {\n                    if (checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex)) {\n                        selectedDataIndexForLink[dataIndex] = 1;\n                    }\n                });\n            }\n        }\n\n        // Step B\n        ecModel.eachSeries(function (seriesModel, seriesIndex) {\n            var seriesBrushSelected = {\n                seriesId: seriesModel.id,\n                seriesIndex: seriesIndex,\n                seriesName: seriesModel.name,\n                dataIndex: []\n            };\n            // Every series exists in event params, convenient\n            // for user to find series by seriesIndex.\n            thisBrushSelected.selected.push(seriesBrushSelected);\n\n            var selectorsByBrushType = getSelectorsByBrushType(seriesModel);\n            var rangeInfoList = rangeInfoBySeries[seriesIndex];\n\n            var data = seriesModel.getData();\n            var getValueState = linkOthers(seriesIndex)\n                ? function (dataIndex) {\n                    return selectedDataIndexForLink[dataIndex]\n                        ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), 'inBrush')\n                        : 'outOfBrush';\n                }\n                : function (dataIndex) {\n                    return checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex)\n                        ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), 'inBrush')\n                        : 'outOfBrush';\n                };\n\n            // If no supported brush or no brush, all visuals are in original state.\n            (linkOthers(seriesIndex) ? hasBrushExists : brushed(rangeInfoList))\n                && applyVisual(\n                    STATE_LIST, visualMappings, data, getValueState\n                );\n        });\n\n    });\n\n    dispatchAction(api, throttleType, throttleDelay, brushSelected, payload);\n});\n\nfunction dispatchAction(api, throttleType, throttleDelay, brushSelected, payload) {\n    // This event will not be triggered when `setOpion`, otherwise dead lock may\n    // triggered when do `setOption` in event listener, which we do not find\n    // satisfactory way to solve yet. Some considered resolutions:\n    // (a) Diff with prevoius selected data ant only trigger event when changed.\n    // But store previous data and diff precisely (i.e., not only by dataIndex, but\n    // also detect value changes in selected data) might bring complexity or fragility.\n    // (b) Use spectial param like `silent` to suppress event triggering.\n    // But such kind of volatile param may be weird in `setOption`.\n    if (!payload) {\n        return;\n    }\n\n    var zr = api.getZr();\n    if (zr[DISPATCH_FLAG]) {\n        return;\n    }\n\n    if (!zr[DISPATCH_METHOD]) {\n        zr[DISPATCH_METHOD] = doDispatch;\n    }\n\n    var fn = createOrUpdate(zr, DISPATCH_METHOD, throttleDelay, throttleType);\n\n    fn(api, brushSelected);\n}\n\nfunction doDispatch(api, brushSelected) {\n    if (!api.isDisposed()) {\n        var zr = api.getZr();\n        zr[DISPATCH_FLAG] = true;\n        api.dispatchAction({\n            type: 'brushSelect',\n            batch: brushSelected\n        });\n        zr[DISPATCH_FLAG] = false;\n    }\n}\n\nfunction checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex) {\n    for (var i = 0, len = rangeInfoList.length; i < len; i++) {\n        var area = rangeInfoList[i];\n        if (selectorsByBrushType[area.brushType](\n            dataIndex, data, area.selectors, area\n        )) {\n            return true;\n        }\n    }\n}\n\nfunction getSelectorsByBrushType(seriesModel) {\n    var brushSelector = seriesModel.brushSelector;\n    if (isString(brushSelector)) {\n        var sels = [];\n        each$1(selector, function (selectorsByElementType, brushType) {\n            sels[brushType] = function (dataIndex, data, selectors, area) {\n                var itemLayout = data.getItemLayout(dataIndex);\n                return selectorsByElementType[brushSelector](itemLayout, selectors, area);\n            };\n        });\n        return sels;\n    }\n    else if (isFunction(brushSelector)) {\n        var bSelector = {};\n        each$1(selector, function (sel, brushType) {\n            bSelector[brushType] = brushSelector;\n        });\n        return bSelector;\n    }\n    return brushSelector;\n}\n\nfunction brushModelNotControll(brushModel, seriesIndex) {\n    var seriesIndices = brushModel.option.seriesIndex;\n    return seriesIndices != null\n        && seriesIndices !== 'all'\n        && (\n            isArray(seriesIndices)\n            ? indexOf(seriesIndices, seriesIndex) < 0\n            : seriesIndex !== seriesIndices\n        );\n}\n\nfunction bindSelector(area) {\n    var selectors = area.selectors = {};\n    each$1(selector[area.brushType], function (selFn, elType) {\n        // Do not use function binding or curry for performance.\n        selectors[elType] = function (itemLayout) {\n            return selFn(itemLayout, selectors, area);\n        };\n    });\n    return area;\n}\n\nvar boundingRectBuilders = {\n\n    lineX: noop,\n\n    lineY: noop,\n\n    rect: function (area) {\n        return getBoundingRectFromMinMax(area.range);\n    },\n\n    polygon: function (area) {\n        var minMax;\n        var range = area.range;\n\n        for (var i = 0, len = range.length; i < len; i++) {\n            minMax = minMax || [[Infinity, -Infinity], [Infinity, -Infinity]];\n            var rg = range[i];\n            rg[0] < minMax[0][0] && (minMax[0][0] = rg[0]);\n            rg[0] > minMax[0][1] && (minMax[0][1] = rg[0]);\n            rg[1] < minMax[1][0] && (minMax[1][0] = rg[1]);\n            rg[1] > minMax[1][1] && (minMax[1][1] = rg[1]);\n        }\n\n        return minMax && getBoundingRectFromMinMax(minMax);\n    }\n};\n\nfunction getBoundingRectFromMinMax(minMax) {\n    return new BoundingRect(\n        minMax[0][0],\n        minMax[1][0],\n        minMax[0][1] - minMax[0][0],\n        minMax[1][1] - minMax[1][0]\n    );\n}\n\nvar DEFAULT_OUT_OF_BRUSH_COLOR = ['#ddd'];\n\nvar BrushModel = extendComponentModel({\n\n    type: 'brush',\n\n    dependencies: ['geo', 'grid', 'xAxis', 'yAxis', 'parallel', 'series'],\n\n    /**\n     * @protected\n     */\n    defaultOption: {\n        // inBrush: null,\n        // outOfBrush: null,\n        toolbox: null,          // Default value see preprocessor.\n        brushLink: null,        // Series indices array, broadcast using dataIndex.\n                                // or 'all', which means all series. 'none' or null means no series.\n        seriesIndex: 'all',     // seriesIndex array, specify series controlled by this brush component.\n        geoIndex: null,         //\n        xAxisIndex: null,\n        yAxisIndex: null,\n\n        brushType: 'rect',      // Default brushType, see BrushController.\n        brushMode: 'single',    // Default brushMode, 'single' or 'multiple'\n        transformable: true,    // Default transformable.\n        brushStyle: {           // Default brushStyle\n            borderWidth: 1,\n            color: 'rgba(120,140,180,0.3)',\n            borderColor: 'rgba(120,140,180,0.8)'\n        },\n\n        throttleType: 'fixRate',// Throttle in brushSelected event. 'fixRate' or 'debounce'.\n                                // If null, no throttle. Valid only in the first brush component\n        throttleDelay: 0,       // Unit: ms, 0 means every event will be triggered.\n\n        // FIXME\n        // \n        removeOnClick: true,\n\n        z: 10000\n    },\n\n    /**\n     * @readOnly\n     * @type {Array.<Object>}\n     */\n    areas: [],\n\n    /**\n     * Current activated brush type.\n     * If null, brush is inactived.\n     * see module:echarts/component/helper/BrushController\n     * @readOnly\n     * @type {string}\n     */\n    brushType: null,\n\n    /**\n     * Current brush opt.\n     * see module:echarts/component/helper/BrushController\n     * @readOnly\n     * @type {Object}\n     */\n    brushOption: {},\n\n    /**\n     * @readOnly\n     * @type {Array.<Object>}\n     */\n    coordInfoList: [],\n\n    optionUpdated: function (newOption, isInit) {\n        var thisOption = this.option;\n\n        !isInit && replaceVisualOption(\n            thisOption, newOption, ['inBrush', 'outOfBrush']\n        );\n\n        thisOption.inBrush = thisOption.inBrush || {};\n        // Always give default visual, consider setOption at the second time.\n        thisOption.outOfBrush = thisOption.outOfBrush || {color: DEFAULT_OUT_OF_BRUSH_COLOR};\n    },\n\n    /**\n     * If ranges is null/undefined, range state remain.\n     *\n     * @param {Array.<Object>} [ranges]\n     */\n    setAreas: function (areas) {\n        if (__DEV__) {\n            assert(isArray(areas));\n            each$1(areas, function (area) {\n                assert(area.brushType, 'Illegal areas');\n            });\n        }\n\n        // If ranges is null/undefined, range state remain.\n        // This helps user to dispatchAction({type: 'brush'}) with no areas\n        // set but just want to get the current brush select info from a `brush` event.\n        if (!areas) {\n            return;\n        }\n\n        this.areas = map(areas, function (area) {\n            return generateBrushOption(this.option, area);\n        }, this);\n    },\n\n    /**\n     * see module:echarts/component/helper/BrushController\n     * @param {Object} brushOption\n     */\n    setBrushOption: function (brushOption) {\n        this.brushOption = generateBrushOption(this.option, brushOption);\n        this.brushType = this.brushOption.brushType;\n    }\n\n});\n\nfunction generateBrushOption(option, brushOption) {\n    return merge(\n        {\n            brushType: option.brushType,\n            brushMode: option.brushMode,\n            transformable: option.transformable,\n            brushStyle: new Model(option.brushStyle).getItemStyle(),\n            removeOnClick: option.removeOnClick,\n            z: option.z\n        },\n        brushOption,\n        true\n    );\n}\n\nextendComponentView({\n\n    type: 'brush',\n\n    init: function (ecModel, api) {\n\n        /**\n         * @readOnly\n         * @type {module:echarts/model/Global}\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @readOnly\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this.api = api;\n\n        /**\n         * @readOnly\n         * @type {module:echarts/component/brush/BrushModel}\n         */\n        this.model;\n\n        /**\n         * @private\n         * @type {module:echarts/component/helper/BrushController}\n         */\n        (this._brushController = new BrushController(api.getZr()))\n            .on('brush', bind(this._onBrush, this))\n            .mount();\n    },\n\n    /**\n     * @override\n     */\n    render: function (brushModel) {\n        this.model = brushModel;\n        return updateController.apply(this, arguments);\n    },\n\n    /**\n     * @override\n     */\n    updateView: updateController,\n\n    /**\n     * @override\n     */\n    updateLayout: updateController,\n\n    /**\n     * @override\n     */\n    updateVisual: updateController,\n\n    /**\n     * @override\n     */\n    dispose: function () {\n        this._brushController.dispose();\n    },\n\n    /**\n     * @private\n     */\n    _onBrush: function (areas, opt) {\n        var modelId = this.model.id;\n\n        this.model.brushTargetManager.setOutputRanges(areas, this.ecModel);\n\n        // Action is not dispatched on drag end, because the drag end\n        // emits the same params with the last drag move event, and\n        // may have some delay when using touch pad, which makes\n        // animation not smooth (when using debounce).\n        (!opt.isEnd || opt.removeOnClick) && this.api.dispatchAction({\n            type: 'brush',\n            brushId: modelId,\n            areas: clone(areas),\n            $from: modelId\n        });\n    }\n\n});\n\nfunction updateController(brushModel, ecModel, api, payload) {\n    // Do not update controller when drawing.\n    (!payload || payload.$from !== brushModel.id) && this._brushController\n        .setPanels(brushModel.brushTargetManager.makePanelOpts(api))\n        .enableBrush(brushModel.brushOption)\n        .updateCovers(brushModel.areas.slice());\n}\n\n/**\n * payload: {\n *      brushIndex: number, or,\n *      brushId: string, or,\n *      brushName: string,\n *      globalRanges: Array\n * }\n */\nregisterAction(\n        {type: 'brush', event: 'brush', update: 'updateView'},\n    function (payload, ecModel) {\n        ecModel.eachComponent({mainType: 'brush', query: payload}, function (brushModel) {\n            brushModel.setAreas(payload.areas);\n        });\n    }\n);\n\n/**\n * payload: {\n *      brushComponents: [\n *          {\n *              brushId,\n *              brushIndex,\n *              brushName,\n *              series: [\n *                  {\n *                      seriesId,\n *                      seriesIndex,\n *                      seriesName,\n *                      rawIndices: [21, 34, ...]\n *                  },\n *                  ...\n *              ]\n *          },\n *          ...\n *      ]\n * }\n */\nregisterAction(\n        {type: 'brushSelect', event: 'brushSelected', update: 'none'},\n    function () {}\n);\n\nvar features = {};\n\nfunction register$1(name, ctor) {\n    features[name] = ctor;\n}\n\nfunction get$5(name) {\n    return features[name];\n}\n\nvar lang = {\n    toolbox: {\n        brush: {\n            title: {\n                rect: '',\n                polygon: '',\n                lineX: '',\n                lineY: '',\n                keep: '',\n                clear: ''\n            }\n        },\n        dataView: {\n            title: '',\n            lang: ['', '', '']\n        },\n        dataZoom: {\n            title: {\n                zoom: '',\n                back: ''\n            }\n        },\n        magicType: {\n            title: {\n                line: '',\n                bar: '',\n                stack: '',\n                tiled: ''\n            }\n        },\n        restore: {\n            title: ''\n        },\n        saveAsImage: {\n            title: '',\n            lang: ['']\n        }\n    }\n};\n\nvar brushLang = lang.toolbox.brush;\n\nfunction Brush(model, ecModel, api) {\n    this.model = model;\n    this.ecModel = ecModel;\n    this.api = api;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this._brushType;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this._brushMode;\n}\n\nBrush.defaultOption = {\n    show: true,\n    type: ['rect', 'polygon', 'lineX', 'lineY', 'keep', 'clear'],\n    icon: {\n        rect: 'M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13', // jshint ignore:line\n        polygon: 'M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2', // jshint ignore:line\n        lineX: 'M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4', // jshint ignore:line\n        lineY: 'M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4', // jshint ignore:line\n        keep: 'M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z', // jshint ignore:line\n        clear: 'M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2' // jshint ignore:line\n    },\n    // `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear`\n    title: clone(brushLang.title)\n};\n\nvar proto$1 = Brush.prototype;\n\nproto$1.render =\nproto$1.updateView =\nproto$1.updateLayout = function (featureModel, ecModel, api) {\n    var brushType;\n    var brushMode;\n    var isBrushed;\n\n    ecModel.eachComponent({mainType: 'brush'}, function (brushModel) {\n        brushType = brushModel.brushType;\n        brushMode = brushModel.brushOption.brushMode || 'single';\n        isBrushed |= brushModel.areas.length;\n    });\n    this._brushType = brushType;\n    this._brushMode = brushMode;\n\n    each$1(featureModel.get('type', true), function (type) {\n        featureModel.setIconStatus(\n            type,\n            (\n                type === 'keep'\n                ? brushMode === 'multiple'\n                : type === 'clear'\n                ? isBrushed\n                : type === brushType\n            ) ? 'emphasis' : 'normal'\n        );\n    });\n};\n\nproto$1.getIcons = function () {\n    var model = this.model;\n    var availableIcons = model.get('icon', true);\n    var icons = {};\n    each$1(model.get('type', true), function (type) {\n        if (availableIcons[type]) {\n            icons[type] = availableIcons[type];\n        }\n    });\n    return icons;\n};\n\nproto$1.onclick = function (ecModel, api, type) {\n    var brushType = this._brushType;\n    var brushMode = this._brushMode;\n\n    if (type === 'clear') {\n        // Trigger parallel action firstly\n        api.dispatchAction({\n            type: 'axisAreaSelect',\n            intervals: []\n        });\n\n        api.dispatchAction({\n            type: 'brush',\n            command: 'clear',\n            // Clear all areas of all brush components.\n            areas: []\n        });\n    }\n    else {\n        api.dispatchAction({\n            type: 'takeGlobalCursor',\n            key: 'brush',\n            brushOption: {\n                brushType: type === 'keep'\n                    ? brushType\n                    : (brushType === type ? false : type),\n                brushMode: type === 'keep'\n                    ? (brushMode === 'multiple' ? 'single' : 'multiple')\n                    : brushMode\n            }\n        });\n    }\n};\n\nregister$1('brush', Brush);\n\n/**\n * Brush component entry\n */\n\nregisterPreprocessor(preprocessor$1);\n\n// (24*60*60*1000)\nvar PROXIMATE_ONE_DAY = 86400000;\n\n/**\n * Calendar\n *\n * @constructor\n *\n * @param {Object} calendarModel calendarModel\n * @param {Object} ecModel       ecModel\n * @param {Object} api           api\n */\nfunction Calendar(calendarModel, ecModel, api) {\n    this._model = calendarModel;\n}\n\nCalendar.prototype = {\n\n    constructor: Calendar,\n\n    type: 'calendar',\n\n    dimensions: ['time', 'value'],\n\n    // Required in createListFromData\n    getDimensionsInfo: function () {\n        return [{name: 'time', type: 'time'}];\n    },\n\n    getRangeInfo: function () {\n        return this._rangeInfo;\n    },\n\n    getModel: function () {\n        return this._model;\n    },\n\n    getRect: function () {\n        return this._rect;\n    },\n\n    getCellWidth: function () {\n        return this._sw;\n    },\n\n    getCellHeight: function () {\n        return this._sh;\n    },\n\n    getOrient: function () {\n        return this._orient;\n    },\n\n    /**\n     * getFirstDayOfWeek\n     *\n     * @example\n     *     0 : start at Sunday\n     *     1 : start at Monday\n     *\n     * @return {number}\n     */\n    getFirstDayOfWeek: function () {\n        return this._firstDayOfWeek;\n    },\n\n    /**\n     * get date info\n     *\n     * @param  {string|number} date date\n     * @return {Object}\n     * {\n     *      y: string, local full year, eg., '1940',\n     *      m: string, local month, from '01' ot '12',\n     *      d: string, local date, from '01' to '31' (if exists),\n     *      day: It is not date.getDay(). It is the location of the cell in a week, from 0 to 6,\n     *      time: timestamp,\n     *      formatedDate: string, yyyy-MM-dd,\n     *      date: original date object.\n     * }\n     */\n    getDateInfo: function (date) {\n\n        date = parseDate(date);\n\n        var y = date.getFullYear();\n\n        var m = date.getMonth() + 1;\n        m = m < 10 ? '0' + m : m;\n\n        var d = date.getDate();\n        d = d < 10 ? '0' + d : d;\n\n        var day = date.getDay();\n\n        day = Math.abs((day + 7 - this.getFirstDayOfWeek()) % 7);\n\n        return {\n            y: y,\n            m: m,\n            d: d,\n            day: day,\n            time: date.getTime(),\n            formatedDate: y + '-' + m + '-' + d,\n            date: date\n        };\n    },\n\n    getNextNDay: function (date, n) {\n        n = n || 0;\n        if (n === 0) {\n            return this.getDateInfo(date);\n        }\n\n        date = new Date(this.getDateInfo(date).time);\n        date.setDate(date.getDate() + n);\n\n        return this.getDateInfo(date);\n    },\n\n    update: function (ecModel, api) {\n\n        this._firstDayOfWeek = +this._model.getModel('dayLabel').get('firstDay');\n        this._orient = this._model.get('orient');\n        this._lineWidth = this._model.getModel('itemStyle.normal').getItemStyle().lineWidth || 0;\n\n\n        this._rangeInfo = this._getRangeInfo(this._initRangeOption());\n        var weeks = this._rangeInfo.weeks || 1;\n        var whNames = ['width', 'height'];\n        var cellSize = this._model.get('cellSize').slice();\n        var layoutParams = this._model.getBoxLayoutParams();\n        var cellNumbers = this._orient === 'horizontal' ? [weeks, 7] : [7, weeks];\n\n        each$1([0, 1], function (idx) {\n            if (cellSizeSpecified(cellSize, idx)) {\n                layoutParams[whNames[idx]] = cellSize[idx] * cellNumbers[idx];\n            }\n        });\n\n        var whGlobal = {\n            width: api.getWidth(),\n            height: api.getHeight()\n        };\n        var calendarRect = this._rect = getLayoutRect(layoutParams, whGlobal);\n\n        each$1([0, 1], function (idx) {\n            if (!cellSizeSpecified(cellSize, idx)) {\n                cellSize[idx] = calendarRect[whNames[idx]] / cellNumbers[idx];\n            }\n        });\n\n        function cellSizeSpecified(cellSize, idx) {\n            return cellSize[idx] != null && cellSize[idx] !== 'auto';\n        }\n\n        this._sw = cellSize[0];\n        this._sh = cellSize[1];\n    },\n\n\n    /**\n     * Convert a time data(time, value) item to (x, y) point.\n     *\n     * @override\n     * @param  {Array|number} data data\n     * @param  {boolean} [clamp=true] out of range\n     * @return {Array} point\n     */\n    dataToPoint: function (data, clamp) {\n        isArray(data) && (data = data[0]);\n        clamp == null && (clamp = true);\n\n        var dayInfo = this.getDateInfo(data);\n        var range = this._rangeInfo;\n        var date = dayInfo.formatedDate;\n\n        // if not in range return [NaN, NaN]\n        if (clamp && !(dayInfo.time >= range.start.time && dayInfo.time <= range.end.time)) {\n            return [NaN, NaN];\n        }\n\n        var week = dayInfo.day;\n        var nthWeek = this._getRangeInfo([range.start.time, date]).nthWeek;\n\n        if (this._orient === 'vertical') {\n            return [\n                this._rect.x + week * this._sw + this._sw / 2,\n                this._rect.y + nthWeek * this._sh + this._sh / 2\n            ];\n\n        }\n\n        return [\n            this._rect.x + nthWeek * this._sw + this._sw / 2,\n            this._rect.y + week * this._sh + this._sh / 2\n        ];\n\n    },\n\n    /**\n     * Convert a (x, y) point to time data\n     *\n     * @override\n     * @param  {string} point point\n     * @return {string}       data\n     */\n    pointToData: function (point) {\n\n        var date = this.pointToDate(point);\n\n        return date && date.time;\n    },\n\n    /**\n     * Convert a time date item to (x, y) four point.\n     *\n     * @param  {Array} data  date[0] is date\n     * @param  {boolean} [clamp=true]  out of range\n     * @return {Object}       point\n     */\n    dataToRect: function (data, clamp) {\n        var point = this.dataToPoint(data, clamp);\n\n        return {\n            contentShape: {\n                x: point[0] - (this._sw - this._lineWidth) / 2,\n                y: point[1] - (this._sh - this._lineWidth) / 2,\n                width: this._sw - this._lineWidth,\n                height: this._sh - this._lineWidth\n            },\n\n            center: point,\n\n            tl: [\n                point[0] - this._sw / 2,\n                point[1] - this._sh / 2\n            ],\n\n            tr: [\n                point[0] + this._sw / 2,\n                point[1] - this._sh / 2\n            ],\n\n            br: [\n                point[0] + this._sw / 2,\n                point[1] + this._sh / 2\n            ],\n\n            bl: [\n                point[0] - this._sw / 2,\n                point[1] + this._sh / 2\n            ]\n\n        };\n    },\n\n    /**\n     * Convert a (x, y) point to time date\n     *\n     * @param  {Array} point point\n     * @return {Object}       date\n     */\n    pointToDate: function (point) {\n        var nthX = Math.floor((point[0] - this._rect.x) / this._sw) + 1;\n        var nthY = Math.floor((point[1] - this._rect.y) / this._sh) + 1;\n        var range = this._rangeInfo.range;\n\n        if (this._orient === 'vertical') {\n            return this._getDateByWeeksAndDay(nthY, nthX - 1, range);\n        }\n\n        return this._getDateByWeeksAndDay(nthX, nthY - 1, range);\n    },\n\n    /**\n     * @inheritDoc\n     */\n    convertToPixel: curry(doConvert$2, 'dataToPoint'),\n\n    /**\n     * @inheritDoc\n     */\n    convertFromPixel: curry(doConvert$2, 'pointToData'),\n\n    /**\n     * initRange\n     *\n     * @private\n     * @return {Array} [start, end]\n     */\n    _initRangeOption: function () {\n        var range = this._model.get('range');\n\n        var rg = range;\n\n        if (isArray(rg) && rg.length === 1) {\n            rg = rg[0];\n        }\n\n        if (/^\\d{4}$/.test(rg)) {\n            range = [rg + '-01-01', rg + '-12-31'];\n        }\n\n        if (/^\\d{4}[\\/|-]\\d{1,2}$/.test(rg)) {\n\n            var start = this.getDateInfo(rg);\n            var firstDay = start.date;\n            firstDay.setMonth(firstDay.getMonth() + 1);\n\n            var end = this.getNextNDay(firstDay, -1);\n            range = [start.formatedDate, end.formatedDate];\n        }\n\n        if (/^\\d{4}[\\/|-]\\d{1,2}[\\/|-]\\d{1,2}$/.test(rg)) {\n            range = [rg, rg];\n        }\n\n        var tmp = this._getRangeInfo(range);\n\n        if (tmp.start.time > tmp.end.time) {\n            range.reverse();\n        }\n\n        return range;\n    },\n\n    /**\n     * range info\n     *\n     * @private\n     * @param  {Array} range range ['2017-01-01', '2017-07-08']\n     *  If range[0] > range[1], they will not be reversed.\n     * @return {Object}       obj\n     */\n    _getRangeInfo: function (range) {\n        range = [\n            this.getDateInfo(range[0]),\n            this.getDateInfo(range[1])\n        ];\n\n        var reversed;\n        if (range[0].time > range[1].time) {\n            reversed = true;\n            range.reverse();\n        }\n\n        var allDay = Math.floor(range[1].time / PROXIMATE_ONE_DAY)\n            - Math.floor(range[0].time / PROXIMATE_ONE_DAY) + 1;\n\n        // Consider case:\n        // Firstly set system timezone as \"Time Zone: America/Toronto\",\n        // ```\n        // var first = new Date(1478412000000 - 3600 * 1000 * 2.5);\n        // var second = new Date(1478412000000);\n        // var allDays = Math.floor(second / ONE_DAY) - Math.floor(first / ONE_DAY) + 1;\n        // ```\n        // will get wrong result because of DST. So we should fix it.\n        var date = new Date(range[0].time);\n        var startDateNum = date.getDate();\n        var endDateNum = range[1].date.getDate();\n        date.setDate(startDateNum + allDay - 1);\n        // The bias can not over a month, so just compare date.\n        if (date.getDate() !== endDateNum) {\n            var sign = date.getTime() - range[1].time > 0 ? 1 : -1;\n            while (date.getDate() !== endDateNum && (date.getTime() - range[1].time) * sign > 0) {\n                allDay -= sign;\n                date.setDate(startDateNum + allDay - 1);\n            }\n        }\n\n        var weeks = Math.floor((allDay + range[0].day + 6) / 7);\n        var nthWeek = reversed ? -weeks + 1: weeks - 1;\n\n        reversed && range.reverse();\n\n        return {\n            range: [range[0].formatedDate, range[1].formatedDate],\n            start: range[0],\n            end: range[1],\n            allDay: allDay,\n            weeks: weeks,\n            // From 0.\n            nthWeek: nthWeek,\n            fweek: range[0].day,\n            lweek: range[1].day\n        };\n    },\n\n    /**\n     * get date by nthWeeks and week day in range\n     *\n     * @private\n     * @param  {number} nthWeek the week\n     * @param  {number} day   the week day\n     * @param  {Array} range [d1, d2]\n     * @return {Object}\n     */\n    _getDateByWeeksAndDay: function (nthWeek, day, range) {\n        var rangeInfo = this._getRangeInfo(range);\n\n        if (nthWeek > rangeInfo.weeks\n            || (nthWeek === 0 && day < rangeInfo.fweek)\n            || (nthWeek === rangeInfo.weeks && day > rangeInfo.lweek)\n        ) {\n            return false;\n        }\n\n        var nthDay = (nthWeek - 1) * 7 - rangeInfo.fweek + day;\n        var date = new Date(rangeInfo.start.time);\n        date.setDate(rangeInfo.start.d + nthDay);\n\n        return this.getDateInfo(date);\n    }\n};\n\nCalendar.dimensions =  Calendar.prototype.dimensions;\n\nCalendar.getDimensionsInfo =  Calendar.prototype.getDimensionsInfo;\n\nCalendar.create = function (ecModel, api) {\n    var calendarList = [];\n\n    ecModel.eachComponent('calendar', function (calendarModel) {\n        var calendar = new Calendar(calendarModel, ecModel, api);\n        calendarList.push(calendar);\n        calendarModel.coordinateSystem = calendar;\n    });\n\n    ecModel.eachSeries(function (calendarSeries) {\n        if (calendarSeries.get('coordinateSystem') === 'calendar') {\n            // Inject coordinate system\n            calendarSeries.coordinateSystem = calendarList[calendarSeries.get('calendarIndex') || 0];\n        }\n    });\n    return calendarList;\n};\n\nfunction doConvert$2(methodName, ecModel, finder, value) {\n    var calendarModel = finder.calendarModel;\n    var seriesModel = finder.seriesModel;\n\n    var coordSys = calendarModel\n        ? calendarModel.coordinateSystem\n        : seriesModel\n        ? seriesModel.coordinateSystem\n        : null;\n\n    return coordSys === this ? coordSys[methodName](value) : null;\n}\n\nCoordinateSystemManager.register('calendar', Calendar);\n\nvar CalendarModel = ComponentModel.extend({\n\n    type: 'calendar',\n\n    /**\n     * @type {module:echarts/coord/calendar/Calendar}\n     */\n    coordinateSystem: null,\n\n    defaultOption: {\n        zlevel: 0,\n        z: 2,\n        left: 80,\n        top: 60,\n\n        cellSize: 20,\n\n        // horizontal vertical\n        orient: 'horizontal',\n\n        // month separate line style\n        splitLine: {\n            show: true,\n            lineStyle: {\n                color: '#000',\n                width: 1,\n                type: 'solid'\n            }\n        },\n\n        // rect style  temporarily unused emphasis\n        itemStyle: {\n            normal: {\n                color: '#fff',\n                borderWidth: 1,\n                borderColor: '#ccc'\n            }\n        },\n\n        // week text style\n        dayLabel: {\n            show: true,\n\n            // a week first day\n            firstDay: 0,\n\n            // start end\n            position: 'start',\n            margin: '50%', // 50% of cellSize\n            nameMap: 'en',\n            color: '#000'\n        },\n\n        // month text style\n        monthLabel: {\n            show: true,\n\n            // start end\n            position: 'start',\n            margin: 5,\n\n            // center or left\n            align: 'center',\n\n            // cn en []\n            nameMap: 'en',\n            formatter: null,\n            color: '#000'\n        },\n\n        // year text style\n        yearLabel: {\n            show: true,\n\n            // top bottom left right\n            position: null,\n            margin: 30,\n            formatter: null,\n            color: '#ccc',\n            fontFamily: 'sans-serif',\n            fontWeight: 'bolder',\n            fontSize: 20\n        }\n    },\n\n    /**\n     * @override\n     */\n    init: function (option, parentModel, ecModel, extraOpt) {\n        var inputPositionParams = getLayoutParams(option);\n\n        CalendarModel.superApply(this, 'init', arguments);\n\n        mergeAndNormalizeLayoutParams$1(option, inputPositionParams);\n    },\n\n    /**\n     * @override\n     */\n    mergeOption: function (option, extraOpt) {\n        CalendarModel.superApply(this, 'mergeOption', arguments);\n\n        mergeAndNormalizeLayoutParams$1(this.option, option);\n    }\n});\n\nfunction mergeAndNormalizeLayoutParams$1(target, raw) {\n    // Normalize cellSize\n    var cellSize = target.cellSize;\n\n    if (!isArray(cellSize)) {\n        cellSize = target.cellSize = [cellSize, cellSize];\n    }\n    else if (cellSize.length === 1) {\n        cellSize[1] = cellSize[0];\n    }\n\n    var ignoreSize = map([0, 1], function (hvIdx) {\n        // If user have set `width` or both `left` and `right`, cellSize\n        // will be automatically set to 'auto', otherwise the default\n        // setting of cellSize will make `width` setting not work.\n        if (sizeCalculable(raw, hvIdx)) {\n            cellSize[hvIdx] = 'auto';\n        }\n        return cellSize[hvIdx] != null && cellSize[hvIdx] !== 'auto';\n    });\n\n    mergeLayoutParam(target, raw, {\n        type: 'box', ignoreSize: ignoreSize\n    });\n}\n\nvar MONTH_TEXT = {\n    EN: [\n        'Jan', 'Feb', 'Mar',\n        'Apr', 'May', 'Jun',\n        'Jul', 'Aug', 'Sep',\n        'Oct', 'Nov', 'Dec'\n    ],\n    CN: [\n        '', '', '',\n        '', '', '',\n        '', '', '',\n        '', '', ''\n    ]\n};\n\nvar WEEK_TEXT = {\n    EN: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],\n    CN: ['', '', '', '', '', '', '']\n};\n\nextendComponentView({\n\n    type: 'calendar',\n\n    /**\n     * top/left line points\n     *  @private\n     */\n    _tlpoints: null,\n\n    /**\n     * bottom/right line points\n     *  @private\n     */\n    _blpoints: null,\n\n    /**\n     * first day of month\n     *  @private\n     */\n    _firstDayOfMonth: null,\n\n    /**\n     * first day point of month\n     *  @private\n     */\n    _firstDayPoints: null,\n\n    render: function (calendarModel, ecModel, api) {\n\n        var group = this.group;\n\n        group.removeAll();\n\n        var coordSys = calendarModel.coordinateSystem;\n\n        // range info\n        var rangeData = coordSys.getRangeInfo();\n        var orient = coordSys.getOrient();\n\n        this._renderDayRect(calendarModel, rangeData, group);\n\n        // _renderLines must be called prior to following function\n        this._renderLines(calendarModel, rangeData, orient, group);\n\n        this._renderYearText(calendarModel, rangeData, orient, group);\n\n        this._renderMonthText(calendarModel, orient, group);\n\n        this._renderWeekText(calendarModel, rangeData, orient, group);\n    },\n\n    // render day rect\n    _renderDayRect: function (calendarModel, rangeData, group) {\n        var coordSys = calendarModel.coordinateSystem;\n        var itemRectStyleModel = calendarModel.getModel('itemStyle.normal').getItemStyle();\n        var sw = coordSys.getCellWidth();\n        var sh = coordSys.getCellHeight();\n\n        for (var i = rangeData.start.time;\n            i <= rangeData.end.time;\n            i = coordSys.getNextNDay(i, 1).time\n        ) {\n\n            var point = coordSys.dataToRect([i], false).tl;\n\n            // every rect\n            var rect = new Rect({\n                shape: {\n                    x: point[0],\n                    y: point[1],\n                    width: sw,\n                    height: sh\n                },\n                cursor: 'default',\n                style: itemRectStyleModel\n            });\n\n            group.add(rect);\n        }\n\n    },\n\n    // render separate line\n    _renderLines: function (calendarModel, rangeData, orient, group) {\n\n        var self = this;\n\n        var coordSys = calendarModel.coordinateSystem;\n\n        var lineStyleModel = calendarModel.getModel('splitLine.lineStyle').getLineStyle();\n        var show = calendarModel.get('splitLine.show');\n\n        var lineWidth = lineStyleModel.lineWidth;\n\n        this._tlpoints = [];\n        this._blpoints = [];\n        this._firstDayOfMonth = [];\n        this._firstDayPoints = [];\n\n\n        var firstDay = rangeData.start;\n\n        for (var i = 0; firstDay.time <= rangeData.end.time; i++) {\n            addPoints(firstDay.formatedDate);\n\n            if (i === 0) {\n                firstDay = coordSys.getDateInfo(rangeData.start.y + '-' + rangeData.start.m);\n            }\n\n            var date = firstDay.date;\n            date.setMonth(date.getMonth() + 1);\n            firstDay = coordSys.getDateInfo(date);\n        }\n\n        addPoints(coordSys.getNextNDay(rangeData.end.time, 1).formatedDate);\n\n        function addPoints(date) {\n\n            self._firstDayOfMonth.push(coordSys.getDateInfo(date));\n            self._firstDayPoints.push(coordSys.dataToRect([date], false).tl);\n\n            var points = self._getLinePointsOfOneWeek(calendarModel, date, orient);\n\n            self._tlpoints.push(points[0]);\n            self._blpoints.push(points[points.length - 1]);\n\n            show && self._drawSplitline(points, lineStyleModel, group);\n        }\n\n\n        // render top/left line\n        show && this._drawSplitline(self._getEdgesPoints(self._tlpoints, lineWidth, orient), lineStyleModel, group);\n\n        // render bottom/right line\n        show && this._drawSplitline(self._getEdgesPoints(self._blpoints, lineWidth, orient), lineStyleModel, group);\n\n    },\n\n    // get points at both ends\n    _getEdgesPoints: function (points, lineWidth, orient) {\n        var rs = [points[0].slice(), points[points.length - 1].slice()];\n        var idx = orient === 'horizontal' ? 0 : 1;\n\n        // both ends of the line are extend half lineWidth\n        rs[0][idx] = rs[0][idx] - lineWidth / 2;\n        rs[1][idx] = rs[1][idx] + lineWidth / 2;\n\n        return rs;\n    },\n\n    // render split line\n    _drawSplitline: function (points, lineStyleModel, group) {\n\n        var poyline = new Polyline({\n            z2: 20,\n            shape: {\n                points: points\n            },\n            style: lineStyleModel\n        });\n\n        group.add(poyline);\n    },\n\n    // render month line of one week points\n    _getLinePointsOfOneWeek: function (calendarModel, date, orient) {\n\n        var coordSys = calendarModel.coordinateSystem;\n        date = coordSys.getDateInfo(date);\n\n        var points = [];\n\n        for (var i = 0; i < 7; i++) {\n\n            var tmpD = coordSys.getNextNDay(date.time, i);\n            var point = coordSys.dataToRect([tmpD.time], false);\n\n            points[2 * tmpD.day] = point.tl;\n            points[2 * tmpD.day + 1] = point[orient === 'horizontal' ? 'bl' : 'tr'];\n        }\n\n        return points;\n\n    },\n\n    _formatterLabel: function (formatter, params) {\n\n        if (typeof formatter === 'string' && formatter) {\n            return formatTplSimple(formatter, params);\n        }\n\n        if (typeof formatter === 'function') {\n            return formatter(params);\n        }\n\n        return params.nameMap;\n\n    },\n\n    _yearTextPositionControl: function (textEl, point, orient, position, margin) {\n\n        point = point.slice();\n        var aligns = ['center', 'bottom'];\n\n        if (position === 'bottom') {\n            point[1] += margin;\n            aligns = ['center', 'top'];\n        }\n        else if (position === 'left') {\n            point[0] -= margin;\n        }\n        else if (position === 'right') {\n            point[0] += margin;\n            aligns = ['center', 'top'];\n        }\n        else { // top\n            point[1] -= margin;\n        }\n\n        var rotate = 0;\n        if (position === 'left' || position === 'right') {\n            rotate = Math.PI / 2;\n        }\n\n        return {\n            rotation: rotate,\n            position: point,\n            style: {\n                textAlign: aligns[0],\n                textVerticalAlign: aligns[1]\n            }\n        };\n    },\n\n    // render year\n    _renderYearText: function (calendarModel, rangeData, orient, group) {\n        var yearLabel = calendarModel.getModel('yearLabel');\n\n        if (!yearLabel.get('show')) {\n            return;\n        }\n\n        var margin = yearLabel.get('margin');\n        var pos = yearLabel.get('position');\n\n        if (!pos) {\n            pos = orient !== 'horizontal' ? 'top' : 'left';\n        }\n\n        var points = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]];\n        var xc = (points[0][0] + points[1][0]) / 2;\n        var yc = (points[0][1] + points[1][1]) / 2;\n\n        var idx = orient === 'horizontal' ? 0 : 1;\n\n        var posPoints = {\n            top: [xc, points[idx][1]],\n            bottom: [xc, points[1 - idx][1]],\n            left: [points[1 - idx][0], yc],\n            right: [points[idx][0], yc]\n        };\n\n        var name = rangeData.start.y;\n\n        if (+rangeData.end.y > +rangeData.start.y) {\n            name = name + '-' + rangeData.end.y;\n        }\n\n        var formatter = yearLabel.get('formatter');\n\n        var params = {\n            start: rangeData.start.y,\n            end: rangeData.end.y,\n            nameMap: name\n        };\n\n        var content = this._formatterLabel(formatter, params);\n\n        var yearText = new Text({z2: 30});\n        setTextStyle(yearText.style, yearLabel, {text: content}),\n        yearText.attr(this._yearTextPositionControl(yearText, posPoints[pos], orient, pos, margin));\n\n        group.add(yearText);\n    },\n\n    _monthTextPositionControl: function (point, isCenter, orient, position, margin) {\n        var align = 'left';\n        var vAlign = 'top';\n        var x = point[0];\n        var y = point[1];\n\n        if (orient === 'horizontal') {\n            y = y + margin;\n\n            if (isCenter) {\n                align = 'center';\n            }\n\n            if (position === 'start') {\n                vAlign = 'bottom';\n            }\n        }\n        else {\n            x = x + margin;\n\n            if (isCenter) {\n                vAlign = 'middle';\n            }\n\n            if (position === 'start') {\n                align = 'right';\n            }\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: align,\n            textVerticalAlign: vAlign\n        };\n    },\n\n    // render month and year text\n    _renderMonthText: function (calendarModel, orient, group) {\n        var monthLabel = calendarModel.getModel('monthLabel');\n\n        if (!monthLabel.get('show')) {\n            return;\n        }\n\n        var nameMap = monthLabel.get('nameMap');\n        var margin = monthLabel.get('margin');\n        var pos = monthLabel.get('position');\n        var align = monthLabel.get('align');\n\n        var termPoints = [this._tlpoints, this._blpoints];\n\n        if (isString(nameMap)) {\n            nameMap = MONTH_TEXT[nameMap.toUpperCase()] || [];\n        }\n\n        var idx = pos === 'start' ? 0 : 1;\n        var axis = orient === 'horizontal' ? 0 : 1;\n        margin = pos === 'start' ? -margin : margin;\n        var isCenter = (align === 'center');\n\n        for (var i = 0; i < termPoints[idx].length - 1; i++) {\n\n            var tmp = termPoints[idx][i].slice();\n            var firstDay = this._firstDayOfMonth[i];\n\n            if (isCenter) {\n                var firstDayPoints = this._firstDayPoints[i];\n                tmp[axis] = (firstDayPoints[axis] + termPoints[0][i + 1][axis]) / 2;\n            }\n\n            var formatter = monthLabel.get('formatter');\n            var name = nameMap[+firstDay.m - 1];\n            var params = {\n                yyyy: firstDay.y,\n                yy: (firstDay.y + '').slice(2),\n                MM: firstDay.m,\n                M: +firstDay.m,\n                nameMap: name\n            };\n\n            var content = this._formatterLabel(formatter, params);\n\n            var monthText = new Text({z2: 30});\n            extend(\n                setTextStyle(monthText.style, monthLabel, {text: content}),\n                this._monthTextPositionControl(tmp, isCenter, orient, pos, margin)\n            );\n\n            group.add(monthText);\n        }\n    },\n\n    _weekTextPositionControl: function (point, orient, position, margin, cellSize) {\n        var align = 'center';\n        var vAlign = 'middle';\n        var x = point[0];\n        var y = point[1];\n        var isStart = position === 'start';\n\n        if (orient === 'horizontal') {\n            x = x + margin + (isStart ? 1 : -1) * cellSize[0] / 2;\n            align = isStart ? 'right' : 'left';\n        }\n        else {\n            y = y + margin + (isStart ? 1 : -1) * cellSize[1] / 2;\n            vAlign = isStart ? 'bottom' : 'top';\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: align,\n            textVerticalAlign: vAlign\n        };\n    },\n\n    // render weeks\n    _renderWeekText: function (calendarModel, rangeData, orient, group) {\n        var dayLabel = calendarModel.getModel('dayLabel');\n\n        if (!dayLabel.get('show')) {\n            return;\n        }\n\n        var coordSys = calendarModel.coordinateSystem;\n        var pos = dayLabel.get('position');\n        var nameMap = dayLabel.get('nameMap');\n        var margin = dayLabel.get('margin');\n        var firstDayOfWeek = coordSys.getFirstDayOfWeek();\n\n        if (isString(nameMap)) {\n            nameMap = WEEK_TEXT[nameMap.toUpperCase()] || [];\n        }\n\n        var start = coordSys.getNextNDay(\n            rangeData.end.time, (7 - rangeData.lweek)\n        ).time;\n\n        var cellSize = [coordSys.getCellWidth(), coordSys.getCellHeight()];\n        margin = parsePercent$1(margin, cellSize[orient === 'horizontal' ? 0 : 1]);\n\n        if (pos === 'start') {\n            start = coordSys.getNextNDay(\n                rangeData.start.time, -(7 + rangeData.fweek)\n            ).time;\n            margin = -margin;\n        }\n\n        for (var i = 0; i < 7; i++) {\n\n            var tmpD = coordSys.getNextNDay(start, i);\n            var point = coordSys.dataToRect([tmpD.time], false).center;\n            var day = i;\n            day = Math.abs((i + firstDayOfWeek) % 7);\n            var weekText = new Text({z2: 30});\n\n            extend(\n                setTextStyle(weekText.style, dayLabel, {text: nameMap[day]}),\n                this._weekTextPositionControl(point, orient, pos, margin, cellSize)\n            );\n            group.add(weekText);\n        }\n    }\n});\n\n/**\n * @file calendar.js\n * @author dxh\n */\n\n// Model\nextendComponentModel({\n\n    type: 'title',\n\n    layoutMode: {type: 'box', ignoreSize: true},\n\n    defaultOption: {\n        // \n        zlevel: 0,\n        // \n        z: 6,\n        show: true,\n\n        text: '',\n        // \n        // link: null,\n        // self | blank\n        target: 'blank',\n        subtext: '',\n\n        // \n        // sublink: null,\n        // self | blank\n        subtarget: 'blank',\n\n        // 'center'  'left'  'right'\n        //  {number}xpx\n        left: 0,\n        // 'top'  'bottom'  'center'\n        //  {number}ypx\n        top: 0,\n\n        // \n        // 'auto' | 'left' | 'right' | 'center'\n        //  left \n        // textAlign: null\n        //\n        // \n        // 'auto' | 'top' | 'bottom' | 'middle'\n        //  top \n        // textBaseline: null\n\n        backgroundColor: 'rgba(0,0,0,0)',\n\n        // \n        borderColor: '#ccc',\n\n        // px0\n        borderWidth: 0,\n\n        // px5\n        // css\n        padding: 5,\n\n        // px10\n        itemGap: 10,\n        textStyle: {\n            fontSize: 18,\n            fontWeight: 'bolder',\n            color: '#333'\n        },\n        subtextStyle: {\n            color: '#aaa'\n        }\n    }\n});\n\n// View\nextendComponentView({\n\n    type: 'title',\n\n    render: function (titleModel, ecModel, api) {\n        this.group.removeAll();\n\n        if (!titleModel.get('show')) {\n            return;\n        }\n\n        var group = this.group;\n\n        var textStyleModel = titleModel.getModel('textStyle');\n        var subtextStyleModel = titleModel.getModel('subtextStyle');\n\n        var textAlign = titleModel.get('textAlign');\n        var textBaseline = titleModel.get('textBaseline');\n\n        var textEl = new Text({\n            style: setTextStyle({}, textStyleModel, {\n                text: titleModel.get('text'),\n                textFill: textStyleModel.getTextColor()\n            }, {disableBox: true}),\n            z2: 10\n        });\n\n        var textRect = textEl.getBoundingRect();\n\n        var subText = titleModel.get('subtext');\n        var subTextEl = new Text({\n            style: setTextStyle({}, subtextStyleModel, {\n                text: subText,\n                textFill: subtextStyleModel.getTextColor(),\n                y: textRect.height + titleModel.get('itemGap'),\n                textVerticalAlign: 'top'\n            }, {disableBox: true}),\n            z2: 10\n        });\n\n        var link = titleModel.get('link');\n        var sublink = titleModel.get('sublink');\n\n        textEl.silent = !link;\n        subTextEl.silent = !sublink;\n\n        if (link) {\n            textEl.on('click', function () {\n                window.open(link, '_' + titleModel.get('target'));\n            });\n        }\n        if (sublink) {\n            subTextEl.on('click', function () {\n                window.open(sublink, '_' + titleModel.get('subtarget'));\n            });\n        }\n\n        group.add(textEl);\n        subText && group.add(subTextEl);\n        // If no subText, but add subTextEl, there will be an empty line.\n\n        var groupRect = group.getBoundingRect();\n        var layoutOption = titleModel.getBoxLayoutParams();\n        layoutOption.width = groupRect.width;\n        layoutOption.height = groupRect.height;\n        var layoutRect = getLayoutRect(\n            layoutOption, {\n                width: api.getWidth(),\n                height: api.getHeight()\n            }, titleModel.get('padding')\n        );\n        // Adjust text align based on position\n        if (!textAlign) {\n            // Align left if title is on the left. center and right is same\n            textAlign = titleModel.get('left') || titleModel.get('right');\n            if (textAlign === 'middle') {\n                textAlign = 'center';\n            }\n            // Adjust layout by text align\n            if (textAlign === 'right') {\n                layoutRect.x += layoutRect.width;\n            }\n            else if (textAlign === 'center') {\n                layoutRect.x += layoutRect.width / 2;\n            }\n        }\n        if (!textBaseline) {\n            textBaseline = titleModel.get('top') || titleModel.get('bottom');\n            if (textBaseline === 'center') {\n                textBaseline = 'middle';\n            }\n            if (textBaseline === 'bottom') {\n                layoutRect.y += layoutRect.height;\n            }\n            else if (textBaseline === 'middle') {\n                layoutRect.y += layoutRect.height / 2;\n            }\n\n            textBaseline = textBaseline || 'top';\n        }\n\n        group.attr('position', [layoutRect.x, layoutRect.y]);\n        var alignStyle = {\n            textAlign: textAlign,\n            textVerticalAlign: textBaseline\n        };\n        textEl.setStyle(alignStyle);\n        subTextEl.setStyle(alignStyle);\n\n        // Render background\n        // Get groupRect again because textAlign has been changed\n        groupRect = group.getBoundingRect();\n        var padding = layoutRect.margin;\n        var style = titleModel.getItemStyle(['color', 'opacity']);\n        style.fill = titleModel.get('backgroundColor');\n        var rect = new Rect({\n            shape: {\n                x: groupRect.x - padding[3],\n                y: groupRect.y - padding[0],\n                width: groupRect.width + padding[1] + padding[3],\n                height: groupRect.height + padding[0] + padding[2],\n                r: titleModel.get('borderRadius')\n            },\n            style: style,\n            silent: true\n        });\n        subPixelOptimizeRect(rect);\n\n        group.add(rect);\n    }\n});\n\nComponentModel.registerSubTypeDefaulter('dataZoom', function () {\n    // Default 'slider' when no type specified.\n    return 'slider';\n});\n\nvar AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single'];\n// Supported coords.\nvar COORDS = ['cartesian2d', 'polar', 'singleAxis'];\n\n/**\n * @param {string} coordType\n * @return {boolean}\n */\nfunction isCoordSupported(coordType) {\n    return indexOf(COORDS, coordType) >= 0;\n}\n\n/**\n * Create \"each\" method to iterate names.\n *\n * @pubilc\n * @param  {Array.<string>} names\n * @param  {Array.<string>=} attrs\n * @return {Function}\n */\nfunction createNameEach(names, attrs) {\n    names = names.slice();\n    var capitalNames = map(names, capitalFirst);\n    attrs = (attrs || []).slice();\n    var capitalAttrs = map(attrs, capitalFirst);\n\n    return function (callback, context) {\n        each$1(names, function (name, index) {\n            var nameObj = {name: name, capital: capitalNames[index]};\n\n            for (var j = 0; j < attrs.length; j++) {\n                nameObj[attrs[j]] = name + capitalAttrs[j];\n            }\n\n            callback.call(context, nameObj);\n        });\n    };\n}\n\n/**\n * Iterate each dimension name.\n *\n * @public\n * @param {Function} callback The parameter is like:\n *                            {\n *                                name: 'angle',\n *                                capital: 'Angle',\n *                                axis: 'angleAxis',\n *                                axisIndex: 'angleAixs',\n *                                index: 'angleIndex'\n *                            }\n * @param {Object} context\n */\nvar eachAxisDim$1 = createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);\n\n/**\n * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.\n * dataZoomModels and 'links' make up one or more graphics.\n * This function finds the graphic where the source dataZoomModel is in.\n *\n * @public\n * @param {Function} forEachNode Node iterator.\n * @param {Function} forEachEdgeType edgeType iterator\n * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.\n * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}\n */\nfunction createLinkedNodesFinder(forEachNode, forEachEdgeType, edgeIdGetter) {\n\n    return function (sourceNode) {\n        var result = {\n            nodes: [],\n            records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).\n        };\n\n        forEachEdgeType(function (edgeType) {\n            result.records[edgeType.name] = {};\n        });\n\n        if (!sourceNode) {\n            return result;\n        }\n\n        absorb(sourceNode, result);\n\n        var existsLink;\n        do {\n            existsLink = false;\n            forEachNode(processSingleNode);\n        }\n        while (existsLink);\n\n        function processSingleNode(node) {\n            if (!isNodeAbsorded(node, result) && isLinked(node, result)) {\n                absorb(node, result);\n                existsLink = true;\n            }\n        }\n\n        return result;\n    };\n\n    function isNodeAbsorded(node, result) {\n        return indexOf(result.nodes, node) >= 0;\n    }\n\n    function isLinked(node, result) {\n        var hasLink = false;\n        forEachEdgeType(function (edgeType) {\n            each$1(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n                result.records[edgeType.name][edgeId] && (hasLink = true);\n            });\n        });\n        return hasLink;\n    }\n\n    function absorb(node, result) {\n        result.nodes.push(node);\n        forEachEdgeType(function (edgeType) {\n            each$1(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n                result.records[edgeType.name][edgeId] = true;\n            });\n        });\n    }\n}\n\nvar each$25 = each$1;\nvar asc$1 = asc;\n\n/**\n * Operate single axis.\n * One axis can only operated by one axis operator.\n * Different dataZoomModels may be defined to operate the same axis.\n * (i.e. 'inside' data zoom and 'slider' data zoom components)\n * So dataZoomModels share one axisProxy in that case.\n *\n * @class\n */\nvar AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this._dimName = dimName;\n\n    /**\n     * @private\n     */\n    this._axisIndex = axisIndex;\n\n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this._valueWindow;\n\n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this._percentWindow;\n\n    /**\n     * @private\n     * @type {Array.<number>}\n     */\n    this._dataExtent;\n\n    /**\n     * {minSpan, maxSpan, minValueSpan, maxValueSpan}\n     * @private\n     * @type {Object}\n     */\n    this._minMaxSpan;\n\n    /**\n     * @readOnly\n     * @type {module: echarts/model/Global}\n     */\n    this.ecModel = ecModel;\n\n    /**\n     * @private\n     * @type {module: echarts/component/dataZoom/DataZoomModel}\n     */\n    this._dataZoomModel = dataZoomModel;\n};\n\nAxisProxy.prototype = {\n\n    constructor: AxisProxy,\n\n    /**\n     * Whether the axisProxy is hosted by dataZoomModel.\n     *\n     * @public\n     * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n     * @return {boolean}\n     */\n    hostedBy: function (dataZoomModel) {\n        return this._dataZoomModel === dataZoomModel;\n    },\n\n    /**\n     * @return {Array.<number>} Value can only be NaN or finite value.\n     */\n    getDataValueWindow: function () {\n        return this._valueWindow.slice();\n    },\n\n    /**\n     * @return {Array.<number>}\n     */\n    getDataPercentWindow: function () {\n        return this._percentWindow.slice();\n    },\n\n    /**\n     * @public\n     * @param {number} axisIndex\n     * @return {Array} seriesModels\n     */\n    getTargetSeriesModels: function () {\n        var seriesModels = [];\n        var ecModel = this.ecModel;\n\n        ecModel.eachSeries(function (seriesModel) {\n            if (isCoordSupported(seriesModel.get('coordinateSystem'))) {\n                var dimName = this._dimName;\n                var axisModel = ecModel.queryComponents({\n                    mainType: dimName + 'Axis',\n                    index: seriesModel.get(dimName + 'AxisIndex'),\n                    id: seriesModel.get(dimName + 'AxisId')\n                })[0];\n                if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n                    seriesModels.push(seriesModel);\n                }\n            }\n        }, this);\n\n        return seriesModels;\n    },\n\n    getAxisModel: function () {\n        return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n    },\n\n    getOtherAxisModel: function () {\n        var axisDim = this._dimName;\n        var ecModel = this.ecModel;\n        var axisModel = this.getAxisModel();\n        var isCartesian = axisDim === 'x' || axisDim === 'y';\n        var otherAxisDim;\n        var coordSysIndexName;\n        if (isCartesian) {\n            coordSysIndexName = 'gridIndex';\n            otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n        }\n        else {\n            coordSysIndexName = 'polarIndex';\n            otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n        }\n        var foundOtherAxisModel;\n        ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n            if ((otherAxisModel.get(coordSysIndexName) || 0)\n                === (axisModel.get(coordSysIndexName) || 0)\n            ) {\n                foundOtherAxisModel = otherAxisModel;\n            }\n        });\n        return foundOtherAxisModel;\n    },\n\n    getMinMaxSpan: function () {\n        return clone(this._minMaxSpan);\n    },\n\n    /**\n     * Only calculate by given range and this._dataExtent, do not change anything.\n     *\n     * @param {Object} opt\n     * @param {number} [opt.start]\n     * @param {number} [opt.end]\n     * @param {number} [opt.startValue]\n     * @param {number} [opt.endValue]\n     */\n    calculateDataWindow: function (opt) {\n        var dataExtent = this._dataExtent;\n        var axisModel = this.getAxisModel();\n        var scale = axisModel.axis.scale;\n        var rangePropMode = this._dataZoomModel.getRangePropMode();\n        var percentExtent = [0, 100];\n        var percentWindow = [\n            opt.start,\n            opt.end\n        ];\n        var valueWindow = [];\n\n        each$25(['startValue', 'endValue'], function (prop) {\n            valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);\n        });\n\n        // Normalize bound.\n        each$25([0, 1], function (idx) {\n            var boundValue = valueWindow[idx];\n            var boundPercent = percentWindow[idx];\n\n            // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n            // on `valueProp` ('startValue', 'endValue'). The former one is suitable\n            // for cases that a dataZoom component controls multiple axes with different\n            // unit or extent, and the latter one is suitable for accurate zoom by pixel\n            // (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,\n            // but it is awkward that `percentProp` can not be obtained from `valueProp`\n            // accurately (because all of values that are overflow the `dataExtent` will\n            // be calculated to percent '100%'). So we have to use\n            // `dataZoom.getRangePropMode()` to mark which prop is used.\n            // `rangePropMode` is updated only when setOption or dispatchAction, otherwise\n            // it remains its original value.\n\n            if (rangePropMode[idx] === 'percent') {\n                if (boundPercent == null) {\n                    boundPercent = percentExtent[idx];\n                }\n                // Use scale.parse to math round for category or time axis.\n                boundValue = scale.parse(linearMap(\n                    boundPercent, percentExtent, dataExtent, true\n                ));\n            }\n            else {\n                // Calculating `percent` from `value` may be not accurate, because\n                // This calculation can not be inversed, because all of values that\n                // are overflow the `dataExtent` will be calculated to percent '100%'\n                boundPercent = linearMap(\n                    boundValue, dataExtent, percentExtent, true\n                );\n            }\n\n            // valueWindow[idx] = round(boundValue);\n            // percentWindow[idx] = round(boundPercent);\n            valueWindow[idx] = boundValue;\n            percentWindow[idx] = boundPercent;\n        });\n\n        return {\n            valueWindow: asc$1(valueWindow),\n            percentWindow: asc$1(percentWindow)\n        };\n    },\n\n    /**\n     * Notice: reset should not be called before series.restoreData() called,\n     * so it is recommanded to be called in \"process stage\" but not \"model init\n     * stage\".\n     *\n     * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n     */\n    reset: function (dataZoomModel) {\n        if (dataZoomModel !== this._dataZoomModel) {\n            return;\n        }\n\n        // Culculate data window and data extent, and record them.\n        this._dataExtent = calculateDataExtent(\n            this, this._dimName, this.getTargetSeriesModels()\n        );\n\n        var dataWindow = this.calculateDataWindow(dataZoomModel.option);\n\n        this._valueWindow = dataWindow.valueWindow;\n        this._percentWindow = dataWindow.percentWindow;\n\n        setMinMaxSpan(this);\n\n        // Update axis setting then.\n        setAxisModel(this);\n    },\n\n    /**\n     * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n     */\n    restore: function (dataZoomModel) {\n        if (dataZoomModel !== this._dataZoomModel) {\n            return;\n        }\n\n        this._valueWindow = this._percentWindow = null;\n        setAxisModel(this, true);\n    },\n\n    /**\n     * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n     */\n    filterData: function (dataZoomModel) {\n        if (dataZoomModel !== this._dataZoomModel) {\n            return;\n        }\n\n        var axisDim = this._dimName;\n        var seriesModels = this.getTargetSeriesModels();\n        var filterMode = dataZoomModel.get('filterMode');\n        var valueWindow = this._valueWindow;\n\n        if (filterMode === 'none') {\n            return;\n        }\n\n        // FIXME\n        // Toolbox may has dataZoom injected. And if there are stacked bar chart\n        // with NaN data, NaN will be filtered and stack will be wrong.\n        // So we need to force the mode to be set empty.\n        // In fect, it is not a big deal that do not support filterMode-'filter'\n        // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n        // selection\" some day, which might need \"adapt to data extent on the\n        // otherAxis\", which is disabled by filterMode-'empty'.\n        var otherAxisModel = this.getOtherAxisModel();\n        if (dataZoomModel.get('$fromToolbox')\n            && otherAxisModel\n            && otherAxisModel.get('type') === 'category'\n        ) {\n            filterMode = 'empty';\n        }\n\n        // Process series data\n        each$25(seriesModels, function (seriesModel) {\n            var seriesData = seriesModel.getData();\n            var dataDims = seriesModel.coordDimToDataDim(axisDim);\n\n            if (filterMode === 'weakFilter') {\n                seriesData && seriesData.filterSelf(function (dataIndex) {\n                    var leftOut;\n                    var rightOut;\n                    var hasValue;\n                    for (var i = 0; i < dataDims.length; i++) {\n                        var value = seriesData.get(dataDims[i], dataIndex);\n                        var thisHasValue = !isNaN(value);\n                        var thisLeftOut = value < valueWindow[0];\n                        var thisRightOut = value > valueWindow[1];\n                        if (thisHasValue && !thisLeftOut && !thisRightOut) {\n                            return true;\n                        }\n                        thisHasValue && (hasValue = true);\n                        thisLeftOut && (leftOut = true);\n                        thisRightOut && (rightOut = true);\n                    }\n                    // If both left out and right out, do not filter.\n                    return hasValue && leftOut && rightOut;\n                });\n            }\n            else {\n                seriesData && each$25(dataDims, function (dim) {\n                    if (filterMode === 'empty') {\n                        seriesModel.setData(\n                            seriesData.map(dim, function (value) {\n                                return !isInWindow(value) ? NaN : value;\n                            })\n                        );\n                    }\n                    else {\n                        seriesData.filterSelf(dim, isInWindow);\n                    }\n                });\n            }\n        });\n\n        function isInWindow(value) {\n            return value >= valueWindow[0] && value <= valueWindow[1];\n        }\n    }\n};\n\nfunction calculateDataExtent(axisProxy, axisDim, seriesModels) {\n    var dataExtent = [Infinity, -Infinity];\n\n    each$25(seriesModels, function (seriesModel) {\n        var seriesData = seriesModel.getData();\n        if (seriesData) {\n            each$25(seriesModel.coordDimToDataDim(axisDim), function (dim) {\n                var seriesExtent = seriesData.getDataExtent(dim);\n                seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n                seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n            });\n        }\n    });\n\n    if (dataExtent[1] < dataExtent[0]) {\n        dataExtent = [NaN, NaN];\n    }\n\n    // It is important to get \"consistent\" extent when more then one axes is\n    // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n    // when zooming. But it is difficult to know what is \"consistent\", considering\n    // axes have different type or even different meanings (For example, two\n    // time axes are used to compare data of the same date in different years).\n    // So basically dataZoom just obtains extent by series.data (in category axis\n    // extent can be obtained from axis.data).\n    // Nevertheless, user can set min/max/scale on axes to make extent of axes\n    // consistent.\n    fixExtentByAxis(axisProxy, dataExtent);\n\n    return dataExtent;\n}\n\nfunction fixExtentByAxis(axisProxy, dataExtent) {\n    var axisModel = axisProxy.getAxisModel();\n    var min = axisModel.getMin(true);\n\n    // For category axis, if min/max/scale are not set, extent is determined\n    // by axis.data by default.\n    var isCategoryAxis = axisModel.get('type') === 'category';\n    var axisDataLen = isCategoryAxis && (axisModel.get('data') || []).length;\n\n    if (min != null && min !== 'dataMin' && typeof min !== 'function') {\n        dataExtent[0] = min;\n    }\n    else if (isCategoryAxis) {\n        dataExtent[0] = axisDataLen > 0 ? 0 : NaN;\n    }\n\n    var max = axisModel.getMax(true);\n    if (max != null && max !== 'dataMax' && typeof max !== 'function') {\n        dataExtent[1] = max;\n    }\n    else if (isCategoryAxis) {\n        dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;\n    }\n\n    if (!axisModel.get('scale', true)) {\n        dataExtent[0] > 0 && (dataExtent[0] = 0);\n        dataExtent[1] < 0 && (dataExtent[1] = 0);\n    }\n\n    // For value axis, if min/max/scale are not set, we just use the extent obtained\n    // by series data, which may be a little different from the extent calculated by\n    // `axisHelper.getScaleExtent`. But the different just affects the experience a\n    // little when zooming. So it will not be fixed until some users require it strongly.\n\n    return dataExtent;\n}\n\nfunction setAxisModel(axisProxy, isRestore) {\n    var axisModel = axisProxy.getAxisModel();\n\n    var percentWindow = axisProxy._percentWindow;\n    var valueWindow = axisProxy._valueWindow;\n\n    if (!percentWindow) {\n        return;\n    }\n\n    // [0, 500]: arbitrary value, guess axis extent.\n    var precision = getPixelPrecision(valueWindow, [0, 500]);\n    precision = Math.min(precision, 20);\n    // isRestore or isFull\n    var useOrigin = isRestore || (percentWindow[0] === 0 && percentWindow[1] === 100);\n\n    axisModel.setRange(\n        useOrigin ? null : +valueWindow[0].toFixed(precision),\n        useOrigin ? null : +valueWindow[1].toFixed(precision)\n    );\n}\n\nfunction setMinMaxSpan(axisProxy) {\n    var minMaxSpan = axisProxy._minMaxSpan = {};\n    var dataZoomModel = axisProxy._dataZoomModel;\n\n    each$25(['min', 'max'], function (minMax) {\n        minMaxSpan[minMax + 'Span'] = dataZoomModel.get(minMax + 'Span');\n\n        // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n        var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n\n        if (valueSpan != null) {\n            minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n            valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan);\n\n            if (valueSpan != null) {\n                var dataExtent = axisProxy._dataExtent;\n                minMaxSpan[minMax + 'Span'] = linearMap(\n                    dataExtent[0] + valueSpan, dataExtent, [0, 100], true\n                );\n            }\n        }\n    });\n}\n\nvar each$24 = each$1;\nvar eachAxisDim = eachAxisDim$1;\n\nvar DataZoomModel = extendComponentModel({\n\n    type: 'dataZoom',\n\n    dependencies: [\n        'xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'\n    ],\n\n    /**\n     * @protected\n     */\n    defaultOption: {\n        zlevel: 0,\n        z: 4,                   // Higher than normal component (z: 2).\n        orient: null,           // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.\n        xAxisIndex: null,       // Default the first horizontal category axis.\n        yAxisIndex: null,       // Default the first vertical category axis.\n\n        filterMode: 'filter',   // Possible values: 'filter' or 'empty' or 'weakFilter'.\n                                // 'filter': data items which are out of window will be removed. This option is\n                                //          applicable when filtering outliers. For each data item, it will be\n                                //          filtered if one of the relevant dimensions is out of the window.\n                                // 'weakFilter': data items which are out of window will be removed. This option\n                                //          is applicable when filtering outliers. For each data item, it will be\n                                //          filtered only if all  of the relevant dimensions are out of the same\n                                //          side of the window.\n                                // 'empty': data items which are out of window will be set to empty.\n                                //          This option is applicable when user should not neglect\n                                //          that there are some data items out of window.\n                                // 'none': Do not filter.\n                                // Taking line chart as an example, line will be broken in\n                                // the filtered points when filterModel is set to 'empty', but\n                                // be connected when set to 'filter'.\n\n        throttle: null,         // Dispatch action by the fixed rate, avoid frequency.\n                                // default 100. Do not throttle when use null/undefined.\n                                // If animation === true and animationDurationUpdate > 0,\n                                // default value is 100, otherwise 20.\n        start: 0,               // Start percent. 0 ~ 100\n        end: 100,               // End percent. 0 ~ 100\n        startValue: null,       // Start value. If startValue specified, start is ignored.\n        endValue: null,         // End value. If endValue specified, end is ignored.\n        minSpan: null,          // 0 ~ 100\n        maxSpan: null,          // 0 ~ 100\n        minValueSpan: null,     // The range of dataZoom can not be smaller than that.\n        maxValueSpan: null,     // The range of dataZoom can not be larger than that.\n        rangeMode: null         // Array, can be 'value' or 'percent'.\n    },\n\n    /**\n     * @override\n     */\n    init: function (option, parentModel, ecModel) {\n\n        /**\n         * key like x_0, y_1\n         * @private\n         * @type {Object}\n         */\n        this._dataIntervalByAxis = {};\n\n        /**\n         * @private\n         */\n        this._dataInfo = {};\n\n        /**\n         * key like x_0, y_1\n         * @private\n         */\n        this._axisProxies = {};\n\n        /**\n         * @readOnly\n         */\n        this.textStyleModel;\n\n        /**\n         * @private\n         */\n        this._autoThrottle = true;\n\n        /**\n         * 'percent' or 'value'\n         * @private\n         */\n        this._rangePropMode = ['percent', 'percent'];\n\n        var rawOption = retrieveRaw(option);\n\n        this.mergeDefaultAndTheme(option, ecModel);\n\n        this.doInit(rawOption);\n    },\n\n    /**\n     * @override\n     */\n    mergeOption: function (newOption) {\n        var rawOption = retrieveRaw(newOption);\n\n        //FIX #2591\n        merge(this.option, newOption, true);\n\n        this.doInit(rawOption);\n    },\n\n    /**\n     * @protected\n     */\n    doInit: function (rawOption) {\n        var thisOption = this.option;\n\n        // Disable realtime view update if canvas is not supported.\n        if (!env$1.canvasSupported) {\n            thisOption.realtime = false;\n        }\n\n        this._setDefaultThrottle(rawOption);\n\n        updateRangeUse(this, rawOption);\n\n        each$24([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n            // start/end has higher priority over startValue/endValue if they\n            // both set, but we should make chart.setOption({endValue: 1000})\n            // effective, rather than chart.setOption({endValue: 1000, end: null}).\n            if (this._rangePropMode[index] === 'value') {\n                thisOption[names[0]] = null;\n            }\n            // Otherwise do nothing and use the merge result.\n        }, this);\n\n        this.textStyleModel = this.getModel('textStyle');\n\n        this._resetTarget();\n\n        this._giveAxisProxies();\n    },\n\n    /**\n     * @private\n     */\n    _giveAxisProxies: function () {\n        var axisProxies = this._axisProxies;\n\n        this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {\n            var axisModel = this.dependentModels[dimNames.axis][axisIndex];\n\n            // If exists, share axisProxy with other dataZoomModels.\n            var axisProxy = axisModel.__dzAxisProxy || (\n                // Use the first dataZoomModel as the main model of axisProxy.\n                axisModel.__dzAxisProxy = new AxisProxy(\n                    dimNames.name, axisIndex, this, ecModel\n                )\n            );\n            // FIXME\n            // dispose __dzAxisProxy\n\n            axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;\n        }, this);\n    },\n\n    /**\n     * @private\n     */\n    _resetTarget: function () {\n        var thisOption = this.option;\n\n        var autoMode = this._judgeAutoMode();\n\n        eachAxisDim(function (dimNames) {\n            var axisIndexName = dimNames.axisIndex;\n            thisOption[axisIndexName] = normalizeToArray(\n                thisOption[axisIndexName]\n            );\n        }, this);\n\n        if (autoMode === 'axisIndex') {\n            this._autoSetAxisIndex();\n        }\n        else if (autoMode === 'orient') {\n            this._autoSetOrient();\n        }\n    },\n\n    /**\n     * @private\n     */\n    _judgeAutoMode: function () {\n        // Auto set only works for setOption at the first time.\n        // The following is user's reponsibility. So using merged\n        // option is OK.\n        var thisOption = this.option;\n\n        var hasIndexSpecified = false;\n        eachAxisDim(function (dimNames) {\n            // When user set axisIndex as a empty array, we think that user specify axisIndex\n            // but do not want use auto mode. Because empty array may be encountered when\n            // some error occured.\n            if (thisOption[dimNames.axisIndex] != null) {\n                hasIndexSpecified = true;\n            }\n        }, this);\n\n        var orient = thisOption.orient;\n\n        if (orient == null && hasIndexSpecified) {\n            return 'orient';\n        }\n        else if (!hasIndexSpecified) {\n            if (orient == null) {\n                thisOption.orient = 'horizontal';\n            }\n            return 'axisIndex';\n        }\n    },\n\n    /**\n     * @private\n     */\n    _autoSetAxisIndex: function () {\n        var autoAxisIndex = true;\n        var orient = this.get('orient', true);\n        var thisOption = this.option;\n        var dependentModels = this.dependentModels;\n\n        if (autoAxisIndex) {\n            // Find axis that parallel to dataZoom as default.\n            var dimName = orient === 'vertical' ? 'y' : 'x';\n\n            if (dependentModels[dimName + 'Axis'].length) {\n                thisOption[dimName + 'AxisIndex'] = [0];\n                autoAxisIndex = false;\n            }\n            else {\n                each$24(dependentModels.singleAxis, function (singleAxisModel) {\n                    if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) {\n                        thisOption.singleAxisIndex = [singleAxisModel.componentIndex];\n                        autoAxisIndex = false;\n                    }\n                });\n            }\n        }\n\n        if (autoAxisIndex) {\n            // Find the first category axis as default. (consider polar)\n            eachAxisDim(function (dimNames) {\n                if (!autoAxisIndex) {\n                    return;\n                }\n                var axisIndices = [];\n                var axisModels = this.dependentModels[dimNames.axis];\n                if (axisModels.length && !axisIndices.length) {\n                    for (var i = 0, len = axisModels.length; i < len; i++) {\n                        if (axisModels[i].get('type') === 'category') {\n                            axisIndices.push(i);\n                        }\n                    }\n                }\n                thisOption[dimNames.axisIndex] = axisIndices;\n                if (axisIndices.length) {\n                    autoAxisIndex = false;\n                }\n            }, this);\n        }\n\n        if (autoAxisIndex) {\n            // FIXME\n            // ec2xAxisIndexyAxisIndexscatterdataZoom\n            // Grid.js#getScaleByOptiontimelogaxis type\n\n            // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,\n            // dataZoom component auto adopts series that reference to\n            // both xAxis and yAxis which type is 'value'.\n            this.ecModel.eachSeries(function (seriesModel) {\n                if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {\n                    eachAxisDim(function (dimNames) {\n                        var axisIndices = thisOption[dimNames.axisIndex];\n\n                        var axisIndex = seriesModel.get(dimNames.axisIndex);\n                        var axisId = seriesModel.get(dimNames.axisId);\n\n                        var axisModel = seriesModel.ecModel.queryComponents({\n                            mainType: dimNames.axis,\n                            index: axisIndex,\n                            id: axisId\n                        })[0];\n\n                        if (__DEV__) {\n                            if (!axisModel) {\n                                throw new Error(\n                                    dimNames.axis + ' \"' + retrieve(\n                                        axisIndex,\n                                        axisId,\n                                        0\n                                    ) + '\" not found'\n                                );\n                            }\n                        }\n                        axisIndex = axisModel.componentIndex;\n\n                        if (indexOf(axisIndices, axisIndex) < 0) {\n                            axisIndices.push(axisIndex);\n                        }\n                    });\n                }\n            }, this);\n        }\n    },\n\n    /**\n     * @private\n     */\n    _autoSetOrient: function () {\n        var dim;\n\n        // Find the first axis\n        this.eachTargetAxis(function (dimNames) {\n            !dim && (dim = dimNames.name);\n        }, this);\n\n        this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';\n    },\n\n    /**\n     * @private\n     */\n    _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {\n        // FIXME\n        // seriesxAxisIndexyAxisIndex\n        // series.type === scatter\n\n        var is = true;\n        eachAxisDim(function (dimNames) {\n            var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);\n            var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];\n\n            if (!axisModel || axisModel.get('type') !== axisType) {\n                is = false;\n            }\n        }, this);\n        return is;\n    },\n\n    /**\n     * @private\n     */\n    _setDefaultThrottle: function (rawOption) {\n        // When first time user set throttle, auto throttle ends.\n        if (rawOption.hasOwnProperty('throttle')) {\n            this._autoThrottle = false;\n        }\n        if (this._autoThrottle) {\n            var globalOption = this.ecModel.option;\n            this.option.throttle =\n                (globalOption.animation && globalOption.animationDurationUpdate > 0)\n                ? 100 : 20;\n        }\n    },\n\n    /**\n     * @public\n     */\n    getFirstTargetAxisModel: function () {\n        var firstAxisModel;\n        eachAxisDim(function (dimNames) {\n            if (firstAxisModel == null) {\n                var indices = this.get(dimNames.axisIndex);\n                if (indices.length) {\n                    firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];\n                }\n            }\n        }, this);\n\n        return firstAxisModel;\n    },\n\n    /**\n     * @public\n     * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\n     */\n    eachTargetAxis: function (callback, context) {\n        var ecModel = this.ecModel;\n        eachAxisDim(function (dimNames) {\n            each$24(\n                this.get(dimNames.axisIndex),\n                function (axisIndex) {\n                    callback.call(context, dimNames, axisIndex, this, ecModel);\n                },\n                this\n            );\n        }, this);\n    },\n\n    /**\n     * @param {string} dimName\n     * @param {number} axisIndex\n     * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.\n     */\n    getAxisProxy: function (dimName, axisIndex) {\n        return this._axisProxies[dimName + '_' + axisIndex];\n    },\n\n    /**\n     * @param {string} dimName\n     * @param {number} axisIndex\n     * @return {module:echarts/model/Model} If not found, return null/undefined.\n     */\n    getAxisModel: function (dimName, axisIndex) {\n        var axisProxy = this.getAxisProxy(dimName, axisIndex);\n        return axisProxy && axisProxy.getAxisModel();\n    },\n\n    /**\n     * If not specified, set to undefined.\n     *\n     * @public\n     * @param {Object} opt\n     * @param {number} [opt.start]\n     * @param {number} [opt.end]\n     * @param {number} [opt.startValue]\n     * @param {number} [opt.endValue]\n     * @param {boolean} [ignoreUpdateRangeUsg=false]\n     */\n    setRawRange: function (opt, ignoreUpdateRangeUsg) {\n        var option = this.option;\n        each$24([['start', 'startValue'], ['end', 'endValue']], function (names) {\n            // If only one of 'start' and 'startValue' is not null/undefined, the other\n            // should be cleared, which enable clear the option.\n            // If both of them are not set, keep option with the original value, which\n            // enable use only set start but not set end when calling `dispatchAction`.\n            // The same as 'end' and 'endValue'.\n            if (opt[names[0]] != null || opt[names[1]] != null) {\n                option[names[0]] = opt[names[0]];\n                option[names[1]] = opt[names[1]];\n            }\n        }, this);\n\n        !ignoreUpdateRangeUsg && updateRangeUse(this, opt);\n    },\n\n    /**\n     * @public\n     * @return {Array.<number>} [startPercent, endPercent]\n     */\n    getPercentRange: function () {\n        var axisProxy = this.findRepresentativeAxisProxy();\n        if (axisProxy) {\n            return axisProxy.getDataPercentWindow();\n        }\n    },\n\n    /**\n     * @public\n     * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\n     *\n     * @param {string} [axisDimName]\n     * @param {number} [axisIndex]\n     * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.\n     */\n    getValueRange: function (axisDimName, axisIndex) {\n        if (axisDimName == null && axisIndex == null) {\n            var axisProxy = this.findRepresentativeAxisProxy();\n            if (axisProxy) {\n                return axisProxy.getDataValueWindow();\n            }\n        }\n        else {\n            return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();\n        }\n    },\n\n    /**\n     * @public\n     * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy\n     *      corresponding to the axisModel\n     * @return {module:echarts/component/dataZoom/AxisProxy}\n     */\n    findRepresentativeAxisProxy: function (axisModel) {\n        if (axisModel) {\n            return axisModel.__dzAxisProxy;\n        }\n\n        // Find the first hosted axisProxy\n        var axisProxies = this._axisProxies;\n        for (var key in axisProxies) {\n            if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {\n                return axisProxies[key];\n            }\n        }\n\n        // If no hosted axis find not hosted axisProxy.\n        // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,\n        // and the option.start or option.end settings are different. The percentRange\n        // should follow axisProxy.\n        // (We encounter this problem in toolbox data zoom.)\n        for (var key in axisProxies) {\n            if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {\n                return axisProxies[key];\n            }\n        }\n    },\n\n    /**\n     * @return {Array.<string>}\n     */\n    getRangePropMode: function () {\n        return this._rangePropMode.slice();\n    }\n\n});\n\nfunction retrieveRaw(option) {\n    var ret = {};\n    each$24(\n        ['start', 'end', 'startValue', 'endValue', 'throttle'],\n        function (name) {\n            option.hasOwnProperty(name) && (ret[name] = option[name]);\n        }\n    );\n    return ret;\n}\n\nfunction updateRangeUse(dataZoomModel, rawOption) {\n    var rangePropMode = dataZoomModel._rangePropMode;\n    var rangeModeInOption = dataZoomModel.get('rangeMode');\n\n    each$24([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n        var percentSpecified = rawOption[names[0]] != null;\n        var valueSpecified = rawOption[names[1]] != null;\n        if (percentSpecified && !valueSpecified) {\n            rangePropMode[index] = 'percent';\n        }\n        else if (!percentSpecified && valueSpecified) {\n            rangePropMode[index] = 'value';\n        }\n        else if (rangeModeInOption) {\n            rangePropMode[index] = rangeModeInOption[index];\n        }\n        else if (percentSpecified) { // percentSpecified && valueSpecified\n            rangePropMode[index] = 'percent';\n        }\n        // else remain its original setting.\n    });\n}\n\nvar DataZoomView = Component.extend({\n\n    type: 'dataZoom',\n\n    render: function (dataZoomModel, ecModel, api, payload) {\n        this.dataZoomModel = dataZoomModel;\n        this.ecModel = ecModel;\n        this.api = api;\n    },\n\n    /**\n     * Find the first target coordinate system.\n     *\n     * @protected\n     * @return {Object} {\n     *                   grid: [\n     *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},\n     *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},\n     *                       ...\n     *                   ],  // cartesians must not be null/undefined.\n     *                   polar: [\n     *                       {model: coord0, axisModels: [axis4], coordIndex: 0},\n     *                       ...\n     *                   ],  // polars must not be null/undefined.\n     *                   singleAxis: [\n     *                       {model: coord0, axisModels: [], coordIndex: 0}\n     *                   ]\n     */\n    getTargetCoordInfo: function () {\n        var dataZoomModel = this.dataZoomModel;\n        var ecModel = this.ecModel;\n        var coordSysLists = {};\n\n        dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n            var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);\n            if (axisModel) {\n                var coordModel = axisModel.getCoordSysModel();\n                coordModel && save(\n                    coordModel,\n                    axisModel,\n                    coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []),\n                    coordModel.componentIndex\n                );\n            }\n        }, this);\n\n        function save(coordModel, axisModel, store, coordIndex) {\n            var item;\n            for (var i = 0; i < store.length; i++) {\n                if (store[i].model === coordModel) {\n                    item = store[i];\n                    break;\n                }\n            }\n            if (!item) {\n                store.push(item = {\n                    model: coordModel, axisModels: [], coordIndex: coordIndex\n                });\n            }\n            item.axisModels.push(axisModel);\n        }\n\n        return coordSysLists;\n    }\n\n});\n\nvar SliderZoomModel = DataZoomModel.extend({\n\n    type: 'dataZoom.slider',\n\n    layoutMode: 'box',\n\n    /**\n     * @protected\n     */\n    defaultOption: {\n        show: true,\n\n        // ph => placeholder. Using placehoder here because\n        // deault value can only be drived in view stage.\n        right: 'ph',  // Default align to grid rect.\n        top: 'ph',    // Default align to grid rect.\n        width: 'ph',  // Default align to grid rect.\n        height: 'ph', // Default align to grid rect.\n        left: null,   // Default align to grid rect.\n        bottom: null, // Default align to grid rect.\n\n        backgroundColor: 'rgba(47,69,84,0)',    // Background of slider zoom component.\n        // dataBackgroundColor: '#ddd',         // Background coor of data shadow and border of box,\n                                                // highest priority, remain for compatibility of\n                                                // previous version, but not recommended any more.\n        dataBackground: {\n            lineStyle: {\n                color: '#2f4554',\n                width: 0.5,\n                opacity: 0.3\n            },\n            areaStyle: {\n                color: 'rgba(47,69,84,0.3)',\n                opacity: 0.3\n            }\n        },\n        borderColor: '#ddd',                    // border color of the box. For compatibility,\n                                                // if dataBackgroundColor is set, borderColor\n                                                // is ignored.\n\n        fillerColor: 'rgba(167,183,204,0.4)',     // Color of selected area.\n        // handleColor: 'rgba(89,170,216,0.95)',     // Color of handle.\n        // handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z',\n        handleIcon: 'M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z',\n        // Percent of the slider height\n        handleSize: '100%',\n\n        handleStyle: {\n            color: '#a7b7cc'\n        },\n\n        labelPrecision: null,\n        labelFormatter: null,\n        showDetail: true,\n        showDataShadow: 'auto',                 // Default auto decision.\n        realtime: true,\n        zoomLock: false,                        // Whether disable zoom.\n        textStyle: {\n            color: '#333'\n        }\n    }\n\n});\n\nvar Rect$2 = Rect;\nvar linearMap$2 = linearMap;\nvar asc$2 = asc;\nvar bind$4 = bind;\nvar each$26 = each$1;\n\n// Constants\nvar DEFAULT_LOCATION_EDGE_GAP = 7;\nvar DEFAULT_FRAME_BORDER_WIDTH = 1;\nvar DEFAULT_FILLER_SIZE = 30;\nvar HORIZONTAL = 'horizontal';\nvar VERTICAL = 'vertical';\nvar LABEL_GAP = 5;\nvar SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];\n\nvar SliderZoomView = DataZoomView.extend({\n\n    type: 'dataZoom.slider',\n\n    init: function (ecModel, api) {\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._displayables = {};\n\n        /**\n         * @private\n         * @type {string}\n         */\n        this._orient;\n\n        /**\n         * [0, 100]\n         * @private\n         */\n        this._range;\n\n        /**\n         * [coord of the first handle, coord of the second handle]\n         * @private\n         */\n        this._handleEnds;\n\n        /**\n         * [length, thick]\n         * @private\n         * @type {Array.<number>}\n         */\n        this._size;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._handleWidth;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._handleHeight;\n\n        /**\n         * @private\n         */\n        this._location;\n\n        /**\n         * @private\n         */\n        this._dragging;\n\n        /**\n         * @private\n         */\n        this._dataShadowInfo;\n\n        this.api = api;\n    },\n\n    /**\n     * @override\n     */\n    render: function (dataZoomModel, ecModel, api, payload) {\n        SliderZoomView.superApply(this, 'render', arguments);\n\n        createOrUpdate(\n            this,\n            '_dispatchZoomAction',\n            this.dataZoomModel.get('throttle'),\n            'fixRate'\n        );\n\n        this._orient = dataZoomModel.get('orient');\n\n        if (this.dataZoomModel.get('show') === false) {\n            this.group.removeAll();\n            return;\n        }\n\n        // Notice: this._resetInterval() should not be executed when payload.type\n        // is 'dataZoom', origin this._range should be maintained, otherwise 'pan'\n        // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,\n        if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {\n            this._buildView();\n        }\n\n        this._updateView();\n    },\n\n    /**\n     * @override\n     */\n    remove: function () {\n        SliderZoomView.superApply(this, 'remove', arguments);\n        clear(this, '_dispatchZoomAction');\n    },\n\n    /**\n     * @override\n     */\n    dispose: function () {\n        SliderZoomView.superApply(this, 'dispose', arguments);\n        clear(this, '_dispatchZoomAction');\n    },\n\n    _buildView: function () {\n        var thisGroup = this.group;\n\n        thisGroup.removeAll();\n\n        this._resetLocation();\n        this._resetInterval();\n\n        var barGroup = this._displayables.barGroup = new Group();\n\n        this._renderBackground();\n\n        this._renderHandle();\n\n        this._renderDataShadow();\n\n        thisGroup.add(barGroup);\n\n        this._positionGroup();\n    },\n\n    /**\n     * @private\n     */\n    _resetLocation: function () {\n        var dataZoomModel = this.dataZoomModel;\n        var api = this.api;\n\n        // If some of x/y/width/height are not specified,\n        // auto-adapt according to target grid.\n        var coordRect = this._findCoordRect();\n        var ecSize = {width: api.getWidth(), height: api.getHeight()};\n        // Default align by coordinate system rect.\n        var positionInfo = this._orient === HORIZONTAL\n            ? {\n                // Why using 'right', because right should be used in vertical,\n                // and it is better to be consistent for dealing with position param merge.\n                right: ecSize.width - coordRect.x - coordRect.width,\n                top: (ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP),\n                width: coordRect.width,\n                height: DEFAULT_FILLER_SIZE\n            }\n            : { // vertical\n                right: DEFAULT_LOCATION_EDGE_GAP,\n                top: coordRect.y,\n                width: DEFAULT_FILLER_SIZE,\n                height: coordRect.height\n            };\n\n        // Do not write back to option and replace value 'ph', because\n        // the 'ph' value should be recalculated when resize.\n        var layoutParams = getLayoutParams(dataZoomModel.option);\n\n        // Replace the placeholder value.\n        each$1(['right', 'top', 'width', 'height'], function (name) {\n            if (layoutParams[name] === 'ph') {\n                layoutParams[name] = positionInfo[name];\n            }\n        });\n\n        var layoutRect = getLayoutRect(\n            layoutParams,\n            ecSize,\n            dataZoomModel.padding\n        );\n\n        this._location = {x: layoutRect.x, y: layoutRect.y};\n        this._size = [layoutRect.width, layoutRect.height];\n        this._orient === VERTICAL && this._size.reverse();\n    },\n\n    /**\n     * @private\n     */\n    _positionGroup: function () {\n        var thisGroup = this.group;\n        var location = this._location;\n        var orient = this._orient;\n\n        // Just use the first axis to determine mapping.\n        var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();\n        var inverse = targetAxisModel && targetAxisModel.get('inverse');\n\n        var barGroup = this._displayables.barGroup;\n        var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;\n\n        // Transform barGroup.\n        barGroup.attr(\n            (orient === HORIZONTAL && !inverse)\n            ? {scale: otherAxisInverse ? [1, 1] : [1, -1]}\n            : (orient === HORIZONTAL && inverse)\n            ? {scale: otherAxisInverse ? [-1, 1] : [-1, -1]}\n            : (orient === VERTICAL && !inverse)\n            ? {scale: otherAxisInverse ? [1, -1] : [1, 1], rotation: Math.PI / 2}\n            // Dont use Math.PI, considering shadow direction.\n            : {scale: otherAxisInverse ? [-1, -1] : [-1, 1], rotation: Math.PI / 2}\n        );\n\n        // Position barGroup\n        var rect = thisGroup.getBoundingRect([barGroup]);\n        thisGroup.attr('position', [location.x - rect.x, location.y - rect.y]);\n    },\n\n    /**\n     * @private\n     */\n    _getViewExtent: function () {\n        return [0, this._size[0]];\n    },\n\n    _renderBackground: function () {\n        var dataZoomModel = this.dataZoomModel;\n        var size = this._size;\n        var barGroup = this._displayables.barGroup;\n\n        barGroup.add(new Rect$2({\n            silent: true,\n            shape: {\n                x: 0, y: 0, width: size[0], height: size[1]\n            },\n            style: {\n                fill: dataZoomModel.get('backgroundColor')\n            },\n            z2: -40\n        }));\n\n        // Click panel, over shadow, below handles.\n        barGroup.add(new Rect$2({\n            shape: {\n                x: 0, y: 0, width: size[0], height: size[1]\n            },\n            style: {\n                fill: 'transparent'\n            },\n            z2: 0,\n            onclick: bind(this._onClickPanelClick, this)\n        }));\n    },\n\n    _renderDataShadow: function () {\n        var info = this._dataShadowInfo = this._prepareDataShadowInfo();\n\n        if (!info) {\n            return;\n        }\n\n        var size = this._size;\n        var seriesModel = info.series;\n        var data = seriesModel.getRawData();\n        var otherDim = seriesModel.getShadowDim\n            ? seriesModel.getShadowDim() // @see candlestick\n            : info.otherDim;\n\n        if (otherDim == null) {\n            return;\n        }\n\n        var otherDataExtent = data.getDataExtent(otherDim);\n        // Nice extent.\n        var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;\n        otherDataExtent = [\n            otherDataExtent[0] - otherOffset,\n            otherDataExtent[1] + otherOffset\n        ];\n        var otherShadowExtent = [0, size[1]];\n\n        var thisShadowExtent = [0, size[0]];\n\n        var areaPoints = [[size[0], 0], [0, 0]];\n        var linePoints = [];\n        var step = thisShadowExtent[1] / (data.count() - 1);\n        var thisCoord = 0;\n\n        // Optimize for large data shadow\n        var stride = Math.round(data.count() / size[0]);\n        var lastIsEmpty;\n        data.each([otherDim], function (value, index) {\n            if (stride > 0 && (index % stride)) {\n                thisCoord += step;\n                return;\n            }\n\n            // FIXME\n            // Should consider axis.min/axis.max when drawing dataShadow.\n\n            // FIXME\n            // list\n            var isEmpty = value == null || isNaN(value) || value === '';\n            // See #4235.\n            var otherCoord = isEmpty\n                ? 0 : linearMap$2(value, otherDataExtent, otherShadowExtent, true);\n\n            // Attempt to draw data shadow precisely when there are empty value.\n            if (isEmpty && !lastIsEmpty && index) {\n                areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);\n                linePoints.push([linePoints[linePoints.length - 1][0], 0]);\n            }\n            else if (!isEmpty && lastIsEmpty) {\n                areaPoints.push([thisCoord, 0]);\n                linePoints.push([thisCoord, 0]);\n            }\n\n            areaPoints.push([thisCoord, otherCoord]);\n            linePoints.push([thisCoord, otherCoord]);\n\n            thisCoord += step;\n            lastIsEmpty = isEmpty;\n        });\n\n        var dataZoomModel = this.dataZoomModel;\n        // var dataBackgroundModel = dataZoomModel.getModel('dataBackground');\n        this._displayables.barGroup.add(new Polygon({\n            shape: {points: areaPoints},\n            style: defaults(\n                {fill: dataZoomModel.get('dataBackgroundColor')},\n                dataZoomModel.getModel('dataBackground.areaStyle').getAreaStyle()\n            ),\n            silent: true,\n            z2: -20\n        }));\n        this._displayables.barGroup.add(new Polyline({\n            shape: {points: linePoints},\n            style: dataZoomModel.getModel('dataBackground.lineStyle').getLineStyle(),\n            silent: true,\n            z2: -19\n        }));\n    },\n\n    _prepareDataShadowInfo: function () {\n        var dataZoomModel = this.dataZoomModel;\n        var showDataShadow = dataZoomModel.get('showDataShadow');\n\n        if (showDataShadow === false) {\n            return;\n        }\n\n        // Find a representative series.\n        var result;\n        var ecModel = this.ecModel;\n\n        dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n            var seriesModels = dataZoomModel\n                .getAxisProxy(dimNames.name, axisIndex)\n                .getTargetSeriesModels();\n\n            each$1(seriesModels, function (seriesModel) {\n                if (result) {\n                    return;\n                }\n\n                if (showDataShadow !== true && indexOf(\n                        SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')\n                    ) < 0\n                ) {\n                    return;\n                }\n\n                var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;\n                var otherDim = getOtherDim(dimNames.name);\n                var otherAxisInverse;\n                var coordSys = seriesModel.coordinateSystem;\n                if (otherDim != null && coordSys.getOtherAxis) {\n                    otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;\n                }\n\n                result = {\n                    thisAxis: thisAxis,\n                    series: seriesModel,\n                    thisDim: dimNames.name,\n                    otherDim: otherDim,\n                    otherAxisInverse: otherAxisInverse\n                };\n\n            }, this);\n\n        }, this);\n\n        return result;\n    },\n\n    _renderHandle: function () {\n        var displaybles = this._displayables;\n        var handles = displaybles.handles = [];\n        var handleLabels = displaybles.handleLabels = [];\n        var barGroup = this._displayables.barGroup;\n        var size = this._size;\n        var dataZoomModel = this.dataZoomModel;\n\n        barGroup.add(displaybles.filler = new Rect$2({\n            draggable: true,\n            cursor: getCursor(this._orient),\n            drift: bind$4(this._onDragMove, this, 'all'),\n            onmousemove: function (e) {\n                // Fot mobile devicem, prevent screen slider on the button.\n                stop(e.event);\n            },\n            ondragstart: bind$4(this._showDataInfo, this, true),\n            ondragend: bind$4(this._onDragEnd, this),\n            onmouseover: bind$4(this._showDataInfo, this, true),\n            onmouseout: bind$4(this._showDataInfo, this, false),\n            style: {\n                fill: dataZoomModel.get('fillerColor'),\n                textPosition : 'inside'\n            }\n        }));\n\n        // Frame border.\n        barGroup.add(new Rect$2(subPixelOptimizeRect({\n            silent: true,\n            shape: {\n                x: 0,\n                y: 0,\n                width: size[0],\n                height: size[1]\n            },\n            style: {\n                stroke: dataZoomModel.get('dataBackgroundColor')\n                    || dataZoomModel.get('borderColor'),\n                lineWidth: DEFAULT_FRAME_BORDER_WIDTH,\n                fill: 'rgba(0,0,0,0)'\n            }\n        })));\n\n        each$26([0, 1], function (handleIndex) {\n            var path = createIcon(\n                dataZoomModel.get('handleIcon'),\n                {\n                    cursor: getCursor(this._orient),\n                    draggable: true,\n                    drift: bind$4(this._onDragMove, this, handleIndex),\n                    onmousemove: function (e) {\n                        // Fot mobile devicem, prevent screen slider on the button.\n                        stop(e.event);\n                    },\n                    ondragend: bind$4(this._onDragEnd, this),\n                    onmouseover: bind$4(this._showDataInfo, this, true),\n                    onmouseout: bind$4(this._showDataInfo, this, false)\n                },\n                {x: -1, y: 0, width: 2, height: 2}\n            );\n\n            var bRect = path.getBoundingRect();\n            this._handleHeight = parsePercent$1(dataZoomModel.get('handleSize'), this._size[1]);\n            this._handleWidth = bRect.width / bRect.height * this._handleHeight;\n\n            path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());\n            var handleColor = dataZoomModel.get('handleColor');\n            // Compatitable with previous version\n            if (handleColor != null) {\n                path.style.fill = handleColor;\n            }\n\n            barGroup.add(handles[handleIndex] = path);\n\n            var textStyleModel = dataZoomModel.textStyleModel;\n\n            this.group.add(\n                handleLabels[handleIndex] = new Text({\n                silent: true,\n                invisible: true,\n                style: {\n                    x: 0, y: 0, text: '',\n                    textVerticalAlign: 'middle',\n                    textAlign: 'center',\n                    textFill: textStyleModel.getTextColor(),\n                    textFont: textStyleModel.getFont()\n                },\n                z2: 10\n            }));\n\n        }, this);\n    },\n\n    /**\n     * @private\n     */\n    _resetInterval: function () {\n        var range = this._range = this.dataZoomModel.getPercentRange();\n        var viewExtent = this._getViewExtent();\n\n        this._handleEnds = [\n            linearMap$2(range[0], [0, 100], viewExtent, true),\n            linearMap$2(range[1], [0, 100], viewExtent, true)\n        ];\n    },\n\n    /**\n     * @private\n     * @param {(number|string)} handleIndex 0 or 1 or 'all'\n     * @param {number} delta\n     */\n    _updateInterval: function (handleIndex, delta) {\n        var dataZoomModel = this.dataZoomModel;\n        var handleEnds = this._handleEnds;\n        var viewExtend = this._getViewExtent();\n        var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n        var percentExtent = [0, 100];\n\n        sliderMove(\n            delta,\n            handleEnds,\n            viewExtend,\n            dataZoomModel.get('zoomLock') ? 'all' : handleIndex,\n            minMaxSpan.minSpan != null\n                ? linearMap$2(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null,\n            minMaxSpan.maxSpan != null\n                ? linearMap$2(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null\n        );\n\n        this._range = asc$2([\n            linearMap$2(handleEnds[0], viewExtend, percentExtent, true),\n            linearMap$2(handleEnds[1], viewExtend, percentExtent, true)\n        ]);\n    },\n\n    /**\n     * @private\n     */\n    _updateView: function (nonRealtime) {\n        var displaybles = this._displayables;\n        var handleEnds = this._handleEnds;\n        var handleInterval = asc$2(handleEnds.slice());\n        var size = this._size;\n\n        each$26([0, 1], function (handleIndex) {\n            // Handles\n            var handle = displaybles.handles[handleIndex];\n            var handleHeight = this._handleHeight;\n            handle.attr({\n                scale: [handleHeight / 2, handleHeight / 2],\n                position: [handleEnds[handleIndex], size[1] / 2 - handleHeight / 2]\n            });\n        }, this);\n\n        // Filler\n        displaybles.filler.setShape({\n            x: handleInterval[0],\n            y: 0,\n            width: handleInterval[1] - handleInterval[0],\n            height: size[1]\n        });\n\n        this._updateDataInfo(nonRealtime);\n    },\n\n    /**\n     * @private\n     */\n    _updateDataInfo: function (nonRealtime) {\n        var dataZoomModel = this.dataZoomModel;\n        var displaybles = this._displayables;\n        var handleLabels = displaybles.handleLabels;\n        var orient = this._orient;\n        var labelTexts = ['', ''];\n\n        // FIXME\n        // dateformatterautoformatterec2 date.getAutoFormatter\n        if (dataZoomModel.get('showDetail')) {\n            var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n\n            if (axisProxy) {\n                var axis = axisProxy.getAxisModel().axis;\n                var range = this._range;\n\n                var dataInterval = nonRealtime\n                    // See #4434, data and axis are not processed and reset yet in non-realtime mode.\n                    ? axisProxy.calculateDataWindow({\n                        start: range[0], end: range[1]\n                    }).valueWindow\n                    : axisProxy.getDataValueWindow();\n\n                labelTexts = [\n                    this._formatLabel(dataInterval[0], axis),\n                    this._formatLabel(dataInterval[1], axis)\n                ];\n            }\n        }\n\n        var orderedHandleEnds = asc$2(this._handleEnds.slice());\n\n        setLabel.call(this, 0);\n        setLabel.call(this, 1);\n\n        function setLabel(handleIndex) {\n            // Label\n            // Text should not transform by barGroup.\n            // Ignore handlers transform\n            var barTransform = getTransform(\n                displaybles.handles[handleIndex].parent, this.group\n            );\n            var direction = transformDirection(\n                handleIndex === 0 ? 'right' : 'left', barTransform\n            );\n            var offset = this._handleWidth / 2 + LABEL_GAP;\n            var textPoint = applyTransform$1(\n                [\n                    orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset),\n                    this._size[1] / 2\n                ],\n                barTransform\n            );\n            handleLabels[handleIndex].setStyle({\n                x: textPoint[0],\n                y: textPoint[1],\n                textVerticalAlign: orient === HORIZONTAL ? 'middle' : direction,\n                textAlign: orient === HORIZONTAL ? direction : 'center',\n                text: labelTexts[handleIndex]\n            });\n        }\n    },\n\n    /**\n     * @private\n     */\n    _formatLabel: function (value, axis) {\n        var dataZoomModel = this.dataZoomModel;\n        var labelFormatter = dataZoomModel.get('labelFormatter');\n\n        var labelPrecision = dataZoomModel.get('labelPrecision');\n        if (labelPrecision == null || labelPrecision === 'auto') {\n            labelPrecision = axis.getPixelPrecision();\n        }\n\n        var valueStr = (value == null || isNaN(value))\n            ? ''\n            // FIXME Glue code\n            : (axis.type === 'category' || axis.type === 'time')\n                ? axis.scale.getLabel(Math.round(value))\n                // param of toFixed should less then 20.\n                : value.toFixed(Math.min(labelPrecision, 20));\n\n        return isFunction(labelFormatter)\n            ? labelFormatter(value, valueStr)\n            : isString(labelFormatter)\n            ? labelFormatter.replace('{value}', valueStr)\n            : valueStr;\n    },\n\n    /**\n     * @private\n     * @param {boolean} showOrHide true: show, false: hide\n     */\n    _showDataInfo: function (showOrHide) {\n        // Always show when drgging.\n        showOrHide = this._dragging || showOrHide;\n\n        var handleLabels = this._displayables.handleLabels;\n        handleLabels[0].attr('invisible', !showOrHide);\n        handleLabels[1].attr('invisible', !showOrHide);\n    },\n\n    _onDragMove: function (handleIndex, dx, dy) {\n        this._dragging = true;\n\n        // Transform dx, dy to bar coordination.\n        var barTransform = this._displayables.barGroup.getLocalTransform();\n        var vertex = applyTransform$1([dx, dy], barTransform, true);\n\n        this._updateInterval(handleIndex, vertex[0]);\n\n        var realtime = this.dataZoomModel.get('realtime');\n\n        this._updateView(!realtime);\n\n        if (realtime) {\n            realtime && this._dispatchZoomAction();\n        }\n    },\n\n    _onDragEnd: function () {\n        this._dragging = false;\n        this._showDataInfo(false);\n        this._dispatchZoomAction();\n    },\n\n    _onClickPanelClick: function (e) {\n        var size = this._size;\n        var localPoint = this._displayables.barGroup.transformCoordToLocal(e.offsetX, e.offsetY);\n\n        if (localPoint[0] < 0 || localPoint[0] > size[0]\n            || localPoint[1] < 0 || localPoint[1] > size[1]\n        ) {\n            return;\n        }\n\n        var handleEnds = this._handleEnds;\n        var center = (handleEnds[0] + handleEnds[1]) / 2;\n\n        this._updateInterval('all', localPoint[0] - center);\n        this._updateView();\n        this._dispatchZoomAction();\n    },\n\n    /**\n     * This action will be throttled.\n     * @private\n     */\n    _dispatchZoomAction: function () {\n        var range = this._range;\n\n        this.api.dispatchAction({\n            type: 'dataZoom',\n            from: this.uid,\n            dataZoomId: this.dataZoomModel.id,\n            start: range[0],\n            end: range[1]\n        });\n    },\n\n    /**\n     * @private\n     */\n    _findCoordRect: function () {\n        // Find the grid coresponding to the first axis referred by dataZoom.\n        var rect;\n        each$26(this.getTargetCoordInfo(), function (coordInfoList) {\n            if (!rect && coordInfoList.length) {\n                var coordSys = coordInfoList[0].model.coordinateSystem;\n                rect = coordSys.getRect && coordSys.getRect();\n            }\n        });\n        if (!rect) {\n            var width = this.api.getWidth();\n            var height = this.api.getHeight();\n            rect = {\n                x: width * 0.2,\n                y: height * 0.2,\n                width: width * 0.6,\n                height: height * 0.6\n            };\n        }\n\n        return rect;\n    }\n\n});\n\nfunction getOtherDim(thisDim) {\n    // FIXME\n    // getOtherAxis\n    var map$$1 = {x: 'y', y: 'x', radius: 'angle', angle: 'radius'};\n    return map$$1[thisDim];\n}\n\nfunction getCursor(orient) {\n    return orient === 'vertical' ? 'ns-resize' : 'ew-resize';\n}\n\nDataZoomModel.extend({\n\n    type: 'dataZoom.inside',\n\n    /**\n     * @protected\n     */\n    defaultOption: {\n        disabled: false,   // Whether disable this inside zoom.\n        zoomLock: false,   // Whether disable zoom but only pan.\n        zoomOnMouseWheel: true, // Can be: true / false / 'shift' / 'ctrl' / 'alt'.\n        moveOnMouseMove: true,   // Can be: true / false / 'shift' / 'ctrl' / 'alt'.\n        preventDefaultMouseMove: true\n    }\n});\n\n// Only create one roam controller for each coordinate system.\n// one roam controller might be refered by two inside data zoom\n// components (for example, one for x and one for y). When user\n// pan or zoom, only dispatch one action for those data zoom\n// components.\n\nvar curry$6 = curry;\n\nvar ATTR$1 = '\\0_ec_dataZoom_roams';\n\n\n/**\n * @public\n * @param {module:echarts/ExtensionAPI} api\n * @param {Object} dataZoomInfo\n * @param {string} dataZoomInfo.coordId\n * @param {Function} dataZoomInfo.containsPoint\n * @param {Array.<string>} dataZoomInfo.allCoordIds\n * @param {string} dataZoomInfo.dataZoomId\n * @param {number} dataZoomInfo.throttleRate\n * @param {Function} dataZoomInfo.panGetRange\n * @param {Function} dataZoomInfo.zoomGetRange\n * @param {boolean} [dataZoomInfo.zoomLock]\n * @param {boolean} [dataZoomInfo.disabled]\n */\nfunction register$2(api, dataZoomInfo) {\n    var store = giveStore(api);\n    var theDataZoomId = dataZoomInfo.dataZoomId;\n    var theCoordId = dataZoomInfo.coordId;\n\n    // Do clean when a dataZoom changes its target coordnate system.\n    // Avoid memory leak, dispose all not-used-registered.\n    each$1(store, function (record, coordId) {\n        var dataZoomInfos = record.dataZoomInfos;\n        if (dataZoomInfos[theDataZoomId]\n            && indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0\n        ) {\n            delete dataZoomInfos[theDataZoomId];\n            record.count--;\n        }\n    });\n\n    cleanStore(store);\n\n    var record = store[theCoordId];\n    // Create if needed.\n    if (!record) {\n        record = store[theCoordId] = {\n            coordId: theCoordId,\n            dataZoomInfos: {},\n            count: 0\n        };\n        record.controller = createController(api, record);\n        record.dispatchAction = curry(dispatchAction$1, api);\n    }\n\n    // Update reference of dataZoom.\n    !(record.dataZoomInfos[theDataZoomId]) && record.count++;\n    record.dataZoomInfos[theDataZoomId] = dataZoomInfo;\n\n    var controllerParams = mergeControllerParams(record.dataZoomInfos);\n    record.controller.enable(controllerParams.controlType, controllerParams.opt);\n\n    // Consider resize, area should be always updated.\n    record.controller.setPointerChecker(dataZoomInfo.containsPoint);\n\n    // Update throttle.\n    createOrUpdate(\n        record,\n        'dispatchAction',\n        dataZoomInfo.throttleRate,\n        'fixRate'\n    );\n}\n\n/**\n * @public\n * @param {module:echarts/ExtensionAPI} api\n * @param {string} dataZoomId\n */\nfunction unregister$1(api, dataZoomId) {\n    var store = giveStore(api);\n\n    each$1(store, function (record) {\n        record.controller.dispose();\n        var dataZoomInfos = record.dataZoomInfos;\n        if (dataZoomInfos[dataZoomId]) {\n            delete dataZoomInfos[dataZoomId];\n            record.count--;\n        }\n    });\n\n    cleanStore(store);\n}\n\n/**\n * @public\n */\nfunction shouldRecordRange(payload, dataZoomId) {\n    if (payload && payload.type === 'dataZoom' && payload.batch) {\n        for (var i = 0, len = payload.batch.length; i < len; i++) {\n            if (payload.batch[i].dataZoomId === dataZoomId) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n/**\n * @public\n */\nfunction generateCoordId(coordModel) {\n    return coordModel.type + '\\0_' + coordModel.id;\n}\n\n/**\n * Key: coordId, value: {dataZoomInfos: [], count, controller}\n * @type {Array.<Object>}\n */\nfunction giveStore(api) {\n    // Mount store on zrender instance, so that we do not\n    // need to worry about dispose.\n    var zr = api.getZr();\n    return zr[ATTR$1] || (zr[ATTR$1] = {});\n}\n\nfunction createController(api, newRecord) {\n    var controller = new RoamController(api.getZr());\n    controller.on('pan', curry$6(onPan, newRecord));\n    controller.on('zoom', curry$6(onZoom, newRecord));\n\n    return controller;\n}\n\nfunction cleanStore(store) {\n    each$1(store, function (record, coordId) {\n        if (!record.count) {\n            record.controller.dispose();\n            delete store[coordId];\n        }\n    });\n}\n\nfunction onPan(record, dx, dy, oldX, oldY, newX, newY) {\n    wrapAndDispatch(record, function (info) {\n        return info.panGetRange(record.controller, dx, dy, oldX, oldY, newX, newY);\n    });\n}\n\nfunction onZoom(record, scale, mouseX, mouseY) {\n    wrapAndDispatch(record, function (info) {\n        return info.zoomGetRange(record.controller, scale, mouseX, mouseY);\n    });\n}\n\nfunction wrapAndDispatch(record, getRange) {\n    var batch = [];\n\n    each$1(record.dataZoomInfos, function (info) {\n        var range = getRange(info);\n        !info.disabled && range && batch.push({\n            dataZoomId: info.dataZoomId,\n            start: range[0],\n            end: range[1]\n        });\n    });\n\n    record.dispatchAction(batch);\n}\n\n/**\n * This action will be throttled.\n */\nfunction dispatchAction$1(api, batch) {\n    api.dispatchAction({\n        type: 'dataZoom',\n        batch: batch\n    });\n}\n\n/**\n * Merge roamController settings when multiple dataZooms share one roamController.\n */\nfunction mergeControllerParams(dataZoomInfos) {\n    var controlType;\n    var opt = {};\n    var typePriority = {\n        'true': 2,\n        'move': 1,\n        'false': 0,\n        'undefined': -1\n    };\n    each$1(dataZoomInfos, function (dataZoomInfo) {\n        var oneType = dataZoomInfo.disabled ? false : dataZoomInfo.zoomLock ? 'move' : true;\n        typePriority[oneType] > typePriority[controlType] && (controlType = oneType);\n        // Do not support that different 'shift'/'ctrl'/'alt' setting used in one coord sys.\n        extend(opt, dataZoomInfo.roamControllerOpt);\n    });\n\n    return {\n        controlType: controlType,\n        opt: opt\n    };\n}\n\nvar bind$5 = bind;\n\nvar InsideZoomView = DataZoomView.extend({\n\n    type: 'dataZoom.inside',\n\n    /**\n     * @override\n     */\n    init: function (ecModel, api) {\n        /**\n         * 'throttle' is used in this.dispatchAction, so we save range\n         * to avoid missing some 'pan' info.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._range;\n    },\n\n    /**\n     * @override\n     */\n    render: function (dataZoomModel, ecModel, api, payload) {\n        InsideZoomView.superApply(this, 'render', arguments);\n\n        // Notice: origin this._range should be maintained, and should not be re-fetched\n        // from dataZoomModel when payload.type is 'dataZoom', otherwise 'pan' or 'zoom'\n        // info will be missed because of 'throttle' of this.dispatchAction.\n        if (shouldRecordRange(payload, dataZoomModel.id)) {\n            this._range = dataZoomModel.getPercentRange();\n        }\n\n        // Reset controllers.\n        each$1(this.getTargetCoordInfo(), function (coordInfoList, coordSysName) {\n\n            var allCoordIds = map(coordInfoList, function (coordInfo) {\n                return generateCoordId(coordInfo.model);\n            });\n\n            each$1(coordInfoList, function (coordInfo) {\n                var coordModel = coordInfo.model;\n                var dataZoomOption = dataZoomModel.option;\n\n                register$2(\n                    api,\n                    {\n                        coordId: generateCoordId(coordModel),\n                        allCoordIds: allCoordIds,\n                        containsPoint: function (e, x, y) {\n                            return coordModel.coordinateSystem.containPoint([x, y]);\n                        },\n                        dataZoomId: dataZoomModel.id,\n                        throttleRate: dataZoomModel.get('throttle', true),\n                        panGetRange: bind$5(this._onPan, this, coordInfo, coordSysName),\n                        zoomGetRange: bind$5(this._onZoom, this, coordInfo, coordSysName),\n                        zoomLock: dataZoomOption.zoomLock,\n                        disabled: dataZoomOption.disabled,\n                        roamControllerOpt: {\n                            zoomOnMouseWheel: dataZoomOption.zoomOnMouseWheel,\n                            moveOnMouseMove: dataZoomOption.moveOnMouseMove,\n                            preventDefaultMouseMove: dataZoomOption.preventDefaultMouseMove\n                        }\n                    }\n                );\n            }, this);\n\n        }, this);\n    },\n\n    /**\n     * @override\n     */\n    dispose: function () {\n        unregister$1(this.api, this.dataZoomModel.id);\n        InsideZoomView.superApply(this, 'dispose', arguments);\n        this._range = null;\n    },\n\n    /**\n     * @private\n     */\n    _onPan: function (coordInfo, coordSysName, controller, dx, dy, oldX, oldY, newX, newY) {\n        var range = this._range.slice();\n\n        // Calculate transform by the first axis.\n        var axisModel = coordInfo.axisModels[0];\n        if (!axisModel) {\n            return;\n        }\n\n        var directionInfo = getDirectionInfo[coordSysName](\n            [oldX, oldY], [newX, newY], axisModel, controller, coordInfo\n        );\n\n        var percentDelta = directionInfo.signal\n            * (range[1] - range[0])\n            * directionInfo.pixel / directionInfo.pixelLength;\n\n        sliderMove(percentDelta, range, [0, 100], 'all');\n\n        return (this._range = range);\n    },\n\n    /**\n     * @private\n     */\n    _onZoom: function (coordInfo, coordSysName, controller, scale, mouseX, mouseY) {\n        var range = this._range.slice();\n\n        // Calculate transform by the first axis.\n        var axisModel = coordInfo.axisModels[0];\n        if (!axisModel) {\n            return;\n        }\n\n        var directionInfo = getDirectionInfo[coordSysName](\n            null, [mouseX, mouseY], axisModel, controller, coordInfo\n        );\n        var percentPoint = (\n            directionInfo.signal > 0\n                ? (directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel)\n                : (directionInfo.pixel - directionInfo.pixelStart)\n            ) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];\n\n        scale = Math.max(1 / scale, 0);\n        range[0] = (range[0] - percentPoint) * scale + percentPoint;\n        range[1] = (range[1] - percentPoint) * scale + percentPoint;\n\n        // Restrict range.\n        var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n\n        sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);\n\n        return (this._range = range);\n    }\n\n});\n\nvar getDirectionInfo = {\n\n    grid: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n        var axis = axisModel.axis;\n        var ret = {};\n        var rect = coordInfo.model.coordinateSystem.getRect();\n        oldPoint = oldPoint || [0, 0];\n\n        if (axis.dim === 'x') {\n            ret.pixel = newPoint[0] - oldPoint[0];\n            ret.pixelLength = rect.width;\n            ret.pixelStart = rect.x;\n            ret.signal = axis.inverse ? 1 : -1;\n        }\n        else { // axis.dim === 'y'\n            ret.pixel = newPoint[1] - oldPoint[1];\n            ret.pixelLength = rect.height;\n            ret.pixelStart = rect.y;\n            ret.signal = axis.inverse ? -1 : 1;\n        }\n\n        return ret;\n    },\n\n    polar: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n        var axis = axisModel.axis;\n        var ret = {};\n        var polar = coordInfo.model.coordinateSystem;\n        var radiusExtent = polar.getRadiusAxis().getExtent();\n        var angleExtent = polar.getAngleAxis().getExtent();\n\n        oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];\n        newPoint = polar.pointToCoord(newPoint);\n\n        if (axisModel.mainType === 'radiusAxis') {\n            ret.pixel = newPoint[0] - oldPoint[0];\n            // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);\n            // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);\n            ret.pixelLength = radiusExtent[1] - radiusExtent[0];\n            ret.pixelStart = radiusExtent[0];\n            ret.signal = axis.inverse ? 1 : -1;\n        }\n        else { // 'angleAxis'\n            ret.pixel = newPoint[1] - oldPoint[1];\n            // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);\n            // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);\n            ret.pixelLength = angleExtent[1] - angleExtent[0];\n            ret.pixelStart = angleExtent[0];\n            ret.signal = axis.inverse ? -1 : 1;\n        }\n\n        return ret;\n    },\n\n    singleAxis: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n        var axis = axisModel.axis;\n        var rect = coordInfo.model.coordinateSystem.getRect();\n        var ret = {};\n\n        oldPoint = oldPoint || [0, 0];\n\n        if (axis.orient === 'horizontal') {\n            ret.pixel = newPoint[0] - oldPoint[0];\n            ret.pixelLength = rect.width;\n            ret.pixelStart = rect.x;\n            ret.signal = axis.inverse ? 1 : -1;\n        }\n        else { // 'vertical'\n            ret.pixel = newPoint[1] - oldPoint[1];\n            ret.pixelLength = rect.height;\n            ret.pixelStart = rect.y;\n            ret.signal = axis.inverse ? -1 : 1;\n        }\n\n        return ret;\n    }\n};\n\nregisterProcessor(function (ecModel, api) {\n\n    ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n        // We calculate window and reset axis here but not in model\n        // init stage and not after action dispatch handler, because\n        // reset should be called after seriesData.restoreData.\n        dataZoomModel.eachTargetAxis(resetSingleAxis);\n\n        // Caution: data zoom filtering is order sensitive when using\n        // percent range and no min/max/scale set on axis.\n        // For example, we have dataZoom definition:\n        // [\n        //      {xAxisIndex: 0, start: 30, end: 70},\n        //      {yAxisIndex: 0, start: 20, end: 80}\n        // ]\n        // In this case, [20, 80] of y-dataZoom should be based on data\n        // that have filtered by x-dataZoom using range of [30, 70],\n        // but should not be based on full raw data. Thus sliding\n        // x-dataZoom will change both ranges of xAxis and yAxis,\n        // while sliding y-dataZoom will only change the range of yAxis.\n        // So we should filter x-axis after reset x-axis immediately,\n        // and then reset y-axis and filter y-axis.\n        dataZoomModel.eachTargetAxis(filterSingleAxis);\n    });\n\n    ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n        // Fullfill all of the range props so that user\n        // is able to get them from chart.getOption().\n        var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n        var percentRange = axisProxy.getDataPercentWindow();\n        var valueRange = axisProxy.getDataValueWindow();\n\n        dataZoomModel.setRawRange({\n            start: percentRange[0],\n            end: percentRange[1],\n            startValue: valueRange[0],\n            endValue: valueRange[1]\n        }, true);\n    });\n});\n\nfunction resetSingleAxis(dimNames, axisIndex, dataZoomModel) {\n    dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel);\n}\n\nfunction filterSingleAxis(dimNames, axisIndex, dataZoomModel) {\n    dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel);\n}\n\nregisterAction('dataZoom', function (payload, ecModel) {\n\n    var linkedNodesFinder = createLinkedNodesFinder(\n        bind(ecModel.eachComponent, ecModel, 'dataZoom'),\n        eachAxisDim$1,\n        function (model, dimNames) {\n            return model.get(dimNames.axisIndex);\n        }\n    );\n\n    var effectedModels = [];\n\n    ecModel.eachComponent(\n        {mainType: 'dataZoom', query: payload},\n        function (model, index) {\n            effectedModels.push.apply(\n                effectedModels, linkedNodesFinder(model).nodes\n            );\n        }\n    );\n\n    each$1(effectedModels, function (dataZoomModel, index) {\n        dataZoomModel.setRawRange({\n            start: payload.start,\n            end: payload.end,\n            startValue: payload.startValue,\n            endValue: payload.endValue\n        });\n    });\n\n});\n\n/**\n * DataZoom component entry\n */\n\nvar each$27 = each$1;\n\nvar preprocessor$2 = function (option) {\n    var visualMap = option && option.visualMap;\n\n    if (!isArray(visualMap)) {\n        visualMap = visualMap ? [visualMap] : [];\n    }\n\n    each$27(visualMap, function (opt) {\n        if (!opt) {\n            return;\n        }\n\n        // rename splitList to pieces\n        if (has$1(opt, 'splitList') && !has$1(opt, 'pieces')) {\n            opt.pieces = opt.splitList;\n            delete opt.splitList;\n        }\n\n        var pieces = opt.pieces;\n        if (pieces && isArray(pieces)) {\n            each$27(pieces, function (piece) {\n                if (isObject(piece)) {\n                    if (has$1(piece, 'start') && !has$1(piece, 'min')) {\n                        piece.min = piece.start;\n                    }\n                    if (has$1(piece, 'end') && !has$1(piece, 'max')) {\n                        piece.max = piece.end;\n                    }\n                }\n            });\n        }\n    });\n};\n\nfunction has$1(obj, name) {\n    return obj && obj.hasOwnProperty && obj.hasOwnProperty(name);\n}\n\nComponentModel.registerSubTypeDefaulter('visualMap', function (option) {\n    // Compatible with ec2, when splitNumber === 0, continuous visualMap will be used.\n    return (\n            !option.categories\n            && (\n                !(\n                    option.pieces\n                        ? option.pieces.length > 0\n                        : option.splitNumber > 0\n                )\n                || option.calculable\n            )\n        )\n        ? 'continuous' : 'piecewise';\n});\n\nregisterVisual(PRIORITY.VISUAL.COMPONENT, function (ecModel) {\n    ecModel.eachComponent('visualMap', function (visualMapModel) {\n        processSingleVisualMap(visualMapModel, ecModel);\n    });\n\n    prepareVisualMeta(ecModel);\n});\n\nfunction processSingleVisualMap(visualMapModel, ecModel) {\n    visualMapModel.eachTargetSeries(function (seriesModel) {\n        var data = seriesModel.getData();\n\n        applyVisual(\n            visualMapModel.stateList,\n            visualMapModel.targetVisuals,\n            data,\n            visualMapModel.getValueState,\n            visualMapModel,\n            visualMapModel.getDataDimension(data)\n        );\n    });\n}\n\n// Only support color.\nfunction prepareVisualMeta(ecModel) {\n    ecModel.eachSeries(function (seriesModel) {\n        var data = seriesModel.getData();\n        var visualMetaList = [];\n\n        ecModel.eachComponent('visualMap', function (visualMapModel) {\n            if (visualMapModel.isTargetSeries(seriesModel)) {\n                var visualMeta = visualMapModel.getVisualMeta(\n                    bind(getColorVisual, null, seriesModel, visualMapModel)\n                ) || {stops: [], outerColors: []};\n                visualMeta.dimension = visualMapModel.getDataDimension(data);\n                visualMetaList.push(visualMeta);\n            }\n        });\n\n        // console.log(JSON.stringify(visualMetaList.map(a => a.stops)));\n        seriesModel.getData().setVisual('visualMeta', visualMetaList);\n    });\n}\n\n// FIXME\n// performance and export for heatmap?\n// value can be Infinity or -Infinity\nfunction getColorVisual(seriesModel, visualMapModel, value, valueState) {\n    var mappings = visualMapModel.targetVisuals[valueState];\n    var visualTypes = VisualMapping.prepareVisualTypes(mappings);\n    var resultVisual = {\n        color: seriesModel.getData().getVisual('color') // default color.\n    };\n\n    for (var i = 0, len = visualTypes.length; i < len; i++) {\n        var type = visualTypes[i];\n        var mapping = mappings[\n            type === 'opacity' ? '__alphaForOpacity' : type\n        ];\n        mapping && mapping.applyVisual(value, getVisual, setVisual);\n    }\n\n    return resultVisual.color;\n\n    function getVisual(key) {\n        return resultVisual[key];\n    }\n\n    function setVisual(key, value) {\n        resultVisual[key] = value;\n    }\n}\n\n/**\n * @file Visual mapping.\n */\n\nvar visualDefault = {\n\n    /**\n     * @public\n     */\n    get: function (visualType, key, isCategory) {\n        var value = clone(\n            (defaultOption$3[visualType] || {})[key]\n        );\n\n        return isCategory\n            ? (isArray(value) ? value[value.length - 1] : value)\n            : value;\n    }\n\n};\n\nvar defaultOption$3 = {\n\n    color: {\n        active: ['#006edd', '#e0ffff'],\n        inactive: ['rgba(0,0,0,0)']\n    },\n\n    colorHue: {\n        active: [0, 360],\n        inactive: [0, 0]\n    },\n\n    colorSaturation: {\n        active: [0.3, 1],\n        inactive: [0, 0]\n    },\n\n    colorLightness: {\n        active: [0.9, 0.5],\n        inactive: [0, 0]\n    },\n\n    colorAlpha: {\n        active: [0.3, 1],\n        inactive: [0, 0]\n    },\n\n    opacity: {\n        active: [0.3, 1],\n        inactive: [0, 0]\n    },\n\n    symbol: {\n        active: ['circle', 'roundRect', 'diamond'],\n        inactive: ['none']\n    },\n\n    symbolSize: {\n        active: [10, 50],\n        inactive: [0, 0]\n    }\n};\n\nvar mapVisual$2 = VisualMapping.mapVisual;\nvar eachVisual = VisualMapping.eachVisual;\nvar isArray$3 = isArray;\nvar each$28 = each$1;\nvar asc$3 = asc;\nvar linearMap$3 = linearMap;\nvar noop$2 = noop;\n\nvar DEFAULT_COLOR = ['#f6efa6', '#d88273', '#bf444c'];\n\nvar VisualMapModel = extendComponentModel({\n\n    type: 'visualMap',\n\n    dependencies: ['series'],\n\n    /**\n     * @readOnly\n     * @type {Array.<string>}\n     */\n    stateList: ['inRange', 'outOfRange'],\n\n    /**\n     * @readOnly\n     * @type {Array.<string>}\n     */\n    replacableOptionKeys: [\n        'inRange', 'outOfRange', 'target', 'controller', 'color'\n    ],\n\n    /**\n     * [lowerBound, upperBound]\n     *\n     * @readOnly\n     * @type {Array.<number>}\n     */\n    dataBound: [-Infinity, Infinity],\n\n    /**\n     * @readOnly\n     * @type {string|Object}\n     */\n    layoutMode: {type: 'box', ignoreSize: true},\n\n    /**\n     * @protected\n     */\n    defaultOption: {\n        show: true,\n\n        zlevel: 0,\n        z: 4,\n\n        seriesIndex: 'all',     // 'all' or null/undefined: all series.\n                                // A number or an array of number: the specified series.\n\n                                // set min: 0, max: 200, only for campatible with ec2.\n                                // In fact min max should not have default value.\n        min: 0,                 // min value, must specified if pieces is not specified.\n        max: 200,               // max value, must specified if pieces is not specified.\n\n        dimension: null,\n        inRange: null,          // 'color', 'colorHue', 'colorSaturation', 'colorLightness', 'colorAlpha',\n                                // 'symbol', 'symbolSize'\n        outOfRange: null,       // 'color', 'colorHue', 'colorSaturation',\n                                // 'colorLightness', 'colorAlpha',\n                                // 'symbol', 'symbolSize'\n\n        left: 0,                // 'center'  'left'  'right'  {number} (px)\n        right: null,            // The same as left.\n        top: null,              // 'top'  'bottom'  'center'  {number} (px)\n        bottom: 0,              // The same as top.\n\n        itemWidth: null,\n        itemHeight: null,\n        inverse: false,\n        orient: 'vertical',        // 'horizontal'  'vertical'\n\n        backgroundColor: 'rgba(0,0,0,0)',\n        borderColor: '#ccc',       // \n        contentColor: '#5793f3',\n        inactiveColor: '#aaa',\n        borderWidth: 0,            // px0\n        padding: 5,                // px5\n                                    // css\n        textGap: 10,               //\n        precision: 0,              // 0\n        color: null,               //deprecatedec2piecesinRange/outOfRange\n\n        formatter: null,\n        text: null,                // ['', '']ec2text[0]text[1]\n        textStyle: {\n            color: '#333'          // \n        }\n    },\n\n    /**\n     * @protected\n     */\n    init: function (option, parentModel, ecModel) {\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._dataExtent;\n\n        /**\n         * @readOnly\n         */\n        this.targetVisuals = {};\n\n        /**\n         * @readOnly\n         */\n        this.controllerVisuals = {};\n\n        /**\n         * @readOnly\n         */\n        this.textStyleModel;\n\n        /**\n         * [width, height]\n         * @readOnly\n         * @type {Array.<number>}\n         */\n        this.itemSize;\n\n        this.mergeDefaultAndTheme(option, ecModel);\n    },\n\n    /**\n     * @protected\n     */\n    optionUpdated: function (newOption, isInit) {\n        var thisOption = this.option;\n\n        // FIXME\n        // necessary?\n        // Disable realtime view update if canvas is not supported.\n        if (!env$1.canvasSupported) {\n            thisOption.realtime = false;\n        }\n\n        !isInit && replaceVisualOption(\n            thisOption, newOption, this.replacableOptionKeys\n        );\n\n        this.textStyleModel = this.getModel('textStyle');\n\n        this.resetItemSize();\n\n        this.completeVisualOption();\n    },\n\n    /**\n     * @protected\n     */\n    resetVisual: function (supplementVisualOption) {\n        var stateList = this.stateList;\n        supplementVisualOption = bind(supplementVisualOption, this);\n\n        this.controllerVisuals = createVisualMappings(\n            this.option.controller, stateList, supplementVisualOption\n        );\n        this.targetVisuals = createVisualMappings(\n            this.option.target, stateList, supplementVisualOption\n        );\n    },\n\n    /**\n     * @protected\n     * @return {Array.<number>} An array of series indices.\n     */\n    getTargetSeriesIndices: function () {\n        var optionSeriesIndex = this.option.seriesIndex;\n        var seriesIndices = [];\n\n        if (optionSeriesIndex == null || optionSeriesIndex === 'all') {\n            this.ecModel.eachSeries(function (seriesModel, index) {\n                seriesIndices.push(index);\n            });\n        }\n        else {\n            seriesIndices = normalizeToArray(optionSeriesIndex);\n        }\n\n        return seriesIndices;\n    },\n\n    /**\n     * @public\n     */\n    eachTargetSeries: function (callback, context) {\n        each$1(this.getTargetSeriesIndices(), function (seriesIndex) {\n            callback.call(context, this.ecModel.getSeriesByIndex(seriesIndex));\n        }, this);\n    },\n\n    /**\n     * @pubilc\n     */\n    isTargetSeries: function (seriesModel) {\n        var is = false;\n        this.eachTargetSeries(function (model) {\n            model === seriesModel && (is = true);\n        });\n        return is;\n    },\n\n    /**\n     * @example\n     * this.formatValueText(someVal); // format single numeric value to text.\n     * this.formatValueText(someVal, true); // format single category value to text.\n     * this.formatValueText([min, max]); // format numeric min-max to text.\n     * this.formatValueText([this.dataBound[0], max]); // using data lower bound.\n     * this.formatValueText([min, this.dataBound[1]]); // using data upper bound.\n     *\n     * @param {number|Array.<number>} value Real value, or this.dataBound[0 or 1].\n     * @param {boolean} [isCategory=false] Only available when value is number.\n     * @param {Array.<string>} edgeSymbols Open-close symbol when value is interval.\n     * @return {string}\n     * @protected\n     */\n    formatValueText: function(value, isCategory, edgeSymbols) {\n        var option = this.option;\n        var precision = option.precision;\n        var dataBound = this.dataBound;\n        var formatter = option.formatter;\n        var isMinMax;\n        var textValue;\n        edgeSymbols = edgeSymbols || ['<', '>'];\n\n        if (isArray(value)) {\n            value = value.slice();\n            isMinMax = true;\n        }\n\n        textValue = isCategory\n            ? value\n            : (isMinMax\n                ? [toFixed(value[0]), toFixed(value[1])]\n                : toFixed(value)\n            );\n\n        if (isString(formatter)) {\n            return formatter\n                .replace('{value}', isMinMax ? textValue[0] : textValue)\n                .replace('{value2}', isMinMax ? textValue[1] : textValue);\n        }\n        else if (isFunction(formatter)) {\n            return isMinMax\n                ? formatter(value[0], value[1])\n                : formatter(value);\n        }\n\n        if (isMinMax) {\n            if (value[0] === dataBound[0]) {\n                return edgeSymbols[0] + ' ' + textValue[1];\n            }\n            else if (value[1] === dataBound[1]) {\n                return edgeSymbols[1] + ' ' + textValue[0];\n            }\n            else {\n                return textValue[0] + ' - ' + textValue[1];\n            }\n        }\n        else { // Format single value (includes category case).\n            return textValue;\n        }\n\n        function toFixed(val) {\n            return val === dataBound[0]\n                ? 'min'\n                : val === dataBound[1]\n                ? 'max'\n                : (+val).toFixed(Math.min(precision, 20));\n        }\n    },\n\n    /**\n     * @protected\n     */\n    resetExtent: function () {\n        var thisOption = this.option;\n\n        // Can not calculate data extent by data here.\n        // Because series and data may be modified in processing stage.\n        // So we do not support the feature \"auto min/max\".\n\n        var extent = asc$3([thisOption.min, thisOption.max]);\n\n        this._dataExtent = extent;\n    },\n\n    /**\n     * @public\n     * @param {module:echarts/data/List} list\n     * @return {string} Concrete dimention. If return null/undefined,\n     *                  no dimension used.\n     */\n    getDataDimension: function (list) {\n        var optDim = this.option.dimension;\n        return optDim != null\n            ? optDim : list.dimensions.length - 1;\n    },\n\n    /**\n     * @public\n     * @override\n     */\n    getExtent: function () {\n        return this._dataExtent.slice();\n    },\n\n    /**\n     * @protected\n     */\n    completeVisualOption: function () {\n        var thisOption = this.option;\n        var base = {inRange: thisOption.inRange, outOfRange: thisOption.outOfRange};\n\n        var target = thisOption.target || (thisOption.target = {});\n        var controller = thisOption.controller || (thisOption.controller = {});\n\n        merge(target, base); // Do not override\n        merge(controller, base); // Do not override\n\n        var isCategory = this.isCategory();\n\n        completeSingle.call(this, target);\n        completeSingle.call(this, controller);\n        completeInactive.call(this, target, 'inRange', 'outOfRange');\n        // completeInactive.call(this, target, 'outOfRange', 'inRange');\n        completeController.call(this, controller);\n\n        function completeSingle(base) {\n            // Compatible with ec2 dataRange.color.\n            // The mapping order of dataRange.color is: [high value, ..., low value]\n            // whereas inRange.color and outOfRange.color is [low value, ..., high value]\n            // Notice: ec2 has no inverse.\n            if (isArray$3(thisOption.color)\n                // If there has been inRange: {symbol: ...}, adding color is a mistake.\n                // So adding color only when no inRange defined.\n                && !base.inRange\n            ) {\n                base.inRange = {color: thisOption.color.slice().reverse()};\n            }\n\n            // Compatible with previous logic, always give a defautl color, otherwise\n            // simple config with no inRange and outOfRange will not work.\n            // Originally we use visualMap.color as the default color, but setOption at\n            // the second time the default color will be erased. So we change to use\n            // constant DEFAULT_COLOR.\n            // If user do not want the defualt color, set inRange: {color: null}.\n            base.inRange = base.inRange || {color: DEFAULT_COLOR};\n\n            // If using shortcut like: {inRange: 'symbol'}, complete default value.\n            each$28(this.stateList, function (state) {\n                var visualType = base[state];\n\n                if (isString(visualType)) {\n                    var defa = visualDefault.get(visualType, 'active', isCategory);\n                    if (defa) {\n                        base[state] = {};\n                        base[state][visualType] = defa;\n                    }\n                    else {\n                        // Mark as not specified.\n                        delete base[state];\n                    }\n                }\n            }, this);\n        }\n\n        function completeInactive(base, stateExist, stateAbsent) {\n            var optExist = base[stateExist];\n            var optAbsent = base[stateAbsent];\n\n            if (optExist && !optAbsent) {\n                optAbsent = base[stateAbsent] = {};\n                each$28(optExist, function (visualData, visualType) {\n                    if (!VisualMapping.isValidType(visualType)) {\n                        return;\n                    }\n\n                    var defa = visualDefault.get(visualType, 'inactive', isCategory);\n\n                    if (defa != null) {\n                        optAbsent[visualType] = defa;\n\n                        // Compatibable with ec2:\n                        // Only inactive color to rgba(0,0,0,0) can not\n                        // make label transparent, so use opacity also.\n                        if (visualType === 'color'\n                            && !optAbsent.hasOwnProperty('opacity')\n                            && !optAbsent.hasOwnProperty('colorAlpha')\n                        ) {\n                            optAbsent.opacity = [0, 0];\n                        }\n                    }\n                });\n            }\n        }\n\n        function completeController(controller) {\n            var symbolExists = (controller.inRange || {}).symbol\n                || (controller.outOfRange || {}).symbol;\n            var symbolSizeExists = (controller.inRange || {}).symbolSize\n                || (controller.outOfRange || {}).symbolSize;\n            var inactiveColor = this.get('inactiveColor');\n\n            each$28(this.stateList, function (state) {\n\n                var itemSize = this.itemSize;\n                var visuals = controller[state];\n\n                // Set inactive color for controller if no other color\n                // attr (like colorAlpha) specified.\n                if (!visuals) {\n                    visuals = controller[state] = {\n                        color: isCategory ? inactiveColor : [inactiveColor]\n                    };\n                }\n\n                // Consistent symbol and symbolSize if not specified.\n                if (visuals.symbol == null) {\n                    visuals.symbol = symbolExists\n                        && clone(symbolExists)\n                        || (isCategory ? 'roundRect' : ['roundRect']);\n                }\n                if (visuals.symbolSize == null) {\n                    visuals.symbolSize = symbolSizeExists\n                        && clone(symbolSizeExists)\n                        || (isCategory ? itemSize[0] : [itemSize[0], itemSize[0]]);\n                }\n\n                // Filter square and none.\n                visuals.symbol = mapVisual$2(visuals.symbol, function (symbol) {\n                    return (symbol === 'none' || symbol === 'square') ? 'roundRect' : symbol;\n                });\n\n                // Normalize symbolSize\n                var symbolSize = visuals.symbolSize;\n\n                if (symbolSize != null) {\n                    var max = -Infinity;\n                    // symbolSize can be object when categories defined.\n                    eachVisual(symbolSize, function (value) {\n                        value > max && (max = value);\n                    });\n                    visuals.symbolSize = mapVisual$2(symbolSize, function (value) {\n                        return linearMap$3(value, [0, max], [0, itemSize[0]], true);\n                    });\n                }\n\n            }, this);\n        }\n    },\n\n    /**\n     * @protected\n     */\n    resetItemSize: function () {\n        this.itemSize = [\n            parseFloat(this.get('itemWidth')),\n            parseFloat(this.get('itemHeight'))\n        ];\n    },\n\n    /**\n     * @public\n     */\n    isCategory: function () {\n        return !!this.option.categories;\n    },\n\n    /**\n     * @public\n     * @abstract\n     */\n    setSelected: noop$2,\n\n    /**\n     * @public\n     * @abstract\n     * @param {*|module:echarts/data/List} valueOrData\n     * @param {number} dataIndex\n     * @return {string} state See this.stateList\n     */\n    getValueState: noop$2,\n\n    /**\n     * FIXME\n     * Do not publish to thirt-part-dev temporarily\n     * util the interface is stable. (Should it return\n     * a function but not visual meta?)\n     *\n     * @pubilc\n     * @abstract\n     * @param {Function} getColorVisual\n     *        params: value, valueState\n     *        return: color\n     * @return {Object} visualMeta\n     *        should includes {stops, outerColors}\n     *        outerColor means [colorBeyondMinValue, colorBeyondMaxValue]\n     */\n    getVisualMeta: noop$2\n\n});\n\n// Constant\nvar DEFAULT_BAR_BOUND = [20, 140];\n\nvar ContinuousModel = VisualMapModel.extend({\n\n    type: 'visualMap.continuous',\n\n    /**\n     * @protected\n     */\n    defaultOption: {\n        align: 'auto',          // 'auto', 'left', 'right', 'top', 'bottom'\n        calculable: false,      // This prop effect default component type determine,\n                                // See echarts/component/visualMap/typeDefaulter.\n        range: null,            // selected range. In default case `range` is [min, max]\n                                // and can auto change along with modification of min max,\n                                // util use specifid a range.\n        realtime: true,         // Whether realtime update.\n        itemHeight: null,       // The length of the range control edge.\n        itemWidth: null,        // The length of the other side.\n        hoverLink: true,        // Enable hover highlight.\n        hoverLinkDataSize: null,// The size of hovered data.\n        hoverLinkOnHandle: null // Whether trigger hoverLink when hover handle.\n                                // If not specified, follow the value of `realtime`.\n    },\n\n    /**\n     * @override\n     */\n    optionUpdated: function (newOption, isInit) {\n        ContinuousModel.superApply(this, 'optionUpdated', arguments);\n\n        this.resetExtent();\n\n        this.resetVisual(function (mappingOption) {\n            mappingOption.mappingMethod = 'linear';\n            mappingOption.dataExtent = this.getExtent();\n        });\n\n        this._resetRange();\n    },\n\n    /**\n     * @protected\n     * @override\n     */\n    resetItemSize: function () {\n        ContinuousModel.superApply(this, 'resetItemSize', arguments);\n\n        var itemSize = this.itemSize;\n\n        this._orient === 'horizontal' && itemSize.reverse();\n\n        (itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]);\n        (itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]);\n    },\n\n    /**\n     * @private\n     */\n    _resetRange: function () {\n        var dataExtent = this.getExtent();\n        var range = this.option.range;\n\n        if (!range || range.auto) {\n            // `range` should always be array (so we dont use other\n            // value like 'auto') for user-friend. (consider getOption).\n            dataExtent.auto = 1;\n            this.option.range = dataExtent;\n        }\n        else if (isArray(range)) {\n            if (range[0] > range[1]) {\n                range.reverse();\n            }\n            range[0] = Math.max(range[0], dataExtent[0]);\n            range[1] = Math.min(range[1], dataExtent[1]);\n        }\n    },\n\n    /**\n     * @protected\n     * @override\n     */\n    completeVisualOption: function () {\n        VisualMapModel.prototype.completeVisualOption.apply(this, arguments);\n\n        each$1(this.stateList, function (state) {\n            var symbolSize = this.option.controller[state].symbolSize;\n            if (symbolSize && symbolSize[0] !== symbolSize[1]) {\n                symbolSize[0] = 0; // For good looking.\n            }\n        }, this);\n    },\n\n    /**\n     * @override\n     */\n    setSelected: function (selected) {\n        this.option.range = selected.slice();\n        this._resetRange();\n    },\n\n    /**\n     * @public\n     */\n    getSelected: function () {\n        var dataExtent = this.getExtent();\n\n        var dataInterval = asc(\n            (this.get('range') || []).slice()\n        );\n\n        // Clamp\n        dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]);\n        dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]);\n        dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]);\n        dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]);\n\n        return dataInterval;\n    },\n\n    /**\n     * @override\n     */\n    getValueState: function (value) {\n        var range = this.option.range;\n        var dataExtent = this.getExtent();\n\n        // When range[0] === dataExtent[0], any value larger than dataExtent[0] maps to 'inRange'.\n        // range[1] is processed likewise.\n        return (\n            (range[0] <= dataExtent[0] || range[0] <= value)\n            && (range[1] >= dataExtent[1] || value <= range[1])\n        ) ? 'inRange' : 'outOfRange';\n    },\n\n    /**\n     * @params {Array.<number>} range target value: range[0] <= value && value <= range[1]\n     * @return {Array.<Object>} [{seriesId, dataIndices: <Array.<number>>}, ...]\n     */\n    findTargetDataIndices: function (range) {\n        var result = [];\n\n        this.eachTargetSeries(function (seriesModel) {\n            var dataIndices = [];\n            var data = seriesModel.getData();\n\n            data.each(this.getDataDimension(data), function (value, dataIndex) {\n                range[0] <= value && value <= range[1] && dataIndices.push(dataIndex);\n            }, true, this);\n\n            result.push({seriesId: seriesModel.id, dataIndex: dataIndices});\n        }, this);\n\n        return result;\n    },\n\n    /**\n     * @implement\n     */\n    getVisualMeta: function (getColorVisual) {\n        var oVals = getColorStopValues(this, 'outOfRange', this.getExtent());\n        var iVals = getColorStopValues(this, 'inRange', this.option.range.slice());\n        var stops = [];\n\n        function setStop(value, valueState) {\n            stops.push({\n                value: value,\n                color: getColorVisual(value, valueState)\n            });\n        }\n\n        // Format to: outOfRange -- inRange -- outOfRange.\n        var iIdx = 0;\n        var oIdx = 0;\n        var iLen = iVals.length;\n        var oLen = oVals.length;\n\n        for (; oIdx < oLen && (!iVals.length || oVals[oIdx] <= iVals[0]); oIdx++) {\n            // If oVal[oIdx] === iVals[iIdx], oVal[oIdx] should be ignored.\n            if (oVals[oIdx] < iVals[iIdx]) {\n                setStop(oVals[oIdx], 'outOfRange');\n            }\n        }\n        for (var first = 1; iIdx < iLen; iIdx++, first = 0) {\n            // If range is full, value beyond min, max will be clamped.\n            // make a singularity\n            first && stops.length && setStop(iVals[iIdx], 'outOfRange');\n            setStop(iVals[iIdx], 'inRange');\n        }\n        for (var first = 1; oIdx < oLen; oIdx++) {\n            if (!iVals.length || iVals[iVals.length - 1] < oVals[oIdx]) {\n                // make a singularity\n                if (first) {\n                    stops.length && setStop(stops[stops.length - 1].value, 'outOfRange');\n                    first = 0;\n                }\n                setStop(oVals[oIdx], 'outOfRange');\n            }\n        }\n\n        var stopsLen = stops.length;\n\n        return {\n            stops: stops,\n            outerColors: [\n                stopsLen ? stops[0].color : 'transparent',\n                stopsLen ? stops[stopsLen - 1].color : 'transparent'\n            ]\n        };\n    }\n\n});\n\nfunction getColorStopValues(visualMapModel, valueState, dataExtent) {\n    if (dataExtent[0] === dataExtent[1]) {\n        return dataExtent.slice();\n    }\n\n    // When using colorHue mapping, it is not linear color any more.\n    // Moreover, canvas gradient seems not to be accurate linear.\n    // FIXME\n    // Should be arbitrary value 100? or based on pixel size?\n    var count = 200;\n    var step = (dataExtent[1] - dataExtent[0]) / count;\n\n    var value = dataExtent[0];\n    var stopValues = [];\n    for (var i = 0; i <= count && value < dataExtent[1]; i++) {\n        stopValues.push(value);\n        value += step;\n    }\n    stopValues.push(dataExtent[1]);\n\n    return stopValues;\n}\n\nvar VisualMapView = extendComponentView({\n\n    type: 'visualMap',\n\n    /**\n     * @readOnly\n     * @type {Object}\n     */\n    autoPositionValues: {left: 1, right: 1, top: 1, bottom: 1},\n\n    init: function (ecModel, api) {\n        /**\n         * @readOnly\n         * @type {module:echarts/model/Global}\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @readOnly\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this.api = api;\n\n        /**\n         * @readOnly\n         * @type {module:echarts/component/visualMap/visualMapModel}\n         */\n        this.visualMapModel;\n    },\n\n    /**\n     * @protected\n     */\n    render: function (visualMapModel, ecModel, api, payload) {\n        this.visualMapModel = visualMapModel;\n\n        if (visualMapModel.get('show') === false) {\n            this.group.removeAll();\n            return;\n        }\n\n        this.doRender.apply(this, arguments);\n    },\n\n    /**\n     * @protected\n     */\n    renderBackground: function (group) {\n        var visualMapModel = this.visualMapModel;\n        var padding = normalizeCssArray$1(visualMapModel.get('padding') || 0);\n        var rect = group.getBoundingRect();\n\n        group.add(new Rect({\n            z2: -1, // Lay background rect on the lowest layer.\n            silent: true,\n            shape: {\n                x: rect.x - padding[3],\n                y: rect.y - padding[0],\n                width: rect.width + padding[3] + padding[1],\n                height: rect.height + padding[0] + padding[2]\n            },\n            style: {\n                fill: visualMapModel.get('backgroundColor'),\n                stroke: visualMapModel.get('borderColor'),\n                lineWidth: visualMapModel.get('borderWidth')\n            }\n        }));\n    },\n\n    /**\n     * @protected\n     * @param {number} targetValue can be Infinity or -Infinity\n     * @param {string=} visualCluster Only can be 'color' 'opacity' 'symbol' 'symbolSize'\n     * @param {Object} [opts]\n     * @param {string=} [opts.forceState] Specify state, instead of using getValueState method.\n     * @param {string=} [opts.convertOpacityToAlpha=false] For color gradient in controller widget.\n     * @return {*} Visual value.\n     */\n    getControllerVisual: function (targetValue, visualCluster, opts) {\n        opts = opts || {};\n\n        var forceState = opts.forceState;\n        var visualMapModel = this.visualMapModel;\n        var visualObj = {};\n\n        // Default values.\n        if (visualCluster === 'symbol') {\n            visualObj.symbol = visualMapModel.get('itemSymbol');\n        }\n        if (visualCluster === 'color') {\n            var defaultColor = visualMapModel.get('contentColor');\n            visualObj.color = defaultColor;\n        }\n\n        function getter(key) {\n            return visualObj[key];\n        }\n\n        function setter(key, value) {\n            visualObj[key] = value;\n        }\n\n        var mappings = visualMapModel.controllerVisuals[\n            forceState || visualMapModel.getValueState(targetValue)\n        ];\n        var visualTypes = VisualMapping.prepareVisualTypes(mappings);\n\n        each$1(visualTypes, function (type) {\n            var visualMapping = mappings[type];\n            if (opts.convertOpacityToAlpha && type === 'opacity') {\n                type = 'colorAlpha';\n                visualMapping = mappings.__alphaForOpacity;\n            }\n            if (VisualMapping.dependsOn(type, visualCluster)) {\n                visualMapping && visualMapping.applyVisual(\n                    targetValue, getter, setter\n                );\n            }\n        });\n\n        return visualObj[visualCluster];\n    },\n\n    /**\n     * @protected\n     */\n    positionGroup: function (group) {\n        var model = this.visualMapModel;\n        var api = this.api;\n\n        positionElement(\n            group,\n            model.getBoxLayoutParams(),\n            {width: api.getWidth(), height: api.getHeight()}\n        );\n    },\n\n    /**\n     * @protected\n     * @abstract\n     */\n    doRender: noop\n\n});\n\n/**\n * @param {module:echarts/component/visualMap/VisualMapModel} visualMapModel\\\n * @param {module:echarts/ExtensionAPI} api\n * @param {Array.<number>} itemSize always [short, long]\n * @return {string} 'left' or 'right' or 'top' or 'bottom'\n */\nfunction getItemAlign(visualMapModel, api, itemSize) {\n    var modelOption = visualMapModel.option;\n    var itemAlign = modelOption.align;\n\n    if (itemAlign != null && itemAlign !== 'auto') {\n        return itemAlign;\n    }\n\n    // Auto decision align.\n    var ecSize = {width: api.getWidth(), height: api.getHeight()};\n    var realIndex = modelOption.orient === 'horizontal' ? 1 : 0;\n\n    var paramsSet = [\n        ['left', 'right', 'width'],\n        ['top', 'bottom', 'height']\n    ];\n    var reals = paramsSet[realIndex];\n    var fakeValue = [0, null, 10];\n\n    var layoutInput = {};\n    for (var i = 0; i < 3; i++) {\n        layoutInput[paramsSet[1 - realIndex][i]] = fakeValue[i];\n        layoutInput[reals[i]] = i === 2 ? itemSize[0] : modelOption[reals[i]];\n    }\n\n    var rParam = [['x', 'width', 3], ['y', 'height', 0]][realIndex];\n    var rect = getLayoutRect(layoutInput, ecSize, modelOption.padding);\n\n    return reals[\n        (rect.margin[rParam[2]] || 0) + rect[rParam[0]] + rect[rParam[1]] * 0.5\n            < ecSize[rParam[1]] * 0.5 ? 0 : 1\n    ];\n}\n\n/**\n * Prepare dataIndex for outside usage, where dataIndex means rawIndex, and\n * dataIndexInside means filtered index.\n */\nfunction convertDataIndex(batch) {\n    each$1(batch || [], function (batchItem) {\n        if (batch.dataIndex != null) {\n            batch.dataIndexInside = batch.dataIndex;\n            batch.dataIndex = null;\n        }\n    });\n    return batch;\n}\n\nvar linearMap$4 = linearMap;\nvar each$29 = each$1;\nvar mathMin$7 = Math.min;\nvar mathMax$7 = Math.max;\n\n// Arbitrary value\nvar HOVER_LINK_SIZE = 12;\nvar HOVER_LINK_OUT = 6;\n\n// Notice:\n// Any \"interval\" should be by the order of [low, high].\n// \"handle0\" (handleIndex === 0) maps to\n// low data value: this._dataInterval[0] and has low coord.\n// \"handle1\" (handleIndex === 1) maps to\n// high data value: this._dataInterval[1] and has high coord.\n// The logic of transform is implemented in this._createBarGroup.\n\nvar ContinuousView = VisualMapView.extend({\n\n    type: 'visualMap.continuous',\n\n    /**\n     * @override\n     */\n    init: function () {\n\n        ContinuousView.superApply(this, 'init', arguments);\n\n        /**\n         * @private\n         */\n        this._shapes = {};\n\n        /**\n         * @private\n         */\n        this._dataInterval = [];\n\n        /**\n         * @private\n         */\n        this._handleEnds = [];\n\n        /**\n         * @private\n         */\n        this._orient;\n\n        /**\n         * @private\n         */\n        this._useHandle;\n\n        /**\n         * @private\n         */\n        this._hoverLinkDataIndices = [];\n\n        /**\n         * @private\n         */\n        this._dragging;\n\n        /**\n         * @private\n         */\n        this._hovering;\n    },\n\n    /**\n     * @protected\n     * @override\n     */\n    doRender: function (visualMapModel, ecModel, api, payload) {\n        if (!payload || payload.type !== 'selectDataRange' || payload.from !== this.uid) {\n            this._buildView();\n        }\n    },\n\n    /**\n     * @private\n     */\n    _buildView: function () {\n        this.group.removeAll();\n\n        var visualMapModel = this.visualMapModel;\n        var thisGroup = this.group;\n\n        this._orient = visualMapModel.get('orient');\n        this._useHandle = visualMapModel.get('calculable');\n\n        this._resetInterval();\n\n        this._renderBar(thisGroup);\n\n        var dataRangeText = visualMapModel.get('text');\n        this._renderEndsText(thisGroup, dataRangeText, 0);\n        this._renderEndsText(thisGroup, dataRangeText, 1);\n\n        // Do this for background size calculation.\n        this._updateView(true);\n\n        // After updating view, inner shapes is built completely,\n        // and then background can be rendered.\n        this.renderBackground(thisGroup);\n\n        // Real update view\n        this._updateView();\n\n        this._enableHoverLinkToSeries();\n        this._enableHoverLinkFromSeries();\n\n        this.positionGroup(thisGroup);\n    },\n\n    /**\n     * @private\n     */\n    _renderEndsText: function (group, dataRangeText, endsIndex) {\n        if (!dataRangeText) {\n            return;\n        }\n\n        // Compatible with ec2, text[0] map to high value, text[1] map low value.\n        var text = dataRangeText[1 - endsIndex];\n        text = text != null ? text + '' : '';\n\n        var visualMapModel = this.visualMapModel;\n        var textGap = visualMapModel.get('textGap');\n        var itemSize = visualMapModel.itemSize;\n\n        var barGroup = this._shapes.barGroup;\n        var position = this._applyTransform(\n            [\n                itemSize[0] / 2,\n                endsIndex === 0 ? -textGap : itemSize[1] + textGap\n            ],\n            barGroup\n        );\n        var align = this._applyTransform(\n            endsIndex === 0 ? 'bottom' : 'top',\n            barGroup\n        );\n        var orient = this._orient;\n        var textStyleModel = this.visualMapModel.textStyleModel;\n\n        this.group.add(new Text({\n            style: {\n                x: position[0],\n                y: position[1],\n                textVerticalAlign: orient === 'horizontal' ? 'middle' : align,\n                textAlign: orient === 'horizontal' ? align : 'center',\n                text: text,\n                textFont: textStyleModel.getFont(),\n                textFill: textStyleModel.getTextColor()\n            }\n        }));\n    },\n\n    /**\n     * @private\n     */\n    _renderBar: function (targetGroup) {\n        var visualMapModel = this.visualMapModel;\n        var shapes = this._shapes;\n        var itemSize = visualMapModel.itemSize;\n        var orient = this._orient;\n        var useHandle = this._useHandle;\n        var itemAlign = getItemAlign(visualMapModel, this.api, itemSize);\n        var barGroup = shapes.barGroup = this._createBarGroup(itemAlign);\n\n        // Bar\n        barGroup.add(shapes.outOfRange = createPolygon());\n        barGroup.add(shapes.inRange = createPolygon(\n            null,\n            useHandle ? getCursor$1(this._orient) : null,\n            bind(this._dragHandle, this, 'all', false),\n            bind(this._dragHandle, this, 'all', true)\n        ));\n\n        var textRect = visualMapModel.textStyleModel.getTextRect('');\n        var textSize = mathMax$7(textRect.width, textRect.height);\n\n        // Handle\n        if (useHandle) {\n            shapes.handleThumbs = [];\n            shapes.handleLabels = [];\n            shapes.handleLabelPoints = [];\n\n            this._createHandle(barGroup, 0, itemSize, textSize, orient, itemAlign);\n            this._createHandle(barGroup, 1, itemSize, textSize, orient, itemAlign);\n        }\n\n        this._createIndicator(barGroup, itemSize, textSize, orient);\n\n        targetGroup.add(barGroup);\n    },\n\n    /**\n     * @private\n     */\n    _createHandle: function (barGroup, handleIndex, itemSize, textSize, orient) {\n        var onDrift = bind(this._dragHandle, this, handleIndex, false);\n        var onDragEnd = bind(this._dragHandle, this, handleIndex, true);\n        var handleThumb = createPolygon(\n            createHandlePoints(handleIndex, textSize),\n            getCursor$1(this._orient),\n            onDrift,\n            onDragEnd\n        );\n        handleThumb.position[0] = itemSize[0];\n        barGroup.add(handleThumb);\n\n        // Text is always horizontal layout but should not be effected by\n        // transform (orient/inverse). So label is built separately but not\n        // use zrender/graphic/helper/RectText, and is located based on view\n        // group (according to handleLabelPoint) but not barGroup.\n        var textStyleModel = this.visualMapModel.textStyleModel;\n        var handleLabel = new Text({\n            draggable: true,\n            drift: onDrift,\n            onmousemove: function (e) {\n                // Fot mobile devicem, prevent screen slider on the button.\n                stop(e.event);\n            },\n            ondragend: onDragEnd,\n            style: {\n                x: 0, y: 0, text: '',\n                textFont: textStyleModel.getFont(),\n                textFill: textStyleModel.getTextColor()\n            }\n        });\n        this.group.add(handleLabel);\n\n        var handleLabelPoint = [\n            orient === 'horizontal'\n                ? textSize / 2\n                : textSize * 1.5,\n            orient === 'horizontal'\n                ? (handleIndex === 0 ? -(textSize * 1.5) : (textSize * 1.5))\n                : (handleIndex === 0 ? -textSize / 2 : textSize / 2)\n        ];\n\n        var shapes = this._shapes;\n        shapes.handleThumbs[handleIndex] = handleThumb;\n        shapes.handleLabelPoints[handleIndex] = handleLabelPoint;\n        shapes.handleLabels[handleIndex] = handleLabel;\n    },\n\n    /**\n     * @private\n     */\n    _createIndicator: function (barGroup, itemSize, textSize, orient) {\n        var indicator = createPolygon([[0, 0]], 'move');\n        indicator.position[0] = itemSize[0];\n        indicator.attr({invisible: true, silent: true});\n        barGroup.add(indicator);\n\n        var textStyleModel = this.visualMapModel.textStyleModel;\n        var indicatorLabel = new Text({\n            silent: true,\n            invisible: true,\n            style: {\n                x: 0, y: 0, text: '',\n                textFont: textStyleModel.getFont(),\n                textFill: textStyleModel.getTextColor()\n            }\n        });\n        this.group.add(indicatorLabel);\n\n        var indicatorLabelPoint = [\n            orient === 'horizontal' ? textSize / 2 : HOVER_LINK_OUT + 3,\n            0\n        ];\n\n        var shapes = this._shapes;\n        shapes.indicator = indicator;\n        shapes.indicatorLabel = indicatorLabel;\n        shapes.indicatorLabelPoint = indicatorLabelPoint;\n    },\n\n    /**\n     * @private\n     */\n    _dragHandle: function (handleIndex, isEnd, dx, dy) {\n        if (!this._useHandle) {\n            return;\n        }\n\n        this._dragging = !isEnd;\n\n        if (!isEnd) {\n            // Transform dx, dy to bar coordination.\n            var vertex = this._applyTransform([dx, dy], this._shapes.barGroup, true);\n            this._updateInterval(handleIndex, vertex[1]);\n\n            // Considering realtime, update view should be executed\n            // before dispatch action.\n            this._updateView();\n        }\n\n        // dragEnd do not dispatch action when realtime.\n        if (isEnd === !this.visualMapModel.get('realtime')) { // jshint ignore:line\n            this.api.dispatchAction({\n                type: 'selectDataRange',\n                from: this.uid,\n                visualMapId: this.visualMapModel.id,\n                selected: this._dataInterval.slice()\n            });\n        }\n\n        if (isEnd) {\n            !this._hovering && this._clearHoverLinkToSeries();\n        }\n        else if (useHoverLinkOnHandle(this.visualMapModel)) {\n            this._doHoverLinkToSeries(this._handleEnds[handleIndex], false);\n        }\n    },\n\n    /**\n     * @private\n     */\n    _resetInterval: function () {\n        var visualMapModel = this.visualMapModel;\n\n        var dataInterval = this._dataInterval = visualMapModel.getSelected();\n        var dataExtent = visualMapModel.getExtent();\n        var sizeExtent = [0, visualMapModel.itemSize[1]];\n\n        this._handleEnds = [\n            linearMap$4(dataInterval[0], dataExtent, sizeExtent, true),\n            linearMap$4(dataInterval[1], dataExtent, sizeExtent, true)\n        ];\n    },\n\n    /**\n     * @private\n     * @param {(number|string)} handleIndex 0 or 1 or 'all'\n     * @param {number} dx\n     * @param {number} dy\n     */\n    _updateInterval: function (handleIndex, delta) {\n        delta = delta || 0;\n        var visualMapModel = this.visualMapModel;\n        var handleEnds = this._handleEnds;\n        var sizeExtent = [0, visualMapModel.itemSize[1]];\n\n        sliderMove(\n            delta,\n            handleEnds,\n            sizeExtent,\n            handleIndex,\n            // cross is forbiden\n            0\n        );\n\n        var dataExtent = visualMapModel.getExtent();\n        // Update data interval.\n        this._dataInterval = [\n            linearMap$4(handleEnds[0], sizeExtent, dataExtent, true),\n            linearMap$4(handleEnds[1], sizeExtent, dataExtent, true)\n        ];\n    },\n\n    /**\n     * @private\n     */\n    _updateView: function (forSketch) {\n        var visualMapModel = this.visualMapModel;\n        var dataExtent = visualMapModel.getExtent();\n        var shapes = this._shapes;\n\n        var outOfRangeHandleEnds = [0, visualMapModel.itemSize[1]];\n        var inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds;\n\n        var visualInRange = this._createBarVisual(\n            this._dataInterval, dataExtent, inRangeHandleEnds, 'inRange'\n        );\n        var visualOutOfRange = this._createBarVisual(\n            dataExtent, dataExtent, outOfRangeHandleEnds, 'outOfRange'\n        );\n\n        shapes.inRange\n            .setStyle({\n                fill: visualInRange.barColor,\n                opacity: visualInRange.opacity\n            })\n            .setShape('points', visualInRange.barPoints);\n        shapes.outOfRange\n            .setStyle({\n                fill: visualOutOfRange.barColor,\n                opacity: visualOutOfRange.opacity\n            })\n            .setShape('points', visualOutOfRange.barPoints);\n\n        this._updateHandle(inRangeHandleEnds, visualInRange);\n    },\n\n    /**\n     * @private\n     */\n    _createBarVisual: function (dataInterval, dataExtent, handleEnds, forceState) {\n        var opts = {\n            forceState: forceState,\n            convertOpacityToAlpha: true\n        };\n        var colorStops = this._makeColorGradient(dataInterval, opts);\n\n        var symbolSizes = [\n            this.getControllerVisual(dataInterval[0], 'symbolSize', opts),\n            this.getControllerVisual(dataInterval[1], 'symbolSize', opts)\n        ];\n        var barPoints = this._createBarPoints(handleEnds, symbolSizes);\n\n        return {\n            barColor: new LinearGradient(0, 0, 0, 1, colorStops),\n            barPoints: barPoints,\n            handlesColor: [\n                colorStops[0].color,\n                colorStops[colorStops.length - 1].color\n            ]\n        };\n    },\n\n    /**\n     * @private\n     */\n    _makeColorGradient: function (dataInterval, opts) {\n        // Considering colorHue, which is not linear, so we have to sample\n        // to calculate gradient color stops, but not only caculate head\n        // and tail.\n        var sampleNumber = 100; // Arbitrary value.\n        var colorStops = [];\n        var step = (dataInterval[1] - dataInterval[0]) / sampleNumber;\n\n        colorStops.push({\n            color: this.getControllerVisual(dataInterval[0], 'color', opts),\n            offset: 0\n        });\n\n        for (var i = 1; i < sampleNumber; i++) {\n            var currValue = dataInterval[0] + step * i;\n            if (currValue > dataInterval[1]) {\n                break;\n            }\n            colorStops.push({\n                color: this.getControllerVisual(currValue, 'color', opts),\n                offset: i / sampleNumber\n            });\n        }\n\n        colorStops.push({\n            color: this.getControllerVisual(dataInterval[1], 'color', opts),\n            offset: 1\n        });\n\n        return colorStops;\n    },\n\n    /**\n     * @private\n     */\n    _createBarPoints: function (handleEnds, symbolSizes) {\n        var itemSize = this.visualMapModel.itemSize;\n\n        return [\n            [itemSize[0] - symbolSizes[0], handleEnds[0]],\n            [itemSize[0], handleEnds[0]],\n            [itemSize[0], handleEnds[1]],\n            [itemSize[0] - symbolSizes[1], handleEnds[1]]\n        ];\n    },\n\n    /**\n     * @private\n     */\n    _createBarGroup: function (itemAlign) {\n        var orient = this._orient;\n        var inverse = this.visualMapModel.get('inverse');\n\n        return new Group(\n            (orient === 'horizontal' && !inverse)\n            ? {scale: itemAlign === 'bottom' ? [1, 1] : [-1, 1], rotation: Math.PI / 2}\n            : (orient === 'horizontal' && inverse)\n            ? {scale: itemAlign === 'bottom' ? [-1, 1] : [1, 1], rotation: -Math.PI / 2}\n            : (orient === 'vertical' && !inverse)\n            ? {scale: itemAlign === 'left' ? [1, -1] : [-1, -1]}\n            : {scale: itemAlign === 'left' ? [1, 1] : [-1, 1]}\n        );\n    },\n\n    /**\n     * @private\n     */\n    _updateHandle: function (handleEnds, visualInRange) {\n        if (!this._useHandle) {\n            return;\n        }\n\n        var shapes = this._shapes;\n        var visualMapModel = this.visualMapModel;\n        var handleThumbs = shapes.handleThumbs;\n        var handleLabels = shapes.handleLabels;\n\n        each$29([0, 1], function (handleIndex) {\n            var handleThumb = handleThumbs[handleIndex];\n            handleThumb.setStyle('fill', visualInRange.handlesColor[handleIndex]);\n            handleThumb.position[1] = handleEnds[handleIndex];\n\n            // Update handle label position.\n            var textPoint = applyTransform$1(\n                shapes.handleLabelPoints[handleIndex],\n                getTransform(handleThumb, this.group)\n            );\n            handleLabels[handleIndex].setStyle({\n                x: textPoint[0],\n                y: textPoint[1],\n                text: visualMapModel.formatValueText(this._dataInterval[handleIndex]),\n                textVerticalAlign: 'middle',\n                textAlign: this._applyTransform(\n                    this._orient === 'horizontal'\n                        ? (handleIndex === 0 ? 'bottom' : 'top')\n                        : 'left',\n                    shapes.barGroup\n                )\n            });\n        }, this);\n    },\n\n    /**\n     * @private\n     * @param {number} cursorValue\n     * @param {number} textValue\n     * @param {string} [rangeSymbol]\n     * @param {number} [halfHoverLinkSize]\n     */\n    _showIndicator: function (cursorValue, textValue, rangeSymbol, halfHoverLinkSize) {\n        var visualMapModel = this.visualMapModel;\n        var dataExtent = visualMapModel.getExtent();\n        var itemSize = visualMapModel.itemSize;\n        var sizeExtent = [0, itemSize[1]];\n        var pos = linearMap$4(cursorValue, dataExtent, sizeExtent, true);\n\n        var shapes = this._shapes;\n        var indicator = shapes.indicator;\n        if (!indicator) {\n            return;\n        }\n\n        indicator.position[1] = pos;\n        indicator.attr('invisible', false);\n        indicator.setShape('points', createIndicatorPoints(\n            !!rangeSymbol, halfHoverLinkSize, pos, itemSize[1]\n        ));\n\n        var opts = {convertOpacityToAlpha: true};\n        var color = this.getControllerVisual(cursorValue, 'color', opts);\n        indicator.setStyle('fill', color);\n\n        // Update handle label position.\n        var textPoint = applyTransform$1(\n            shapes.indicatorLabelPoint,\n            getTransform(indicator, this.group)\n        );\n\n        var indicatorLabel = shapes.indicatorLabel;\n        indicatorLabel.attr('invisible', false);\n        var align = this._applyTransform('left', shapes.barGroup);\n        var orient = this._orient;\n        indicatorLabel.setStyle({\n            text: (rangeSymbol ? rangeSymbol : '') + visualMapModel.formatValueText(textValue),\n            textVerticalAlign: orient === 'horizontal' ? align : 'middle',\n            textAlign: orient === 'horizontal' ? 'center' : align,\n            x: textPoint[0],\n            y: textPoint[1]\n        });\n    },\n\n    /**\n     * @private\n     */\n    _enableHoverLinkToSeries: function () {\n        var self = this;\n        this._shapes.barGroup\n\n            .on('mousemove', function (e) {\n                self._hovering = true;\n\n                if (!self._dragging) {\n                    var itemSize = self.visualMapModel.itemSize;\n                    var pos = self._applyTransform(\n                        [e.offsetX, e.offsetY], self._shapes.barGroup, true, true\n                    );\n                    // For hover link show when hover handle, which might be\n                    // below or upper than sizeExtent.\n                    pos[1] = mathMin$7(mathMax$7(0, pos[1]), itemSize[1]);\n                    self._doHoverLinkToSeries(\n                        pos[1],\n                        0 <= pos[0] && pos[0] <= itemSize[0]\n                    );\n                }\n            })\n\n            .on('mouseout', function () {\n                // When mouse is out of handle, hoverLink still need\n                // to be displayed when realtime is set as false.\n                self._hovering = false;\n                !self._dragging && self._clearHoverLinkToSeries();\n            });\n    },\n\n    /**\n     * @private\n     */\n    _enableHoverLinkFromSeries: function () {\n        var zr = this.api.getZr();\n\n        if (this.visualMapModel.option.hoverLink) {\n            zr.on('mouseover', this._hoverLinkFromSeriesMouseOver, this);\n            zr.on('mouseout', this._hideIndicator, this);\n        }\n        else {\n            this._clearHoverLinkFromSeries();\n        }\n    },\n\n    /**\n     * @private\n     */\n    _doHoverLinkToSeries: function (cursorPos, hoverOnBar) {\n        var visualMapModel = this.visualMapModel;\n        var itemSize = visualMapModel.itemSize;\n\n        if (!visualMapModel.option.hoverLink) {\n            return;\n        }\n\n        var sizeExtent = [0, itemSize[1]];\n        var dataExtent = visualMapModel.getExtent();\n\n        // For hover link show when hover handle, which might be below or upper than sizeExtent.\n        cursorPos = mathMin$7(mathMax$7(sizeExtent[0], cursorPos), sizeExtent[1]);\n\n        var halfHoverLinkSize = getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent);\n        var hoverRange = [cursorPos - halfHoverLinkSize, cursorPos + halfHoverLinkSize];\n        var cursorValue = linearMap$4(cursorPos, sizeExtent, dataExtent, true);\n        var valueRange = [\n            linearMap$4(hoverRange[0], sizeExtent, dataExtent, true),\n            linearMap$4(hoverRange[1], sizeExtent, dataExtent, true)\n        ];\n        // Consider data range is out of visualMap range, see test/visualMap-continuous.html,\n        // where china and india has very large population.\n        hoverRange[0] < sizeExtent[0] && (valueRange[0] = -Infinity);\n        hoverRange[1] > sizeExtent[1] && (valueRange[1] = Infinity);\n\n        // Do not show indicator when mouse is over handle,\n        // otherwise labels overlap, especially when dragging.\n        if (hoverOnBar) {\n            if (valueRange[0] === -Infinity) {\n                this._showIndicator(cursorValue, valueRange[1], '< ', halfHoverLinkSize);\n            }\n            else if (valueRange[1] === Infinity) {\n                this._showIndicator(cursorValue, valueRange[0], '> ', halfHoverLinkSize);\n            }\n            else {\n                this._showIndicator(cursorValue, cursorValue, ' ', halfHoverLinkSize);\n            }\n        }\n\n        // When realtime is set as false, handles, which are in barGroup,\n        // also trigger hoverLink, which help user to realize where they\n        // focus on when dragging. (see test/heatmap-large.html)\n        // When realtime is set as true, highlight will not show when hover\n        // handle, because the label on handle, which displays a exact value\n        // but not range, might mislead users.\n        var oldBatch = this._hoverLinkDataIndices;\n        var newBatch = [];\n        if (hoverOnBar || useHoverLinkOnHandle(visualMapModel)) {\n            newBatch = this._hoverLinkDataIndices = visualMapModel.findTargetDataIndices(valueRange);\n        }\n\n        var resultBatches = compressBatches(oldBatch, newBatch);\n\n        this._dispatchHighDown('downplay', convertDataIndex(resultBatches[0]));\n        this._dispatchHighDown('highlight', convertDataIndex(resultBatches[1]));\n    },\n\n    /**\n     * @private\n     */\n    _hoverLinkFromSeriesMouseOver: function (e) {\n        var el = e.target;\n        var visualMapModel = this.visualMapModel;\n\n        if (!el || el.dataIndex == null) {\n            return;\n        }\n\n        var dataModel = this.ecModel.getSeriesByIndex(el.seriesIndex);\n\n        if (!visualMapModel.isTargetSeries(dataModel)) {\n            return;\n        }\n\n        var data = dataModel.getData(el.dataType);\n        var dim = data.getDimension(visualMapModel.getDataDimension(data));\n        var value = data.get(dim, el.dataIndex, true);\n\n        if (!isNaN(value)) {\n            this._showIndicator(value, value);\n        }\n    },\n\n    /**\n     * @private\n     */\n    _hideIndicator: function () {\n        var shapes = this._shapes;\n        shapes.indicator && shapes.indicator.attr('invisible', true);\n        shapes.indicatorLabel && shapes.indicatorLabel.attr('invisible', true);\n    },\n\n    /**\n     * @private\n     */\n    _clearHoverLinkToSeries: function () {\n        this._hideIndicator();\n\n        var indices = this._hoverLinkDataIndices;\n        this._dispatchHighDown('downplay', convertDataIndex(indices));\n\n        indices.length = 0;\n    },\n\n    /**\n     * @private\n     */\n    _clearHoverLinkFromSeries: function () {\n        this._hideIndicator();\n\n        var zr = this.api.getZr();\n        zr.off('mouseover', this._hoverLinkFromSeriesMouseOver);\n        zr.off('mouseout', this._hideIndicator);\n    },\n\n    /**\n     * @private\n     */\n    _applyTransform: function (vertex, element, inverse, global) {\n        var transform = getTransform(element, global ? null : this.group);\n\n        return graphic[\n            isArray(vertex) ? 'applyTransform' : 'transformDirection'\n        ](vertex, transform, inverse);\n    },\n\n    /**\n     * @private\n     */\n    _dispatchHighDown: function (type, batch) {\n        batch && batch.length && this.api.dispatchAction({\n            type: type,\n            batch: batch\n        });\n    },\n\n    /**\n     * @override\n     */\n    dispose: function () {\n        this._clearHoverLinkFromSeries();\n        this._clearHoverLinkToSeries();\n    },\n\n    /**\n     * @override\n     */\n    remove: function () {\n        this._clearHoverLinkFromSeries();\n        this._clearHoverLinkToSeries();\n    }\n\n});\n\nfunction createPolygon(points, cursor, onDrift, onDragEnd) {\n    return new Polygon({\n        shape: {points: points},\n        draggable: !!onDrift,\n        cursor: cursor,\n        drift: onDrift,\n        onmousemove: function (e) {\n            // Fot mobile devicem, prevent screen slider on the button.\n            stop(e.event);\n        },\n        ondragend: onDragEnd\n    });\n}\n\nfunction createHandlePoints(handleIndex, textSize) {\n    return handleIndex === 0\n        ? [[0, 0], [textSize, 0], [textSize, -textSize]]\n        : [[0, 0], [textSize, 0], [textSize, textSize]];\n}\n\nfunction createIndicatorPoints(isRange, halfHoverLinkSize, pos, extentMax) {\n    return isRange\n        ? [ // indicate range\n            [0, -mathMin$7(halfHoverLinkSize, mathMax$7(pos, 0))],\n            [HOVER_LINK_OUT, 0],\n            [0, mathMin$7(halfHoverLinkSize, mathMax$7(extentMax - pos, 0))]\n        ]\n        : [ // indicate single value\n            [0, 0], [5, -5], [5, 5]\n        ];\n}\n\nfunction getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent) {\n    var halfHoverLinkSize = HOVER_LINK_SIZE / 2;\n    var hoverLinkDataSize = visualMapModel.get('hoverLinkDataSize');\n    if (hoverLinkDataSize) {\n        halfHoverLinkSize = linearMap$4(hoverLinkDataSize, dataExtent, sizeExtent, true) / 2;\n    }\n    return halfHoverLinkSize;\n}\n\nfunction useHoverLinkOnHandle(visualMapModel) {\n    var hoverLinkOnHandle = visualMapModel.get('hoverLinkOnHandle');\n    return !!(hoverLinkOnHandle == null ? visualMapModel.get('realtime') : hoverLinkOnHandle);\n}\n\nfunction getCursor$1(orient) {\n    return orient === 'vertical' ? 'ns-resize' : 'ew-resize';\n}\n\nvar actionInfo$2 = {\n    type: 'selectDataRange',\n    event: 'dataRangeSelected',\n    // FIXME use updateView appears wrong\n    update: 'update'\n};\n\nregisterAction(actionInfo$2, function (payload, ecModel) {\n\n    ecModel.eachComponent({mainType: 'visualMap', query: payload}, function (model) {\n        model.setSelected(payload.selected);\n    });\n\n});\n\n/**\n * DataZoom component entry\n */\n\nregisterPreprocessor(preprocessor$2);\n\nvar PiecewiseModel = VisualMapModel.extend({\n\n    type: 'visualMap.piecewise',\n\n    /**\n     * Order Rule:\n     *\n     * option.categories / option.pieces / option.text / option.selected:\n     *     If !option.inverse,\n     *     Order when vertical: ['top', ..., 'bottom'].\n     *     Order when horizontal: ['left', ..., 'right'].\n     *     If option.inverse, the meaning of\n     *     the order should be reversed.\n     *\n     * this._pieceList:\n     *     The order is always [low, ..., high].\n     *\n     * Mapping from location to low-high:\n     *     If !option.inverse\n     *     When vertical, top is high.\n     *     When horizontal, right is high.\n     *     If option.inverse, reverse.\n     */\n\n    /**\n     * @protected\n     */\n    defaultOption: {\n        selected: null,             // Object. If not specified, means selected.\n                                    // When pieces and splitNumber: {'0': true, '5': true}\n                                    // When categories: {'cate1': false, 'cate3': true}\n                                    // When selected === false, means all unselected.\n\n        minOpen: false,             // Whether include values that smaller than `min`.\n        maxOpen: false,             // Whether include values that bigger than `max`.\n\n        align: 'auto',              // 'auto', 'left', 'right'\n        itemWidth: 20,              // When put the controller vertically, it is the length of\n                                    // horizontal side of each item. Otherwise, vertical side.\n        itemHeight: 14,             // When put the controller vertically, it is the length of\n                                    // vertical side of each item. Otherwise, horizontal side.\n        itemSymbol: 'roundRect',\n        pieceList: null,            // Each item is Object, with some of those attrs:\n                                    // {min, max, lt, gt, lte, gte, value,\n                                    // color, colorSaturation, colorAlpha, opacity,\n                                    // symbol, symbolSize}, which customize the range or visual\n                                    // coding of the certain piece. Besides, see \"Order Rule\".\n        categories: null,           // category names, like: ['some1', 'some2', 'some3'].\n                                    // Attr min/max are ignored when categories set. See \"Order Rule\"\n        splitNumber: 5,             // If set to 5, auto split five pieces equally.\n                                    // If set to 0 and component type not set, component type will be\n                                    // determined as \"continuous\". (It is less reasonable but for ec2\n                                    // compatibility, see echarts/component/visualMap/typeDefaulter)\n        selectedMode: 'multiple',   // Can be 'multiple' or 'single'.\n        itemGap: 10,                // The gap between two items, in px.\n        hoverLink: true,            // Enable hover highlight.\n\n        showLabel: null             // By default, when text is used, label will hide (the logic\n                                    // is remained for compatibility reason)\n    },\n\n    /**\n     * @override\n     */\n    optionUpdated: function (newOption, isInit) {\n        PiecewiseModel.superApply(this, 'optionUpdated', arguments);\n\n        /**\n         * The order is always [low, ..., high].\n         * [{text: string, interval: Array.<number>}, ...]\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._pieceList = [];\n\n        this.resetExtent();\n\n        /**\n         * 'pieces', 'categories', 'splitNumber'\n         * @type {string}\n         */\n        var mode = this._mode = this._determineMode();\n\n        resetMethods[this._mode].call(this);\n\n        this._resetSelected(newOption, isInit);\n\n        var categories = this.option.categories;\n\n        this.resetVisual(function (mappingOption, state) {\n            if (mode === 'categories') {\n                mappingOption.mappingMethod = 'category';\n                mappingOption.categories = clone(categories);\n            }\n            else {\n                mappingOption.dataExtent = this.getExtent();\n                mappingOption.mappingMethod = 'piecewise';\n                mappingOption.pieceList = map(this._pieceList, function (piece) {\n                    var piece = clone(piece);\n                    if (state !== 'inRange') {\n                        // FIXME\n                        // outOfRange do not support special visual in pieces.\n                        piece.visual = null;\n                    }\n                    return piece;\n                });\n            }\n        });\n    },\n\n    /**\n     * @protected\n     * @override\n     */\n    completeVisualOption: function () {\n        // Consider this case:\n        // visualMap: {\n        //      pieces: [{symbol: 'circle', lt: 0}, {symbol: 'rect', gte: 0}]\n        // }\n        // where no inRange/outOfRange set but only pieces. So we should make\n        // default inRange/outOfRange for this case, otherwise visuals that only\n        // appear in `pieces` will not be taken into account in visual encoding.\n\n        var option = this.option;\n        var visualTypesInPieces = {};\n        var visualTypes = VisualMapping.listVisualTypes();\n        var isCategory = this.isCategory();\n\n        each$1(option.pieces, function (piece) {\n            each$1(visualTypes, function (visualType) {\n                if (piece.hasOwnProperty(visualType)) {\n                    visualTypesInPieces[visualType] = 1;\n                }\n            });\n        });\n\n        each$1(visualTypesInPieces, function (v, visualType) {\n            var exists = 0;\n            each$1(this.stateList, function (state) {\n                exists |= has(option, state, visualType)\n                    || has(option.target, state, visualType);\n            }, this);\n\n            !exists && each$1(this.stateList, function (state) {\n                (option[state] || (option[state] = {}))[visualType] = visualDefault.get(\n                    visualType, state === 'inRange' ? 'active' : 'inactive', isCategory\n                );\n            });\n        }, this);\n\n        function has(obj, state, visualType) {\n            return obj && obj[state] && (\n                isObject(obj[state])\n                    ? obj[state].hasOwnProperty(visualType)\n                    : obj[state] === visualType // e.g., inRange: 'symbol'\n            );\n        }\n\n        VisualMapModel.prototype.completeVisualOption.apply(this, arguments);\n    },\n\n    _resetSelected: function (newOption, isInit) {\n        var thisOption = this.option;\n        var pieceList = this._pieceList;\n\n        // Selected do not merge but all override.\n        var selected = (isInit ? thisOption : newOption).selected || {};\n        thisOption.selected = selected;\n\n        // Consider 'not specified' means true.\n        each$1(pieceList, function (piece, index) {\n            var key = this.getSelectedMapKey(piece);\n            if (!selected.hasOwnProperty(key)) {\n                selected[key] = true;\n            }\n        }, this);\n\n        if (thisOption.selectedMode === 'single') {\n            // Ensure there is only one selected.\n            var hasSel = false;\n\n            each$1(pieceList, function (piece, index) {\n                var key = this.getSelectedMapKey(piece);\n                if (selected[key]) {\n                    hasSel\n                        ? (selected[key] = false)\n                        : (hasSel = true);\n                }\n            }, this);\n        }\n        // thisOption.selectedMode === 'multiple', default: all selected.\n    },\n\n    /**\n     * @public\n     */\n    getSelectedMapKey: function (piece) {\n        return this._mode === 'categories'\n            ? piece.value + '' : piece.index + '';\n    },\n\n    /**\n     * @public\n     */\n    getPieceList: function () {\n        return this._pieceList;\n    },\n\n    /**\n     * @private\n     * @return {string}\n     */\n    _determineMode: function () {\n        var option = this.option;\n\n        return option.pieces && option.pieces.length > 0\n            ? 'pieces'\n            : this.option.categories\n            ? 'categories'\n            : 'splitNumber';\n    },\n\n    /**\n     * @public\n     * @override\n     */\n    setSelected: function (selected) {\n        this.option.selected = clone(selected);\n    },\n\n    /**\n     * @public\n     * @override\n     */\n    getValueState: function (value) {\n        var index = VisualMapping.findPieceIndex(value, this._pieceList);\n\n        return index != null\n            ? (this.option.selected[this.getSelectedMapKey(this._pieceList[index])]\n                ? 'inRange' : 'outOfRange'\n            )\n            : 'outOfRange';\n    },\n\n    /**\n     * @public\n     * @params {number} pieceIndex piece index in visualMapModel.getPieceList()\n     * @return {Array.<Object>} [{seriesId, dataIndices: <Array.<number>>}, ...]\n     */\n    findTargetDataIndices: function (pieceIndex) {\n        var result = [];\n\n        this.eachTargetSeries(function (seriesModel) {\n            var dataIndices = [];\n            var data = seriesModel.getData();\n\n            data.each(this.getDataDimension(data), function (value, dataIndex) {\n                // Should always base on model pieceList, because it is order sensitive.\n                var pIdx = VisualMapping.findPieceIndex(value, this._pieceList);\n                pIdx === pieceIndex && dataIndices.push(dataIndex);\n            }, true, this);\n\n            result.push({seriesId: seriesModel.id, dataIndex: dataIndices});\n        }, this);\n\n        return result;\n    },\n\n    /**\n     * @private\n     * @param {Object} piece piece.value or piece.interval is required.\n     * @return {number} Can be Infinity or -Infinity\n     */\n    getRepresentValue: function (piece) {\n        var representValue;\n        if (this.isCategory()) {\n            representValue = piece.value;\n        }\n        else {\n            if (piece.value != null) {\n                representValue = piece.value;\n            }\n            else {\n                var pieceInterval = piece.interval || [];\n                representValue = (pieceInterval[0] === -Infinity && pieceInterval[1] === Infinity)\n                    ? 0\n                    : (pieceInterval[0] + pieceInterval[1]) / 2;\n            }\n        }\n        return representValue;\n    },\n\n    getVisualMeta: function (getColorVisual) {\n        // Do not support category. (category axis is ordinal, numerical)\n        if (this.isCategory()) {\n            return;\n        }\n\n        var stops = [];\n        var outerColors = [];\n        var visualMapModel = this;\n\n        function setStop(interval, valueState) {\n            var representValue = visualMapModel.getRepresentValue({interval: interval});\n            if (!valueState) {\n                valueState = visualMapModel.getValueState(representValue);\n            }\n            var color = getColorVisual(representValue, valueState);\n            if (interval[0] === -Infinity) {\n                outerColors[0] = color;\n            }\n            else if (interval[1] === Infinity) {\n                outerColors[1] = color;\n            }\n            else {\n                stops.push(\n                    {value: interval[0], color: color},\n                    {value: interval[1], color: color}\n                );\n            }\n        }\n\n        // Suplement\n        var pieceList = this._pieceList.slice();\n        if (!pieceList.length) {\n            pieceList.push({interval: [-Infinity, Infinity]});\n        }\n        else {\n            var edge = pieceList[0].interval[0];\n            edge !== -Infinity && pieceList.unshift({interval: [-Infinity, edge]});\n            edge = pieceList[pieceList.length - 1].interval[1];\n            edge !== Infinity && pieceList.push({interval: [edge, Infinity]});\n        }\n\n        var curr = -Infinity;\n        each$1(pieceList, function (piece) {\n            var interval = piece.interval;\n            if (interval) {\n                // Fulfill gap.\n                interval[0] > curr && setStop([curr, interval[0]], 'outOfRange');\n                setStop(interval.slice());\n                curr = interval[1];\n            }\n        }, this);\n\n        return {stops: stops, outerColors: outerColors};\n    }\n\n});\n\n/**\n * Key is this._mode\n * @type {Object}\n * @this {module:echarts/component/viusalMap/PiecewiseMode}\n */\nvar resetMethods = {\n\n    splitNumber: function () {\n        var thisOption = this.option;\n        var pieceList = this._pieceList;\n        var precision = Math.min(thisOption.precision, 20);\n        var dataExtent = this.getExtent();\n        var splitNumber = thisOption.splitNumber;\n        splitNumber = Math.max(parseInt(splitNumber, 10), 1);\n        thisOption.splitNumber = splitNumber;\n\n        var splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber;\n        // Precision auto-adaption\n        while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {\n            precision++;\n        }\n        thisOption.precision = precision;\n        splitStep = +splitStep.toFixed(precision);\n\n        var index = 0;\n\n        if (thisOption.minOpen) {\n            pieceList.push({\n                index: index++,\n                interval: [-Infinity, dataExtent[0]],\n                close: [0, 0]\n            });\n        }\n\n        for (\n            var curr = dataExtent[0], len = index + splitNumber;\n            index < len;\n            curr += splitStep\n        ) {\n            var max = index === splitNumber - 1 ? dataExtent[1] : (curr + splitStep);\n\n            pieceList.push({\n                index: index++,\n                interval: [curr, max],\n                close: [1, 1]\n            });\n        }\n\n        if (thisOption.maxOpen) {\n            pieceList.push({\n                index: index++,\n                interval: [dataExtent[1], Infinity],\n                close: [0, 0]\n            });\n        }\n\n        reformIntervals(pieceList);\n\n        each$1(pieceList, function (piece) {\n            piece.text = this.formatValueText(piece.interval);\n        }, this);\n    },\n\n    categories: function () {\n        var thisOption = this.option;\n        each$1(thisOption.categories, function (cate) {\n            // FIXME categorypieceListvisualMappingpieceList\n            // \n            this._pieceList.push({\n                text: this.formatValueText(cate, true),\n                value: cate\n            });\n        }, this);\n\n        // See \"Order Rule\".\n        normalizeReverse(thisOption, this._pieceList);\n    },\n\n    pieces: function () {\n        var thisOption = this.option;\n        var pieceList = this._pieceList;\n\n        each$1(thisOption.pieces, function (pieceListItem, index) {\n\n            if (!isObject(pieceListItem)) {\n                pieceListItem = {value: pieceListItem};\n            }\n\n            var item = {text: '', index: index};\n\n            if (pieceListItem.label != null) {\n                item.text = pieceListItem.label;\n            }\n\n            if (pieceListItem.hasOwnProperty('value')) {\n                var value = item.value = pieceListItem.value;\n                item.interval = [value, value];\n                item.close = [1, 1];\n            }\n            else {\n                // `min` `max` is legacy option.\n                // `lt` `gt` `lte` `gte` is recommanded.\n                var interval = item.interval = [];\n                var close = item.close = [0, 0];\n\n                var closeList = [1, 0, 1];\n                var infinityList = [-Infinity, Infinity];\n\n                var useMinMax = [];\n                for (var lg = 0; lg < 2; lg++) {\n                    var names = [['gte', 'gt', 'min'], ['lte', 'lt', 'max']][lg];\n                    for (var i = 0; i < 3 && interval[lg] == null; i++) {\n                        interval[lg] = pieceListItem[names[i]];\n                        close[lg] = closeList[i];\n                        useMinMax[lg] = i === 2;\n                    }\n                    interval[lg] == null && (interval[lg] = infinityList[lg]);\n                }\n                useMinMax[0] && interval[1] === Infinity && (close[0] = 0);\n                useMinMax[1] && interval[0] === -Infinity && (close[1] = 0);\n\n                if (__DEV__) {\n                    if (interval[0] > interval[1]) {\n                        console.warn(\n                            'Piece ' + index + 'is illegal: ' + interval\n                            + ' lower bound should not greater then uppper bound.'\n                        );\n                    }\n                }\n\n                if (interval[0] === interval[1] && close[0] && close[1]) {\n                    // Consider: [{min: 5, max: 5, visual: {...}}, {min: 0, max: 5}],\n                    // we use value to lift the priority when min === max\n                    item.value = interval[0];\n                }\n            }\n\n            item.visual = VisualMapping.retrieveVisuals(pieceListItem);\n\n            pieceList.push(item);\n\n        }, this);\n\n        // See \"Order Rule\".\n        normalizeReverse(thisOption, pieceList);\n        // Only pieces\n        reformIntervals(pieceList);\n\n        each$1(pieceList, function (piece) {\n            var close = piece.close;\n            var edgeSymbols = [['<', ''][close[1]], ['>', ''][close[0]]];\n            piece.text = piece.text || this.formatValueText(\n                piece.value != null ? piece.value : piece.interval,\n                false,\n                edgeSymbols\n            );\n        }, this);\n    }\n};\n\nfunction normalizeReverse(thisOption, pieceList) {\n    var inverse = thisOption.inverse;\n    if (thisOption.orient === 'vertical' ? !inverse : inverse) {\n            pieceList.reverse();\n    }\n}\n\nvar PiecewiseVisualMapView = VisualMapView.extend({\n\n    type: 'visualMap.piecewise',\n\n    /**\n     * @protected\n     * @override\n     */\n    doRender: function () {\n        var thisGroup = this.group;\n\n        thisGroup.removeAll();\n\n        var visualMapModel = this.visualMapModel;\n        var textGap = visualMapModel.get('textGap');\n        var textStyleModel = visualMapModel.textStyleModel;\n        var textFont = textStyleModel.getFont();\n        var textFill = textStyleModel.getTextColor();\n        var itemAlign = this._getItemAlign();\n        var itemSize = visualMapModel.itemSize;\n        var viewData = this._getViewData();\n        var endsText = viewData.endsText;\n        var showLabel = retrieve(visualMapModel.get('showLabel', true), !endsText);\n\n        endsText && this._renderEndsText(\n            thisGroup, endsText[0], itemSize, showLabel, itemAlign\n        );\n\n        each$1(viewData.viewPieceList, renderItem, this);\n\n        endsText && this._renderEndsText(\n            thisGroup, endsText[1], itemSize, showLabel, itemAlign\n        );\n\n        box(\n            visualMapModel.get('orient'), thisGroup, visualMapModel.get('itemGap')\n        );\n\n        this.renderBackground(thisGroup);\n\n        this.positionGroup(thisGroup);\n\n        function renderItem(item) {\n            var piece = item.piece;\n\n            var itemGroup = new Group();\n            itemGroup.onclick = bind(this._onItemClick, this, piece);\n\n            this._enableHoverLink(itemGroup, item.indexInModelPieceList);\n\n            var representValue = visualMapModel.getRepresentValue(piece);\n\n            this._createItemSymbol(\n                itemGroup, representValue, [0, 0, itemSize[0], itemSize[1]]\n            );\n\n            if (showLabel) {\n                var visualState = this.visualMapModel.getValueState(representValue);\n\n                itemGroup.add(new Text({\n                    style: {\n                        x: itemAlign === 'right' ? -textGap : itemSize[0] + textGap,\n                        y: itemSize[1] / 2,\n                        text: piece.text,\n                        textVerticalAlign: 'middle',\n                        textAlign: itemAlign,\n                        textFont: textFont,\n                        textFill: textFill,\n                        opacity: visualState === 'outOfRange' ? 0.5 : 1\n                    }\n                }));\n            }\n\n            thisGroup.add(itemGroup);\n        }\n    },\n\n    /**\n     * @private\n     */\n    _enableHoverLink: function (itemGroup, pieceIndex) {\n        itemGroup\n            .on('mouseover', bind(onHoverLink, this, 'highlight'))\n            .on('mouseout', bind(onHoverLink, this, 'downplay'));\n\n        function onHoverLink(method) {\n            var visualMapModel = this.visualMapModel;\n\n            visualMapModel.option.hoverLink && this.api.dispatchAction({\n                type: method,\n                batch: convertDataIndex(\n                    visualMapModel.findTargetDataIndices(pieceIndex)\n                )\n            });\n        }\n    },\n\n    /**\n     * @private\n     */\n    _getItemAlign: function () {\n        var visualMapModel = this.visualMapModel;\n        var modelOption = visualMapModel.option;\n\n        if (modelOption.orient === 'vertical') {\n            return getItemAlign(\n                visualMapModel, this.api, visualMapModel.itemSize\n            );\n        }\n        else { // horizontal, most case left unless specifying right.\n            var align = modelOption.align;\n            if (!align || align === 'auto') {\n                align = 'left';\n            }\n            return align;\n        }\n    },\n\n    /**\n     * @private\n     */\n    _renderEndsText: function (group, text, itemSize, showLabel, itemAlign) {\n        if (!text) {\n            return;\n        }\n\n        var itemGroup = new Group();\n        var textStyleModel = this.visualMapModel.textStyleModel;\n\n        itemGroup.add(new Text({\n            style: {\n                x: showLabel ? (itemAlign === 'right' ? itemSize[0] : 0) : itemSize[0] / 2,\n                y: itemSize[1] / 2,\n                textVerticalAlign: 'middle',\n                textAlign: showLabel ? itemAlign : 'center',\n                text: text,\n                textFont: textStyleModel.getFont(),\n                textFill: textStyleModel.getTextColor()\n            }\n        }));\n\n        group.add(itemGroup);\n    },\n\n    /**\n     * @private\n     * @return {Object} {peiceList, endsText} The order is the same as screen pixel order.\n     */\n    _getViewData: function () {\n        var visualMapModel = this.visualMapModel;\n\n        var viewPieceList = map(visualMapModel.getPieceList(), function (piece, index) {\n            return {piece: piece, indexInModelPieceList: index};\n        });\n        var endsText = visualMapModel.get('text');\n\n        // Consider orient and inverse.\n        var orient = visualMapModel.get('orient');\n        var inverse = visualMapModel.get('inverse');\n\n        // Order of model pieceList is always [low, ..., high]\n        if (orient === 'horizontal' ? inverse : !inverse) {\n            viewPieceList.reverse();\n        }\n        // Origin order of endsText is [high, low]\n        else if (endsText) {\n            endsText = endsText.slice().reverse();\n        }\n\n        return {viewPieceList: viewPieceList, endsText: endsText};\n    },\n\n    /**\n     * @private\n     */\n    _createItemSymbol: function (group, representValue, shapeParam) {\n        group.add(createSymbol(\n            this.getControllerVisual(representValue, 'symbol'),\n            shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3],\n            this.getControllerVisual(representValue, 'color')\n        ));\n    },\n\n    /**\n     * @private\n     */\n    _onItemClick: function (piece) {\n        var visualMapModel = this.visualMapModel;\n        var option = visualMapModel.option;\n        var selected = clone(option.selected);\n        var newKey = visualMapModel.getSelectedMapKey(piece);\n\n        if (option.selectedMode === 'single') {\n            selected[newKey] = true;\n            each$1(selected, function (o, key) {\n                selected[key] = key === newKey;\n            });\n        }\n        else {\n            selected[newKey] = !selected[newKey];\n        }\n\n        this.api.dispatchAction({\n            type: 'selectDataRange',\n            from: this.uid,\n            visualMapId: this.visualMapModel.id,\n            selected: selected\n        });\n    }\n});\n\n/**\n * DataZoom component entry\n */\n\nregisterPreprocessor(preprocessor$2);\n\n/**\n * visualMap component entry\n */\n\nvar addCommas$1 = addCommas;\nvar encodeHTML$1 = encodeHTML;\n\nfunction fillLabel(opt) {\n    defaultEmphasis(opt.label, ['show']);\n}\nvar MarkerModel = extendComponentModel({\n\n    type: 'marker',\n\n    dependencies: ['series', 'grid', 'polar', 'geo'],\n\n    /**\n     * @overrite\n     */\n    init: function (option, parentModel, ecModel, extraOpt) {\n\n        if (__DEV__) {\n            if (this.type === 'marker') {\n                throw new Error('Marker component is abstract component. Use markLine, markPoint, markArea instead.');\n            }\n        }\n        this.mergeDefaultAndTheme(option, ecModel);\n        this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);\n    },\n\n    /**\n     * @return {boolean}\n     */\n    isAnimationEnabled: function () {\n        if (env$1.node) {\n            return false;\n        }\n\n        var hostSeries = this.__hostSeries;\n        return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();\n    },\n\n    mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {\n        var MarkerModel = this.constructor;\n        var modelPropName = this.mainType + 'Model';\n        if (!createdBySelf) {\n            ecModel.eachSeries(function (seriesModel) {\n\n                var markerOpt = seriesModel.get(this.mainType);\n\n                var markerModel = seriesModel[modelPropName];\n                if (!markerOpt || !markerOpt.data) {\n                    seriesModel[modelPropName] = null;\n                    return;\n                }\n                if (!markerModel) {\n                    if (isInit) {\n                        // Default label emphasis `position` and `show`\n                        fillLabel(markerOpt);\n                    }\n                    each$1(markerOpt.data, function (item) {\n                        // FIXME Overwrite fillLabel method ?\n                        if (item instanceof Array) {\n                            fillLabel(item[0]);\n                            fillLabel(item[1]);\n                        }\n                        else {\n                            fillLabel(item);\n                        }\n                    });\n\n                    markerModel = new MarkerModel(\n                        markerOpt, this, ecModel\n                    );\n\n                    extend(markerModel, {\n                        mainType: this.mainType,\n                        // Use the same series index and name\n                        seriesIndex: seriesModel.seriesIndex,\n                        name: seriesModel.name,\n                        createdBySelf: true\n                    });\n\n                    markerModel.__hostSeries = seriesModel;\n                }\n                else {\n                    markerModel.mergeOption(markerOpt, ecModel, true);\n                }\n                seriesModel[modelPropName] = markerModel;\n            }, this);\n        }\n    },\n\n    formatTooltip: function (dataIndex) {\n        var data = this.getData();\n        var value = this.getRawValue(dataIndex);\n        var formattedValue = isArray(value)\n            ? map(value, addCommas$1).join(', ') : addCommas$1(value);\n        var name = data.getName(dataIndex);\n        var html = encodeHTML$1(this.name);\n        if (value != null || name) {\n            html += '<br />';\n        }\n        if (name) {\n            html += encodeHTML$1(name);\n            if (value != null) {\n                html += ' : ';\n            }\n        }\n        if (value != null) {\n            html += encodeHTML$1(formattedValue);\n        }\n        return html;\n    },\n\n    getData: function () {\n        return this._data;\n    },\n\n    setData: function (data) {\n        this._data = data;\n    }\n});\n\nmixin(MarkerModel, dataFormatMixin);\n\nMarkerModel.extend({\n\n    type: 'markPoint',\n\n    defaultOption: {\n        zlevel: 0,\n        z: 5,\n        symbol: 'pin',\n        symbolSize: 50,\n        //symbolRotate: 0,\n        //symbolOffset: [0, 0]\n        tooltip: {\n            trigger: 'item'\n        },\n        label: {\n            normal: {\n                show: true,\n                position: 'inside'\n            },\n            emphasis: {\n                show: true\n            }\n        },\n        itemStyle: {\n            normal: {\n                borderWidth: 2\n            }\n        }\n    }\n});\n\nvar indexOf$3 = indexOf;\n\nfunction hasXOrY(item) {\n    return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n}\n\nfunction hasXAndY(item) {\n    return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n}\n\nfunction getPrecision$1(data, valueAxisDim, dataIndex) {\n    var precision = -1;\n    do {\n        precision = Math.max(\n            getPrecision(data.get(\n                valueAxisDim, dataIndex\n            )),\n            precision\n        );\n        data = data.stackedOn;\n    } while (data);\n\n    return precision;\n}\n\nfunction markerTypeCalculatorWithExtent(\n    mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex\n) {\n    var coordArr = [];\n    var value = numCalculate(data, targetDataDim, mlType);\n\n    var dataIndex = data.indicesOfNearest(targetDataDim, value, true)[0];\n    coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex, true);\n    coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex, true);\n\n    var precision = getPrecision$1(data, targetDataDim, dataIndex);\n    precision = Math.min(precision, 20);\n    if (precision >= 0) {\n        coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n    }\n\n    return coordArr;\n}\n\nvar curry$7 = curry;\n// TODO Specified percent\nvar markerTypeCalculator = {\n    /**\n     * @method\n     * @param {module:echarts/data/List} data\n     * @param {string} baseAxisDim\n     * @param {string} valueAxisDim\n     */\n    min: curry$7(markerTypeCalculatorWithExtent, 'min'),\n    /**\n     * @method\n     * @param {module:echarts/data/List} data\n     * @param {string} baseAxisDim\n     * @param {string} valueAxisDim\n     */\n    max: curry$7(markerTypeCalculatorWithExtent, 'max'),\n\n    /**\n     * @method\n     * @param {module:echarts/data/List} data\n     * @param {string} baseAxisDim\n     * @param {string} valueAxisDim\n     */\n    average: curry$7(markerTypeCalculatorWithExtent, 'average')\n};\n\n/**\n * Transform markPoint data item to format used in List by do the following\n * 1. Calculate statistic like `max`, `min`, `average`\n * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\n * @param  {module:echarts/model/Series} seriesModel\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {Object}\n */\nfunction dataTransform(seriesModel, item) {\n    var data = seriesModel.getData();\n    var coordSys = seriesModel.coordinateSystem;\n\n    // 1. If not specify the position with pixel directly\n    // 2. If `coord` is not a data array. Which uses `xAxis`,\n    // `yAxis` to specify the coord on each dimension\n\n    // parseFloat first because item.x and item.y can be percent string like '20%'\n    if (item && !hasXAndY(item) && !isArray(item.coord) && coordSys) {\n        var dims = coordSys.dimensions;\n        var axisInfo = getAxisInfo$1(item, data, coordSys, seriesModel);\n\n        // Clone the option\n        // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n        item = clone(item);\n\n        if (item.type\n            && markerTypeCalculator[item.type]\n            && axisInfo.baseAxis && axisInfo.valueAxis\n        ) {\n            var otherCoordIndex = indexOf$3(dims, axisInfo.baseAxis.dim);\n            var targetCoordIndex = indexOf$3(dims, axisInfo.valueAxis.dim);\n\n            item.coord = markerTypeCalculator[item.type](\n                data, axisInfo.baseDataDim, axisInfo.valueDataDim,\n                otherCoordIndex, targetCoordIndex\n            );\n            // Force to use the value of calculated value.\n            item.value = item.coord[targetCoordIndex];\n        }\n        else {\n            // FIXME Only has one of xAxis and yAxis.\n            var coord = [\n                item.xAxis != null ? item.xAxis : item.radiusAxis,\n                item.yAxis != null ? item.yAxis : item.angleAxis\n            ];\n            // Each coord support max, min, average\n            for (var i = 0; i < 2; i++) {\n                if (markerTypeCalculator[coord[i]]) {\n                    var dataDim = seriesModel.coordDimToDataDim(dims[i])[0];\n                    coord[i] = numCalculate(data, dataDim, coord[i]);\n                }\n            }\n            item.coord = coord;\n        }\n    }\n    return item;\n}\n\nfunction getAxisInfo$1(item, data, coordSys, seriesModel) {\n    var ret = {};\n\n    if (item.valueIndex != null || item.valueDim != null) {\n        ret.valueDataDim = item.valueIndex != null\n            ? data.getDimension(item.valueIndex) : item.valueDim;\n        ret.valueAxis = coordSys.getAxis(seriesModel.dataDimToCoordDim(ret.valueDataDim));\n        ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n        ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n    }\n    else {\n        ret.baseAxis = seriesModel.getBaseAxis();\n        ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n        ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];\n        ret.valueDataDim = seriesModel.coordDimToDataDim(ret.valueAxis.dim)[0];\n    }\n\n    return ret;\n}\n\n/**\n * Filter data which is out of coordinateSystem range\n * [dataFilter description]\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {boolean}\n */\nfunction dataFilter$1(coordSys, item) {\n    // Alwalys return true if there is no coordSys\n    return (coordSys && coordSys.containData && item.coord && !hasXOrY(item))\n        ? coordSys.containData(item.coord) : true;\n}\n\nfunction dimValueGetter(item, dimName, dataIndex, dimIndex) {\n    // x, y, radius, angle\n    if (dimIndex < 2) {\n        return item.coord && item.coord[dimIndex];\n    }\n    return item.value;\n}\n\nfunction numCalculate(data, valueDataDim, type) {\n    if (type === 'average') {\n        var sum = 0;\n        var count = 0;\n        data.each(valueDataDim, function (val, idx) {\n            if (!isNaN(val)) {\n                sum += val;\n                count++;\n            }\n        }, true);\n        return sum / count;\n    }\n    else {\n        return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];\n    }\n}\n\nvar MarkerView = extendComponentView({\n\n    type: 'marker',\n\n    init: function () {\n        /**\n         * Markline grouped by series\n         * @private\n         * @type {module:zrender/core/util.HashMap}\n         */\n        this.markerGroupMap = createHashMap();\n    },\n\n    render: function (markerModel, ecModel, api) {\n        var markerGroupMap = this.markerGroupMap;\n        markerGroupMap.each(function (item) {\n            item.__keep = false;\n        });\n\n        var markerModelKey = this.type + 'Model';\n        ecModel.eachSeries(function (seriesModel) {\n            var markerModel = seriesModel[markerModelKey];\n            markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);\n        }, this);\n\n        markerGroupMap.each(function (item) {\n            !item.__keep && this.group.remove(item.group);\n        }, this);\n    },\n\n    renderSeries: function () {}\n});\n\nfunction updateMarkerLayout(mpData, seriesModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    mpData.each(function (idx) {\n        var itemModel = mpData.getItemModel(idx);\n        var point;\n        var xPx = parsePercent$1(itemModel.get('x'), api.getWidth());\n        var yPx = parsePercent$1(itemModel.get('y'), api.getHeight());\n        if (!isNaN(xPx) && !isNaN(yPx)) {\n            point = [xPx, yPx];\n        }\n        // Chart like bar may have there own marker positioning logic\n        else if (seriesModel.getMarkerPosition) {\n            // Use the getMarkerPoisition\n            point = seriesModel.getMarkerPosition(\n                mpData.getValues(mpData.dimensions, idx)\n            );\n        }\n        else if (coordSys) {\n            var x = mpData.get(coordSys.dimensions[0], idx);\n            var y = mpData.get(coordSys.dimensions[1], idx);\n            point = coordSys.dataToPoint([x, y]);\n\n        }\n\n        // Use x, y if has any\n        if (!isNaN(xPx)) {\n            point[0] = xPx;\n        }\n        if (!isNaN(yPx)) {\n            point[1] = yPx;\n        }\n\n        mpData.setItemLayout(idx, point);\n    });\n}\n\nMarkerView.extend({\n\n    type: 'markPoint',\n\n    updateLayout: function (markPointModel, ecModel, api) {\n        ecModel.eachSeries(function (seriesModel) {\n            var mpModel = seriesModel.markPointModel;\n            if (mpModel) {\n                updateMarkerLayout(mpModel.getData(), seriesModel, api);\n                this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);\n            }\n        }, this);\n    },\n\n    renderSeries: function (seriesModel, mpModel, ecModel, api) {\n        var coordSys = seriesModel.coordinateSystem;\n        var seriesId = seriesModel.id;\n        var seriesData = seriesModel.getData();\n\n        var symbolDrawMap = this.markerGroupMap;\n        var symbolDraw = symbolDrawMap.get(seriesId)\n            || symbolDrawMap.set(seriesId, new SymbolDraw());\n\n        var mpData = createList$1(coordSys, seriesModel, mpModel);\n\n        // FIXME\n        mpModel.setData(mpData);\n\n        updateMarkerLayout(mpModel.getData(), seriesModel, api);\n\n        mpData.each(function (idx) {\n            var itemModel = mpData.getItemModel(idx);\n            var symbolSize = itemModel.getShallow('symbolSize');\n            if (typeof symbolSize === 'function') {\n                // FIXME  ECharts 2.x2.x \n                symbolSize = symbolSize(\n                    mpModel.getRawValue(idx), mpModel.getDataParams(idx)\n                );\n            }\n            mpData.setItemVisual(idx, {\n                symbolSize: symbolSize,\n                color: itemModel.get('itemStyle.normal.color')\n                    || seriesData.getVisual('color'),\n                symbol: itemModel.getShallow('symbol')\n            });\n        });\n\n        // TODO Text are wrong\n        symbolDraw.updateData(mpData);\n        this.group.add(symbolDraw.group);\n\n        // Set host model for tooltip\n        // FIXME\n        mpData.eachItemGraphicEl(function (el) {\n            el.traverse(function (child) {\n                child.dataModel = mpModel;\n            });\n        });\n\n        symbolDraw.__keep = true;\n\n        symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');\n    }\n});\n\n/**\n * @inner\n * @param {module:echarts/coord/*} [coordSys]\n * @param {module:echarts/model/Series} seriesModel\n * @param {module:echarts/model/Model} mpModel\n */\nfunction createList$1(coordSys, seriesModel, mpModel) {\n    var coordDimsInfos;\n    if (coordSys) {\n        coordDimsInfos = map(coordSys && coordSys.dimensions, function (coordDim) {\n            var info = seriesModel.getData().getDimensionInfo(\n                seriesModel.coordDimToDataDim(coordDim)[0]\n            ) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n            info.name = coordDim;\n            return info;\n        });\n    }\n    else {\n        coordDimsInfos =[{\n            name: 'value',\n            type: 'float'\n        }];\n    }\n\n    var mpData = new List(coordDimsInfos, mpModel);\n    var dataOpt = map(mpModel.get('data'), curry(\n            dataTransform, seriesModel\n        ));\n    if (coordSys) {\n        dataOpt = filter(\n            dataOpt, curry(dataFilter$1, coordSys)\n        );\n    }\n\n    mpData.initData(dataOpt, null,\n        coordSys ? dimValueGetter : function (item) {\n            return item.value;\n        }\n    );\n\n    return mpData;\n}\n\n// HINT Markpoint can't be used too much\nregisterPreprocessor(function (opt) {\n    // Make sure markPoint component is enabled\n    opt.markPoint = opt.markPoint || {};\n});\n\nMarkerModel.extend({\n\n    type: 'markLine',\n\n    defaultOption: {\n        zlevel: 0,\n        z: 5,\n\n        symbol: ['circle', 'arrow'],\n        symbolSize: [8, 16],\n\n        //symbolRotate: 0,\n\n        precision: 2,\n        tooltip: {\n            trigger: 'item'\n        },\n        label: {\n            normal: {\n                show: true,\n                position: 'end'\n            },\n            emphasis: {\n                show: true\n            }\n        },\n        lineStyle: {\n            normal: {\n                type: 'dashed'\n            },\n            emphasis: {\n                width: 3\n            }\n        },\n        animationEasing: 'linear'\n    }\n});\n\nvar markLineTransform = function (seriesModel, coordSys, mlModel, item) {\n    var data = seriesModel.getData();\n    // Special type markLine like 'min', 'max', 'average'\n    var mlType = item.type;\n\n    if (!isArray(item)\n        && (\n            mlType === 'min' || mlType === 'max' || mlType === 'average'\n            // In case\n            // data: [{\n            //   yAxis: 10\n            // }]\n            || (item.xAxis != null || item.yAxis != null)\n        )\n    ) {\n        var valueAxis;\n        var valueDataDim;\n        var value;\n\n        if (item.yAxis != null || item.xAxis != null) {\n            valueDataDim = item.yAxis != null ? 'y' : 'x';\n            valueAxis = coordSys.getAxis(valueDataDim);\n\n            value = retrieve(item.yAxis, item.xAxis);\n        }\n        else {\n            var axisInfo = getAxisInfo$1(item, data, coordSys, seriesModel);\n            valueDataDim = axisInfo.valueDataDim;\n            valueAxis = axisInfo.valueAxis;\n            value = numCalculate(data, valueDataDim, mlType);\n        }\n        var valueIndex = valueDataDim === 'x' ? 0 : 1;\n        var baseIndex = 1 - valueIndex;\n\n        var mlFrom = clone(item);\n        var mlTo = {};\n\n        mlFrom.type = null;\n\n        mlFrom.coord = [];\n        mlTo.coord = [];\n        mlFrom.coord[baseIndex] = -Infinity;\n        mlTo.coord[baseIndex] = Infinity;\n\n        var precision = mlModel.get('precision');\n        if (precision >= 0 && typeof value === 'number') {\n            value = +value.toFixed(Math.min(precision, 20));\n        }\n\n        mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;\n\n        item = [mlFrom, mlTo, { // Extra option for tooltip and label\n            type: mlType,\n            valueIndex: item.valueIndex,\n            // Force to use the value of calculated value.\n            value: value\n        }];\n    }\n\n    item = [\n        dataTransform(seriesModel, item[0]),\n        dataTransform(seriesModel, item[1]),\n        extend({}, item[2])\n    ];\n\n    // Avoid line data type is extended by from(to) data type\n    item[2].type = item[2].type || '';\n\n    // Merge from option and to option into line option\n    merge(item[2], item[0]);\n    merge(item[2], item[1]);\n\n    return item;\n};\n\nfunction isInifinity(val) {\n    return !isNaN(val) && !isFinite(val);\n}\n\n// If a markLine has one dim\nfunction ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n    var otherDimIndex = 1 - dimIndex;\n    var dimName = coordSys.dimensions[dimIndex];\n    return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex])\n        && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);\n}\n\nfunction markLineFilter(coordSys, item) {\n    if (coordSys.type === 'cartesian2d') {\n        var fromCoord = item[0].coord;\n        var toCoord = item[1].coord;\n        // In case\n        // {\n        //  markLine: {\n        //    data: [{ yAxis: 2 }]\n        //  }\n        // }\n        if (\n            fromCoord && toCoord &&\n            (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys)\n            || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))\n        ) {\n            return true;\n        }\n    }\n    return dataFilter$1(coordSys, item[0])\n        && dataFilter$1(coordSys, item[1]);\n}\n\nfunction updateSingleMarkerEndLayout(\n    data, idx, isFrom, seriesModel, api\n) {\n    var coordSys = seriesModel.coordinateSystem;\n    var itemModel = data.getItemModel(idx);\n\n    var point;\n    var xPx = parsePercent$1(itemModel.get('x'), api.getWidth());\n    var yPx = parsePercent$1(itemModel.get('y'), api.getHeight());\n    if (!isNaN(xPx) && !isNaN(yPx)) {\n        point = [xPx, yPx];\n    }\n    else {\n        // Chart like bar may have there own marker positioning logic\n        if (seriesModel.getMarkerPosition) {\n            // Use the getMarkerPoisition\n            point = seriesModel.getMarkerPosition(\n                data.getValues(data.dimensions, idx)\n            );\n        }\n        else {\n            var dims = coordSys.dimensions;\n            var x = data.get(dims[0], idx);\n            var y = data.get(dims[1], idx);\n            point = coordSys.dataToPoint([x, y]);\n        }\n        // Expand line to the edge of grid if value on one axis is Inifnity\n        // In case\n        //  markLine: {\n        //    data: [{\n        //      yAxis: 2\n        //      // or\n        //      type: 'average'\n        //    }]\n        //  }\n        if (coordSys.type === 'cartesian2d') {\n            var xAxis = coordSys.getAxis('x');\n            var yAxis = coordSys.getAxis('y');\n            var dims = coordSys.dimensions;\n            if (isInifinity(data.get(dims[0], idx))) {\n                point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);\n            }\n            else if (isInifinity(data.get(dims[1], idx))) {\n                point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);\n            }\n        }\n\n        // Use x, y if has any\n        if (!isNaN(xPx)) {\n            point[0] = xPx;\n        }\n        if (!isNaN(yPx)) {\n            point[1] = yPx;\n        }\n    }\n\n    data.setItemLayout(idx, point);\n}\n\nMarkerView.extend({\n\n    type: 'markLine',\n\n    updateLayout: function (markLineModel, ecModel, api) {\n        ecModel.eachSeries(function (seriesModel) {\n            var mlModel = seriesModel.markLineModel;\n            if (mlModel) {\n                var mlData = mlModel.getData();\n                var fromData = mlModel.__from;\n                var toData = mlModel.__to;\n                // Update visual and layout of from symbol and to symbol\n                fromData.each(function (idx) {\n                    updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);\n                    updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);\n                });\n                // Update layout of line\n                mlData.each(function (idx) {\n                    mlData.setItemLayout(idx, [\n                        fromData.getItemLayout(idx),\n                        toData.getItemLayout(idx)\n                    ]);\n                });\n\n                this.markerGroupMap.get(seriesModel.id).updateLayout();\n\n            }\n        }, this);\n    },\n\n    renderSeries: function (seriesModel, mlModel, ecModel, api) {\n        var coordSys = seriesModel.coordinateSystem;\n        var seriesId = seriesModel.id;\n        var seriesData = seriesModel.getData();\n\n        var lineDrawMap = this.markerGroupMap;\n        var lineDraw = lineDrawMap.get(seriesId)\n            || lineDrawMap.set(seriesId, new LineDraw());\n        this.group.add(lineDraw.group);\n\n        var mlData = createList$2(coordSys, seriesModel, mlModel);\n\n        var fromData = mlData.from;\n        var toData = mlData.to;\n        var lineData = mlData.line;\n\n        mlModel.__from = fromData;\n        mlModel.__to = toData;\n        // Line data for tooltip and formatter\n        mlModel.setData(lineData);\n\n        var symbolType = mlModel.get('symbol');\n        var symbolSize = mlModel.get('symbolSize');\n        if (!isArray(symbolType)) {\n            symbolType = [symbolType, symbolType];\n        }\n        if (typeof symbolSize === 'number') {\n            symbolSize = [symbolSize, symbolSize];\n        }\n\n        // Update visual and layout of from symbol and to symbol\n        mlData.from.each(function (idx) {\n            updateDataVisualAndLayout(fromData, idx, true);\n            updateDataVisualAndLayout(toData, idx, false);\n        });\n\n        // Update visual and layout of line\n        lineData.each(function (idx) {\n            var lineColor = lineData.getItemModel(idx).get('lineStyle.normal.color');\n            lineData.setItemVisual(idx, {\n                color: lineColor || fromData.getItemVisual(idx, 'color')\n            });\n            lineData.setItemLayout(idx, [\n                fromData.getItemLayout(idx),\n                toData.getItemLayout(idx)\n            ]);\n\n            lineData.setItemVisual(idx, {\n                'fromSymbolSize': fromData.getItemVisual(idx, 'symbolSize'),\n                'fromSymbol': fromData.getItemVisual(idx, 'symbol'),\n                'toSymbolSize': toData.getItemVisual(idx, 'symbolSize'),\n                'toSymbol': toData.getItemVisual(idx, 'symbol')\n            });\n        });\n\n        lineDraw.updateData(lineData);\n\n        // Set host model for tooltip\n        // FIXME\n        mlData.line.eachItemGraphicEl(function (el, idx) {\n            el.traverse(function (child) {\n                child.dataModel = mlModel;\n            });\n        });\n\n        function updateDataVisualAndLayout(data, idx, isFrom) {\n            var itemModel = data.getItemModel(idx);\n\n            updateSingleMarkerEndLayout(\n                data, idx, isFrom, seriesModel, api\n            );\n\n            data.setItemVisual(idx, {\n                symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],\n                symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],\n                color: itemModel.get('itemStyle.normal.color') || seriesData.getVisual('color')\n            });\n        }\n\n        lineDraw.__keep = true;\n\n        lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');\n    }\n});\n\n/**\n * @inner\n * @param {module:echarts/coord/*} coordSys\n * @param {module:echarts/model/Series} seriesModel\n * @param {module:echarts/model/Model} mpModel\n */\nfunction createList$2(coordSys, seriesModel, mlModel) {\n\n    var coordDimsInfos;\n    if (coordSys) {\n        coordDimsInfos = map(coordSys && coordSys.dimensions, function (coordDim) {\n            var info = seriesModel.getData().getDimensionInfo(\n                seriesModel.coordDimToDataDim(coordDim)[0]\n            ) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n            info.name = coordDim;\n            return info;\n        });\n    }\n    else {\n        coordDimsInfos =[{\n            name: 'value',\n            type: 'float'\n        }];\n    }\n\n    var fromData = new List(coordDimsInfos, mlModel);\n    var toData = new List(coordDimsInfos, mlModel);\n    // No dimensions\n    var lineData = new List([], mlModel);\n\n    var optData = map(mlModel.get('data'), curry(\n        markLineTransform, seriesModel, coordSys, mlModel\n    ));\n    if (coordSys) {\n        optData = filter(\n            optData, curry(markLineFilter, coordSys)\n        );\n    }\n    var dimValueGetter$$1 = coordSys ? dimValueGetter : function (item) {\n        return item.value;\n    };\n    fromData.initData(\n        map(optData, function (item) { return item[0]; }),\n        null, dimValueGetter$$1\n    );\n    toData.initData(\n        map(optData, function (item) { return item[1]; }),\n        null, dimValueGetter$$1\n    );\n    lineData.initData(\n        map(optData, function (item) { return item[2]; })\n    );\n    lineData.hasItemOption = true;\n\n    return {\n        from: fromData,\n        to: toData,\n        line: lineData\n    };\n}\n\nregisterPreprocessor(function (opt) {\n    // Make sure markLine component is enabled\n    opt.markLine = opt.markLine || {};\n});\n\nMarkerModel.extend({\n\n    type: 'markArea',\n\n    defaultOption: {\n        zlevel: 0,\n        // PENDING\n        z: 1,\n        tooltip: {\n            trigger: 'item'\n        },\n        // markArea should fixed on the coordinate system\n        animation: false,\n        label: {\n            normal: {\n                show: true,\n                position: 'top'\n            },\n            emphasis: {\n                show: true,\n                position: 'top'\n            }\n        },\n        itemStyle: {\n            normal: {\n                // color and borderColor default to use color from series\n                // color: 'auto'\n                // borderColor: 'auto'\n                borderWidth: 0\n            }\n        }\n    }\n});\n\n// TODO Better on polar\n\nvar markAreaTransform = function (seriesModel, coordSys, maModel, item) {\n    var lt = dataTransform(seriesModel, item[0]);\n    var rb = dataTransform(seriesModel, item[1]);\n    var retrieve$$1 = retrieve;\n\n    // FIXME make sure lt is less than rb\n    var ltCoord = lt.coord;\n    var rbCoord = rb.coord;\n    ltCoord[0] = retrieve$$1(ltCoord[0], -Infinity);\n    ltCoord[1] = retrieve$$1(ltCoord[1], -Infinity);\n\n    rbCoord[0] = retrieve$$1(rbCoord[0], Infinity);\n    rbCoord[1] = retrieve$$1(rbCoord[1], Infinity);\n\n    // Merge option into one\n    var result = mergeAll([{}, lt, rb]);\n\n    result.coord = [\n        lt.coord, rb.coord\n    ];\n    result.x0 = lt.x;\n    result.y0 = lt.y;\n    result.x1 = rb.x;\n    result.y1 = rb.y;\n    return result;\n};\n\nfunction isInifinity$1(val) {\n    return !isNaN(val) && !isFinite(val);\n}\n\n// If a markArea has one dim\nfunction ifMarkLineHasOnlyDim$1(dimIndex, fromCoord, toCoord, coordSys) {\n    var otherDimIndex = 1 - dimIndex;\n    return isInifinity$1(fromCoord[otherDimIndex]) && isInifinity$1(toCoord[otherDimIndex]);\n}\n\nfunction markAreaFilter(coordSys, item) {\n    var fromCoord = item.coord[0];\n    var toCoord = item.coord[1];\n    if (coordSys.type === 'cartesian2d') {\n        // In case\n        // {\n        //  markArea: {\n        //    data: [{ yAxis: 2 }]\n        //  }\n        // }\n        if (\n            fromCoord && toCoord &&\n            (ifMarkLineHasOnlyDim$1(1, fromCoord, toCoord, coordSys)\n            || ifMarkLineHasOnlyDim$1(0, fromCoord, toCoord, coordSys))\n        ) {\n            return true;\n        }\n    }\n    return dataFilter$1(coordSys, {\n            coord: fromCoord,\n            x: item.x0,\n            y: item.y0\n        })\n        || dataFilter$1(coordSys, {\n            coord: toCoord,\n            x: item.x1,\n            y: item.y1\n        });\n}\n\n// dims can be ['x0', 'y0'], ['x1', 'y1'], ['x0', 'y1'], ['x1', 'y0']\nfunction getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var itemModel = data.getItemModel(idx);\n\n    var point;\n    var xPx = parsePercent$1(itemModel.get(dims[0]), api.getWidth());\n    var yPx = parsePercent$1(itemModel.get(dims[1]), api.getHeight());\n    if (!isNaN(xPx) && !isNaN(yPx)) {\n        point = [xPx, yPx];\n    }\n    else {\n        // Chart like bar may have there own marker positioning logic\n        if (seriesModel.getMarkerPosition) {\n            // Use the getMarkerPoisition\n            point = seriesModel.getMarkerPosition(\n                data.getValues(dims, idx)\n            );\n        }\n        else {\n            var x = data.get(dims[0], idx);\n            var y = data.get(dims[1], idx);\n            point = coordSys.dataToPoint([x, y], true);\n        }\n        if (coordSys.type === 'cartesian2d') {\n            var xAxis = coordSys.getAxis('x');\n            var yAxis = coordSys.getAxis('y');\n            var x = data.get(dims[0], idx);\n            var y = data.get(dims[1], idx);\n            if (isInifinity$1(x)) {\n                point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === 'x0' ? 0 : 1]);\n            }\n            else if (isInifinity$1(y)) {\n                point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === 'y0' ? 0 : 1]);\n            }\n        }\n\n        // Use x, y if has any\n        if (!isNaN(xPx)) {\n            point[0] = xPx;\n        }\n        if (!isNaN(yPx)) {\n            point[1] = yPx;\n        }\n    }\n\n    return point;\n}\n\nvar dimPermutations = [['x0', 'y0'], ['x1', 'y0'], ['x1', 'y1'], ['x0', 'y1']];\n\nMarkerView.extend({\n\n    type: 'markArea',\n\n    updateLayout: function (markAreaModel, ecModel, api) {\n        ecModel.eachSeries(function (seriesModel) {\n            var maModel = seriesModel.markAreaModel;\n            if (maModel) {\n                var areaData = maModel.getData();\n                areaData.each(function (idx) {\n                    var points = map(dimPermutations, function (dim) {\n                        return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);\n                    });\n                    // Layout\n                    areaData.setItemLayout(idx, points);\n                    var el = areaData.getItemGraphicEl(idx);\n                    el.setShape('points', points);\n                });\n            }\n        }, this);\n    },\n\n    renderSeries: function (seriesModel, maModel, ecModel, api) {\n        var coordSys = seriesModel.coordinateSystem;\n        var seriesName = seriesModel.name;\n        var seriesData = seriesModel.getData();\n\n        var areaGroupMap = this.markerGroupMap;\n        var polygonGroup = areaGroupMap.get(seriesName)\n            || areaGroupMap.set(seriesName, {group: new Group()});\n\n        this.group.add(polygonGroup.group);\n        polygonGroup.__keep = true;\n\n        var areaData = createList$3(coordSys, seriesModel, maModel);\n\n        // Line data for tooltip and formatter\n        maModel.setData(areaData);\n\n        // Update visual and layout of line\n        areaData.each(function (idx) {\n            // Layout\n            areaData.setItemLayout(idx, map(dimPermutations, function (dim) {\n                return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);\n            }));\n\n            // Visual\n            areaData.setItemVisual(idx, {\n                color: seriesData.getVisual('color')\n            });\n        });\n\n\n        areaData.diff(polygonGroup.__data)\n            .add(function (idx) {\n                var polygon = new Polygon({\n                    shape: {\n                        points: areaData.getItemLayout(idx)\n                    }\n                });\n                areaData.setItemGraphicEl(idx, polygon);\n                polygonGroup.group.add(polygon);\n            })\n            .update(function (newIdx, oldIdx) {\n                var polygon = polygonGroup.__data.getItemGraphicEl(oldIdx);\n                updateProps(polygon, {\n                    shape: {\n                        points: areaData.getItemLayout(newIdx)\n                    }\n                }, maModel, newIdx);\n                polygonGroup.group.add(polygon);\n                areaData.setItemGraphicEl(newIdx, polygon);\n            })\n            .remove(function (idx) {\n                var polygon = polygonGroup.__data.getItemGraphicEl(idx);\n                polygonGroup.group.remove(polygon);\n            })\n            .execute();\n\n        areaData.eachItemGraphicEl(function (polygon, idx) {\n            var itemModel = areaData.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            var labelHoverModel = itemModel.getModel('label.emphasis');\n            var color = areaData.getItemVisual(idx, 'color');\n            polygon.useStyle(\n                defaults(\n                    itemModel.getModel('itemStyle.normal').getItemStyle(),\n                    {\n                        fill: modifyAlpha(color, 0.4),\n                        stroke: color\n                    }\n                )\n            );\n\n            polygon.hoverStyle = itemModel.getModel('itemStyle.emphasis').getItemStyle();\n\n            setLabelStyle(\n                polygon.style, polygon.hoverStyle, labelModel, labelHoverModel,\n                {\n                    labelFetcher: maModel,\n                    labelDataIndex: idx,\n                    defaultText: areaData.getName(idx) || '',\n                    isRectText: true,\n                    autoColor: color\n                }\n            );\n\n            setHoverStyle(polygon, {});\n\n            polygon.dataModel = maModel;\n        });\n\n        polygonGroup.__data = areaData;\n\n        polygonGroup.group.silent = maModel.get('silent') || seriesModel.get('silent');\n    }\n});\n\n/**\n * @inner\n * @param {module:echarts/coord/*} coordSys\n * @param {module:echarts/model/Series} seriesModel\n * @param {module:echarts/model/Model} mpModel\n */\nfunction createList$3(coordSys, seriesModel, maModel) {\n\n    var coordDimsInfos;\n    var areaData;\n    var dims = ['x0', 'y0', 'x1', 'y1'];\n    if (coordSys) {\n        coordDimsInfos = map(coordSys && coordSys.dimensions, function (coordDim) {\n            var info = seriesModel.getData().getDimensionInfo(\n                seriesModel.coordDimToDataDim(coordDim)[0]\n            ) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n            info.name = coordDim;\n            return info;\n        });\n        areaData = new List(map(dims, function (dim, idx) {\n            return {\n                name: dim,\n                type: coordDimsInfos[idx % 2].type\n            };\n        }), maModel);\n    }\n    else {\n        coordDimsInfos =[{\n            name: 'value',\n            type: 'float'\n        }];\n        areaData = new List(coordDimsInfos, maModel);\n    }\n\n    var optData = map(maModel.get('data'), curry(\n        markAreaTransform, seriesModel, coordSys, maModel\n    ));\n    if (coordSys) {\n        optData = filter(\n            optData, curry(markAreaFilter, coordSys)\n        );\n    }\n\n    var dimValueGetter$$1 = coordSys ? function (item, dimName, dataIndex, dimIndex) {\n        return item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];\n    } : function (item) {\n        return item.value;\n    };\n    areaData.initData(optData, null, dimValueGetter$$1);\n    areaData.hasItemOption = true;\n    return areaData;\n}\n\nregisterPreprocessor(function (opt) {\n    // Make sure markArea component is enabled\n    opt.markArea = opt.markArea || {};\n});\n\nvar preprocessor$3 = function (option) {\n    var timelineOpt = option && option.timeline;\n\n    if (!isArray(timelineOpt)) {\n        timelineOpt = timelineOpt ? [timelineOpt] : [];\n    }\n\n    each$1(timelineOpt, function (opt) {\n        if (!opt) {\n            return;\n        }\n\n        compatibleEC2(opt);\n    });\n};\n\nfunction compatibleEC2(opt) {\n    var type = opt.type;\n\n    var ec2Types = {'number': 'value', 'time': 'time'};\n\n    // Compatible with ec2\n    if (ec2Types[type]) {\n        opt.axisType = ec2Types[type];\n        delete opt.type;\n    }\n\n    transferItem(opt);\n\n    if (has$2(opt, 'controlPosition')) {\n        var controlStyle = opt.controlStyle || (opt.controlStyle = {});\n        if (!has$2(controlStyle, 'position')) {\n            controlStyle.position = opt.controlPosition;\n        }\n        if (controlStyle.position === 'none' && !has$2(controlStyle, 'show')) {\n            controlStyle.show = false;\n            delete controlStyle.position;\n        }\n        delete opt.controlPosition;\n    }\n\n    each$1(opt.data || [], function (dataItem) {\n        if (isObject(dataItem) && !isArray(dataItem)) {\n            if (!has$2(dataItem, 'value') && has$2(dataItem, 'name')) {\n                // In ec2, using name as value.\n                dataItem.value = dataItem.name;\n            }\n            transferItem(dataItem);\n        }\n    });\n}\n\nfunction transferItem(opt) {\n    var itemStyle = opt.itemStyle || (opt.itemStyle = {});\n\n    var itemStyleEmphasis = itemStyle.emphasis || (itemStyle.emphasis = {});\n\n    // Transfer label out\n    var label = opt.label || (opt.label || {});\n    var labelNormal = label.normal || (label.normal = {});\n    var excludeLabelAttr = {normal: 1, emphasis: 1};\n\n    each$1(label, function (value, name) {\n        if (!excludeLabelAttr[name] && !has$2(labelNormal, name)) {\n            labelNormal[name] = value;\n        }\n    });\n\n    if (itemStyleEmphasis.label && !has$2(label, 'emphasis')) {\n        label.emphasis = itemStyleEmphasis.label;\n        delete itemStyleEmphasis.label;\n    }\n}\n\nfunction has$2(obj, attr) {\n    return obj.hasOwnProperty(attr);\n}\n\nComponentModel.registerSubTypeDefaulter('timeline', function () {\n    // Only slider now.\n    return 'slider';\n});\n\nregisterAction(\n\n    {type: 'timelineChange', event: 'timelineChanged', update: 'prepareAndUpdate'},\n\n    function (payload, ecModel) {\n\n        var timelineModel = ecModel.getComponent('timeline');\n        if (timelineModel && payload.currentIndex != null) {\n            timelineModel.setCurrentIndex(payload.currentIndex);\n\n            if (!timelineModel.get('loop', true) && timelineModel.isIndexMax()) {\n                timelineModel.setPlayState(false);\n            }\n        }\n\n        // Set normalized currentIndex to payload.\n        ecModel.resetOption('timeline');\n\n        return defaults({\n            currentIndex: timelineModel.option.currentIndex\n        }, payload);\n    }\n);\n\nregisterAction(\n\n    {type: 'timelinePlayChange', event: 'timelinePlayChanged', update: 'update'},\n\n    function (payload, ecModel) {\n        var timelineModel = ecModel.getComponent('timeline');\n        if (timelineModel && payload.playState != null) {\n            timelineModel.setPlayState(payload.playState);\n        }\n    }\n);\n\nvar TimelineModel = ComponentModel.extend({\n\n    type: 'timeline',\n\n    layoutMode: 'box',\n\n    /**\n     * @protected\n     */\n    defaultOption: {\n\n        zlevel: 0,                  // \n        z: 4,                       // \n        show: true,\n\n        axisType: 'time',  //  value, category\n\n        realtime: true,\n\n        left: '20%',\n        top: null,\n        right: '20%',\n        bottom: 0,\n        width: null,\n        height: 40,\n        padding: 5,\n\n        controlPosition: 'left',           // 'left' 'right' 'top' 'bottom' 'none'\n        autoPlay: false,\n        rewind: false,                     // \n        loop: true,\n        playInterval: 2000,                // ms\n\n        currentIndex: 0,\n\n        itemStyle: {\n            normal: {},\n            emphasis: {}\n        },\n        label: {\n            normal: {\n                color: '#000'\n            },\n            emphasis: {}\n        },\n\n        data: []\n    },\n\n    /**\n     * @override\n     */\n    init: function (option, parentModel, ecModel) {\n\n        /**\n         * @private\n         * @type {module:echarts/data/List}\n         */\n        this._data;\n\n        /**\n         * @private\n         * @type {Array.<string>}\n         */\n        this._names;\n\n        this.mergeDefaultAndTheme(option, ecModel);\n        this._initData();\n    },\n\n    /**\n     * @override\n     */\n    mergeOption: function (option) {\n        TimelineModel.superApply(this, 'mergeOption', arguments);\n        this._initData();\n    },\n\n    /**\n     * @param {number} [currentIndex]\n     */\n    setCurrentIndex: function (currentIndex) {\n        if (currentIndex == null) {\n            currentIndex = this.option.currentIndex;\n        }\n        var count = this._data.count();\n\n        if (this.option.loop) {\n            currentIndex = (currentIndex % count + count) % count;\n        }\n        else {\n            currentIndex >= count && (currentIndex = count - 1);\n            currentIndex < 0 && (currentIndex = 0);\n        }\n\n        this.option.currentIndex = currentIndex;\n    },\n\n    /**\n     * @return {number} currentIndex\n     */\n    getCurrentIndex: function () {\n        return this.option.currentIndex;\n    },\n\n    /**\n     * @return {boolean}\n     */\n    isIndexMax: function () {\n        return this.getCurrentIndex() >= this._data.count() - 1;\n    },\n\n    /**\n     * @param {boolean} state true: play, false: stop\n     */\n    setPlayState: function (state) {\n        this.option.autoPlay = !!state;\n    },\n\n    /**\n     * @return {boolean} true: play, false: stop\n     */\n    getPlayState: function () {\n        return !!this.option.autoPlay;\n    },\n\n    /**\n     * @private\n     */\n    _initData: function () {\n        var thisOption = this.option;\n        var dataArr = thisOption.data || [];\n        var axisType = thisOption.axisType;\n        var names = this._names = [];\n\n        if (axisType === 'category') {\n            var idxArr = [];\n            each$1(dataArr, function (item, index) {\n                var value = getDataItemValue(item);\n                var newItem;\n\n                if (isObject(item)) {\n                    newItem = clone(item);\n                    newItem.value = index;\n                }\n                else {\n                    newItem = index;\n                }\n\n                idxArr.push(newItem);\n\n                if (!isString(value) && (value == null || isNaN(value))) {\n                    value = '';\n                }\n\n                names.push(value + '');\n            });\n            dataArr = idxArr;\n        }\n\n        var dimType = ({category: 'ordinal', time: 'time'})[axisType] || 'number';\n\n        var data = this._data = new List([{name: 'value', type: dimType}], this);\n\n        data.initData(dataArr, names);\n    },\n\n    getData: function () {\n        return this._data;\n    },\n\n    /**\n     * @public\n     * @return {Array.<string>} categoreis\n     */\n    getCategories: function () {\n        if (this.get('axisType') === 'category') {\n            return this._names.slice();\n        }\n    }\n\n});\n\nvar SliderTimelineModel = TimelineModel.extend({\n\n    type: 'timeline.slider',\n\n    /**\n     * @protected\n     */\n    defaultOption: {\n\n        backgroundColor: 'rgba(0,0,0,0)',   // \n        borderColor: '#ccc',               // \n        borderWidth: 0,                    // px0\n\n        orient: 'horizontal',              // 'vertical'\n        inverse: false,\n\n        tooltip: {                          // boolean or Object\n            trigger: 'item'                 // data item may also have tootip attr.\n        },\n\n        symbol: 'emptyCircle',\n        symbolSize: 10,\n\n        lineStyle: {\n            show: true,\n            width: 2,\n            color: '#304654'\n        },\n        label: {                            // \n            position: 'auto',           // auto left right top bottom\n                                        // When using number, label position is not\n                                        // restricted by viewRect.\n                                        // positive: right/bottom, negative: left/top\n            normal: {\n                show: true,\n                interval: 'auto',\n                rotate: 0,\n                // formatter: null,\n                // TEXTSTYLE\n                color: '#304654'\n            },\n            emphasis: {\n                show: true,\n                // TEXTSTYLE\n                color: '#c23531'\n            }\n        },\n        itemStyle: {\n            normal: {\n                color: '#304654',\n                borderWidth: 1\n            },\n            emphasis: {\n                color: '#c23531'\n            }\n        },\n\n        checkpointStyle: {\n            symbol: 'circle',\n            symbolSize: 13,\n            color: '#c23531',\n            borderWidth: 5,\n            borderColor: 'rgba(194,53,49, 0.5)',\n            animation: true,\n            animationDuration: 300,\n            animationEasing: 'quinticInOut'\n        },\n\n        controlStyle: {\n            show: true,\n            showPlayBtn: true,\n            showPrevBtn: true,\n            showNextBtn: true,\n            itemSize: 22,\n            itemGap: 12,\n            position: 'left',  // 'left' 'right' 'top' 'bottom'\n            playIcon: 'path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z', // jshint ignore:line\n            stopIcon: 'path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z', // jshint ignore:line\n            nextIcon: 'path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z', // jshint ignore:line\n            prevIcon: 'path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z', // jshint ignore:line\n            normal: {\n                color: '#304654',\n                borderColor: '#304654',\n                borderWidth: 1\n            },\n            emphasis: {\n                color: '#c23531',\n                borderColor: '#c23531',\n                borderWidth: 2\n            }\n        },\n        data: []\n    }\n\n});\n\nmixin(SliderTimelineModel, dataFormatMixin);\n\nvar TimelineView = Component.extend({\n    type: 'timeline'\n});\n\n/**\n * Extend axis 2d\n * @constructor module:echarts/coord/cartesian/Axis2D\n * @extends {module:echarts/coord/cartesian/Axis}\n * @param {string} dim\n * @param {*} scale\n * @param {Array.<number>} coordExtent\n * @param {string} axisType\n * @param {string} position\n */\nvar TimelineAxis = function (dim, scale, coordExtent, axisType) {\n\n    Axis.call(this, dim, scale, coordExtent);\n\n    /**\n     * Axis type\n     *  - 'category'\n     *  - 'value'\n     *  - 'time'\n     *  - 'log'\n     * @type {string}\n     */\n    this.type = axisType || 'value';\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this._autoLabelInterval;\n\n    /**\n     * Axis model\n     * @param {module:echarts/component/TimelineModel}\n     */\n    this.model = null;\n};\n\nTimelineAxis.prototype = {\n\n    constructor: TimelineAxis,\n\n    /**\n     * @public\n     * @return {number}\n     */\n    getLabelInterval: function () {\n        var timelineModel = this.model;\n        var labelModel = timelineModel.getModel('label.normal');\n        var labelInterval = labelModel.get('interval');\n\n        if (labelInterval != null && labelInterval != 'auto') {\n            return labelInterval;\n        }\n\n        var labelInterval = this._autoLabelInterval;\n\n        if (!labelInterval) {\n            labelInterval = this._autoLabelInterval = getAxisLabelInterval(\n                map(this.scale.getTicks(), this.dataToCoord, this),\n                getFormattedLabels(this, labelModel.get('formatter')),\n                labelModel.getFont(),\n                timelineModel.get('orient') === 'horizontal' ? 0 : 90,\n                labelModel.get('rotate')\n            );\n        }\n\n        return labelInterval;\n    },\n\n    /**\n     * If label is ignored.\n     * Automatically used when axis is category and label can not be all shown\n     * @public\n     * @param  {number} idx\n     * @return {boolean}\n     */\n    isLabelIgnored: function (idx) {\n        if (this.type === 'category') {\n            var labelInterval = this.getLabelInterval();\n            return ((typeof labelInterval === 'function')\n                && !labelInterval(idx, this.scale.getLabel(idx)))\n                || idx % (labelInterval + 1);\n        }\n    }\n\n};\n\ninherits(TimelineAxis, Axis);\n\nvar bind$6 = bind;\nvar each$30 = each$1;\n\nvar PI$4 = Math.PI;\n\nTimelineView.extend({\n\n    type: 'timeline.slider',\n\n    init: function (ecModel, api) {\n\n        this.api = api;\n\n        /**\n         * @private\n         * @type {module:echarts/component/timeline/TimelineAxis}\n         */\n        this._axis;\n\n        /**\n         * @private\n         * @type {module:zrender/core/BoundingRect}\n         */\n        this._viewRect;\n\n        /**\n         * @type {number}\n         */\n        this._timer;\n\n        /**\n         * @type {module:zrender/Element}\n         */\n        this._currentPointer;\n\n        /**\n         * @type {module:zrender/container/Group}\n         */\n        this._mainGroup;\n\n        /**\n         * @type {module:zrender/container/Group}\n         */\n        this._labelGroup;\n    },\n\n    /**\n     * @override\n     */\n    render: function (timelineModel, ecModel, api, payload) {\n        this.model = timelineModel;\n        this.api = api;\n        this.ecModel = ecModel;\n\n        this.group.removeAll();\n\n        if (timelineModel.get('show', true)) {\n\n            var layoutInfo = this._layout(timelineModel, api);\n            var mainGroup = this._createGroup('mainGroup');\n            var labelGroup = this._createGroup('labelGroup');\n\n            /**\n             * @private\n             * @type {module:echarts/component/timeline/TimelineAxis}\n             */\n            var axis = this._axis = this._createAxis(layoutInfo, timelineModel);\n\n            timelineModel.formatTooltip = function (dataIndex) {\n                return encodeHTML(axis.scale.getLabel(dataIndex));\n            };\n\n            each$30(\n                ['AxisLine', 'AxisTick', 'Control', 'CurrentPointer'],\n                function (name) {\n                    this['_render' + name](layoutInfo, mainGroup, axis, timelineModel);\n                },\n                this\n            );\n\n            this._renderAxisLabel(layoutInfo, labelGroup, axis, timelineModel);\n            this._position(layoutInfo, timelineModel);\n        }\n\n        this._doPlayStop();\n    },\n\n    /**\n     * @override\n     */\n    remove: function () {\n        this._clearTimer();\n        this.group.removeAll();\n    },\n\n    /**\n     * @override\n     */\n    dispose: function () {\n        this._clearTimer();\n    },\n\n    _layout: function (timelineModel, api) {\n        var labelPosOpt = timelineModel.get('label.normal.position');\n        var orient = timelineModel.get('orient');\n        var viewRect = getViewRect$4(timelineModel, api);\n        // Auto label offset.\n        if (labelPosOpt == null || labelPosOpt === 'auto') {\n            labelPosOpt = orient === 'horizontal'\n                ? ((viewRect.y + viewRect.height / 2) < api.getHeight() / 2 ? '-' : '+')\n                : ((viewRect.x + viewRect.width / 2) < api.getWidth() / 2 ? '+' : '-');\n        }\n        else if (isNaN(labelPosOpt)) {\n            labelPosOpt = ({\n                horizontal: {top: '-', bottom: '+'},\n                vertical: {left: '-', right: '+'}\n            })[orient][labelPosOpt];\n        }\n\n        var labelAlignMap = {\n            horizontal: 'center',\n            vertical: (labelPosOpt >= 0 || labelPosOpt === '+') ? 'left' : 'right'\n        };\n\n        var labelBaselineMap = {\n            horizontal: (labelPosOpt >= 0 || labelPosOpt === '+') ? 'top' : 'bottom',\n            vertical: 'middle'\n        };\n        var rotationMap = {\n            horizontal: 0,\n            vertical: PI$4 / 2\n        };\n\n        // Position\n        var mainLength = orient === 'vertical' ? viewRect.height : viewRect.width;\n\n        var controlModel = timelineModel.getModel('controlStyle');\n        var showControl = controlModel.get('show');\n        var controlSize = showControl ? controlModel.get('itemSize') : 0;\n        var controlGap = showControl ? controlModel.get('itemGap') : 0;\n        var sizePlusGap = controlSize + controlGap;\n\n        // Special label rotate.\n        var labelRotation = timelineModel.get('label.normal.rotate') || 0;\n        labelRotation = labelRotation * PI$4 / 180; // To radian.\n\n        var playPosition;\n        var prevBtnPosition;\n        var nextBtnPosition;\n        var axisExtent;\n        var controlPosition = controlModel.get('position', true);\n        var showControl = controlModel.get('show', true);\n        var showPlayBtn = showControl && controlModel.get('showPlayBtn', true);\n        var showPrevBtn = showControl && controlModel.get('showPrevBtn', true);\n        var showNextBtn = showControl && controlModel.get('showNextBtn', true);\n        var xLeft = 0;\n        var xRight = mainLength;\n\n        // position[0] means left, position[1] means middle.\n        if (controlPosition === 'left' || controlPosition === 'bottom') {\n            showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);\n            showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);\n            showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n        }\n        else { // 'top' 'right'\n            showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n            showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);\n            showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n        }\n        axisExtent = [xLeft, xRight];\n\n        if (timelineModel.get('inverse')) {\n            axisExtent.reverse();\n        }\n\n        return {\n            viewRect: viewRect,\n            mainLength: mainLength,\n            orient: orient,\n\n            rotation: rotationMap[orient],\n            labelRotation: labelRotation,\n            labelPosOpt: labelPosOpt,\n            labelAlign: timelineModel.get('label.normal.align') || labelAlignMap[orient],\n            labelBaseline: timelineModel.get('label.normal.verticalAlign')\n                || timelineModel.get('label.normal.baseline')\n                || labelBaselineMap[orient],\n\n            // Based on mainGroup.\n            playPosition: playPosition,\n            prevBtnPosition: prevBtnPosition,\n            nextBtnPosition: nextBtnPosition,\n            axisExtent: axisExtent,\n\n            controlSize: controlSize,\n            controlGap: controlGap\n        };\n    },\n\n    _position: function (layoutInfo, timelineModel) {\n        // Position is be called finally, because bounding rect is needed for\n        // adapt content to fill viewRect (auto adapt offset).\n\n        // Timeline may be not all in the viewRect when 'offset' is specified\n        // as a number, because it is more appropriate that label aligns at\n        // 'offset' but not the other edge defined by viewRect.\n\n        var mainGroup = this._mainGroup;\n        var labelGroup = this._labelGroup;\n\n        var viewRect = layoutInfo.viewRect;\n        if (layoutInfo.orient === 'vertical') {\n            // transfrom to horizontal, inverse rotate by left-top point.\n            var m = create$1();\n            var rotateOriginX = viewRect.x;\n            var rotateOriginY = viewRect.y + viewRect.height;\n            translate(m, m, [-rotateOriginX, -rotateOriginY]);\n            rotate(m, m, -PI$4 / 2);\n            translate(m, m, [rotateOriginX, rotateOriginY]);\n            viewRect = viewRect.clone();\n            viewRect.applyTransform(m);\n        }\n\n        var viewBound = getBound(viewRect);\n        var mainBound = getBound(mainGroup.getBoundingRect());\n        var labelBound = getBound(labelGroup.getBoundingRect());\n\n        var mainPosition = mainGroup.position;\n        var labelsPosition = labelGroup.position;\n\n        labelsPosition[0] = mainPosition[0] = viewBound[0][0];\n\n        var labelPosOpt = layoutInfo.labelPosOpt;\n\n        if (isNaN(labelPosOpt)) { // '+' or '-'\n            var mainBoundIdx = labelPosOpt === '+' ? 0 : 1;\n            toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);\n            toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);\n        }\n        else {\n            var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;\n            toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);\n            labelsPosition[1] = mainPosition[1] + labelPosOpt;\n        }\n\n        mainGroup.attr('position', mainPosition);\n        labelGroup.attr('position', labelsPosition);\n        mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;\n\n        setOrigin(mainGroup);\n        setOrigin(labelGroup);\n\n        function setOrigin(targetGroup) {\n            var pos = targetGroup.position;\n            targetGroup.origin = [\n                viewBound[0][0] - pos[0],\n                viewBound[1][0] - pos[1]\n            ];\n        }\n\n        function getBound(rect) {\n            // [[xmin, xmax], [ymin, ymax]]\n            return [\n                [rect.x, rect.x + rect.width],\n                [rect.y, rect.y + rect.height]\n            ];\n        }\n\n        function toBound(fromPos, from, to, dimIdx, boundIdx) {\n            fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];\n        }\n    },\n\n    _createAxis: function (layoutInfo, timelineModel) {\n        var data = timelineModel.getData();\n        var axisType = timelineModel.get('axisType');\n\n        var scale = createScaleByModel(timelineModel, axisType);\n        var dataExtent = data.getDataExtent('value');\n        scale.setExtent(dataExtent[0], dataExtent[1]);\n        this._customizeScale(scale, data);\n        scale.niceTicks();\n\n        var axis = new TimelineAxis('value', scale, layoutInfo.axisExtent, axisType);\n        axis.model = timelineModel;\n\n        return axis;\n    },\n\n    _customizeScale: function (scale, data) {\n\n        scale.getTicks = function () {\n            return data.mapArray(['value'], function (value) {\n                return value;\n            });\n        };\n\n        scale.getTicksLabels = function () {\n            return map(this.getTicks(), scale.getLabel, scale);\n        };\n    },\n\n    _createGroup: function (name) {\n        var newGroup = this['_' + name] = new Group();\n        this.group.add(newGroup);\n        return newGroup;\n    },\n\n    _renderAxisLine: function (layoutInfo, group, axis, timelineModel) {\n        var axisExtent = axis.getExtent();\n\n        if (!timelineModel.get('lineStyle.show')) {\n            return;\n        }\n\n        group.add(new Line({\n            shape: {\n                x1: axisExtent[0], y1: 0,\n                x2: axisExtent[1], y2: 0\n            },\n            style: extend(\n                {lineCap: 'round'},\n                timelineModel.getModel('lineStyle').getLineStyle()\n            ),\n            silent: true,\n            z2: 1\n        }));\n    },\n\n    /**\n     * @private\n     */\n    _renderAxisTick: function (layoutInfo, group, axis, timelineModel) {\n        var data = timelineModel.getData();\n        var ticks = axis.scale.getTicks();\n\n        each$30(ticks, function (value, dataIndex) {\n\n            var tickCoord = axis.dataToCoord(value);\n            var itemModel = data.getItemModel(dataIndex);\n            var itemStyleModel = itemModel.getModel('itemStyle.normal');\n            var hoverStyleModel = itemModel.getModel('itemStyle.emphasis');\n            var symbolOpt = {\n                position: [tickCoord, 0],\n                onclick: bind$6(this._changeTimeline, this, dataIndex)\n            };\n            var el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);\n            setHoverStyle(el, hoverStyleModel.getItemStyle());\n\n            if (itemModel.get('tooltip')) {\n                el.dataIndex = dataIndex;\n                el.dataModel = timelineModel;\n            }\n            else {\n                el.dataIndex = el.dataModel = null;\n            }\n\n        }, this);\n    },\n\n    /**\n     * @private\n     */\n    _renderAxisLabel: function (layoutInfo, group, axis, timelineModel) {\n        var labelModel = timelineModel.getModel('label.normal');\n\n        if (!labelModel.get('show')) {\n            return;\n        }\n\n        var data = timelineModel.getData();\n        var ticks = axis.scale.getTicks();\n        var labels = getFormattedLabels(\n            axis, labelModel.get('formatter')\n        );\n        var labelInterval = axis.getLabelInterval();\n\n        each$30(ticks, function (tick, dataIndex) {\n            if (axis.isLabelIgnored(dataIndex, labelInterval)) {\n                return;\n            }\n\n            var itemModel = data.getItemModel(dataIndex);\n            var normalLabelModel = itemModel.getModel('label.normal');\n            var hoverLabelModel = itemModel.getModel('label.emphasis');\n            var tickCoord = axis.dataToCoord(tick);\n            var textEl = new Text({\n                position: [tickCoord, 0],\n                rotation: layoutInfo.labelRotation - layoutInfo.rotation,\n                onclick: bind$6(this._changeTimeline, this, dataIndex),\n                silent: false\n            });\n            setTextStyle(textEl.style, normalLabelModel, {\n                text: labels[dataIndex],\n                textAlign: layoutInfo.labelAlign,\n                textVerticalAlign: layoutInfo.labelBaseline\n            });\n\n            group.add(textEl);\n            setHoverStyle(\n                textEl, setTextStyle({}, hoverLabelModel)\n            );\n\n        }, this);\n    },\n\n    /**\n     * @private\n     */\n    _renderControl: function (layoutInfo, group, axis, timelineModel) {\n        var controlSize = layoutInfo.controlSize;\n        var rotation = layoutInfo.rotation;\n\n        var itemStyle = timelineModel.getModel('controlStyle.normal').getItemStyle();\n        var hoverStyle = timelineModel.getModel('controlStyle.emphasis').getItemStyle();\n        var rect = [0, -controlSize / 2, controlSize, controlSize];\n        var playState = timelineModel.getPlayState();\n        var inverse = timelineModel.get('inverse', true);\n\n        makeBtn(\n            layoutInfo.nextBtnPosition,\n            'controlStyle.nextIcon',\n            bind$6(this._changeTimeline, this, inverse ? '-' : '+')\n        );\n        makeBtn(\n            layoutInfo.prevBtnPosition,\n            'controlStyle.prevIcon',\n            bind$6(this._changeTimeline, this, inverse ? '+' : '-')\n        );\n        makeBtn(\n            layoutInfo.playPosition,\n            'controlStyle.' + (playState ? 'stopIcon' : 'playIcon'),\n            bind$6(this._handlePlayClick, this, !playState),\n            true\n        );\n\n        function makeBtn(position, iconPath, onclick, willRotate) {\n            if (!position) {\n                return;\n            }\n            var opt = {\n                position: position,\n                origin: [controlSize / 2, 0],\n                rotation: willRotate ? -rotation : 0,\n                rectHover: true,\n                style: itemStyle,\n                onclick: onclick\n            };\n            var btn = makeIcon(timelineModel, iconPath, rect, opt);\n            group.add(btn);\n            setHoverStyle(btn, hoverStyle);\n        }\n    },\n\n    _renderCurrentPointer: function (layoutInfo, group, axis, timelineModel) {\n        var data = timelineModel.getData();\n        var currentIndex = timelineModel.getCurrentIndex();\n        var pointerModel = data.getItemModel(currentIndex).getModel('checkpointStyle');\n        var me = this;\n\n        var callback = {\n            onCreate: function (pointer) {\n                pointer.draggable = true;\n                pointer.drift = bind$6(me._handlePointerDrag, me);\n                pointer.ondragend = bind$6(me._handlePointerDragend, me);\n                pointerMoveTo(pointer, currentIndex, axis, timelineModel, true);\n            },\n            onUpdate: function (pointer) {\n                pointerMoveTo(pointer, currentIndex, axis, timelineModel);\n            }\n        };\n\n        // Reuse when exists, for animation and drag.\n        this._currentPointer = giveSymbol(\n            pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback\n        );\n    },\n\n    _handlePlayClick: function (nextState) {\n        this._clearTimer();\n        this.api.dispatchAction({\n            type: 'timelinePlayChange',\n            playState: nextState,\n            from: this.uid\n        });\n    },\n\n    _handlePointerDrag: function (dx, dy, e) {\n        this._clearTimer();\n        this._pointerChangeTimeline([e.offsetX, e.offsetY]);\n    },\n\n    _handlePointerDragend: function (e) {\n        this._pointerChangeTimeline([e.offsetX, e.offsetY], true);\n    },\n\n    _pointerChangeTimeline: function (mousePos, trigger) {\n        var toCoord = this._toAxisCoord(mousePos)[0];\n\n        var axis = this._axis;\n        var axisExtent = asc(axis.getExtent().slice());\n\n        toCoord > axisExtent[1] && (toCoord = axisExtent[1]);\n        toCoord < axisExtent[0] && (toCoord = axisExtent[0]);\n\n        this._currentPointer.position[0] = toCoord;\n        this._currentPointer.dirty();\n\n        var targetDataIndex = this._findNearestTick(toCoord);\n        var timelineModel = this.model;\n\n        if (trigger || (\n            targetDataIndex !== timelineModel.getCurrentIndex()\n            && timelineModel.get('realtime')\n        )) {\n            this._changeTimeline(targetDataIndex);\n        }\n    },\n\n    _doPlayStop: function () {\n        this._clearTimer();\n\n        if (this.model.getPlayState()) {\n            this._timer = setTimeout(\n                bind$6(handleFrame, this),\n                this.model.get('playInterval')\n            );\n        }\n\n        function handleFrame() {\n            // Do not cache\n            var timelineModel = this.model;\n            this._changeTimeline(\n                timelineModel.getCurrentIndex()\n                + (timelineModel.get('rewind', true) ? -1 : 1)\n            );\n        }\n    },\n\n    _toAxisCoord: function (vertex) {\n        var trans = this._mainGroup.getLocalTransform();\n        return applyTransform$1(vertex, trans, true);\n    },\n\n    _findNearestTick: function (axisCoord) {\n        var data = this.model.getData();\n        var dist = Infinity;\n        var targetDataIndex;\n        var axis = this._axis;\n\n        data.each(['value'], function (value, dataIndex) {\n            var coord = axis.dataToCoord(value);\n            var d = Math.abs(coord - axisCoord);\n            if (d < dist) {\n                dist = d;\n                targetDataIndex = dataIndex;\n            }\n        });\n\n        return targetDataIndex;\n    },\n\n    _clearTimer: function () {\n        if (this._timer) {\n            clearTimeout(this._timer);\n            this._timer = null;\n        }\n    },\n\n    _changeTimeline: function (nextIndex) {\n        var currentIndex = this.model.getCurrentIndex();\n\n        if (nextIndex === '+') {\n            nextIndex = currentIndex + 1;\n        }\n        else if (nextIndex === '-') {\n            nextIndex = currentIndex - 1;\n        }\n\n        this.api.dispatchAction({\n            type: 'timelineChange',\n            currentIndex: nextIndex,\n            from: this.uid\n        });\n    }\n\n});\n\nfunction getViewRect$4(model, api) {\n    return getLayoutRect(\n        model.getBoxLayoutParams(),\n        {\n            width: api.getWidth(),\n            height: api.getHeight()\n        },\n        model.get('padding')\n    );\n}\n\nfunction makeIcon(timelineModel, objPath, rect, opts) {\n    var icon = makePath(\n        timelineModel.get(objPath).replace(/^path:\\/\\//, ''),\n        clone(opts || {}),\n        new BoundingRect(rect[0], rect[1], rect[2], rect[3]),\n        'center'\n    );\n\n    return icon;\n}\n\n/**\n * Create symbol or update symbol\n * opt: basic position and event handlers\n */\nfunction giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {\n    var color = itemStyleModel.get('color');\n\n    if (!symbol) {\n        var symbolType = hostModel.get('symbol');\n        symbol = createSymbol(symbolType, -1, -1, 2, 2, color);\n        symbol.setStyle('strokeNoScale', true);\n        group.add(symbol);\n        callback && callback.onCreate(symbol);\n    }\n    else {\n        symbol.setColor(color);\n        group.add(symbol); // Group may be new, also need to add.\n        callback && callback.onUpdate(symbol);\n    }\n\n    // Style\n    var itemStyle = itemStyleModel.getItemStyle(['color', 'symbol', 'symbolSize']);\n    symbol.setStyle(itemStyle);\n\n    // Transform and events.\n    opt = merge({\n        rectHover: true,\n        z2: 100\n    }, opt, true);\n\n    var symbolSize = hostModel.get('symbolSize');\n    symbolSize = symbolSize instanceof Array\n        ? symbolSize.slice()\n        : [+symbolSize, +symbolSize];\n    symbolSize[0] /= 2;\n    symbolSize[1] /= 2;\n    opt.scale = symbolSize;\n\n    var symbolOffset = hostModel.get('symbolOffset');\n    if (symbolOffset) {\n        var pos = opt.position = opt.position || [0, 0];\n        pos[0] += parsePercent$1(symbolOffset[0], symbolSize[0]);\n        pos[1] += parsePercent$1(symbolOffset[1], symbolSize[1]);\n    }\n\n    var symbolRotate = hostModel.get('symbolRotate');\n    opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;\n\n    symbol.attr(opt);\n\n    // FIXME\n    // (1) When symbol.style.strokeNoScale is true and updateTransform is not performed,\n    // getBoundingRect will return wrong result.\n    // (This is supposed to be resolved in zrender, but it is a little difficult to\n    // leverage performance and auto updateTransform)\n    // (2) All of ancesters of symbol do not scale, so we can just updateTransform symbol.\n    symbol.updateTransform();\n\n    return symbol;\n}\n\nfunction pointerMoveTo(pointer, dataIndex, axis, timelineModel, noAnimation) {\n    if (pointer.dragging) {\n        return;\n    }\n\n    var pointerModel = timelineModel.getModel('checkpointStyle');\n    var toCoord = axis.dataToCoord(timelineModel.getData().get(['value'], dataIndex));\n\n    if (noAnimation || !pointerModel.get('animation', true)) {\n        pointer.attr({position: [toCoord, 0]});\n    }\n    else {\n        pointer.stopAnimation(true);\n        pointer.animateTo(\n            {position: [toCoord, 0]},\n            pointerModel.get('animationDuration', true),\n            pointerModel.get('animationEasing', true)\n        );\n    }\n}\n\n/**\n * DataZoom component entry\n */\n\nregisterPreprocessor(preprocessor$3);\n\nvar ToolboxModel = extendComponentModel({\n\n    type: 'toolbox',\n\n    layoutMode: {\n        type: 'box',\n        ignoreSize: true\n    },\n\n    mergeDefaultAndTheme: function (option) {\n        ToolboxModel.superApply(this, 'mergeDefaultAndTheme', arguments);\n\n        each$1(this.option.feature, function (featureOpt, featureName) {\n            var Feature = get$5(featureName);\n            Feature && merge(featureOpt, Feature.defaultOption);\n        });\n    },\n\n    defaultOption: {\n\n        show: true,\n\n        z: 6,\n\n        zlevel: 0,\n\n        orient: 'horizontal',\n\n        left: 'right',\n\n        top: 'top',\n\n        // right\n        // bottom\n\n        backgroundColor: 'transparent',\n\n        borderColor: '#ccc',\n\n        borderRadius: 0,\n\n        borderWidth: 0,\n\n        padding: 5,\n\n        itemSize: 15,\n\n        itemGap: 8,\n\n        showTitle: true,\n\n        iconStyle: {\n            normal: {\n                borderColor: '#666',\n                color: 'none'\n            },\n            emphasis: {\n                borderColor: '#3E98C5'\n            }\n        }\n        // textStyle: {},\n\n        // feature\n    }\n});\n\nextendComponentView({\n\n    type: 'toolbox',\n\n    render: function (toolboxModel, ecModel, api, payload) {\n        var group = this.group;\n        group.removeAll();\n\n        if (!toolboxModel.get('show')) {\n            return;\n        }\n\n        var itemSize = +toolboxModel.get('itemSize');\n        var featureOpts = toolboxModel.get('feature') || {};\n        var features = this._features || (this._features = {});\n\n        var featureNames = [];\n        each$1(featureOpts, function (opt, name) {\n            featureNames.push(name);\n        });\n\n        (new DataDiffer(this._featureNames || [], featureNames))\n            .add(processFeature)\n            .update(processFeature)\n            .remove(curry(processFeature, null))\n            .execute();\n\n        // Keep for diff.\n        this._featureNames = featureNames;\n\n        function processFeature(newIndex, oldIndex) {\n            var featureName = featureNames[newIndex];\n            var oldName = featureNames[oldIndex];\n            var featureOpt = featureOpts[featureName];\n            var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);\n            var feature;\n\n            if (featureName && !oldName) { // Create\n                if (isUserFeatureName(featureName)) {\n                    feature = {\n                        model: featureModel,\n                        onclick: featureModel.option.onclick,\n                        featureName: featureName\n                    };\n                }\n                else {\n                    var Feature = get$5(featureName);\n                    if (!Feature) {\n                        return;\n                    }\n                    feature = new Feature(featureModel, ecModel, api);\n                }\n                features[featureName] = feature;\n            }\n            else {\n                feature = features[oldName];\n                // If feature does not exsit.\n                if (!feature) {\n                    return;\n                }\n                feature.model = featureModel;\n                feature.ecModel = ecModel;\n                feature.api = api;\n            }\n\n            if (!featureName && oldName) {\n                feature.dispose && feature.dispose(ecModel, api);\n                return;\n            }\n\n            if (!featureModel.get('show') || feature.unusable) {\n                feature.remove && feature.remove(ecModel, api);\n                return;\n            }\n\n            createIconPaths(featureModel, feature, featureName);\n\n            featureModel.setIconStatus = function (iconName, status) {\n                var option = this.option;\n                var iconPaths = this.iconPaths;\n                option.iconStatus = option.iconStatus || {};\n                option.iconStatus[iconName] = status;\n                // FIXME\n                iconPaths[iconName] && iconPaths[iconName].trigger(status);\n            };\n\n            if (feature.render) {\n                feature.render(featureModel, ecModel, api, payload);\n            }\n        }\n\n        function createIconPaths(featureModel, feature, featureName) {\n            var iconStyleModel = featureModel.getModel('iconStyle');\n\n            // If one feature has mutiple icon. they are orginaized as\n            // {\n            //     icon: {\n            //         foo: '',\n            //         bar: ''\n            //     },\n            //     title: {\n            //         foo: '',\n            //         bar: ''\n            //     }\n            // }\n            var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon');\n            var titles = featureModel.get('title') || {};\n            if (typeof icons === 'string') {\n                var icon = icons;\n                var title = titles;\n                icons = {};\n                titles = {};\n                icons[featureName] = icon;\n                titles[featureName] = title;\n            }\n            var iconPaths = featureModel.iconPaths = {};\n            each$1(icons, function (iconStr, iconName) {\n                var path = createIcon(\n                    iconStr,\n                    {},\n                    {\n                        x: -itemSize / 2,\n                        y: -itemSize / 2,\n                        width: itemSize,\n                        height: itemSize\n                    }\n                );\n                path.setStyle(iconStyleModel.getModel('normal').getItemStyle());\n                path.hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();\n\n                setHoverStyle(path);\n\n                if (toolboxModel.get('showTitle')) {\n                    path.__title = titles[iconName];\n                    path.on('mouseover', function () {\n                            // Should not reuse above hoverStyle, which might be modified.\n                            var hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();\n                            path.setStyle({\n                                text: titles[iconName],\n                                textPosition: hoverStyle.textPosition || 'bottom',\n                                textFill: hoverStyle.fill || hoverStyle.stroke || '#000',\n                                textAlign: hoverStyle.textAlign || 'center'\n                            });\n                        })\n                        .on('mouseout', function () {\n                            path.setStyle({\n                                textFill: null\n                            });\n                        });\n                }\n                path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal');\n\n                group.add(path);\n                path.on('click', bind(\n                    feature.onclick, feature, ecModel, api, iconName\n                ));\n\n                iconPaths[iconName] = path;\n            });\n        }\n\n        layout$2(group, toolboxModel, api);\n        // Render background after group is layout\n        // FIXME\n        group.add(makeBackground(group.getBoundingRect(), toolboxModel));\n\n        // Adjust icon title positions to avoid them out of screen\n        group.eachChild(function (icon) {\n            var titleText = icon.__title;\n            var hoverStyle = icon.hoverStyle;\n            // May be background element\n            if (hoverStyle && titleText) {\n                var rect = getBoundingRect(\n                    titleText, makeFont(hoverStyle)\n                );\n                var offsetX = icon.position[0] + group.position[0];\n                var offsetY = icon.position[1] + group.position[1] + itemSize;\n\n                var needPutOnTop = false;\n                if (offsetY + rect.height > api.getHeight()) {\n                    hoverStyle.textPosition = 'top';\n                    needPutOnTop = true;\n                }\n                var topOffset = needPutOnTop ? (-5 - rect.height) : (itemSize + 8);\n                if (offsetX + rect.width /  2 > api.getWidth()) {\n                    hoverStyle.textPosition = ['100%', topOffset];\n                    hoverStyle.textAlign = 'right';\n                }\n                else if (offsetX - rect.width / 2 < 0) {\n                    hoverStyle.textPosition = [0, topOffset];\n                    hoverStyle.textAlign = 'left';\n                }\n            }\n        });\n    },\n\n    updateView: function (toolboxModel, ecModel, api, payload) {\n        each$1(this._features, function (feature) {\n            feature.updateView && feature.updateView(feature.model, ecModel, api, payload);\n        });\n    },\n\n    updateLayout: function (toolboxModel, ecModel, api, payload) {\n        each$1(this._features, function (feature) {\n            feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);\n        });\n    },\n\n    remove: function (ecModel, api) {\n        each$1(this._features, function (feature) {\n            feature.remove && feature.remove(ecModel, api);\n        });\n        this.group.removeAll();\n    },\n\n    dispose: function (ecModel, api) {\n        each$1(this._features, function (feature) {\n            feature.dispose && feature.dispose(ecModel, api);\n        });\n    }\n});\n\nfunction isUserFeatureName(featureName) {\n    return featureName.indexOf('my') === 0;\n}\n\nvar saveAsImageLang = lang.toolbox.saveAsImage;\n\nfunction SaveAsImage(model) {\n    this.model = model;\n}\n\nSaveAsImage.defaultOption = {\n    show: true,\n    icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',\n    title: saveAsImageLang.title,\n    type: 'png',\n    // Default use option.backgroundColor\n    // backgroundColor: '#fff',\n    name: '',\n    excludeComponents: ['toolbox'],\n    pixelRatio: 1,\n    lang: saveAsImageLang.lang.slice()\n};\n\nSaveAsImage.prototype.unusable = !env$1.canvasSupported;\n\nvar proto$2 = SaveAsImage.prototype;\n\nproto$2.onclick = function (ecModel, api) {\n    var model = this.model;\n    var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';\n    var $a = document.createElement('a');\n    var type = model.get('type', true) || 'png';\n    $a.download = title + '.' + type;\n    $a.target = '_blank';\n    var url = api.getConnectedDataURL({\n        type: type,\n        backgroundColor: model.get('backgroundColor', true)\n            || ecModel.get('backgroundColor') || '#fff',\n        excludeComponents: model.get('excludeComponents'),\n        pixelRatio: model.get('pixelRatio')\n    });\n    $a.href = url;\n    // Chrome and Firefox\n    if (typeof MouseEvent === 'function' && !env$1.browser.ie && !env$1.browser.edge) {\n        var evt = new MouseEvent('click', {\n            view: window,\n            bubbles: true,\n            cancelable: false\n        });\n        $a.dispatchEvent(evt);\n    }\n    // IE\n    else {\n        if (window.navigator.msSaveOrOpenBlob) {\n            var bstr = atob(url.split(',')[1]);\n            var n = bstr.length;\n            var u8arr = new Uint8Array(n);\n            while(n--) {\n                u8arr[n] = bstr.charCodeAt(n);\n            }\n            var blob = new Blob([u8arr]);\n            window.navigator.msSaveOrOpenBlob(blob, title + '.' + type);\n        }\n        else {\n            var lang$$1 = model.get('lang');\n            var html = '' +\n                '<body style=\"margin:0;\">' +\n                '<img src=\"' + url + '\" style=\"max-width:100%;\" title=\"' + ((lang$$1 && lang$$1[0]) || '') + '\" />' +\n                '</body>';\n            var tab = window.open();\n            tab.document.write(html);\n        }\n    }\n};\n\nregister$1(\n    'saveAsImage', SaveAsImage\n);\n\nvar magicTypeLang = lang.toolbox.magicType;\n\nfunction MagicType(model) {\n    this.model = model;\n}\n\nMagicType.defaultOption = {\n    show: true,\n    type: [],\n    // Icon group\n    icon: {\n        line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',\n        bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',\n        stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z', // jshint ignore:line\n        tiled: 'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z'\n    },\n    // `line`, `bar`, `stack`, `tiled`\n    title: clone(magicTypeLang.title),\n    option: {},\n    seriesIndex: {}\n};\n\nvar proto$3 = MagicType.prototype;\n\nproto$3.getIcons = function () {\n    var model = this.model;\n    var availableIcons = model.get('icon');\n    var icons = {};\n    each$1(model.get('type'), function (type) {\n        if (availableIcons[type]) {\n            icons[type] = availableIcons[type];\n        }\n    });\n    return icons;\n};\n\nvar seriesOptGenreator = {\n    'line': function (seriesType, seriesId, seriesModel, model) {\n        if (seriesType === 'bar') {\n            return merge({\n                id: seriesId,\n                type: 'line',\n                // Preserve data related option\n                data: seriesModel.get('data'),\n                stack: seriesModel.get('stack'),\n                markPoint: seriesModel.get('markPoint'),\n                markLine: seriesModel.get('markLine')\n            }, model.get('option.line') || {}, true);\n        }\n    },\n    'bar': function (seriesType, seriesId, seriesModel, model) {\n        if (seriesType === 'line') {\n            return merge({\n                id: seriesId,\n                type: 'bar',\n                // Preserve data related option\n                data: seriesModel.get('data'),\n                stack: seriesModel.get('stack'),\n                markPoint: seriesModel.get('markPoint'),\n                markLine: seriesModel.get('markLine')\n            }, model.get('option.bar') || {}, true);\n        }\n    },\n    'stack': function (seriesType, seriesId, seriesModel, model) {\n        if (seriesType === 'line' || seriesType === 'bar') {\n            return merge({\n                id: seriesId,\n                stack: '__ec_magicType_stack__'\n            }, model.get('option.stack') || {}, true);\n        }\n    },\n    'tiled': function (seriesType, seriesId, seriesModel, model) {\n        if (seriesType === 'line' || seriesType === 'bar') {\n            return merge({\n                id: seriesId,\n                stack: ''\n            }, model.get('option.tiled') || {}, true);\n        }\n    }\n};\n\nvar radioTypes = [\n    ['line', 'bar'],\n    ['stack', 'tiled']\n];\n\nproto$3.onclick = function (ecModel, api, type) {\n    var model = this.model;\n    var seriesIndex = model.get('seriesIndex.' + type);\n    // Not supported magicType\n    if (!seriesOptGenreator[type]) {\n        return;\n    }\n    var newOption = {\n        series: []\n    };\n    var generateNewSeriesTypes = function (seriesModel) {\n        var seriesType = seriesModel.subType;\n        var seriesId = seriesModel.id;\n        var newSeriesOpt = seriesOptGenreator[type](\n            seriesType, seriesId, seriesModel, model\n        );\n        if (newSeriesOpt) {\n            // PENDING If merge original option?\n            defaults(newSeriesOpt, seriesModel.option);\n            newOption.series.push(newSeriesOpt);\n        }\n        // Modify boundaryGap\n        var coordSys = seriesModel.coordinateSystem;\n        if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {\n            var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n            if (categoryAxis) {\n                var axisDim = categoryAxis.dim;\n                var axisType = axisDim + 'Axis';\n                var axisModel = ecModel.queryComponents({\n                    mainType: axisType,\n                    index: seriesModel.get(name + 'Index'),\n                    id: seriesModel.get(name + 'Id')\n                })[0];\n                var axisIndex = axisModel.componentIndex;\n\n                newOption[axisType] = newOption[axisType] || [];\n                for (var i = 0; i <= axisIndex; i++) {\n                    newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};\n                }\n                newOption[axisType][axisIndex].boundaryGap = type === 'bar' ? true : false;\n            }\n        }\n    };\n\n    each$1(radioTypes, function (radio) {\n        if (indexOf(radio, type) >= 0) {\n            each$1(radio, function (item) {\n                model.setIconStatus(item, 'normal');\n            });\n        }\n    });\n\n    model.setIconStatus(type, 'emphasis');\n\n    ecModel.eachComponent(\n        {\n            mainType: 'series',\n            query: seriesIndex == null ? null : {\n                seriesIndex: seriesIndex\n            }\n        }, generateNewSeriesTypes\n    );\n    api.dispatchAction({\n        type: 'changeMagicType',\n        currentType: type,\n        newOption: newOption\n    });\n};\n\nregisterAction({\n    type: 'changeMagicType',\n    event: 'magicTypeChanged',\n    update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n    ecModel.mergeOption(payload.newOption);\n});\n\nregister$1('magicType', MagicType);\n\nvar dataViewLang = lang.toolbox.dataView;\n\nvar BLOCK_SPLITER = new Array(60).join('-');\nvar ITEM_SPLITER = '\\t';\n/**\n * Group series into two types\n *  1. on category axis, like line, bar\n *  2. others, like scatter, pie\n * @param {module:echarts/model/Global} ecModel\n * @return {Object}\n * @inner\n */\nfunction groupSeries(ecModel) {\n    var seriesGroupByCategoryAxis = {};\n    var otherSeries = [];\n    var meta = [];\n    ecModel.eachRawSeries(function (seriesModel) {\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {\n            var baseAxis = coordSys.getBaseAxis();\n            if (baseAxis.type === 'category') {\n                var key = baseAxis.dim + '_' + baseAxis.index;\n                if (!seriesGroupByCategoryAxis[key]) {\n                    seriesGroupByCategoryAxis[key] = {\n                        categoryAxis: baseAxis,\n                        valueAxis: coordSys.getOtherAxis(baseAxis),\n                        series: []\n                    };\n                    meta.push({\n                        axisDim: baseAxis.dim,\n                        axisIndex: baseAxis.index\n                    });\n                }\n                seriesGroupByCategoryAxis[key].series.push(seriesModel);\n            }\n            else {\n                otherSeries.push(seriesModel);\n            }\n        }\n        else {\n            otherSeries.push(seriesModel);\n        }\n    });\n\n    return {\n        seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,\n        other: otherSeries,\n        meta: meta\n    };\n}\n\n/**\n * Assemble content of series on cateogory axis\n * @param {Array.<module:echarts/model/Series>} series\n * @return {string}\n * @inner\n */\nfunction assembleSeriesWithCategoryAxis(series) {\n    var tables = [];\n    each$1(series, function (group, key) {\n        var categoryAxis = group.categoryAxis;\n        var valueAxis = group.valueAxis;\n        var valueAxisDim = valueAxis.dim;\n\n        var headers = [' '].concat(map(group.series, function (series) {\n            return series.name;\n        }));\n        var columns = [categoryAxis.model.getCategories()];\n        each$1(group.series, function (series) {\n            columns.push(series.getRawData().mapArray(valueAxisDim, function (val) {\n                return val;\n            }));\n        });\n        // Assemble table content\n        var lines = [headers.join(ITEM_SPLITER)];\n        for (var i = 0; i < columns[0].length; i++) {\n            var items = [];\n            for (var j = 0; j < columns.length; j++) {\n                items.push(columns[j][i]);\n            }\n            lines.push(items.join(ITEM_SPLITER));\n        }\n        tables.push(lines.join('\\n'));\n    });\n    return tables.join('\\n\\n' +  BLOCK_SPLITER + '\\n\\n');\n}\n\n/**\n * Assemble content of other series\n * @param {Array.<module:echarts/model/Series>} series\n * @return {string}\n * @inner\n */\nfunction assembleOtherSeries(series) {\n    return map(series, function (series) {\n        var data = series.getRawData();\n        var lines = [series.name];\n        var vals = [];\n        data.each(data.dimensions, function () {\n            var argLen = arguments.length;\n            var dataIndex = arguments[argLen - 1];\n            var name = data.getName(dataIndex);\n            for (var i = 0; i < argLen - 1; i++) {\n                vals[i] = arguments[i];\n            }\n            lines.push((name ? (name + ITEM_SPLITER) : '') + vals.join(ITEM_SPLITER));\n        });\n        return lines.join('\\n');\n    }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n}\n\n/**\n * @param {module:echarts/model/Global}\n * @return {Object}\n * @inner\n */\nfunction getContentFromModel(ecModel) {\n\n    var result = groupSeries(ecModel);\n\n    return {\n        value: filter([\n                assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis),\n                assembleOtherSeries(result.other)\n            ], function (str) {\n                return str.replace(/[\\n\\t\\s]/g, '');\n            }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n'),\n\n        meta: result.meta\n    };\n}\n\n\nfunction trim(str) {\n    return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n}\n/**\n * If a block is tsv format\n */\nfunction isTSVFormat(block) {\n    // Simple method to find out if a block is tsv format\n    var firstLine = block.slice(0, block.indexOf('\\n'));\n    if (firstLine.indexOf(ITEM_SPLITER) >= 0) {\n        return true;\n    }\n}\n\nvar itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');\n/**\n * @param {string} tsv\n * @return {Object}\n */\nfunction parseTSVContents(tsv) {\n    var tsvLines = tsv.split(/\\n+/g);\n    var headers = trim(tsvLines.shift()).split(itemSplitRegex);\n\n    var categories = [];\n    var series = map(headers, function (header) {\n        return {\n            name: header,\n            data: []\n        };\n    });\n    for (var i = 0; i < tsvLines.length; i++) {\n        var items = trim(tsvLines[i]).split(itemSplitRegex);\n        categories.push(items.shift());\n        for (var j = 0; j < items.length; j++) {\n            series[j] && (series[j].data[i] = items[j]);\n        }\n    }\n    return {\n        series: series,\n        categories: categories\n    };\n}\n\n/**\n * @param {string} str\n * @return {Array.<Object>}\n * @inner\n */\nfunction parseListContents(str) {\n    var lines = str.split(/\\n+/g);\n    var seriesName = trim(lines.shift());\n\n    var data = [];\n    for (var i = 0; i < lines.length; i++) {\n        var items = trim(lines[i]).split(itemSplitRegex);\n        var name = '';\n        var value;\n        var hasName = false;\n        if (isNaN(items[0])) { // First item is name\n            hasName = true;\n            name = items[0];\n            items = items.slice(1);\n            data[i] = {\n                name: name,\n                value: []\n            };\n            value = data[i].value;\n        }\n        else {\n            value = data[i] = [];\n        }\n        for (var j = 0; j < items.length; j++) {\n            value.push(+items[j]);\n        }\n        if (value.length === 1) {\n            hasName ? (data[i].value = value[0]) : (data[i] = value[0]);\n        }\n    }\n\n    return {\n        name: seriesName,\n        data: data\n    };\n}\n\n/**\n * @param {string} str\n * @param {Array.<Object>} blockMetaList\n * @return {Object}\n * @inner\n */\nfunction parseContents(str, blockMetaList) {\n    var blocks = str.split(new RegExp('\\n*' + BLOCK_SPLITER + '\\n*', 'g'));\n    var newOption = {\n        series: []\n    };\n    each$1(blocks, function (block, idx) {\n        if (isTSVFormat(block)) {\n            var result = parseTSVContents(block);\n            var blockMeta = blockMetaList[idx];\n            var axisKey = blockMeta.axisDim + 'Axis';\n\n            if (blockMeta) {\n                newOption[axisKey] = newOption[axisKey] || [];\n                newOption[axisKey][blockMeta.axisIndex] = {\n                    data: result.categories\n                };\n                newOption.series = newOption.series.concat(result.series);\n            }\n        }\n        else {\n            var result = parseListContents(block);\n            newOption.series.push(result);\n        }\n    });\n    return newOption;\n}\n\n/**\n * @alias {module:echarts/component/toolbox/feature/DataView}\n * @constructor\n * @param {module:echarts/model/Model} model\n */\nfunction DataView(model) {\n\n    this._dom = null;\n\n    this.model = model;\n}\n\nDataView.defaultOption = {\n    show: true,\n    readOnly: false,\n    optionToContent: null,\n    contentToOption: null,\n\n    icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',\n    title: clone(dataViewLang.title),\n    lang: clone(dataViewLang.lang),\n    backgroundColor: '#fff',\n    textColor: '#000',\n    textareaColor: '#fff',\n    textareaBorderColor: '#333',\n    buttonColor: '#c23531',\n    buttonTextColor: '#fff'\n};\n\nDataView.prototype.onclick = function (ecModel, api) {\n    var container = api.getDom();\n    var model = this.model;\n    if (this._dom) {\n        container.removeChild(this._dom);\n    }\n    var root = document.createElement('div');\n    root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';\n    root.style.backgroundColor = model.get('backgroundColor') || '#fff';\n\n    // Create elements\n    var header = document.createElement('h4');\n    var lang$$1 = model.get('lang') || [];\n    header.innerHTML = lang$$1[0] || model.get('title');\n    header.style.cssText = 'margin: 10px 20px;';\n    header.style.color = model.get('textColor');\n\n    var viewMain = document.createElement('div');\n    var textarea = document.createElement('textarea');\n    viewMain.style.cssText = 'display:block;width:100%;overflow:auto;';\n\n    var optionToContent = model.get('optionToContent');\n    var contentToOption = model.get('contentToOption');\n    var result = getContentFromModel(ecModel);\n    if (typeof optionToContent === 'function') {\n        var htmlOrDom = optionToContent(api.getOption());\n        if (typeof htmlOrDom === 'string') {\n            viewMain.innerHTML = htmlOrDom;\n        }\n        else if (isDom(htmlOrDom)) {\n            viewMain.appendChild(htmlOrDom);\n        }\n    }\n    else {\n        // Use default textarea\n        viewMain.appendChild(textarea);\n        textarea.readOnly = model.get('readOnly');\n        textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';\n        textarea.style.color = model.get('textColor');\n        textarea.style.borderColor = model.get('textareaBorderColor');\n        textarea.style.backgroundColor = model.get('textareaColor');\n        textarea.value = result.value;\n    }\n\n    var blockMetaList = result.meta;\n\n    var buttonContainer = document.createElement('div');\n    buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';\n\n    var buttonStyle = 'float:right;margin-right:20px;border:none;'\n        + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';\n    var closeButton = document.createElement('div');\n    var refreshButton = document.createElement('div');\n\n    buttonStyle += ';background-color:' + model.get('buttonColor');\n    buttonStyle += ';color:' + model.get('buttonTextColor');\n\n    var self = this;\n\n    function close() {\n        container.removeChild(root);\n        self._dom = null;\n    }\n    addEventListener(closeButton, 'click', close);\n\n    addEventListener(refreshButton, 'click', function () {\n        var newOption;\n        try {\n            if (typeof contentToOption === 'function') {\n                newOption = contentToOption(viewMain, api.getOption());\n            }\n            else {\n                newOption = parseContents(textarea.value, blockMetaList);\n            }\n        }\n        catch (e) {\n            close();\n            throw new Error('Data view format error ' + e);\n        }\n        if (newOption) {\n            api.dispatchAction({\n                type: 'changeDataView',\n                newOption: newOption\n            });\n        }\n\n        close();\n    });\n\n    closeButton.innerHTML = lang$$1[1];\n    refreshButton.innerHTML = lang$$1[2];\n    refreshButton.style.cssText = buttonStyle;\n    closeButton.style.cssText = buttonStyle;\n\n    !model.get('readOnly') && buttonContainer.appendChild(refreshButton);\n    buttonContainer.appendChild(closeButton);\n\n    // http://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea\n    addEventListener(textarea, 'keydown', function (e) {\n        if ((e.keyCode || e.which) === 9) {\n            // get caret position/selection\n            var val = this.value;\n            var start = this.selectionStart;\n            var end = this.selectionEnd;\n\n            // set textarea value to: text before caret + tab + text after caret\n            this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end);\n\n            // put caret at right position again\n            this.selectionStart = this.selectionEnd = start + 1;\n\n            // prevent the focus lose\n            stop(e);\n        }\n    });\n\n    root.appendChild(header);\n    root.appendChild(viewMain);\n    root.appendChild(buttonContainer);\n\n    viewMain.style.height = (container.clientHeight - 80) + 'px';\n\n    container.appendChild(root);\n    this._dom = root;\n};\n\nDataView.prototype.remove = function (ecModel, api) {\n    this._dom && api.getDom().removeChild(this._dom);\n};\n\nDataView.prototype.dispose = function (ecModel, api) {\n    this.remove(ecModel, api);\n};\n\n/**\n * @inner\n */\nfunction tryMergeDataOption(newData, originalData) {\n    return map(newData, function (newVal, idx) {\n        var original = originalData && originalData[idx];\n        if (isObject(original) && !isArray(original)) {\n            if (isObject(newVal) && !isArray(newVal)) {\n                newVal = newVal.value;\n            }\n            // Original data has option\n            return defaults({\n                value: newVal\n            }, original);\n        }\n        else {\n            return newVal;\n        }\n    });\n}\n\nregister$1('dataView', DataView);\n\nregisterAction({\n    type: 'changeDataView',\n    event: 'dataViewChanged',\n    update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n    var newSeriesOptList = [];\n    each$1(payload.newOption.series, function (seriesOpt) {\n        var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];\n        if (!seriesModel) {\n            // New created series\n            // Geuss the series type\n            newSeriesOptList.push(extend({\n                // Default is scatter\n                type: 'scatter'\n            }, seriesOpt));\n        }\n        else {\n            var originalData = seriesModel.get('data');\n            newSeriesOptList.push({\n                name: seriesOpt.name,\n                data: tryMergeDataOption(seriesOpt.data, originalData)\n            });\n        }\n    });\n\n    ecModel.mergeOption(defaults({\n        series: newSeriesOptList\n    }, payload.newOption));\n});\n\nvar each$32 = each$1;\n\nvar ATTR$2 = '\\0_ec_hist_store';\n\n/**\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]}\n */\nfunction push(ecModel, newSnapshot) {\n    var store = giveStore$1(ecModel);\n\n    // If previous dataZoom can not be found,\n    // complete an range with current range.\n    each$32(newSnapshot, function (batchItem, dataZoomId) {\n        var i = store.length - 1;\n        for (; i >= 0; i--) {\n            var snapshot = store[i];\n            if (snapshot[dataZoomId]) {\n                break;\n            }\n        }\n        if (i < 0) {\n            // No origin range set, create one by current range.\n            var dataZoomModel = ecModel.queryComponents(\n                {mainType: 'dataZoom', subType: 'select', id: dataZoomId}\n            )[0];\n            if (dataZoomModel) {\n                var percentRange = dataZoomModel.getPercentRange();\n                store[0][dataZoomId] = {\n                    dataZoomId: dataZoomId,\n                    start: percentRange[0],\n                    end: percentRange[1]\n                };\n            }\n        }\n    });\n\n    store.push(newSnapshot);\n}\n\n/**\n * @param {module:echarts/model/Global} ecModel\n * @return {Object} snapshot\n */\nfunction pop(ecModel) {\n    var store = giveStore$1(ecModel);\n    var head = store[store.length - 1];\n    store.length > 1 && store.pop();\n\n    // Find top for all dataZoom.\n    var snapshot = {};\n    each$32(head, function (batchItem, dataZoomId) {\n        for (var i = store.length - 1; i >= 0; i--) {\n            var batchItem = store[i][dataZoomId];\n            if (batchItem) {\n                snapshot[dataZoomId] = batchItem;\n                break;\n            }\n        }\n    });\n\n    return snapshot;\n}\n\n/**\n * @param {module:echarts/model/Global} ecModel\n */\nfunction clear$1(ecModel) {\n    ecModel[ATTR$2] = null;\n}\n\n/**\n * @param {module:echarts/model/Global} ecModel\n * @return {number} records. always >= 1.\n */\nfunction count(ecModel) {\n    return giveStore$1(ecModel).length;\n}\n\n/**\n * [{key: dataZoomId, value: {dataZoomId, range}}, ...]\n * History length of each dataZoom may be different.\n * this._history[0] is used to store origin range.\n * @type {Array.<Object>}\n */\nfunction giveStore$1(ecModel) {\n    var store = ecModel[ATTR$2];\n    if (!store) {\n        store = ecModel[ATTR$2] = [{}];\n    }\n    return store;\n}\n\nDataZoomModel.extend({\n    type: 'dataZoom.select'\n});\n\nDataZoomView.extend({\n    type: 'dataZoom.select'\n});\n\n/**\n * DataZoom component entry\n */\n\n// Use dataZoomSelect\nvar dataZoomLang = lang.toolbox.dataZoom;\nvar each$31 = each$1;\n\n// Spectial component id start with \\0ec\\0, see echarts/model/Global.js~hasInnerId\nvar DATA_ZOOM_ID_BASE = '\\0_ec_\\0toolbox-dataZoom_';\n\nfunction DataZoom(model, ecModel, api) {\n\n    /**\n     * @private\n     * @type {module:echarts/component/helper/BrushController}\n     */\n    (this._brushController = new BrushController(api.getZr()))\n        .on('brush', bind(this._onBrush, this))\n        .mount();\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this._isZoomActive;\n}\n\nDataZoom.defaultOption = {\n    show: true,\n    // Icon group\n    icon: {\n        zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',\n        back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'\n    },\n    // `zoom`, `back`\n    title: clone(dataZoomLang.title)\n};\n\nvar proto$4 = DataZoom.prototype;\n\nproto$4.render = function (featureModel, ecModel, api, payload) {\n    this.model = featureModel;\n    this.ecModel = ecModel;\n    this.api = api;\n\n    updateZoomBtnStatus(featureModel, ecModel, this, payload, api);\n    updateBackBtnStatus(featureModel, ecModel);\n};\n\nproto$4.onclick = function (ecModel, api, type) {\n    handlers$1[type].call(this);\n};\n\nproto$4.remove = function (ecModel, api) {\n    this._brushController.unmount();\n};\n\nproto$4.dispose = function (ecModel, api) {\n    this._brushController.dispose();\n};\n\n/**\n * @private\n */\nvar handlers$1 = {\n\n    zoom: function () {\n        var nextActive = !this._isZoomActive;\n\n        this.api.dispatchAction({\n            type: 'takeGlobalCursor',\n            key: 'dataZoomSelect',\n            dataZoomSelectActive: nextActive\n        });\n    },\n\n    back: function () {\n        this._dispatchZoomAction(pop(this.ecModel));\n    }\n};\n\n/**\n * @private\n */\nproto$4._onBrush = function (areas, opt) {\n    if (!opt.isEnd || !areas.length) {\n        return;\n    }\n    var snapshot = {};\n    var ecModel = this.ecModel;\n\n    this._brushController.updateCovers([]); // remove cover\n\n    var brushTargetManager = new BrushTargetManager(\n        retrieveAxisSetting(this.model.option), ecModel, {include: ['grid']}\n    );\n    brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n        if (coordSys.type !== 'cartesian2d') {\n            return;\n        }\n\n        var brushType = area.brushType;\n        if (brushType === 'rect') {\n            setBatch('x', coordSys, coordRange[0]);\n            setBatch('y', coordSys, coordRange[1]);\n        }\n        else {\n            setBatch(({lineX: 'x', lineY: 'y'})[brushType], coordSys, coordRange);\n        }\n    });\n\n    push(ecModel, snapshot);\n\n    this._dispatchZoomAction(snapshot);\n\n    function setBatch(dimName, coordSys, minMax) {\n        var axis = coordSys.getAxis(dimName);\n        var axisModel = axis.model;\n        var dataZoomModel = findDataZoom(dimName, axisModel, ecModel);\n\n        // Restrict range.\n        var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();\n        if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {\n            minMax = sliderMove(\n                0, minMax.slice(), axis.scale.getExtent(), 0,\n                minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan\n            );\n        }\n\n        dataZoomModel && (snapshot[dataZoomModel.id] = {\n            dataZoomId: dataZoomModel.id,\n            startValue: minMax[0],\n            endValue: minMax[1]\n        });\n    }\n\n    function findDataZoom(dimName, axisModel, ecModel) {\n        var found;\n        ecModel.eachComponent({mainType: 'dataZoom', subType: 'select'}, function (dzModel) {\n            var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);\n            has && (found = dzModel);\n        });\n        return found;\n    }\n};\n\n/**\n * @private\n */\nproto$4._dispatchZoomAction = function (snapshot) {\n    var batch = [];\n\n    // Convert from hash map to array.\n    each$31(snapshot, function (batchItem, dataZoomId) {\n        batch.push(clone(batchItem));\n    });\n\n    batch.length && this.api.dispatchAction({\n        type: 'dataZoom',\n        from: this.uid,\n        batch: batch\n    });\n};\n\nfunction retrieveAxisSetting(option) {\n    var setting = {};\n    // Compatible with previous setting: null => all axis, false => no axis.\n    each$1(['xAxisIndex', 'yAxisIndex'], function (name) {\n        setting[name] = option[name];\n        setting[name] == null && (setting[name] = 'all');\n        (setting[name] === false || setting[name] === 'none') && (setting[name] = []);\n    });\n    return setting;\n}\n\nfunction updateBackBtnStatus(featureModel, ecModel) {\n    featureModel.setIconStatus(\n        'back',\n        count(ecModel) > 1 ? 'emphasis' : 'normal'\n    );\n}\n\nfunction updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {\n    var zoomActive = view._isZoomActive;\n\n    if (payload && payload.type === 'takeGlobalCursor') {\n        zoomActive = payload.key === 'dataZoomSelect'\n            ? payload.dataZoomSelectActive : false;\n    }\n\n    view._isZoomActive = zoomActive;\n\n    featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');\n\n    var brushTargetManager = new BrushTargetManager(\n        retrieveAxisSetting(featureModel.option), ecModel, {include: ['grid']}\n    );\n\n    view._brushController\n        .setPanels(brushTargetManager.makePanelOpts(api, function (targetInfo) {\n            return (targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared)\n                ? 'lineX'\n                : (!targetInfo.xAxisDeclared && targetInfo.yAxisDeclared)\n                ? 'lineY'\n                : 'rect';\n        }))\n        .enableBrush(\n            zoomActive\n            ? {\n                brushType: 'auto',\n                brushStyle: {\n                    // FIXME user customized?\n                    lineWidth: 0,\n                    fill: 'rgba(0,0,0,0.2)'\n                }\n            }\n            : false\n        );\n}\n\n\nregister$1('dataZoom', DataZoom);\n\n\n// Create special dataZoom option for select\nregisterPreprocessor(function (option) {\n    if (!option) {\n        return;\n    }\n\n    var dataZoomOpts = option.dataZoom || (option.dataZoom = []);\n    if (!isArray(dataZoomOpts)) {\n        option.dataZoom = dataZoomOpts = [dataZoomOpts];\n    }\n\n    var toolboxOpt = option.toolbox;\n    if (toolboxOpt) {\n        // Assume there is only one toolbox\n        if (isArray(toolboxOpt)) {\n            toolboxOpt = toolboxOpt[0];\n        }\n\n        if (toolboxOpt && toolboxOpt.feature) {\n            var dataZoomOpt = toolboxOpt.feature.dataZoom;\n            addForAxis('xAxis', dataZoomOpt);\n            addForAxis('yAxis', dataZoomOpt);\n        }\n    }\n\n    function addForAxis(axisName, dataZoomOpt) {\n        if (!dataZoomOpt) {\n            return;\n        }\n\n        // Try not to modify model, because it is not merged yet.\n        var axisIndicesName = axisName + 'Index';\n        var givenAxisIndices = dataZoomOpt[axisIndicesName];\n        if (givenAxisIndices != null\n            && givenAxisIndices != 'all'\n            && !isArray(givenAxisIndices)\n        ) {\n            givenAxisIndices = (givenAxisIndices === false || givenAxisIndices === 'none') ? [] : [givenAxisIndices];\n        }\n\n        forEachComponent(axisName, function (axisOpt, axisIndex) {\n            if (givenAxisIndices != null\n                && givenAxisIndices != 'all'\n                && indexOf(givenAxisIndices, axisIndex) === -1\n            ) {\n                return;\n            }\n            var newOpt = {\n                type: 'select',\n                $fromToolbox: true,\n                // Id for merge mapping.\n                id: DATA_ZOOM_ID_BASE + axisName + axisIndex\n            };\n            // FIXME\n            // Only support one axis now.\n            newOpt[axisIndicesName] = axisIndex;\n            dataZoomOpts.push(newOpt);\n        });\n    }\n\n    function forEachComponent(mainType, cb) {\n        var opts = option[mainType];\n        if (!isArray(opts)) {\n            opts = opts ? [opts] : [];\n        }\n        each$31(opts, cb);\n    }\n});\n\nvar restoreLang = lang.toolbox.restore;\n\nfunction Restore(model) {\n    this.model = model;\n}\n\nRestore.defaultOption = {\n    show: true,\n    icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',\n    title: restoreLang.title\n};\n\nvar proto$5 = Restore.prototype;\n\nproto$5.onclick = function (ecModel, api, type) {\n    clear$1(ecModel);\n\n    api.dispatchAction({\n        type: 'restore',\n        from: this.uid\n    });\n};\n\nregister$1('restore', Restore);\n\nregisterAction(\n    {type: 'restore', event: 'restore', update: 'prepareAndUpdate'},\n    function (payload, ecModel) {\n        ecModel.resetOption('recreate');\n    }\n);\n\nvar urn = 'urn:schemas-microsoft-com:vml';\nvar win = typeof window === 'undefined' ? null : window;\n\nvar vmlInited = false;\n\nvar doc = win && win.document;\n\nfunction createNode(tagName) {\n    return doCreateNode(tagName);\n}\n\n// Avoid assign to an exported variable, for transforming to cjs.\nvar doCreateNode;\n\nif (doc && !env$1.canvasSupported) {\n    try {\n        !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n        doCreateNode = function (tagName) {\n            return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n        };\n    }\n    catch (e) {\n        doCreateNode = function (tagName) {\n            return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n        };\n    }\n}\n\n// From raphael\nfunction initVML() {\n    if (vmlInited || !doc) {\n        return;\n    }\n    vmlInited = true;\n\n    var styleSheets = doc.styleSheets;\n    if (styleSheets.length < 31) {\n        doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n    }\n    else {\n        // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n        styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n    }\n}\n\n// http://www.w3.org/TR/NOTE-VML\n// TODO Use proxy like svg instead of overwrite brush methods\n\nvar CMD$3 = PathProxy.CMD;\nvar round$3 = Math.round;\nvar sqrt = Math.sqrt;\nvar abs$1 = Math.abs;\nvar cos = Math.cos;\nvar sin = Math.sin;\nvar mathMax$8 = Math.max;\n\nif (!env$1.canvasSupported) {\n\n    var comma = ',';\n    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n\n    var Z = 21600;\n    var Z2 = Z / 2;\n\n    var ZLEVEL_BASE = 100000;\n    var Z_BASE$1 = 1000;\n\n    var initRootElStyle = function (el) {\n        el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n        el.coordsize = Z + ','  + Z;\n        el.coordorigin = '0,0';\n    };\n\n    var encodeHtmlAttribute = function (s) {\n        return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n    };\n\n    var rgb2Str = function (r, g, b) {\n        return 'rgb(' + [r, g, b].join(',') + ')';\n    };\n\n    var append = function (parent, child) {\n        if (child && parent && child.parentNode !== parent) {\n            parent.appendChild(child);\n        }\n    };\n\n    var remove = function (parent, child) {\n        if (child && parent && child.parentNode === parent) {\n            parent.removeChild(child);\n        }\n    };\n\n    var getZIndex = function (zlevel, z, z2) {\n        // z  [0, 1000]\n        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE$1 + z2;\n    };\n\n    var parsePercent$3 = function (value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    };\n\n    /***************************************************\n     * PATH\n     **************************************************/\n\n    var setColorAndOpacity = function (el, color, opacity) {\n        var colorArr = parse(color);\n        opacity = +opacity;\n        if (isNaN(opacity)) {\n            opacity = 1;\n        }\n        if (colorArr) {\n            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n            el.opacity = opacity * colorArr[3];\n        }\n    };\n\n    var getColorAndAlpha = function (color) {\n        var colorArr = parse(color);\n        return [\n            rgb2Str(colorArr[0], colorArr[1], colorArr[2]),\n            colorArr[3]\n        ];\n    };\n\n    var updateFillNode = function (el, style, zrEl) {\n        // TODO pattern\n        var fill = style.fill;\n        if (fill != null) {\n            // Modified from excanvas\n            if (fill instanceof Gradient) {\n                var gradientType;\n                var angle = 0;\n                var focus = [0, 0];\n                // additional offset\n                var shift = 0;\n                // scale factor for offset\n                var expansion = 1;\n                var rect = zrEl.getBoundingRect();\n                var rectWidth = rect.width;\n                var rectHeight = rect.height;\n                if (fill.type === 'linear') {\n                    gradientType = 'gradient';\n                    var transform = zrEl.transform;\n                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n                    var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n                    if (transform) {\n                        applyTransform(p0, p0, transform);\n                        applyTransform(p1, p1, transform);\n                    }\n                    var dx = p1[0] - p0[0];\n                    var dy = p1[1] - p0[1];\n                    angle = Math.atan2(dx, dy) * 180 / Math.PI;\n                    // The angle should be a non-negative number.\n                    if (angle < 0) {\n                        angle += 360;\n                    }\n\n                    // Very small angles produce an unexpected result because they are\n                    // converted to a scientific notation string.\n                    if (angle < 1e-6) {\n                        angle = 0;\n                    }\n                }\n                else {\n                    gradientType = 'gradientradial';\n                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n                    var transform = zrEl.transform;\n                    var scale$$1 = zrEl.scale;\n                    var width = rectWidth;\n                    var height = rectHeight;\n                    focus = [\n                        // Percent in bounding rect\n                        (p0[0] - rect.x) / width,\n                        (p0[1] - rect.y) / height\n                    ];\n                    if (transform) {\n                        applyTransform(p0, p0, transform);\n                    }\n\n                    width /= scale$$1[0] * Z;\n                    height /= scale$$1[1] * Z;\n                    var dimension = mathMax$8(width, height);\n                    shift = 2 * 0 / dimension;\n                    expansion = 2 * fill.r / dimension - shift;\n                }\n\n                // We need to sort the color stops in ascending order by offset,\n                // otherwise IE won't interpret it correctly.\n                var stops = fill.colorStops.slice();\n                stops.sort(function(cs1, cs2) {\n                    return cs1.offset - cs2.offset;\n                });\n\n                var length$$1 = stops.length;\n                // Color and alpha list of first and last stop\n                var colorAndAlphaList = [];\n                var colors = [];\n                for (var i = 0; i < length$$1; i++) {\n                    var stop = stops[i];\n                    var colorAndAlpha = getColorAndAlpha(stop.color);\n                    colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n                    if (i === 0 || i === length$$1 - 1) {\n                        colorAndAlphaList.push(colorAndAlpha);\n                    }\n                }\n\n                if (length$$1 >= 2) {\n                    var color1 = colorAndAlphaList[0][0];\n                    var color2 = colorAndAlphaList[1][0];\n                    var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n                    var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n\n                    el.type = gradientType;\n                    el.method = 'none';\n                    el.focus = '100%';\n                    el.angle = angle;\n                    el.color = color1;\n                    el.color2 = color2;\n                    el.colors = colors.join(',');\n                    // When colors attribute is used, the meanings of opacity and o:opacity2\n                    // are reversed.\n                    el.opacity = opacity2;\n                    // FIXME g_o_:opacity ?\n                    el.opacity2 = opacity1;\n                }\n                if (gradientType === 'radial') {\n                    el.focusposition = focus.join(',');\n                }\n            }\n            else {\n                // FIXME Change from Gradient fill to color fill\n                setColorAndOpacity(el, fill, style.opacity);\n            }\n        }\n    };\n\n    var updateStrokeNode = function (el, style) {\n        // if (style.lineJoin != null) {\n        //     el.joinstyle = style.lineJoin;\n        // }\n        // if (style.miterLimit != null) {\n        //     el.miterlimit = style.miterLimit * Z;\n        // }\n        // if (style.lineCap != null) {\n        //     el.endcap = style.lineCap;\n        // }\n        if (style.lineDash != null) {\n            el.dashstyle = style.lineDash.join(' ');\n        }\n        if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n            setColorAndOpacity(el, style.stroke, style.opacity);\n        }\n    };\n\n    var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n        var isFill = type == 'fill';\n        var el = vmlEl.getElementsByTagName(type)[0];\n        // Stroke must have lineWidth\n        if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {\n            vmlEl[isFill ? 'filled' : 'stroked'] = 'true';\n            // FIXME Remove before updating, or set `colors` will throw error\n            if (style[type] instanceof Gradient) {\n                remove(vmlEl, el);\n            }\n            if (!el) {\n                el = createNode(type);\n            }\n\n            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n            append(vmlEl, el);\n        }\n        else {\n            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n            remove(vmlEl, el);\n        }\n    };\n\n    var points$3 = [[], [], []];\n    var pathDataToString = function (path, m) {\n        var M = CMD$3.M;\n        var C = CMD$3.C;\n        var L = CMD$3.L;\n        var A = CMD$3.A;\n        var Q = CMD$3.Q;\n\n        var str = [];\n        var nPoint;\n        var cmdStr;\n        var cmd;\n        var i;\n        var xi;\n        var yi;\n        var data = path.data;\n        var dataLength = path.len();\n        for (i = 0; i < dataLength;) {\n            cmd = data[i++];\n            cmdStr = '';\n            nPoint = 0;\n            switch (cmd) {\n                case M:\n                    cmdStr = ' m ';\n                    nPoint = 1;\n                    xi = data[i++];\n                    yi = data[i++];\n                    points$3[0][0] = xi;\n                    points$3[0][1] = yi;\n                    break;\n                case L:\n                    cmdStr = ' l ';\n                    nPoint = 1;\n                    xi = data[i++];\n                    yi = data[i++];\n                    points$3[0][0] = xi;\n                    points$3[0][1] = yi;\n                    break;\n                case Q:\n                case C:\n                    cmdStr = ' c ';\n                    nPoint = 3;\n                    var x1 = data[i++];\n                    var y1 = data[i++];\n                    var x2 = data[i++];\n                    var y2 = data[i++];\n                    var x3;\n                    var y3;\n                    if (cmd === Q) {\n                        // Convert quadratic to cubic using degree elevation\n                        x3 = x2;\n                        y3 = y2;\n                        x2 = (x2 + 2 * x1) / 3;\n                        y2 = (y2 + 2 * y1) / 3;\n                        x1 = (xi + 2 * x1) / 3;\n                        y1 = (yi + 2 * y1) / 3;\n                    }\n                    else {\n                        x3 = data[i++];\n                        y3 = data[i++];\n                    }\n                    points$3[0][0] = x1;\n                    points$3[0][1] = y1;\n                    points$3[1][0] = x2;\n                    points$3[1][1] = y2;\n                    points$3[2][0] = x3;\n                    points$3[2][1] = y3;\n\n                    xi = x3;\n                    yi = y3;\n                    break;\n                case A:\n                    var x = 0;\n                    var y = 0;\n                    var sx = 1;\n                    var sy = 1;\n                    var angle = 0;\n                    if (m) {\n                        // Extract SRT from matrix\n                        x = m[4];\n                        y = m[5];\n                        sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n                        sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n                        angle = Math.atan2(-m[1] / sy, m[0] / sx);\n                    }\n\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var startAngle = data[i++] + angle;\n                    var endAngle = data[i++] + startAngle + angle;\n                    // FIXME\n                    // var psi = data[i++];\n                    i++;\n                    var clockwise = data[i++];\n\n                    var x0 = cx + cos(startAngle) * rx;\n                    var y0 = cy + sin(startAngle) * ry;\n\n                    var x1 = cx + cos(endAngle) * rx;\n                    var y1 = cy + sin(endAngle) * ry;\n\n                    var type = clockwise ? ' wa ' : ' at ';\n                    if (Math.abs(x0 - x1) < 1e-4) {\n                        // IE won't render arches drawn counter clockwise if x0 == x1.\n                        if (Math.abs(endAngle - startAngle) > 1e-2) {\n                            // Offset x0 by 1/80 of a pixel. Use something\n                            // that can be represented in binary\n                            if (clockwise) {\n                                x0 += 270 / Z;\n                            }\n                        }\n                        else {\n                            // Avoid case draw full circle\n                            if (Math.abs(y0 - cy) < 1e-4) {\n                                if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {\n                                    y1 -= 270 / Z;\n                                }\n                                else {\n                                    y1 += 270 / Z;\n                                }\n                            }\n                            else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {\n                                x1 += 270 / Z;\n                            }\n                            else {\n                                x1 -= 270 / Z;\n                            }\n                        }\n                    }\n                    str.push(\n                        type,\n                        round$3(((cx - rx) * sx + x) * Z - Z2), comma,\n                        round$3(((cy - ry) * sy + y) * Z - Z2), comma,\n                        round$3(((cx + rx) * sx + x) * Z - Z2), comma,\n                        round$3(((cy + ry) * sy + y) * Z - Z2), comma,\n                        round$3((x0 * sx + x) * Z - Z2), comma,\n                        round$3((y0 * sy + y) * Z - Z2), comma,\n                        round$3((x1 * sx + x) * Z - Z2), comma,\n                        round$3((y1 * sy + y) * Z - Z2)\n                    );\n\n                    xi = x1;\n                    yi = y1;\n                    break;\n                case CMD$3.R:\n                    var p0 = points$3[0];\n                    var p1 = points$3[1];\n                    // x0, y0\n                    p0[0] = data[i++];\n                    p0[1] = data[i++];\n                    // x1, y1\n                    p1[0] = p0[0] + data[i++];\n                    p1[1] = p0[1] + data[i++];\n\n                    if (m) {\n                        applyTransform(p0, p0, m);\n                        applyTransform(p1, p1, m);\n                    }\n\n                    p0[0] = round$3(p0[0] * Z - Z2);\n                    p1[0] = round$3(p1[0] * Z - Z2);\n                    p0[1] = round$3(p0[1] * Z - Z2);\n                    p1[1] = round$3(p1[1] * Z - Z2);\n                    str.push(\n                        // x0, y0\n                        ' m ', p0[0], comma, p0[1],\n                        // x1, y0\n                        ' l ', p1[0], comma, p0[1],\n                        // x1, y1\n                        ' l ', p1[0], comma, p1[1],\n                        // x0, y1\n                        ' l ', p0[0], comma, p1[1]\n                    );\n                    break;\n                case CMD$3.Z:\n                    // FIXME Update xi, yi\n                    str.push(' x ');\n            }\n\n            if (nPoint > 0) {\n                str.push(cmdStr);\n                for (var k = 0; k < nPoint; k++) {\n                    var p = points$3[k];\n\n                    m && applyTransform(p, p, m);\n                    //  round \n                    str.push(\n                        round$3(p[0] * Z - Z2), comma, round$3(p[1] * Z - Z2),\n                        k < nPoint - 1 ? comma : ''\n                    );\n                }\n            }\n        }\n\n        return str.join('');\n    };\n\n    // Rewrite the original path method\n    Path.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n\n        var vmlEl = this._vmlEl;\n        if (!vmlEl) {\n            vmlEl = createNode('shape');\n            initRootElStyle(vmlEl);\n\n            this._vmlEl = vmlEl;\n        }\n\n        updateFillAndStroke(vmlEl, 'fill', style, this);\n        updateFillAndStroke(vmlEl, 'stroke', style, this);\n\n        var m = this.transform;\n        var needTransform = m != null;\n        var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n        if (strokeEl) {\n            var lineWidth = style.lineWidth;\n            // Get the line scale.\n            // Determinant of this.m_ means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            if (needTransform && !style.strokeNoScale) {\n                var det = m[0] * m[3] - m[1] * m[2];\n                lineWidth *= sqrt(abs$1(det));\n            }\n            strokeEl.weight = lineWidth + 'px';\n        }\n\n        var path = this.path || (this.path = new PathProxy());\n        if (this.__dirtyPath) {\n            path.beginPath();\n            this.buildPath(path, this.shape);\n            path.toStatic();\n            this.__dirtyPath = false;\n        }\n\n        vmlEl.path = pathDataToString(path, this.transform);\n\n        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Append to root\n        append(vmlRoot, vmlEl);\n\n        // Text\n        if (style.text != null) {\n            this.drawRectText(vmlRoot, this.getBoundingRect());\n        }\n        else {\n            this.removeRectText(vmlRoot);\n        }\n    };\n\n    Path.prototype.onRemove = function (vmlRoot) {\n        remove(vmlRoot, this._vmlEl);\n        this.removeRectText(vmlRoot);\n    };\n\n    Path.prototype.onAdd = function (vmlRoot) {\n        append(vmlRoot, this._vmlEl);\n        this.appendRectText(vmlRoot);\n    };\n\n    /***************************************************\n     * IMAGE\n     **************************************************/\n    var isImage = function (img) {\n        // FIXME img instanceof Image  img IE8 \n        return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';\n        // return img instanceof Image;\n    };\n\n    // Rewrite the original path method\n    ZImage.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n        var image = style.image;\n\n        // Image original width, height\n        var ow;\n        var oh;\n\n        if (isImage(image)) {\n            var src = image.src;\n            if (src === this._imageSrc) {\n                ow = this._imageWidth;\n                oh = this._imageHeight;\n            }\n            else {\n                var imageRuntimeStyle = image.runtimeStyle;\n                var oldRuntimeWidth = imageRuntimeStyle.width;\n                var oldRuntimeHeight = imageRuntimeStyle.height;\n                imageRuntimeStyle.width = 'auto';\n                imageRuntimeStyle.height = 'auto';\n\n                // get the original size\n                ow = image.width;\n                oh = image.height;\n\n                // and remove overides\n                imageRuntimeStyle.width = oldRuntimeWidth;\n                imageRuntimeStyle.height = oldRuntimeHeight;\n\n                // Caching image original width, height and src\n                this._imageSrc = src;\n                this._imageWidth = ow;\n                this._imageHeight = oh;\n            }\n            image = src;\n        }\n        else {\n            if (image === this._imageSrc) {\n                ow = this._imageWidth;\n                oh = this._imageHeight;\n            }\n        }\n        if (!image) {\n            return;\n        }\n\n        var x = style.x || 0;\n        var y = style.y || 0;\n\n        var dw = style.width;\n        var dh = style.height;\n\n        var sw = style.sWidth;\n        var sh = style.sHeight;\n        var sx = style.sx || 0;\n        var sy = style.sy || 0;\n\n        var hasCrop = sw && sh;\n\n        var vmlEl = this._vmlEl;\n        if (!vmlEl) {\n            // FIXME  group  left, top  0 \n            // vmlEl = vmlCore.createNode('group');\n            vmlEl = doc.createElement('div');\n            initRootElStyle(vmlEl);\n\n            this._vmlEl = vmlEl;\n        }\n\n        var vmlElStyle = vmlEl.style;\n        var hasRotation = false;\n        var m;\n        var scaleX = 1;\n        var scaleY = 1;\n        if (this.transform) {\n            m = this.transform;\n            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n\n            hasRotation = m[1] || m[2];\n        }\n        if (hasRotation) {\n            // If filters are necessary (rotation exists), create them\n            // filters are bog-slow, so only create them if abbsolutely necessary\n            // The following check doesn't account for skews (which don't exist\n            // in the canvas spec (yet) anyway.\n            // From excanvas\n            var p0 = [x, y];\n            var p1 = [x + dw, y];\n            var p2 = [x, y + dh];\n            var p3 = [x + dw, y + dh];\n            applyTransform(p0, p0, m);\n            applyTransform(p1, p1, m);\n            applyTransform(p2, p2, m);\n            applyTransform(p3, p3, m);\n\n            var maxX = mathMax$8(p0[0], p1[0], p2[0], p3[0]);\n            var maxY = mathMax$8(p0[1], p1[1], p2[1], p3[1]);\n\n            var transformFilter = [];\n            transformFilter.push('M11=', m[0] / scaleX, comma,\n                        'M12=', m[2] / scaleY, comma,\n                        'M21=', m[1] / scaleX, comma,\n                        'M22=', m[3] / scaleY, comma,\n                        'Dx=', round$3(x * scaleX + m[4]), comma,\n                        'Dy=', round$3(y * scaleY + m[5]));\n\n            vmlElStyle.padding = '0 ' + round$3(maxX) + 'px ' + round$3(maxY) + 'px 0';\n            // FIXME DXImageTransform  IE11 \n            vmlElStyle.filter = imageTransformPrefix + '.Matrix('\n                + transformFilter.join('') + ', SizingMethod=clip)';\n\n        }\n        else {\n            if (m) {\n                x = x * scaleX + m[4];\n                y = y * scaleY + m[5];\n            }\n            vmlElStyle.filter = '';\n            vmlElStyle.left = round$3(x) + 'px';\n            vmlElStyle.top = round$3(y) + 'px';\n        }\n\n        var imageEl = this._imageEl;\n        var cropEl = this._cropEl;\n\n        if (!imageEl) {\n            imageEl = doc.createElement('div');\n            this._imageEl = imageEl;\n        }\n        var imageELStyle = imageEl.style;\n        if (hasCrop) {\n            // Needs know image original width and height\n            if (! (ow && oh)) {\n                var tmpImage = new Image();\n                var self = this;\n                tmpImage.onload = function () {\n                    tmpImage.onload = null;\n                    ow = tmpImage.width;\n                    oh = tmpImage.height;\n                    // Adjust image width and height to fit the ratio destinationSize / sourceSize\n                    imageELStyle.width = round$3(scaleX * ow * dw / sw) + 'px';\n                    imageELStyle.height = round$3(scaleY * oh * dh / sh) + 'px';\n\n                    // Caching image original width, height and src\n                    self._imageWidth = ow;\n                    self._imageHeight = oh;\n                    self._imageSrc = image;\n                };\n                tmpImage.src = image;\n            }\n            else {\n                imageELStyle.width = round$3(scaleX * ow * dw / sw) + 'px';\n                imageELStyle.height = round$3(scaleY * oh * dh / sh) + 'px';\n            }\n\n            if (! cropEl) {\n                cropEl = doc.createElement('div');\n                cropEl.style.overflow = 'hidden';\n                this._cropEl = cropEl;\n            }\n            var cropElStyle = cropEl.style;\n            cropElStyle.width = round$3((dw + sx * dw / sw) * scaleX);\n            cropElStyle.height = round$3((dh + sy * dh / sh) * scaleY);\n            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx='\n                    + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';\n\n            if (! cropEl.parentNode) {\n                vmlEl.appendChild(cropEl);\n            }\n            if (imageEl.parentNode != cropEl) {\n                cropEl.appendChild(imageEl);\n            }\n        }\n        else {\n            imageELStyle.width = round$3(scaleX * dw) + 'px';\n            imageELStyle.height = round$3(scaleY * dh) + 'px';\n\n            vmlEl.appendChild(imageEl);\n\n            if (cropEl && cropEl.parentNode) {\n                vmlEl.removeChild(cropEl);\n                this._cropEl = null;\n            }\n        }\n\n        var filterStr = '';\n        var alpha = style.opacity;\n        if (alpha < 1) {\n            filterStr += '.Alpha(opacity=' + round$3(alpha * 100) + ') ';\n        }\n        filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n\n        imageELStyle.filter = filterStr;\n\n        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Append to root\n        append(vmlRoot, vmlEl);\n\n        // Text\n        if (style.text != null) {\n            this.drawRectText(vmlRoot, this.getBoundingRect());\n        }\n    };\n\n    ZImage.prototype.onRemove = function (vmlRoot) {\n        remove(vmlRoot, this._vmlEl);\n\n        this._vmlEl = null;\n        this._cropEl = null;\n        this._imageEl = null;\n\n        this.removeRectText(vmlRoot);\n    };\n\n    ZImage.prototype.onAdd = function (vmlRoot) {\n        append(vmlRoot, this._vmlEl);\n        this.appendRectText(vmlRoot);\n    };\n\n\n    /***************************************************\n     * TEXT\n     **************************************************/\n\n    var DEFAULT_STYLE_NORMAL = 'normal';\n\n    var fontStyleCache = {};\n    var fontStyleCacheCount = 0;\n    var MAX_FONT_CACHE_SIZE = 100;\n    var fontEl = document.createElement('div');\n\n    var getFontStyle = function (fontString) {\n        var fontStyle = fontStyleCache[fontString];\n        if (!fontStyle) {\n            // Clear cache\n            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n                fontStyleCacheCount = 0;\n                fontStyleCache = {};\n            }\n\n            var style = fontEl.style;\n            var fontFamily;\n            try {\n                style.font = fontString;\n                fontFamily = style.fontFamily.split(',')[0];\n            }\n            catch (e) {\n            }\n\n            fontStyle = {\n                style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n                variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n                weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n                size: parseFloat(style.fontSize || 12) | 0,\n                family: fontFamily || 'Microsoft YaHei'\n            };\n\n            fontStyleCache[fontString] = fontStyle;\n            fontStyleCacheCount++;\n        }\n        return fontStyle;\n    };\n\n    var textMeasureEl;\n    // Overwrite measure text method\n    $override$1('measureText', function (text, textFont) {\n        var doc$$1 = doc;\n        if (!textMeasureEl) {\n            textMeasureEl = doc$$1.createElement('div');\n            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;'\n                + 'padding:0;margin:0;border:none;white-space:pre;';\n            doc.body.appendChild(textMeasureEl);\n        }\n\n        try {\n            textMeasureEl.style.font = textFont;\n        } catch (ex) {\n            // Ignore failures to set to invalid font.\n        }\n        textMeasureEl.innerHTML = '';\n        // Don't use innerHTML or innerText because they allow markup/whitespace.\n        textMeasureEl.appendChild(doc$$1.createTextNode(text));\n        return {\n            width: textMeasureEl.offsetWidth\n        };\n    });\n\n    var tmpRect$2 = new BoundingRect();\n\n    var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n\n        var style = this.style;\n\n        // Optimize, avoid normalize every time.\n        this.__dirty && normalizeTextStyle(style, true);\n\n        var text = style.text;\n        // Convert to string\n        text != null && (text += '');\n        if (!text) {\n            return;\n        }\n\n        // Convert rich text to plain text. Rich text is not supported in\n        // IE8-, but tags in rich text template will be removed.\n        if (style.rich) {\n            var contentBlock = parseRichText(text, style);\n            text = [];\n            for (var i = 0; i < contentBlock.lines.length; i++) {\n                var tokens = contentBlock.lines[i].tokens;\n                var textLine = [];\n                for (var j = 0; j < tokens.length; j++) {\n                    textLine.push(tokens[j].text);\n                }\n                text.push(textLine.join(''));\n            }\n            text = text.join('\\n');\n        }\n\n        var x;\n        var y;\n        var align = style.textAlign;\n        var verticalAlign = style.textVerticalAlign;\n\n        var fontStyle = getFontStyle(style.font);\n        // FIXME encodeHtmlAttribute ?\n        var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' '\n            + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n\n        textRect = textRect || getBoundingRect(text, font, align, verticalAlign);\n\n        // Transform rect to view space\n        var m = this.transform;\n        // Ignore transform for text in other element\n        if (m && !fromTextEl) {\n            tmpRect$2.copy(rect);\n            tmpRect$2.applyTransform(m);\n            rect = tmpRect$2;\n        }\n\n        if (!fromTextEl) {\n            var textPosition = style.textPosition;\n            var distance$$1 = style.textDistance;\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                x = rect.x + parsePercent$3(textPosition[0], rect.width);\n                y = rect.y + parsePercent$3(textPosition[1], rect.height);\n\n                align = align || 'left';\n            }\n            else {\n                var res = adjustTextPositionOnRect(\n                    textPosition, rect, distance$$1\n                );\n                x = res.x;\n                y = res.y;\n\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                verticalAlign = verticalAlign || res.textVerticalAlign;\n            }\n        }\n        else {\n            x = rect.x;\n            y = rect.y;\n        }\n\n        x = adjustTextX(x, textRect.width, align);\n        y = adjustTextY(y, textRect.height, verticalAlign);\n\n        // Force baseline 'middle'\n        y += textRect.height / 2;\n\n        // var fontSize = fontStyle.size;\n        // 1.75 is an arbitrary number, as there is no info about the text baseline\n        // switch (baseline) {\n            // case 'hanging':\n            // case 'top':\n            //     y += fontSize / 1.75;\n            //     break;\n        //     case 'middle':\n        //         break;\n        //     default:\n        //     // case null:\n        //     // case 'alphabetic':\n        //     // case 'ideographic':\n        //     // case 'bottom':\n        //         y -= fontSize / 2.25;\n        //         break;\n        // }\n\n        // switch (align) {\n        //     case 'left':\n        //         break;\n        //     case 'center':\n        //         x -= textRect.width / 2;\n        //         break;\n        //     case 'right':\n        //         x -= textRect.width;\n        //         break;\n            // case 'end':\n                // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n                // break;\n            // case 'start':\n                // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n                // break;\n            // default:\n            //     align = 'left';\n        // }\n\n        var createNode$$1 = createNode;\n\n        var textVmlEl = this._textVmlEl;\n        var pathEl;\n        var textPathEl;\n        var skewEl;\n        if (!textVmlEl) {\n            textVmlEl = createNode$$1('line');\n            pathEl = createNode$$1('path');\n            textPathEl = createNode$$1('textpath');\n            skewEl = createNode$$1('skew');\n\n            // FIXME Why here is not cammel case\n            // Align 'center' seems wrong\n            textPathEl.style['v-text-align'] = 'left';\n\n            initRootElStyle(textVmlEl);\n\n            pathEl.textpathok = true;\n            textPathEl.on = true;\n\n            textVmlEl.from = '0 0';\n            textVmlEl.to = '1000 0.05';\n\n            append(textVmlEl, skewEl);\n            append(textVmlEl, pathEl);\n            append(textVmlEl, textPathEl);\n\n            this._textVmlEl = textVmlEl;\n        }\n        else {\n            //  appendChild \n            skewEl = textVmlEl.firstChild;\n            pathEl = skewEl.nextSibling;\n            textPathEl = pathEl.nextSibling;\n        }\n\n        var coords = [x, y];\n        var textVmlElStyle = textVmlEl.style;\n        // Ignore transform for text in other element\n        if (m && fromTextEl) {\n            applyTransform(coords, coords, m);\n\n            skewEl.on = true;\n\n            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma +\n            m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';\n\n            // Text position\n            skewEl.offset = (round$3(coords[0]) || 0) + ',' + (round$3(coords[1]) || 0);\n            // Left top point as origin\n            skewEl.origin = '0 0';\n\n            textVmlElStyle.left = '0px';\n            textVmlElStyle.top = '0px';\n        }\n        else {\n            skewEl.on = false;\n            textVmlElStyle.left = round$3(x) + 'px';\n            textVmlElStyle.top = round$3(y) + 'px';\n        }\n\n        textPathEl.string = encodeHtmlAttribute(text);\n        // TODO\n        try {\n            textPathEl.style.font = font;\n        }\n        // Error font format\n        catch (e) {}\n\n        updateFillAndStroke(textVmlEl, 'fill', {\n            fill: style.textFill,\n            opacity: style.opacity\n        }, this);\n        updateFillAndStroke(textVmlEl, 'stroke', {\n            stroke: style.textStroke,\n            opacity: style.opacity,\n            lineDash: style.lineDash\n        }, this);\n\n        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Attached to root\n        append(vmlRoot, textVmlEl);\n    };\n\n    var removeRectText = function (vmlRoot) {\n        remove(vmlRoot, this._textVmlEl);\n        this._textVmlEl = null;\n    };\n\n    var appendRectText = function (vmlRoot) {\n        append(vmlRoot, this._textVmlEl);\n    };\n\n    var list = [RectText, Displayable, ZImage, Path, Text];\n\n    // In case Displayable has been mixed in RectText\n    for (var i$3 = 0; i$3 < list.length; i$3++) {\n        var proto$6 = list[i$3].prototype;\n        proto$6.drawRectText = drawRectText;\n        proto$6.removeRectText = removeRectText;\n        proto$6.appendRectText = appendRectText;\n    }\n\n    Text.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n        if (style.text != null) {\n            this.drawRectText(vmlRoot, {\n                x: style.x || 0, y: style.y || 0,\n                width: 0, height: 0\n            }, this.getBoundingRect(), true);\n        }\n        else {\n            this.removeRectText(vmlRoot);\n        }\n    };\n\n    Text.prototype.onRemove = function (vmlRoot) {\n        this.removeRectText(vmlRoot);\n    };\n\n    Text.prototype.onAdd = function (vmlRoot) {\n        this.appendRectText(vmlRoot);\n    };\n}\n\n/**\n * VML Painter.\n *\n * @module zrender/vml/Painter\n */\n\nfunction parseInt10$1(val) {\n    return parseInt(val, 10);\n}\n\n/**\n * @alias module:zrender/vml/Painter\n */\nfunction VMLPainter(root, storage) {\n\n    initVML();\n\n    this.root = root;\n\n    this.storage = storage;\n\n    var vmlViewport = document.createElement('div');\n\n    var vmlRoot = document.createElement('div');\n\n    vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n\n    vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n\n    root.appendChild(vmlViewport);\n\n    this._vmlRoot = vmlRoot;\n    this._vmlViewport = vmlViewport;\n\n    this.resize();\n\n    // Modify storage\n    var oldDelFromStorage = storage.delFromStorage;\n    var oldAddToStorage = storage.addToStorage;\n    storage.delFromStorage = function (el) {\n        oldDelFromStorage.call(storage, el);\n\n        if (el) {\n            el.onRemove && el.onRemove(vmlRoot);\n        }\n    };\n\n    storage.addToStorage = function (el) {\n        // Displayable already has a vml node\n        el.onAdd && el.onAdd(vmlRoot);\n\n        oldAddToStorage.call(storage, el);\n    };\n\n    this._firstPaint = true;\n}\n\nVMLPainter.prototype = {\n\n    constructor: VMLPainter,\n\n    getType: function () {\n        return 'vml';\n    },\n\n    /**\n     * @return {HTMLDivElement}\n     */\n    getViewportRoot: function () {\n        return this._vmlViewport;\n    },\n\n    getViewportRootOffset: function () {\n        var viewportRoot = this.getViewportRoot();\n        if (viewportRoot) {\n            return {\n                offsetLeft: viewportRoot.offsetLeft || 0,\n                offsetTop: viewportRoot.offsetTop || 0\n            };\n        }\n    },\n\n    /**\n     * \n     */\n    refresh: function () {\n\n        var list = this.storage.getDisplayList(true, true);\n\n        this._paintList(list);\n    },\n\n    _paintList: function (list) {\n        var vmlRoot = this._vmlRoot;\n        for (var i = 0; i < list.length; i++) {\n            var el = list[i];\n            if (el.invisible || el.ignore) {\n                if (!el.__alreadyNotVisible) {\n                    el.onRemove(vmlRoot);\n                }\n                // Set as already invisible\n                el.__alreadyNotVisible = true;\n            }\n            else {\n                if (el.__alreadyNotVisible) {\n                    el.onAdd(vmlRoot);\n                }\n                el.__alreadyNotVisible = false;\n                if (el.__dirty) {\n                    el.beforeBrush && el.beforeBrush();\n                    (el.brushVML || el.brush).call(el, vmlRoot);\n                    el.afterBrush && el.afterBrush();\n                }\n            }\n            el.__dirty = false;\n        }\n\n        if (this._firstPaint) {\n            // Detached from document at first time\n            // to avoid page refreshing too many times\n\n            // FIXME  removeChild \n            this._vmlViewport.appendChild(vmlRoot);\n            this._firstPaint = false;\n        }\n    },\n\n    resize: function (width, height) {\n        var width = width == null ? this._getWidth() : width;\n        var height = height == null ? this._getHeight() : height;\n\n        if (this._width != width || this._height != height) {\n            this._width = width;\n            this._height = height;\n\n            var vmlViewportStyle = this._vmlViewport.style;\n            vmlViewportStyle.width = width + 'px';\n            vmlViewportStyle.height = height + 'px';\n        }\n    },\n\n    dispose: function () {\n        this.root.innerHTML = '';\n\n        this._vmlRoot =\n        this._vmlViewport =\n        this.storage = null;\n    },\n\n    getWidth: function () {\n        return this._width;\n    },\n\n    getHeight: function () {\n        return this._height;\n    },\n\n    clear: function () {\n        if (this._vmlViewport) {\n            this.root.removeChild(this._vmlViewport);\n        }\n    },\n\n    _getWidth: function () {\n        var root = this.root;\n        var stl = root.currentStyle;\n\n        return ((root.clientWidth || parseInt10$1(stl.width))\n                - parseInt10$1(stl.paddingLeft)\n                - parseInt10$1(stl.paddingRight)) | 0;\n    },\n\n    _getHeight: function () {\n        var root = this.root;\n        var stl = root.currentStyle;\n\n        return ((root.clientHeight || parseInt10$1(stl.height))\n                - parseInt10$1(stl.paddingTop)\n                - parseInt10$1(stl.paddingBottom)) | 0;\n    }\n};\n\n// Not supported methods\nfunction createMethodNotSupport(method) {\n    return function () {\n        zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n    };\n}\n\n// Unsupported methods\neach$1([\n    'getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers',\n    'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'\n], function (name) {\n    VMLPainter.prototype[name] = createMethodNotSupport(name);\n});\n\nregisterPainter('vml', VMLPainter);\n\nvar svgURI = 'http://www.w3.org/2000/svg';\n\nfunction createElement(name) {\n    return document.createElementNS(svgURI, name);\n}\n\n// TODO\n// 1. shadow\n// 2. Image: sx, sy, sw, sh\n\nvar CMD$4 = PathProxy.CMD;\nvar arrayJoin = Array.prototype.join;\n\nvar NONE = 'none';\nvar mathRound = Math.round;\nvar mathSin$3 = Math.sin;\nvar mathCos$3 = Math.cos;\nvar PI$5 = Math.PI;\nvar PI2$6 = Math.PI * 2;\nvar degree = 180 / PI$5;\n\nvar EPSILON$4 = 1e-4;\n\nfunction round4(val) {\n    return mathRound(val * 1e4) / 1e4;\n}\n\nfunction isAroundZero$1(val) {\n    return val < EPSILON$4 && val > -EPSILON$4;\n}\n\nfunction pathHasFill(style, isText) {\n    var fill = isText ? style.textFill : style.fill;\n    return fill != null && fill !== NONE;\n}\n\nfunction pathHasStroke(style, isText) {\n    var stroke = isText ? style.textStroke : style.stroke;\n    return stroke != null && stroke !== NONE;\n}\n\nfunction setTransform(svgEl, m) {\n    if (m) {\n        attr(svgEl, 'transform', 'matrix(' + arrayJoin.call(m, ',') + ')');\n    }\n}\n\nfunction attr(el, key, val) {\n    if (!val || val.type !== 'linear' && val.type !== 'radial') {\n        // Don't set attribute for gradient, since it need new dom nodes\n        el.setAttribute(key, val);\n    }\n}\n\nfunction attrXLink(el, key, val) {\n    el.setAttributeNS('http://www.w3.org/1999/xlink', key, val);\n}\n\nfunction bindStyle(svgEl, style, isText) {\n    if (pathHasFill(style, isText)) {\n        var fill = isText ? style.textFill : style.fill;\n        fill = fill === 'transparent' ? NONE : fill;\n\n        /**\n         * FIXME:\n         * This is a temporary fix for Chrome's clipping bug\n         * that happens when a clip-path is referring another one.\n         * This fix should be used before Chrome's bug is fixed.\n         * For an element that has clip-path, and fill is none,\n         * set it to be \"rgba(0, 0, 0, 0.002)\" will hide the element.\n         * Otherwise, it will show black fill color.\n         * 0.002 is used because this won't work for alpha values smaller\n         * than 0.002.\n         *\n         * See\n         * https://bugs.chromium.org/p/chromium/issues/detail?id=659790\n         * for more information.\n         */\n        if (svgEl.getAttribute('clip-path') !== 'none' && fill === NONE) {\n            fill = 'rgba(0, 0, 0, 0.002)';\n        }\n\n        attr(svgEl, 'fill', fill);\n        attr(svgEl, 'fill-opacity', style.opacity);\n    }\n    else {\n        attr(svgEl, 'fill', NONE);\n    }\n\n    if (pathHasStroke(style, isText)) {\n        var stroke = isText ? style.textStroke : style.stroke;\n        stroke = stroke === 'transparent' ? NONE : stroke;\n        attr(svgEl, 'stroke', stroke);\n        var strokeWidth = isText\n            ? style.textStrokeWidth\n            : style.lineWidth;\n        var strokeScale = style.strokeNoScale\n            ? style.host.getLineScale()\n            : 1;\n        attr(svgEl, 'stroke-width', strokeWidth / strokeScale);\n        attr(svgEl, 'paint-order', 'stroke');\n        attr(svgEl, 'stroke-opacity', style.opacity);\n        var lineDash = style.lineDash;\n        if (lineDash) {\n            attr(svgEl, 'stroke-dasharray', style.lineDash.join(','));\n            attr(svgEl, 'stroke-dashoffset', mathRound(style.lineDashOffset || 0));\n        }\n        else {\n            attr(svgEl, 'stroke-dasharray', '');\n        }\n\n        // PENDING\n        style.lineCap && attr(svgEl, 'stroke-linecap', style.lineCap);\n        style.lineJoin && attr(svgEl, 'stroke-linejoin', style.lineJoin);\n        style.miterLimit && attr(svgEl, 'stroke-miterlimit', style.miterLimit);\n    }\n    else {\n        attr(svgEl, 'stroke', NONE);\n    }\n}\n\n/***************************************************\n * PATH\n **************************************************/\nfunction pathDataToString$1(path) {\n    var str = [];\n    var data = path.data;\n    var dataLength = path.len();\n    for (var i = 0; i < dataLength;) {\n        var cmd = data[i++];\n        var cmdStr = '';\n        var nData = 0;\n        switch (cmd) {\n            case CMD$4.M:\n                cmdStr = 'M';\n                nData = 2;\n                break;\n            case CMD$4.L:\n                cmdStr = 'L';\n                nData = 2;\n                break;\n            case CMD$4.Q:\n                cmdStr = 'Q';\n                nData = 4;\n                break;\n            case CMD$4.C:\n                cmdStr = 'C';\n                nData = 6;\n                break;\n            case CMD$4.A:\n                var cx = data[i++];\n                var cy = data[i++];\n                var rx = data[i++];\n                var ry = data[i++];\n                var theta = data[i++];\n                var dTheta = data[i++];\n                var psi = data[i++];\n                var clockwise = data[i++];\n\n                var dThetaPositive = Math.abs(dTheta);\n                var isCircle = isAroundZero$1(dThetaPositive % PI2$6)\n                    && !isAroundZero$1(dThetaPositive);\n\n                var large = false;\n                if (dThetaPositive >= PI2$6) {\n                    large = true;\n                }\n                else if (isAroundZero$1(dThetaPositive)) {\n                    large = false;\n                }\n                else {\n                    large = (dTheta > -PI$5 && dTheta < 0 || dTheta > PI$5)\n                        === !!clockwise;\n                }\n\n                var x0 = round4(cx + rx * mathCos$3(theta));\n                var y0 = round4(cy + ry * mathSin$3(theta));\n\n                // It will not draw if start point and end point are exactly the same\n                // We need to shift the end point with a small value\n                // FIXME A better way to draw circle ?\n                if (isCircle) {\n                    if (clockwise) {\n                        dTheta = PI2$6 - 1e-4;\n                    }\n                    else {\n                        dTheta = -PI2$6 + 1e-4;\n                    }\n\n                    large = true;\n\n                    if (i === 9) {\n                        // Move to (x0, y0) only when CMD.A comes at the\n                        // first position of a shape.\n                        // For instance, when drawing a ring, CMD.A comes\n                        // after CMD.M, so it's unnecessary to move to\n                        // (x0, y0).\n                        str.push('M', x0, y0);\n                    }\n                }\n\n                var x = round4(cx + rx * mathCos$3(theta + dTheta));\n                var y = round4(cy + ry * mathSin$3(theta + dTheta));\n\n                // FIXME Ellipse\n                str.push('A', round4(rx), round4(ry),\n                    mathRound(psi * degree), +large, +clockwise, x, y);\n                break;\n            case CMD$4.Z:\n                cmdStr = 'Z';\n                break;\n            case CMD$4.R:\n                var x = round4(data[i++]);\n                var y = round4(data[i++]);\n                var w = round4(data[i++]);\n                var h = round4(data[i++]);\n                str.push(\n                    'M', x, y,\n                    'L', x + w, y,\n                    'L', x + w, y + h,\n                    'L', x, y + h,\n                    'L', x, y\n                );\n                break;\n        }\n        cmdStr && str.push(cmdStr);\n        for (var j = 0; j < nData; j++) {\n            // PENDING With scale\n            str.push(round4(data[i++]));\n        }\n    }\n    return str.join(' ');\n}\n\nvar svgPath = {};\nsvgPath.brush = function (el) {\n    var style = el.style;\n\n    var svgEl = el.__svgEl;\n    if (!svgEl) {\n        svgEl = createElement('path');\n        el.__svgEl = svgEl;\n    }\n\n    if (!el.path) {\n        el.createPathProxy();\n    }\n    var path = el.path;\n\n    if (el.__dirtyPath) {\n        path.beginPath();\n        el.buildPath(path, el.shape);\n        el.__dirtyPath = false;\n\n        var pathStr = pathDataToString$1(path);\n        if (pathStr.indexOf('NaN') < 0) {\n            // Ignore illegal path, which may happen such in out-of-range\n            // data in Calendar series.\n            attr(svgEl, 'd', pathStr);\n        }\n    }\n\n    bindStyle(svgEl, style);\n    setTransform(svgEl, el.transform);\n\n    if (style.text != null) {\n        svgTextDrawRectText(el, el.getBoundingRect());\n    }\n};\n\n/***************************************************\n * IMAGE\n **************************************************/\nvar svgImage = {};\nsvgImage.brush = function (el) {\n    var style = el.style;\n    var image = style.image;\n\n    if (image instanceof HTMLImageElement) {\n        var src = image.src;\n        image = src;\n    }\n    if (! image) {\n        return;\n    }\n\n    var x = style.x || 0;\n    var y = style.y || 0;\n\n    var dw = style.width;\n    var dh = style.height;\n\n    var svgEl = el.__svgEl;\n    if (! svgEl) {\n        svgEl = createElement('image');\n        el.__svgEl = svgEl;\n    }\n\n    if (image !== el.__imageSrc) {\n        attrXLink(svgEl, 'href', image);\n        // Caching image src\n        el.__imageSrc = image;\n    }\n\n    attr(svgEl, 'width', dw);\n    attr(svgEl, 'height', dh);\n\n    attr(svgEl, 'x', x);\n    attr(svgEl, 'y', y);\n\n    setTransform(svgEl, el.transform);\n\n    if (style.text != null) {\n        svgTextDrawRectText(el, el.getBoundingRect());\n    }\n};\n\n/***************************************************\n * TEXT\n **************************************************/\nvar svgText = {};\nvar tmpRect$3 = new BoundingRect();\n\nvar svgTextDrawRectText = function (el, rect, textRect) {\n    var style = el.style;\n\n    el.__dirty && normalizeTextStyle(style, true);\n\n    var text = style.text;\n    // Convert to string\n    if (text == null) {\n        // Draw no text only when text is set to null, but not ''\n        return;\n    }\n    else {\n        text += '';\n    }\n\n    var textSvgEl = el.__textSvgEl;\n    if (! textSvgEl) {\n        textSvgEl = createElement('text');\n        el.__textSvgEl = textSvgEl;\n    }\n\n    bindStyle(textSvgEl, style, true);\n    if (el instanceof Text || el.style.transformText) {\n        // Transform text with element\n        setTransform(textSvgEl, el.transform);\n    }\n    else {\n        if (el.transform) {\n            tmpRect$3.copy(rect);\n            tmpRect$3.applyTransform(el.transform);\n            rect = tmpRect$3;\n        }\n        else {\n            var pos = el.transformCoordToGlobal(rect.x, rect.y);\n            rect.x = pos[0];\n            rect.y = pos[1];\n        }\n    }\n\n    var x;\n    var y;\n    var textPosition = style.textPosition;\n    var distance = style.textDistance;\n    var align = style.textAlign || 'left';\n\n    if (typeof style.fontSize === 'number') {\n        style.fontSize += 'px';\n    }\n    var font = style.font\n        || [\n            style.fontStyle || '',\n            style.fontWeight || '',\n            style.fontSize || '',\n            style.fontFamily || ''\n        ].join(' ')\n        || DEFAULT_FONT;\n\n    var verticalAlign = getVerticalAlignForSvg(style.textVerticalAlign);\n\n    textRect = getBoundingRect(text, font, align,\n        verticalAlign);\n\n    var lineHeight = textRect.lineHeight;\n    // Text position represented by coord\n    if (textPosition instanceof Array) {\n        x = rect.x + textPosition[0];\n        y = rect.y + textPosition[1];\n    }\n    else {\n        var newPos = adjustTextPositionOnRect(\n            textPosition, rect, distance\n        );\n        x = newPos.x;\n        y = newPos.y;\n        verticalAlign = getVerticalAlignForSvg(newPos.textVerticalAlign);\n        align = newPos.textAlign;\n    }\n\n    attr(textSvgEl, 'alignment-baseline', verticalAlign);\n\n    if (font) {\n        textSvgEl.style.font = font;\n    }\n\n    var textPadding = style.textPadding;\n\n    // Make baseline top\n    attr(textSvgEl, 'x', x);\n    attr(textSvgEl, 'y', y);\n\n    var textLines = text.split('\\n');\n    var nTextLines = textLines.length;\n    var textAnchor = align;\n    // PENDING\n    if (textAnchor === 'left')  {\n        textAnchor = 'start';\n        textPadding && (x += textPadding[3]);\n    }\n    else if (textAnchor === 'right') {\n        textAnchor = 'end';\n        textPadding && (x -= textPadding[1]);\n    }\n    else if (textAnchor === 'center') {\n        textAnchor = 'middle';\n        textPadding && (x += (textPadding[3] - textPadding[1]) / 2);\n    }\n\n    var dy = 0;\n    if (verticalAlign === 'baseline') {\n        dy = -textRect.height + lineHeight;\n        textPadding && (dy -= textPadding[2]);\n    }\n    else if (verticalAlign === 'middle') {\n        dy = (-textRect.height + lineHeight) / 2;\n        textPadding && (y += (textPadding[0] - textPadding[2]) / 2);\n    }\n    else {\n        textPadding && (dy += textPadding[0]);\n    }\n\n    // Font may affect position of each tspan elements\n    if (el.__text !== text || el.__textFont !== font) {\n        var tspanList = el.__tspanList || [];\n        el.__tspanList = tspanList;\n        for (var i = 0; i < nTextLines; i++) {\n            // Using cached tspan elements\n            var tspan = tspanList[i];\n            if (! tspan) {\n                tspan = tspanList[i] = createElement('tspan');\n                textSvgEl.appendChild(tspan);\n                attr(tspan, 'alignment-baseline', verticalAlign);\n                attr(tspan, 'text-anchor', textAnchor);\n            }\n            else {\n                tspan.innerHTML = '';\n            }\n            attr(tspan, 'x', x);\n            attr(tspan, 'y', y + i * lineHeight + dy);\n            tspan.appendChild(document.createTextNode(textLines[i]));\n        }\n        // Remove unsed tspan elements\n        for (; i < tspanList.length; i++) {\n            textSvgEl.removeChild(tspanList[i]);\n        }\n        tspanList.length = nTextLines;\n\n        el.__text = text;\n        el.__textFont = font;\n    }\n    else if (el.__tspanList.length) {\n        // Update span x and y\n        var len = el.__tspanList.length;\n        for (var i = 0; i < len; ++i) {\n            var tspan = el.__tspanList[i];\n            if (tspan) {\n                attr(tspan, 'x', x);\n                attr(tspan, 'y', y + i * lineHeight + dy);\n            }\n        }\n    }\n};\n\nfunction getVerticalAlignForSvg(verticalAlign) {\n    if (verticalAlign === 'middle') {\n        return 'middle';\n    }\n    else if (verticalAlign === 'bottom') {\n        return 'baseline';\n    }\n    else {\n        return 'hanging';\n    }\n}\n\nsvgText.drawRectText = svgTextDrawRectText;\n\nsvgText.brush = function (el) {\n    var style = el.style;\n    if (style.text != null) {\n        //  textPosition\n        style.textPosition = [0, 0];\n        svgTextDrawRectText(el, {\n            x: style.x || 0, y: style.y || 0,\n            width: 0, height: 0\n        }, el.getBoundingRect());\n    }\n};\n\n// Myers' Diff Algorithm\n// Modified from https://github.com/kpdecker/jsdiff/blob/master/src/diff/base.js\n\nfunction Diff() {}\n\nDiff.prototype = {\n    diff: function (oldArr, newArr, equals) {\n        if (!equals) {\n            equals = function (a, b) {\n                return a === b;\n            };\n        }\n        this.equals = equals;\n\n        var self = this;\n\n        oldArr = oldArr.slice();\n        newArr = newArr.slice();\n        // Allow subclasses to massage the input prior to running\n        var newLen = newArr.length;\n        var oldLen = oldArr.length;\n        var editLength = 1;\n        var maxEditLength = newLen + oldLen;\n        var bestPath = [{ newPos: -1, components: [] }];\n\n        // Seed editLength = 0, i.e. the content starts with the same values\n        var oldPos = this.extractCommon(bestPath[0], newArr, oldArr, 0);\n        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n            var indices = [];\n            for (var i = 0; i < newArr.length; i++) {\n                indices.push(i);\n            }\n            // Identity per the equality and tokenizer\n            return [{\n                indices: indices, count: newArr.length\n            }];\n        }\n\n        // Main worker method. checks all permutations of a given edit length for acceptance.\n        function execEditLength() {\n            for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n                var basePath;\n                var addPath = bestPath[diagonalPath - 1];\n                var removePath = bestPath[diagonalPath + 1];\n                var oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n                if (addPath) {\n                    // No one else is going to attempt to use this value, clear it\n                    bestPath[diagonalPath - 1] = undefined;\n                }\n\n                var canAdd = addPath && addPath.newPos + 1 < newLen;\n                var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n                if (!canAdd && !canRemove) {\n                    // If this path is a terminal then prune\n                    bestPath[diagonalPath] = undefined;\n                    continue;\n                }\n\n                // Select the diagonal that we want to branch from. We select the prior\n                // path whose position in the new string is the farthest from the origin\n                // and does not pass the bounds of the diff graph\n                if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n                    basePath = clonePath(removePath);\n                    self.pushComponent(basePath.components, undefined, true);\n                }\n                else {\n                    basePath = addPath;   // No need to clone, we've pulled it from the list\n                    basePath.newPos++;\n                    self.pushComponent(basePath.components, true, undefined);\n                }\n\n                oldPos = self.extractCommon(basePath, newArr, oldArr, diagonalPath);\n\n                // If we have hit the end of both strings, then we are done\n                if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n                    return buildValues(self, basePath.components, newArr, oldArr);\n                }\n                else {\n                    // Otherwise track this path as a potential candidate and continue.\n                    bestPath[diagonalPath] = basePath;\n                }\n            }\n\n            editLength++;\n        }\n\n        while (editLength <= maxEditLength) {\n            var ret = execEditLength();\n            if (ret) {\n                return ret;\n            }\n        }\n    },\n\n    pushComponent: function (components, added, removed) {\n        var last = components[components.length - 1];\n        if (last && last.added === added && last.removed === removed) {\n            // We need to clone here as the component clone operation is just\n            // as shallow array clone\n            components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };\n        }\n        else {\n            components.push({count: 1, added: added, removed: removed });\n        }\n    },\n    extractCommon: function (basePath, newArr, oldArr, diagonalPath) {\n        var newLen = newArr.length;\n        var oldLen = oldArr.length;\n        var newPos = basePath.newPos;\n        var oldPos = newPos - diagonalPath;\n        var commonCount = 0;\n\n        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newArr[newPos + 1], oldArr[oldPos + 1])) {\n            newPos++;\n            oldPos++;\n            commonCount++;\n        }\n\n        if (commonCount) {\n            basePath.components.push({count: commonCount});\n        }\n\n        basePath.newPos = newPos;\n        return oldPos;\n    },\n    tokenize: function (value) {\n        return value.slice();\n    },\n    join: function (value) {\n        return value.slice();\n    }\n};\n\nfunction buildValues(diff, components, newArr, oldArr) {\n    var componentPos = 0;\n    var componentLen = components.length;\n    var newPos = 0;\n    var oldPos = 0;\n\n    for (; componentPos < componentLen; componentPos++) {\n        var component = components[componentPos];\n        if (!component.removed) {\n            var indices = [];\n            for (var i = newPos; i < newPos + component.count; i++) {\n                indices.push(i);\n            }\n            component.indices = indices;\n            newPos += component.count;\n            // Common case\n            if (!component.added) {\n                oldPos += component.count;\n            }\n        }\n        else {\n            var indices = [];\n            for (var i = oldPos; i < oldPos + component.count; i++) {\n                indices.push(i);\n            }\n            component.indices = indices;\n            oldPos += component.count;\n        }\n    }\n\n    return components;\n}\n\nfunction clonePath(path) {\n    return { newPos: path.newPos, components: path.components.slice(0) };\n}\n\nvar arrayDiff = new Diff();\n\nvar arrayDiff$1 = function (oldArr, newArr, callback) {\n    return arrayDiff.diff(oldArr, newArr, callback);\n};\n\n/**\n * @file Manages elements that can be defined in <defs> in SVG,\n *       e.g., gradients, clip path, etc.\n * @author Zhang Wenli\n */\n\nvar MARK_UNUSED = '0';\nvar MARK_USED = '1';\n\n/**\n * Manages elements that can be defined in <defs> in SVG,\n * e.g., gradients, clip path, etc.\n *\n * @class\n * @param {SVGElement}      svgRoot   root of SVG document\n * @param {string|string[]} tagNames  possible tag names\n * @param {string}          markLabel label name to make if the element\n *                                    is used\n */\nfunction Definable(\n    svgRoot,\n    tagNames,\n    markLabel\n) {\n\n    this._svgRoot = svgRoot;\n    this._tagNames = typeof tagNames === 'string' ? [tagNames] : tagNames;\n    this._markLabel = markLabel;\n\n    this.nextId = 0;\n}\n\n\nDefinable.prototype.createElement = createElement;\n\n\n/**\n * Get the <defs> tag for svgRoot; optionally creates one if not exists.\n *\n * @param {boolean} isForceCreating if need to create when not exists\n * @return {SVGDefsElement} SVG <defs> element, null if it doesn't\n * exist and isForceCreating is false\n */\nDefinable.prototype.getDefs = function (isForceCreating) {\n    var svgRoot = this._svgRoot;\n    var defs = this._svgRoot.getElementsByTagName('defs');\n    if (defs.length === 0) {\n        // Not exist\n        if (isForceCreating) {\n            defs = svgRoot.insertBefore(\n                this.createElement('defs'), // Create new tag\n                svgRoot.firstChild // Insert in the front of svg\n            );\n            if (!defs.contains) {\n                // IE doesn't support contains method\n                defs.contains = function (el) {\n                    var children = defs.children;\n                    if (!children) {\n                        return false;\n                    }\n                    for (var i = children.length - 1; i >= 0; --i) {\n                        if (children[i] === el) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n            }\n            return defs;\n        }\n        else {\n            return null;\n        }\n    }\n    else {\n        return defs[0];\n    }\n};\n\n\n/**\n * Update DOM element if necessary.\n *\n * @param {Object|string} element style element. e.g., for gradient,\n *                                it may be '#ccc' or {type: 'linear', ...}\n * @param {Function|undefined} onUpdate update callback\n */\nDefinable.prototype.update = function (element, onUpdate) {\n    if (!element) {\n        return;\n    }\n\n    var defs = this.getDefs(false);\n    if (element._dom && defs.contains(element._dom)) {\n        // Update DOM\n        if (typeof onUpdate === 'function') {\n            onUpdate();\n        }\n    }\n    else {\n        // No previous dom, create new\n        var dom = this.add(element);\n        if (dom) {\n            element._dom = dom;\n        }\n    }\n};\n\n\n/**\n * Add gradient dom to defs\n *\n * @param {SVGElement} dom DOM to be added to <defs>\n */\nDefinable.prototype.addDom = function (dom) {\n    var defs = this.getDefs(true);\n    defs.appendChild(dom);\n};\n\n\n/**\n * Remove DOM of a given element.\n *\n * @param {SVGElement} element element to remove dom\n */\nDefinable.prototype.removeDom = function (element) {\n    var defs = this.getDefs(false);\n    defs.removeChild(element._dom);\n};\n\n\n/**\n * Get DOMs of this element.\n *\n * @return {HTMLDomElement} doms of this defineable elements in <defs>\n */\nDefinable.prototype.getDoms = function () {\n    var defs = this.getDefs(false);\n    if (!defs) {\n        // No dom when defs is not defined\n        return [];\n    }\n\n    var doms = [];\n    each$1(this._tagNames, function (tagName) {\n        var tags = defs.getElementsByTagName(tagName);\n        // Note that tags is HTMLCollection, which is array-like\n        // rather than real array.\n        // So `doms.concat(tags)` add tags as one object.\n        doms = doms.concat([].slice.call(tags));\n    });\n\n    return doms;\n};\n\n\n/**\n * Mark DOMs to be unused before painting, and clear unused ones at the end\n * of the painting.\n */\nDefinable.prototype.markAllUnused = function () {\n    var doms = this.getDoms();\n    var that = this;\n    each$1(doms, function (dom) {\n        dom[that._markLabel] = MARK_UNUSED;\n    });\n};\n\n\n/**\n * Mark a single DOM to be used.\n *\n * @param {SVGElement} dom DOM to mark\n */\nDefinable.prototype.markUsed = function (dom) {\n    if (dom) {\n        dom[this._markLabel] = MARK_USED;\n    }\n};\n\n\n/**\n * Remove unused DOMs defined in <defs>\n */\nDefinable.prototype.removeUnused = function () {\n    var defs = this.getDefs(false);\n    if (!defs) {\n        // Nothing to remove\n        return;\n    }\n\n    var doms = this.getDoms();\n    var that = this;\n    each$1(doms, function (dom) {\n        if (dom[that._markLabel] !== MARK_USED) {\n            // Remove gradient\n            defs.removeChild(dom);\n        }\n    });\n};\n\n\n/**\n * Get SVG proxy.\n *\n * @param {Displayable} displayable displayable element\n * @return {Path|Image|Text} svg proxy of given element\n */\nDefinable.prototype.getSvgProxy = function (displayable) {\n    if (displayable instanceof Path) {\n        return svgPath;\n    }\n    else if (displayable instanceof ZImage) {\n        return svgImage;\n    }\n    else if (displayable instanceof Text) {\n        return svgText;\n    }\n    else {\n        return svgPath;\n    }\n};\n\n\n/**\n * Get text SVG element.\n *\n * @param {Displayable} displayable displayable element\n * @return {SVGElement} SVG element of text\n */\nDefinable.prototype.getTextSvgElement = function (displayable) {\n    return displayable.__textSvgEl;\n};\n\n\n/**\n * Get SVG element.\n *\n * @param {Displayable} displayable displayable element\n * @return {SVGElement} SVG element\n */\nDefinable.prototype.getSvgElement = function (displayable) {\n    return displayable.__svgEl;\n};\n\n/**\n * @file Manages SVG gradient elements.\n * @author Zhang Wenli\n */\n\n/**\n * Manages SVG gradient elements.\n *\n * @class\n * @extends Definable\n * @param   {SVGElement} svgRoot root of SVG document\n */\nfunction GradientManager(svgRoot) {\n    Definable.call(\n        this,\n        svgRoot,\n        ['linearGradient', 'radialGradient'],\n        '__gradient_in_use__'\n    );\n}\n\n\ninherits(GradientManager, Definable);\n\n\n/**\n * Create new gradient DOM for fill or stroke if not exist,\n * but will not update gradient if exists.\n *\n * @param {SvgElement}  svgElement   SVG element to paint\n * @param {Displayable} displayable  zrender displayable element\n */\nGradientManager.prototype.addWithoutUpdate = function (\n    svgElement,\n    displayable\n) {\n    if (displayable && displayable.style) {\n        var that = this;\n        each$1(['fill', 'stroke'], function (fillOrStroke) {\n            if (displayable.style[fillOrStroke]\n                && (displayable.style[fillOrStroke].type === 'linear'\n                || displayable.style[fillOrStroke].type === 'radial')\n            ) {\n                var gradient = displayable.style[fillOrStroke];\n                var defs = that.getDefs(true);\n\n                // Create dom in <defs> if not exists\n                var dom;\n                if (gradient._dom) {\n                    // Gradient exists\n                    dom = gradient._dom;\n                    if (!defs.contains(gradient._dom)) {\n                        // _dom is no longer in defs, recreate\n                        that.addDom(dom);\n                    }\n                }\n                else {\n                    // New dom\n                    dom = that.add(gradient);\n                }\n\n                that.markUsed(displayable);\n\n                var id = dom.getAttribute('id');\n                svgElement.setAttribute(fillOrStroke, 'url(#' + id + ')');\n            }\n        });\n    }\n};\n\n\n/**\n * Add a new gradient tag in <defs>\n *\n * @param   {Gradient} gradient zr gradient instance\n * @return {SVGLinearGradientElement | SVGRadialGradientElement}\n *                            created DOM\n */\nGradientManager.prototype.add = function (gradient) {\n    var dom;\n    if (gradient.type === 'linear') {\n        dom = this.createElement('linearGradient');\n    }\n    else if (gradient.type === 'radial') {\n        dom = this.createElement('radialGradient');\n    }\n    else {\n        zrLog('Illegal gradient type.');\n        return null;\n    }\n\n    // Set dom id with gradient id, since each gradient instance\n    // will have no more than one dom element.\n    // id may exists before for those dirty elements, in which case\n    // id should remain the same, and other attributes should be\n    // updated.\n    gradient.id = gradient.id || this.nextId++;\n    dom.setAttribute('id', 'zr-gradient-' + gradient.id);\n\n    this.updateDom(gradient, dom);\n    this.addDom(dom);\n\n    return dom;\n};\n\n\n/**\n * Update gradient.\n *\n * @param {Gradient} gradient zr gradient instance\n */\nGradientManager.prototype.update = function (gradient) {\n    var that = this;\n    Definable.prototype.update.call(this, gradient, function () {\n        var type = gradient.type;\n        var tagName = gradient._dom.tagName;\n        if (type === 'linear' && tagName === 'linearGradient'\n            || type === 'radial' && tagName === 'radialGradient'\n        ) {\n            // Gradient type is not changed, update gradient\n            that.updateDom(gradient, gradient._dom);\n        }\n        else {\n            // Remove and re-create if type is changed\n            that.removeDom(gradient);\n            that.add(gradient);\n        }\n    });\n};\n\n\n/**\n * Update gradient dom\n *\n * @param {Gradient} gradient zr gradient instance\n * @param {SVGLinearGradientElement | SVGRadialGradientElement} dom\n *                            DOM to update\n */\nGradientManager.prototype.updateDom = function (gradient, dom) {\n    if (gradient.type === 'linear') {\n        dom.setAttribute('x1', gradient.x);\n        dom.setAttribute('y1', gradient.y);\n        dom.setAttribute('x2', gradient.x2);\n        dom.setAttribute('y2', gradient.y2);\n    }\n    else if (gradient.type === 'radial') {\n        dom.setAttribute('cx', gradient.x);\n        dom.setAttribute('cy', gradient.y);\n        dom.setAttribute('r', gradient.r);\n    }\n    else {\n        zrLog('Illegal gradient type.');\n        return;\n    }\n\n    if (gradient.global) {\n        // x1, x2, y1, y2 in range of 0 to canvas width or height\n        dom.setAttribute('gradientUnits', 'userSpaceOnUse');\n    }\n    else {\n        // x1, x2, y1, y2 in range of 0 to 1\n        dom.setAttribute('gradientUnits', 'objectBoundingBox');\n    }\n\n    // Remove color stops if exists\n    dom.innerHTML = '';\n\n    // Add color stops\n    var colors = gradient.colorStops;\n    for (var i = 0, len = colors.length; i < len; ++i) {\n        var stop = this.createElement('stop');\n        stop.setAttribute('offset', colors[i].offset * 100 + '%');\n        stop.setAttribute('stop-color', colors[i].color);\n        dom.appendChild(stop);\n    }\n\n    // Store dom element in gradient, to avoid creating multiple\n    // dom instances for the same gradient element\n    gradient._dom = dom;\n};\n\n/**\n * Mark a single gradient to be used\n *\n * @param {Displayable} displayable displayable element\n */\nGradientManager.prototype.markUsed = function (displayable) {\n    if (displayable.style) {\n        var gradient = displayable.style.fill;\n        if (gradient && gradient._dom) {\n            Definable.prototype.markUsed.call(this, gradient._dom);\n        }\n\n        gradient = displayable.style.stroke;\n        if (gradient && gradient._dom) {\n            Definable.prototype.markUsed.call(this, gradient._dom);\n        }\n    }\n};\n\n/**\n * @file Manages SVG clipPath elements.\n * @author Zhang Wenli\n */\n\n/**\n * Manages SVG clipPath elements.\n *\n * @class\n * @extends Definable\n * @param   {SVGElement} svgRoot root of SVG document\n */\nfunction ClippathManager(svgRoot) {\n    Definable.call(this, svgRoot, 'clipPath', '__clippath_in_use__');\n}\n\n\ninherits(ClippathManager, Definable);\n\n\n/**\n * Update clipPath.\n *\n * @param {Displayable} displayable displayable element\n */\nClippathManager.prototype.update = function (displayable) {\n    var svgEl = this.getSvgElement(displayable);\n    if (svgEl) {\n        this.updateDom(svgEl, displayable.__clipPaths, false);\n    }\n\n    var textEl = this.getTextSvgElement(displayable);\n    if (textEl) {\n        // Make another clipPath for text, since it's transform\n        // matrix is not the same with svgElement\n        this.updateDom(textEl, displayable.__clipPaths, true);\n    }\n\n    this.markUsed(displayable);\n};\n\n\n/**\n * Create an SVGElement of displayable and create a <clipPath> of its\n * clipPath\n *\n * @param {Displayable} parentEl  parent element\n * @param {ClipPath[]}  clipPaths clipPaths of parent element\n * @param {boolean}     isText    if parent element is Text\n */\nClippathManager.prototype.updateDom = function (\n    parentEl,\n    clipPaths,\n    isText\n) {\n    if (clipPaths && clipPaths.length > 0) {\n        // Has clipPath, create <clipPath> with the first clipPath\n        var defs = this.getDefs(true);\n        var clipPath = clipPaths[0];\n        var clipPathEl;\n        var id;\n\n        var dom = isText ? '_textDom' : '_dom';\n\n        if (clipPath[dom]) {\n            // Use a dom that is already in <defs>\n            id = clipPath[dom].getAttribute('id');\n            clipPathEl = clipPath[dom];\n\n            // Use a dom that is already in <defs>\n            if (!defs.contains(clipPathEl)) {\n                // This happens when set old clipPath that has\n                // been previously removed\n                defs.appendChild(clipPathEl);\n            }\n        }\n        else {\n            // New <clipPath>\n            id = 'zr-clip-' + this.nextId;\n            ++this.nextId;\n            clipPathEl = this.createElement('clipPath');\n            clipPathEl.setAttribute('id', id);\n            defs.appendChild(clipPathEl);\n\n            clipPath[dom] = clipPathEl;\n        }\n\n        // Build path and add to <clipPath>\n        var svgProxy = this.getSvgProxy(clipPath);\n        if (clipPath.transform\n            && clipPath.parent.invTransform\n            && !isText\n        ) {\n            /**\n             * If a clipPath has a parent with transform, the transform\n             * of parent should not be considered when setting transform\n             * of clipPath. So we need to transform back from parent's\n             * transform, which is done by multiplying parent's inverse\n             * transform.\n             */\n            // Store old transform\n            var transform = Array.prototype.slice.call(\n                clipPath.transform\n            );\n\n            // Transform back from parent, and brush path\n            mul$1(\n                clipPath.transform,\n                clipPath.parent.invTransform,\n                clipPath.transform\n            );\n            svgProxy.brush(clipPath);\n\n            // Set back transform of clipPath\n            clipPath.transform = transform;\n        }\n        else {\n            svgProxy.brush(clipPath);\n        }\n\n        var pathEl = this.getSvgElement(clipPath);\n        /**\n         * Use `cloneNode()` here to appendChild to multiple parents,\n         * which may happend when Text and other shapes are using the same\n         * clipPath. Since Text will create an extra clipPath DOM due to\n         * different transform rules.\n         */\n        clipPathEl.appendChild(pathEl.cloneNode());\n\n        parentEl.setAttribute('clip-path', 'url(#' + id + ')');\n\n        if (clipPaths.length > 1) {\n            // Make the other clipPaths recursively\n            this.updateDom(clipPathEl, clipPaths.slice(1), isText);\n        }\n    }\n    else {\n        // No clipPath\n        if (parentEl) {\n            parentEl.setAttribute('clip-path', 'none');\n        }\n    }\n};\n\n/**\n * Mark a single clipPath to be used\n *\n * @param {Displayable} displayable displayable element\n */\nClippathManager.prototype.markUsed = function (displayable) {\n    var that = this;\n    if (displayable.__clipPaths && displayable.__clipPaths.length > 0) {\n        each$1(displayable.__clipPaths, function (clipPath) {\n            if (clipPath._dom) {\n                Definable.prototype.markUsed.call(that, clipPath._dom);\n            }\n            if (clipPath._textDom) {\n                Definable.prototype.markUsed.call(that, clipPath._textDom);\n            }\n        });\n    }\n};\n\n/**\n * SVG Painter\n * @module zrender/svg/Painter\n */\n\nfunction parseInt10$2(val) {\n    return parseInt(val, 10);\n}\n\nfunction getSvgProxy(el) {\n    if (el instanceof Path) {\n        return svgPath;\n    }\n    else if (el instanceof ZImage) {\n        return svgImage;\n    }\n    else if (el instanceof Text) {\n        return svgText;\n    }\n    else {\n        return svgPath;\n    }\n}\n\nfunction checkParentAvailable(parent, child) {\n    return child && parent && child.parentNode !== parent;\n}\n\nfunction insertAfter(parent, child, prevSibling) {\n    if (checkParentAvailable(parent, child) && prevSibling) {\n        var nextSibling = prevSibling.nextSibling;\n        nextSibling ? parent.insertBefore(child, nextSibling)\n            : parent.appendChild(child);\n    }\n}\n\nfunction prepend(parent, child) {\n    if (checkParentAvailable(parent, child)) {\n        var firstChild = parent.firstChild;\n        firstChild ? parent.insertBefore(child, firstChild)\n            : parent.appendChild(child);\n    }\n}\n\nfunction remove$1(parent, child) {\n    if (child && parent && child.parentNode === parent) {\n        parent.removeChild(child);\n    }\n}\n\nfunction getTextSvgElement(displayable) {\n    return displayable.__textSvgEl;\n}\n\nfunction getSvgElement(displayable) {\n    return displayable.__svgEl;\n}\n\n/**\n * @alias module:zrender/svg/Painter\n */\nvar SVGPainter = function (root, storage) {\n\n    this.root = root;\n\n    this.storage = storage;\n\n    var svgRoot = createElement('svg');\n    svgRoot.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    svgRoot.setAttribute('version', '1.1');\n    svgRoot.setAttribute('baseProfile', 'full');\n    svgRoot.style['user-select'] = 'none';\n\n    this.gradientManager = new GradientManager(svgRoot);\n    this.clipPathManager = new ClippathManager(svgRoot);\n\n    var viewport = document.createElement('div');\n    viewport.style.cssText = 'overflow: hidden;';\n\n    this._svgRoot = svgRoot;\n    this._viewport = viewport;\n\n    root.appendChild(viewport);\n    viewport.appendChild(svgRoot);\n\n    this.resize();\n\n    this._visibleList = [];\n};\n\nSVGPainter.prototype = {\n\n    constructor: SVGPainter,\n\n    getType: function () {\n        return 'svg';\n    },\n\n    getViewportRoot: function () {\n        return this._viewport;\n    },\n\n    getViewportRootOffset: function () {\n        var viewportRoot = this.getViewportRoot();\n        if (viewportRoot) {\n            return {\n                offsetLeft: viewportRoot.offsetLeft || 0,\n                offsetTop: viewportRoot.offsetTop || 0\n            };\n        }\n    },\n\n    refresh: function () {\n\n        var list = this.storage.getDisplayList(true);\n\n        this._paintList(list);\n    },\n\n    _paintList: function (list) {\n        this.gradientManager.markAllUnused();\n        this.clipPathManager.markAllUnused();\n\n        var svgRoot = this._svgRoot;\n        var visibleList = this._visibleList;\n        var listLen = list.length;\n\n        var newVisibleList = [];\n        var i;\n        for (i = 0; i < listLen; i++) {\n            var displayable = list[i];\n            var svgProxy = getSvgProxy(displayable);\n            if (!displayable.invisible) {\n                if (displayable.__dirty) {\n                    svgProxy && svgProxy.brush(displayable);\n\n                    // Update clipPath\n                    this.clipPathManager.update(displayable);\n\n                    // Update gradient\n                    if (displayable.style) {\n                        this.gradientManager\n                            .update(displayable.style.fill);\n                        this.gradientManager\n                            .update(displayable.style.stroke);\n                    }\n\n                    displayable.__dirty = false;\n                }\n                newVisibleList.push(displayable);\n            }\n        }\n\n        var diff = arrayDiff$1(visibleList, newVisibleList);\n        var prevSvgElement;\n\n        // First do remove, in case element moved to the head and do remove\n        // after add\n        for (i = 0; i < diff.length; i++) {\n            var item = diff[i];\n            if (item.removed) {\n                for (var k = 0; k < item.count; k++) {\n                    var displayable = visibleList[item.indices[k]];\n                    var svgElement = getSvgElement(displayable);\n                    var textSvgElement = getTextSvgElement(displayable);\n                    remove$1(svgRoot, svgElement);\n                    remove$1(svgRoot, textSvgElement);\n                }\n            }\n        }\n        for (i = 0; i < diff.length; i++) {\n            var item = diff[i];\n            if (item.added) {\n                for (var k = 0; k < item.count; k++) {\n                    var displayable = newVisibleList[item.indices[k]];\n                    var svgElement = getSvgElement(displayable);\n                    var textSvgElement = getTextSvgElement(displayable);\n                    prevSvgElement\n                        ? insertAfter(svgRoot, svgElement, prevSvgElement)\n                        : prepend(svgRoot, svgElement);\n                    if (svgElement) {\n                        insertAfter(svgRoot, textSvgElement, svgElement);\n                    }\n                    else if (prevSvgElement) {\n                        insertAfter(\n                            svgRoot, textSvgElement, prevSvgElement\n                        );\n                    }\n                    else {\n                        prepend(svgRoot, textSvgElement);\n                    }\n                    // Insert text\n                    insertAfter(svgRoot, textSvgElement, svgElement);\n                    prevSvgElement = textSvgElement || svgElement\n                        || prevSvgElement;\n\n                    this.gradientManager\n                        .addWithoutUpdate(svgElement, displayable);\n                    this.clipPathManager.markUsed(displayable);\n                }\n            }\n            else if (!item.removed) {\n                for (var k = 0; k < item.count; k++) {\n                    var displayable = newVisibleList[item.indices[k]];\n                    prevSvgElement\n                        = svgElement\n                        = getTextSvgElement(displayable)\n                        || getSvgElement(displayable)\n                        || prevSvgElement;\n\n                    this.gradientManager.markUsed(displayable);\n                    this.gradientManager\n                        .addWithoutUpdate(svgElement, displayable);\n\n                    this.clipPathManager.markUsed(displayable);\n                }\n            }\n        }\n\n        this.gradientManager.removeUnused();\n        this.clipPathManager.removeUnused();\n\n        this._visibleList = newVisibleList;\n    },\n\n    _getDefs: function (isForceCreating) {\n        var svgRoot = this._svgRoot;\n        var defs = this._svgRoot.getElementsByTagName('defs');\n        if (defs.length === 0) {\n            // Not exist\n            if (isForceCreating) {\n                var defs = svgRoot.insertBefore(\n                    createElement('defs'), // Create new tag\n                    svgRoot.firstChild // Insert in the front of svg\n                );\n                if (!defs.contains) {\n                    // IE doesn't support contains method\n                    defs.contains = function (el) {\n                        var children = defs.children;\n                        if (!children) {\n                            return false;\n                        }\n                        for (var i = children.length - 1; i >= 0; --i) {\n                            if (children[i] === el) {\n                                return true;\n                            }\n                        }\n                        return false;\n                    };\n                }\n                return defs;\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return defs[0];\n        }\n    },\n\n    resize: function () {\n        var width = this._getWidth();\n        var height = this._getHeight();\n\n        if (this._width !== width && this._height !== height) {\n            this._width = width;\n            this._height = height;\n\n            var viewportStyle = this._viewport.style;\n            viewportStyle.width = width + 'px';\n            viewportStyle.height = height + 'px';\n\n            var svgRoot = this._svgRoot;\n            // Set width by 'svgRoot.width = width' is invalid\n            svgRoot.setAttribute('width', width);\n            svgRoot.setAttribute('height', height);\n        }\n    },\n\n    getWidth: function () {\n        return this._getWidth();\n    },\n\n    getHeight: function () {\n        return this._getHeight();\n    },\n\n    _getWidth: function () {\n        var root = this.root;\n        var stl = document.defaultView.getComputedStyle(root);\n\n        return ((root.clientWidth || parseInt10$2(stl.width))\n                - parseInt10$2(stl.paddingLeft)\n                - parseInt10$2(stl.paddingRight)) | 0;\n    },\n\n    _getHeight: function () {\n        var root = this.root;\n        var stl = document.defaultView.getComputedStyle(root);\n\n        return ((root.clientHeight || parseInt10$2(stl.height))\n                - parseInt10$2(stl.paddingTop)\n                - parseInt10$2(stl.paddingBottom)) | 0;\n    },\n\n    dispose: function () {\n        this.root.innerHTML = '';\n\n        this._svgRoot\n            = this._viewport\n            = this.storage\n            = null;\n    },\n\n    clear: function () {\n        if (this._viewport) {\n            this.root.removeChild(this._viewport);\n        }\n    },\n\n    pathToSvg: function () {\n        this.refresh();\n        var html = this._svgRoot.outerHTML;\n        return 'data:img/svg+xml;utf-8,' + unescape(html);\n    }\n};\n\n// Not supported methods\nfunction createMethodNotSupport$1(method) {\n    return function () {\n        zrLog('In SVG mode painter not support method \"' + method + '\"');\n    };\n}\n\n// Unsuppoted methods\neach$1([\n    'getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer',\n    'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer',\n    'toDataURL', 'pathToImage'\n], function (name) {\n    SVGPainter.prototype[name] = createMethodNotSupport$1(name);\n});\n\nregisterPainter('svg', SVGPainter);\n\n// Import all charts and components\n\nexports.version = version;\nexports.dependencies = dependencies;\nexports.PRIORITY = PRIORITY;\nexports.init = init;\nexports.connect = connect;\nexports.disConnect = disConnect;\nexports.disconnect = disconnect;\nexports.dispose = dispose;\nexports.getInstanceByDom = getInstanceByDom;\nexports.getInstanceById = getInstanceById;\nexports.registerTheme = registerTheme;\nexports.registerPreprocessor = registerPreprocessor;\nexports.registerProcessor = registerProcessor;\nexports.registerPostUpdate = registerPostUpdate;\nexports.registerAction = registerAction;\nexports.registerCoordinateSystem = registerCoordinateSystem;\nexports.getCoordinateSystemDimensions = getCoordinateSystemDimensions;\nexports.registerLayout = registerLayout;\nexports.registerVisual = registerVisual;\nexports.registerLoading = registerLoading;\nexports.extendComponentModel = extendComponentModel;\nexports.extendComponentView = extendComponentView;\nexports.extendSeriesModel = extendSeriesModel;\nexports.extendChartView = extendChartView;\nexports.setCanvasCreator = setCanvasCreator;\nexports.registerMap = registerMap;\nexports.getMap = getMap;\nexports.dataTool = dataTool;\nexports.zrender = zrender;\nexports.graphic = graphic;\nexports.number = number;\nexports.format = format;\nexports.throttle = throttle;\nexports.helper = helper;\nexports.matrix = matrix;\nexports.vector = vector;\nexports.color = color;\nexports.util = ecUtil;\nexports.List = List;\nexports.Model = Model;\nexports.Axis = Axis;\nexports.env = env$1;\nexports.parseGeoJson = parseGeoJson;\n\n})));\n//# sourceMappingURL=echarts.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./static/echarts.js\n// module id = G7tq\n// module chunks = 1","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"flBox\"}},[_c('transition',{on:{\"before-enter\":_vm.bEnter,\"enter\":_vm.enter,\"after-enter\":_vm.aEnter,\"enter-cancelled\":_vm.enterCanc}},[_c('router-view')],1)],1)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-83553856\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/login.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-83553856\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!sass-loader?{\\\"sourceMap\\\":true}!../../node_modules/vue-loader/lib/selector?type=styles&index=0!./login.vue\")\n}\nvar normalizeComponent = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./login.vue\"\nimport __vue_script__ from \"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./login.vue\"\n/* template */\nimport __vue_template__ from \"!!../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-83553856\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../node_modules/vue-loader/lib/selector?type=template&index=0!./login.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-83553856\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/login.vue\n// module id = null\n// module chunks = ","<template>\n  <div id=\"flBox\">\n    <transition\n    @before-enter=\"bEnter\"\n    @enter=\"enter\"\n    @after-enter=\"aEnter\"\n    @enter-cancelled=\"enterCanc\"\n    >\n        <router-view></router-view>\n    </transition>\n  </div>\n</template>\n\n<script>\nimport '../../static/Detector.js'\nexport default {\n  name: 'login',\n  data () {\n    return {\n    }\n  },\n  mounted () {\n\n  },\n  methods: {\n    bEnter(el){\n      el.style.transform = \"translate(100% ,-200%) scale(0.1) \"\n    },\n    enter(el, done){\n      el.offsetTop;\n      el.style.transform = 'translate(0,0) scale(1)';\n      el.style.transition = \"all 1s cubic-bezier(.19,.93,.46,1.45)\";\n      done()\n    },\n    aEnter(el){\n      // \n    },\n    enterCanc(el){\n\n    }\n  },\n  watch: {\n    // '$route.path': function (newVal, oldVal) {\n    //   console.log(newVal)\n    //   // if(newVal === '/home'){\n    //   //   document.getElementById('canBox').style.display = 'none'\n    //   // }\n    // }\n  },\n  directives: {\n    focus: {\n      inserted: function (el) {\n        el.focus()\n      }\n    }\n  }\n}\n\n</script>\n\n<style lang=\"scss\" scoped>\n   #flBox{\n     width: 100%;\n     max-width: 750px;\n     height: 100%;\n     position: absolute;\n     display: flex;\n     justify-content: center;\n     align-items: center;\n     overflow: hidden;\n   }\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/login.vue","<template>\n    <div id=\"indexBox\">\n      <div id=\"maxbox\">\n        <!--header-->\n        <mt-header style=\"max-width: 750px;z-index: 999\" fixed :title=\"'~'+userName\">\n          <router-link to=\"/\" slot=\"left\">\n            <mt-button style=\"color: #fff\" icon=\"back\"></mt-button>\n          </router-link>\n        </mt-header>\n        <!--view-->\n        <div class=\"content\">\n          <transition>\n            <router-view></router-view>\n          </transition>\n        </div>\n        <!--footer-->\n        <mt-tabbar style=\"z-index: 9999\" fixed :selected.sync=\"selected\">\n          <mt-tab-item id=\"tab1\">\n            <router-link to=\"/home\" tag=\"div\">\n              <i class=\"el-icon-news\"></i>\n              <div></div>\n            </router-link>\n          </mt-tab-item>\n          <mt-tab-item id=\"tab2\">\n            <router-link to=\"/makePic\" tag=\"div\">\n              <i class=\"el-icon-star-off\"></i>\n              <div></div>\n            </router-link>\n          </mt-tab-item>\n          <mt-tab-item id=\"tab3\">\n            <router-link to=\"/echarts\" tag=\"div\">\n              <i class=\"el-icon-time\"></i>\n              <div></div>\n            </router-link>\n          </mt-tab-item>\n          <mt-tab-item id=\"tab4\">\n            <router-link to=\"/richScan\" tag=\"div\">\n              <i class=\"el-icon-view\"></i>\n              <div></div>\n            </router-link>\n          </mt-tab-item>\n        </mt-tabbar>\n      </div>\n    </div>\n</template>\n\n<script>\nexport default {\n  name: 'index',\n  data () {\n    return {\n      selected: '2',\n      userName: localStorage.getItem('user_name')\n    }\n  },\n  created () {\n  },\n  mounted () {\n  },\n  watch: {\n    // '$route.path': function (newVal, oldVal) {\n    //   console.log(document.getElementById('canBox'))\n    //   if(newVal === '/home'){\n    //     document.getElementById('canBox').style.display = 'none'\n    //   }\n    // }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n  #indexBox{\n    width: 100%;\n    height: 100%;\n    position: relative;\n  }\n  .content{\n    width: 100%;\n    height: 100%;\n    position: relative;\n    top: 0px;\n    padding-top: 40px;\n    overflow-x: hidden;\n    box-sizing: border-box;\n  }\n  #maxbox{\n    width: 100%;\n    height: 100%;\n    background: url(\"../assets/images/bg2.gif\");\n    overflow-x:hidden;\n    position: relative;\n  }\n  i {\n    font-size: 20px;\n  }\n  .homeActive {\n    color: #26a2ff;\n    font-weight: bold;\n  }\n  .v-enter{\n    opacity: 0;\n    transform:translateX(100%) scale(0.8);\n  }\n  .v-leave-to{\n    opacity: 0;\n    transform:translateX(-100%);\n    position:absolute;\n    top:60px;\n  }\n  .v-enter-active, .v-leave-active{\n    transition:all 0.6s ease;\n  }\n  .el-footer{\n    height: 50px!important;\n  }\n  .mint-tabbar{\n    height: 50px;\n    max-width: 750px;\n  }\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/index.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"indexBox\"}},[_c('div',{attrs:{\"id\":\"maxbox\"}},[_c('mt-header',{staticStyle:{\"max-width\":\"750px\",\"z-index\":\"999\"},attrs:{\"fixed\":\"\",\"title\":'~'+_vm.userName}},[_c('router-link',{attrs:{\"slot\":\"left\",\"to\":\"/\"},slot:\"left\"},[_c('mt-button',{staticStyle:{\"color\":\"#fff\"},attrs:{\"icon\":\"back\"}},[_vm._v(\"\")])],1)],1),_vm._v(\" \"),_c('div',{staticClass:\"content\"},[_c('transition',[_c('router-view')],1)],1),_vm._v(\" \"),_c('mt-tabbar',{staticStyle:{\"z-index\":\"9999\"},attrs:{\"fixed\":\"\",\"selected\":_vm.selected},on:{\"update:selected\":function($event){_vm.selected=$event}}},[_c('mt-tab-item',{attrs:{\"id\":\"tab1\"}},[_c('router-link',{attrs:{\"to\":\"/home\",\"tag\":\"div\"}},[_c('i',{staticClass:\"el-icon-news\"}),_vm._v(\" \"),_c('div',[_vm._v(\"\")])])],1),_vm._v(\" \"),_c('mt-tab-item',{attrs:{\"id\":\"tab2\"}},[_c('router-link',{attrs:{\"to\":\"/makePic\",\"tag\":\"div\"}},[_c('i',{staticClass:\"el-icon-star-off\"}),_vm._v(\" \"),_c('div',[_vm._v(\"\")])])],1),_vm._v(\" \"),_c('mt-tab-item',{attrs:{\"id\":\"tab3\"}},[_c('router-link',{attrs:{\"to\":\"/echarts\",\"tag\":\"div\"}},[_c('i',{staticClass:\"el-icon-time\"}),_vm._v(\" \"),_c('div',[_vm._v(\"\")])])],1),_vm._v(\" \"),_c('mt-tab-item',{attrs:{\"id\":\"tab4\"}},[_c('router-link',{attrs:{\"to\":\"/richScan\",\"tag\":\"div\"}},[_c('i',{staticClass:\"el-icon-view\"}),_vm._v(\" \"),_c('div',[_vm._v(\"\")])])],1)],1)],1)])}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-4d4cb0c5\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/index.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-4d4cb0c5\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!sass-loader?{\\\"sourceMap\\\":true}!../../node_modules/vue-loader/lib/selector?type=styles&index=0!./index.vue\")\n}\nvar normalizeComponent = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./index.vue\"\nimport __vue_script__ from \"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./index.vue\"\n/* template */\nimport __vue_template__ from \"!!../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-4d4cb0c5\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../node_modules/vue-loader/lib/selector?type=template&index=0!./index.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-4d4cb0c5\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/index.vue\n// module id = null\n// module chunks = ","<template>\n  <div id=\"logBox\">\n      <input v-model=\"inpVal\" ref=\"def\" required='' maxlength=\"6\" type='text' @blur=\"goToReg\" @keyup.enter=\"goToReg\">\n      <label alt='' placeholder=''></label>\n  </div>\n</template>\n\n<script>\nimport { Toast } from 'mint-ui';\nexport default {\n  name: 'login',\n  data () {\n    return {\n      inpVal: ''\n    }\n  },\n  methods: {\n    goToReg () {\n      let inpValue = this.inpVal.replace(/(^\\s*)|(\\s*$)/g, '')\n      if (inpValue !== '' && inpValue != null) {\n        localStorage.setItem('user_name', inpValue)\n        this.$router.push('reg')\n      } else {\n        Toast({\n          message: '',\n          position: 'bottom',\n          duration: 3000\n        });\n        this.$refs.def.value = ''\n      }\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n  #logBox{\n    width: 70%;\n    margin-top: 70%;\n  }\n  input[type=\"text\"] {\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n    width: 100%;\n    height: 40px;\n    margin: 0 0 13px;\n    padding: 13px;\n    border: 1px solid #ffd457;\n    border-radius: 20px;\n    background: #fafafa;\n    resize: none;\n    outline: none;\n    box-shadow: 0 0 20px #ffd457;\n    text-align: center;\n  }\n  input[type=\"text\"][required]:focus {\n    border-color: #ef952e;\n    box-shadow:none;\n  }\n  input[type=\"text\"][required]:focus + label[placeholder]:before {\n    color: #dc832e;\n    font-size: 13px;\n  }\n  input[type=\"text\"][required]:focus + label[placeholder]:before,\n  input[type=\"text\"][required]:valid + label[placeholder]:before {\n    -webkit-transition-duration: .1s;\n    transition-duration: .1s;\n    -webkit-transform: translate(0, -20px);\n    -ms-transform: translate(0, -20px);\n    transform: translate(0, -20px);\n  }\n  input[type=\"text\"][required]:invalid + label[placeholder][alt]:before {\n    content: attr(alt);\n  }\n  input[type=\"text\"][required] + label[placeholder] {\n    display: block;\n    pointer-events: none;\n    line-height: 14px;\n    margin-top: calc(-39px - 2px);\n    margin-bottom: calc(26px + 2px);\n  }\n  input[type=\"text\"][required] + label[placeholder]:before {\n    content: attr(placeholder);\n    display: inline-block;\n    margin: 0 calc(13px + 2px);\n    padding: 0 2px;\n    color: #aaa;\n    white-space: nowrap;\n    -webkit-transition: 0.2s ease-in-out;\n    transition: 0.2s ease-in-out;\n    background-image: -webkit-gradient(linear, left top, left bottom, from(#fafafa), to(#fafafa));\n    background-image: -webkit-linear-gradient(top, #fafafa, #fafafa);\n    background-image: linear-gradient(to bottom, #fafafa, #fafafa);\n    background-size: 100% 2px;\n    background-repeat: no-repeat;\n    background-position: center;\n  }\n  label{\n    text-align: center;\n  }\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/loginChild/log.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"logBox\"}},[_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.inpVal),expression:\"inpVal\"}],ref:\"def\",attrs:{\"required\":\"\",\"maxlength\":\"6\",\"type\":\"text\"},domProps:{\"value\":(_vm.inpVal)},on:{\"blur\":_vm.goToReg,\"keyup\":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,\"enter\",13,$event.key,\"Enter\")){ return null; }return _vm.goToReg($event)},\"input\":function($event){if($event.target.composing){ return; }_vm.inpVal=$event.target.value}}}),_vm._v(\" \"),_c('label',{attrs:{\"alt\":\"\",\"placeholder\":\"\"}})])}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-4ce4668f\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/loginChild/log.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-4ce4668f\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!sass-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./log.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./log.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./log.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-4ce4668f\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./log.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-4ce4668f\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/loginChild/log.vue\n// module id = null\n// module chunks = ","<template>\n  <div id=\"wel\">\n    <div>\n      <i></i>\n      <br><b>{{ userName }}</b>\n      <br>\n    </div>\n    <!--<img src=\"../../../static/bg_content.png\" alt=\"\">-->\n    <img :src=\"bgUrl\" alt=\"\">\n  </div>\n</template>\n\n<script>\nimport bgUrl from '@/assets/images/bg_content.png'\nexport default {\n  name: 'reg',\n  data () {\n    return {\n      userName: localStorage.getItem('user_name'),\n      bgUrl\n    }\n  },\n  mounted () {\n    setTimeout(() => {\n      this.goIndex()\n    }, 3000)\n  },\n  methods: {\n    goIndex () {\n      this.$router.push({path: '/index'})\n      // this.$router.replace({path: '/index'})\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n   #wel{\n     width: 100%;\n     position: absolute;\n     text-align: center;\n     img{\n       width: 50%;\n       max-width: 250px;\n       margin:0 25% 0 25%;\n     }\n     div{\n       width: 100%;\n        position: absolute;\n       top: 50px;\n       text-align: center;\n       font-size: 15px;\n       color: #999;\n     }\n     i{\n       font-style: normal;\n       font-size: 14px;\n     }\n     b{\n       padding: 1px 0;\n       font-size: 18px;\n       display: inline-block;\n       color: #ef952e;\n     }\n   }\n\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/loginChild/reg.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"wel\"}},[_c('div',[_c('i',[_vm._v(\"\")]),_vm._v(\" \"),_c('br'),_c('b',[_vm._v(_vm._s(_vm.userName))]),_vm._v(\" \"),_c('br'),_vm._v(\"\\n  \")]),_vm._v(\" \"),_c('img',{attrs:{\"src\":_vm.bgUrl,\"alt\":\"\"}})])}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-fd294de8\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/loginChild/reg.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-fd294de8\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!sass-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./reg.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./reg.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./reg.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-fd294de8\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./reg.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-fd294de8\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/loginChild/reg.vue\n// module id = null\n// module chunks = ","<template>\n    <div>\n      <el-carousel indicator-position=\"inside\" :type=\"diyType\" :height=\"countHeight\">\n        <el-carousel-item v-for=\"(val,key) in lunboList\" :key=\"val.title\">\n          <img style=\"width: 100%\" :src=\"val.url\" :alt=\"val.title\">\n        </el-carousel-item>\n      </el-carousel>\n    </div>\n</template>\n\n<script>\nexport default {\n  name: 'swiper',\n  data () {\n    return {\n      lunboList: [],\n      countHeight: '',\n      myType: ''\n    }\n  },\n  created () {\n\n  },\n  mounted () {\n    if (this.minVal === undefined) {\n      this.countHeight = parseInt((this.$el.clientWidth * this.swPic.swHeight) / this.swPic.swWidth).toString() + 'px'\n    } else {\n      this.countHeight = parseInt((this.$el.clientWidth * this.swPic.swHeight) / (this.minVal * this.swPic.swWidth)).toString() + 'px'\n    }\n    this.$emit('setType', this.$el.clientHeight)// \n    this.getLunbo()\n  },\n  props: ['diyType', 'swPic', 'minVal'],\n  methods: {\n    getLunbo () {\n      this.axios.get('vue-home').then(msg => {\n        this.lunboList = msg.data.listArray\n        console.log(msg)\n      })\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n  .el-carousel{\n    width: 100%;\n    /*margin-bottom: 10px;*/\n  }\n  .el-carousel__item h3 {\n    color: #475669;\n    font-size: 15px;\n    opacity: 0.75;\n    /*line-height: 120px;*/\n    margin: 0;\n    padding: 0;\n    text-align: center;\n  }\n\n  .el-carousel__item:nth-child(2n) {\n    background-color: #99a9bf;\n  }\n\n  .el-carousel__item:nth-child(2n+1) {\n    background-color: #d3dce6;\n  }\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/common/swiper.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('el-carousel',{attrs:{\"indicator-position\":\"inside\",\"type\":_vm.diyType,\"height\":_vm.countHeight}},_vm._l((_vm.lunboList),function(val,key){return _c('el-carousel-item',{key:val.title},[_c('img',{staticStyle:{\"width\":\"100%\"},attrs:{\"src\":val.url,\"alt\":val.title}})])}),1)],1)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-7f4832d2\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/common/swiper.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-7f4832d2\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!sass-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./swiper.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./swiper.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./swiper.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-7f4832d2\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./swiper.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-7f4832d2\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/common/swiper.vue\n// module id = null\n// module chunks = ","<template>\n  <div>\n    <v-swiper ref=\"swTall\" v-bind:swPic=\"swHeights\" v-on:setType=\"setTypeFn\"></v-swiper>\n    <form action=\"/\">\n      <van-search\n        v-model=\"value\"\n        placeholder=\"\"\n        show-action\n        @search=\"onSearch\"\n        @cancel=\"onCancel\"\n        ref=\"inp\"\n        @focus=\"setTop\"\n      />\n    </form>\n    <van-pull-refresh ref=\"refreshBox\" :style=\"'overflow:scroll;height:'+swTall+'px'\" v-model=\"isLoading\" @refresh=\"onRefresh\">\n      <p v-for=\"item in cardUseList\" :key=\"item.card\">\n        <van-row>\n          <van-col span=\"12\"><span class=\"jin\">NO.{{ item.card }}</span></van-col>\n          <van-col span=\"12\" style=\"text-align: right\">\n            <i :class=\"['icon', 'iconfont', 'icon-zhuanshi', item.name === '' ? 'jin' : 'yin']\"></i>\n            <span>{{ item.name }}</span>\n          </van-col>\n        </van-row>\n        <van-row>\n          <van-col span=\"12\">{{ item.date }}</van-col>\n          <van-col span=\"12\">{{ item.items }}</van-col>\n        </van-row>\n        <van-row>\n          <van-col span=\"12\">{{ item.orderNumber }}</van-col>\n          <van-col span=\"12\">{{ item.times }}</van-col>\n        </van-row>\n      </p>\n      <div class=\"downTips\"></div>\n    </van-pull-refresh>\n  </div>\n</template>\n\n<script>\nimport swiper from '@/components/common/swiper.vue'\nimport 'vant/lib/search/style'\nimport 'vant/lib/pull-refresh/style'\nimport 'vant/lib/row/style'\nimport 'vant/lib/col/style'\nexport default {\n  name: 'home',\n  data () {\n    return {\n      fullscreenLoading: false,\n      newsList: [],\n      count: 0,\n      swHeights: this.$store.getters.showType,\n      value: '',\n      isLoading: false,\n      swTall: 0,\n      cardUseList: [\n        {\n          name: '',\n          card: '111001',\n          date: '2018.1.01',\n          items: '',\n          orderNumber: '11111001',\n          times: 2\n        },\n        {\n          name: '',\n          card: '222002',\n          date: '2018.1.02',\n          items: '',\n          orderNumber: '11111002',\n          times: 3\n        },\n        {\n          name: '',\n          card: '333003',\n          date: '2018.1.03',\n          items: '',\n          orderNumber: '11111003',\n          times: 2\n        },\n        {\n          name: '',\n          card: '444004',\n          date: '2018.1.04',\n          items: '',\n          orderNumber: '11111004',\n          times: 1\n        },\n        {\n          name: '',\n          card: '555005',\n          date: '2018.1.05',\n          items: '',\n          orderNumber: '11111005',\n          times: 5\n        }\n      ]\n    }\n  },\n  created () {\n    this.openFullScreen()\n    // this.getNews()\n    localStorage.setItem('newsList', JSON.stringify(this.cardUseList))\n    localStorage.setItem('newsListCopy', JSON.stringify(this.cardUseList))\n  },\n  components: {\n    'v-swiper': swiper\n  },\n  mounted () {\n    this.init()\n    let swHei = parseInt((this.$el.clientWidth * this.swHeights.swHeight) / this.swHeights.swWidth)\n    // console.log(this.$root.$el.clientHeight)\n    this.swTall = this.$root.$el.clientHeight - swHei - 54 - 50 - 40\n\n  },\n  directives: {\n  },\n  methods: {\n    init () {\n      // this.$store.commit('changeType')\n    },\n    setTypeFn (val) {\n      console.log('faGet' + val)\n    },\n    onSearch () {\n\n    },\n    onCancel () {\n\n    },\n    setTop () {\n      // document.getElementsByClassName('mint-tabbar')[0].style.display = 'none'\n    },\n    onRefresh () {\n      this.value = ''\n      for (let index of new Array(6).fill(1).keys()) {\n        setTimeout(() => {\n          this.$toast('')\n          this.isLoading = false\n          let addObj = {}\n          addObj['name'] = (Math.random() * 10) > 5 ? '' : ''\n          addObj['card'] = Math.floor((Math.random() * 100000000)).toString()\n          addObj['date'] = '2018.1.05'\n          addObj['items'] = (Math.random() * 10) > 5 ? '' : ''\n          addObj['orderNumber'] = '1111100' + Math.floor((Math.random() * 100) + 1)\n          addObj['times'] = parseInt(index)\n          this.cardUseList.unshift(addObj)\n          let addData = JSON.parse(localStorage.getItem('newsListCopy'))\n          addData.push(addObj)\n          localStorage.setItem('newsListCopy', JSON.stringify(addData))\n        }, 1000)\n      }\n    },\n    getNews () {\n      // this.axios.get('vue-home-news').then(msg => {\n      //   // this.newsList=msg.data.newsList\n      //    console.log(msg.body.data.newsList)\n      // })\n    },\n    openFullScreen () {\n      const loading = this.$loading({\n        lock: true,\n        text: 'Loading',\n        spinner: 'el-icon-loading',\n        background: 'rgba(0, 0, 0, 0.7)'\n      });\n      setTimeout(() => {\n        loading.close();\n      }, 1000);\n    }\n  },\n  beforeUpdate () {\n\n  },\n  watch: {\n    cardUseList (newVal) {\n      // console.log(newVal)\n      localStorage.setItem('newsList', JSON.stringify(this.cardUseList))\n    },\n    value (newVal, oldVal) {\n      let newsList = JSON.parse(localStorage.getItem('newsListCopy'))\n      this.cardUseList = []\n      for (let [i, val] of newsList.entries()) {\n        if (val['card'].indexOf(newVal) > -1) {\n          this.cardUseList.unshift(val)\n        }\n      }\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n  @import \"../../assets/fonts/iconfont.css\";\n  .jin{\n    color: #ffc666;\n    vertical-align: top!important;\n  }\n  .yin{\n    color: #bbb;\n    vertical-align: top!important;\n  }\n  .downTips{\n    padding: 5px 0;\n    text-align: center;\n    font-size: 14px;\n    color: #999;\n  }\n  p{\n    background-color: #fff;\n    padding: 5px 10px;\n    box-sizing: border-box;\n    border-bottom: 10px solid #eee;\n    border-top: 1px solid #eee;\n    .van-row:first-of-type{\n      padding: 8px 0;border-bottom: 1px solid #ddd\n    }\n    .van-row:nth-of-type(2){\n      font-size: 15px;padding: 8px 0 4px 0;color:#666\n    }\n    .van-row:last-of-type{\n      font-size: 15px;padding: 4px 0 6px 0;color:#666\n    }\n    &:last-of-type{\n      border-bottom: none;\n    }\n  }\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/children/home.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('v-swiper',{ref:\"swTall\",attrs:{\"swPic\":_vm.swHeights},on:{\"setType\":_vm.setTypeFn}}),_vm._v(\" \"),_c('form',{attrs:{\"action\":\"/\"}},[_c('van-search',{ref:\"inp\",attrs:{\"placeholder\":\"\",\"show-action\":\"\"},on:{\"search\":_vm.onSearch,\"cancel\":_vm.onCancel,\"focus\":_vm.setTop},model:{value:(_vm.value),callback:function ($$v) {_vm.value=$$v},expression:\"value\"}})],1),_vm._v(\" \"),_c('van-pull-refresh',{ref:\"refreshBox\",style:('overflow:scroll;height:'+_vm.swTall+'px'),on:{\"refresh\":_vm.onRefresh},model:{value:(_vm.isLoading),callback:function ($$v) {_vm.isLoading=$$v},expression:\"isLoading\"}},[_vm._l((_vm.cardUseList),function(item){return _c('p',{key:item.card},[_c('van-row',[_c('van-col',{attrs:{\"span\":\"12\"}},[_vm._v(\"\"),_c('span',{staticClass:\"jin\"},[_vm._v(\"NO.\"+_vm._s(item.card))])]),_vm._v(\" \"),_c('van-col',{staticStyle:{\"text-align\":\"right\"},attrs:{\"span\":\"12\"}},[_c('i',{class:['icon', 'iconfont', 'icon-zhuanshi', item.name === '' ? 'jin' : 'yin']}),_vm._v(\" \"),_c('span',[_vm._v(_vm._s(item.name))])])],1),_vm._v(\" \"),_c('van-row',[_c('van-col',{attrs:{\"span\":\"12\"}},[_vm._v(\"\"+_vm._s(item.date))]),_vm._v(\" \"),_c('van-col',{attrs:{\"span\":\"12\"}},[_vm._v(\"\"+_vm._s(item.items))])],1),_vm._v(\" \"),_c('van-row',[_c('van-col',{attrs:{\"span\":\"12\"}},[_vm._v(\"\"+_vm._s(item.orderNumber))]),_vm._v(\" \"),_c('van-col',{attrs:{\"span\":\"12\"}},[_vm._v(\"\"+_vm._s(item.times))])],1)],1)}),_vm._v(\" \"),_c('div',{staticClass:\"downTips\"},[_vm._v(\"\")])],2)],1)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-57006621\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/children/home.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-57006621\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!sass-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./home.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./home.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./home.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-57006621\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./home.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-57006621\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/children/home.vue\n// module id = null\n// module chunks = ","<template>\n    <section>\n      <el-collapse v-model=\"activeName\" accordion style=\"margin-bottom: 50px\">\n        <el-collapse-item name=\"1\">\n          <template slot=\"title\">\n            <span class=\"sr-all count\"><i id=\"allCash\">{{ getSum(payValData) }}</i> / <i id=\"allTime\">{{ getSum(payNumData) }}</i></span>\n          </template>\n          <div style=\"width: 100%;height: 100%\">\n            <div ref=\"echPay\" style=\"height: 250px;\"></div>\n            <div class=\"payStyle\">\n              <el-row v-for=\"(val,ind) in payTitleData\" :key=\"val\">\n                <el-col :span=\"12\">\n                  <span class=\"circle\" v-bind:style = \"{'background-color':colorStyle[ind]}\"></span>\n                  <span>{{val}}</span>\n                </el-col>\n                <el-col :span=\"8\">\n                  {{ payValData[ind] }}\n                </el-col>\n                <el-col :span=\"4\">\n                  {{ payNumData[ind] }}\n                </el-col>\n              </el-row>\n            </div>\n            <div ref=\"echSell\" style=\"height: 250px;\"></div>\n            <div class=\"sellStyle\">\n              <el-row v-for=\"(val,ind) in sellTitleData\" :key=\"val\">\n                <el-col :span=\"12\">\n                  <span class=\"circle\" v-bind:style = \"{'background-color':colorStyle[ind]}\"></span>\n                  <span>{{val}}</span>\n                </el-col>\n                <el-col :span=\"8\">\n                  {{ sellValData[ind] }}\n                </el-col>\n                <el-col :span=\"4\">\n                  {{ sellNumData[ind] }}\n                </el-col>\n              </el-row>\n            </div>\n            <div ref=\"echCus\" style=\"height: 250px;\"></div>\n            <div class=\"cusStyle\">\n              <el-row class=\"mui-row\" v-for=\"(val,ind) in cusTitleData\" :key=\"val\">\n                <el-col :span=\"12\">\n                  <span class=\"circle\" v-bind:style = \"{'background-color':colorStyle[ind]}\"></span>\n                  <span>{{val}}</span>\n                </el-col>\n                <el-col :span=\"8\">\n                  {{ sellValData[ind] }}\n                </el-col>\n                <el-col :span=\"4\">\n                  {{ sellNumData[ind] }}\n                </el-col>\n              </el-row>\n            </div>\n            <div ref=\"echFund\" style=\"height: 250px;\"></div>\n            <div class=\"fundStyle\">\n              <el-row class=\"mui-row\" v-for=\"(val,ind) in fundTitleData\" :key=\"val\">\n                <el-col :span=\"12\">\n                  <span class=\"circle\" v-bind:style = \"{'background-color':colorStyle[ind]}\"></span>\n                  <span>{{val}}</span>\n                </el-col>\n                <el-col :span=\"8\">\n                  {{ fundValData[ind] }}\n                </el-col>\n                <el-col :span=\"4\">\n                  {{ fundNumData[ind] }}\n                </el-col>\n              </el-row>\n            </div>\n          </div>\n        </el-collapse-item>\n        <el-collapse-item name=\"2\">\n          <template slot=\"title\">\n            <span class=\"sr-all count\"> <i id=\"addMember\">{{ getSum(memberValData) }}</i> </span>\n          </template>\n          <div>\n            <div ref=\"echMember\" style=\"height: 300px;\"></div>\n            <div class=\"memberStyle\">\n              <el-row class=\"mui-row\" v-for=\"(val,ind) in memberTitleData\" :key=\"val\">\n                <el-col :span=\"12\">\n                  <span class=\"circle\" v-bind:style = \"{'background-color':colorStyle[ind]}\"></span>\n                  <span>{{val}}</span>\n                </el-col>\n                <el-col :span=\"12\">\n                  {{ memberValData[ind] }}\n                </el-col>\n              </el-row>\n            </div>\n          </div>\n        </el-collapse-item>\n        <el-collapse-item name=\"3\">\n          <template slot=\"title\">\n            <span class=\"sr-all count\"><i id=\"giveInt\">{{ getSum(giveValData) }}</i> / <i id=\"useInt\">{{ getSum(useValData) }}</i></span>\n          </template>\n          <div>\n            <div ref=\"echGiveIntegral\" style=\"height: 300px;\"></div>\n            <div class=\"giveIntegralStyle\">\n              <el-row class=\"mui-row\" v-for=\"(val,ind) in giveTitleData\" :key=\"val\">\n                <el-col :span=\"12\">\n                  <span class=\"circle\" v-bind:style = \"{'background-color':colorStyle[ind]}\"></span>\n                  <span>{{val}}</span>\n                </el-col>\n                <el-col :span=\"12\">\n                  {{ giveValData[ind] }}\n                </el-col>\n              </el-row>\n            </div>\n            <div ref=\"echUseIntegral\" style=\"height: 300px;\"></div>\n            <div class=\"useIntegralStyle\">\n              <el-row class=\"mui-row\" v-for=\"(val,ind) in useTitleData\" :key=\"val\">\n                <el-col :span=\"12\">\n                  <span class=\"circle\" v-bind:style = \"{'background-color':colorStyle[ind]}\"></span>\n                  <span>{{val}}</span>\n                </el-col>\n                <el-col :span=\"12\">\n                  {{ useValData[ind] }}\n                </el-col>\n              </el-row>\n            </div>\n          </div>\n        </el-collapse-item>\n      </el-collapse>\n    </section>\n</template>\n\n<script>\nimport echarts from '../../../static/echarts.js'\n//  require  import require  node_modules  import \nexport default {\n  name: 'makePic',\n  data () {\n    return {\n      activeName: ['1','2','3'],\n      payTitleData: [ '', '', '', '', '', '', '' ],\n      payValData: [52,153.26,42,9.06,34,11,66],\n      payNumData: [1,3,2,5,4,5,7],\n      sellTitleData: ['','',''],\n      sellValData: [12,51,2],\n      sellNumData: [4,5,7],\n      cusTitleData: ['',''],\n      cusValData: [12,51],\n      cusNumData: [5,7],\n      fundTitleData: ['',''],\n      fundValData: [66,11],\n      fundNumData: [5,7],\n      memberTitleData: ['',''],\n      memberValData: [24,37],\n      giveTitleData: ['','','','','',''],\n      giveValData: [34,98,12,52,88,63],\n      useTitleData: ['','','','',''],\n      useValData: [12,33,12,22,65,57],\n      titleArray: ['','','','&','','',''],\n      colorStyle: ['#03A9F5','#8BC24B','#FE5720','#9C26B0','#03BBD5','#607D8B','#CD2437','#FEE600','#22AD37']\n    }\n  },\n  created () {\n\n  },\n  mounted () {\n    const optionPay = {\n      title:{\n        text:this.titleArray[0],\n        textStyle:{\n          fontSize:15,\n          align:'center'\n        },\n        top:10\n      },\n      // tooltip: {\n      //     trigger: 'item',\n      //     formatter: \"{a} <br/>{b}: {c} ({d}%)\"\n      // },\n      color:this.colorStyle,\n      legend: {\n        show:false,\n        orient: 'vertical',\n        x:'left',\n        y: 'bottom',\n        data:this.payTitleData\n      },\n      series: [\n        {\n          name:null,\n          type:'pie',\n          radius: ['30%', '70%'],\n          avoidLabelOverlap: false,\n          label: {\n            normal: {\n              show: false,\n              position: 'top',\n            },\n            emphasis: {\n              show: true,\n              textStyle: {\n                fontSize: '14',\n              }\n            }\n          },\n          labelLine: {\n            normal: {\n              show: false\n            }\n          },\n          data:[\n            {value:this.payValData[0], name:this.payTitleData[0]},\n            {value:this.payValData[1], name:this.payTitleData[1]},\n            {value:this.payValData[2], name:this.payTitleData[2]},\n            {value:this.payValData[3], name:this.payTitleData[3]},\n            {value:this.payValData[4], name:this.payTitleData[4]},\n            {value:this.payValData[5], name:this.payTitleData[5]},\n            {value:this.payValData[6], name:this.payTitleData[6]}\n          ]\n        }\n      ]\n    };\n    const optionSell = {\n      title:{\n        text:this.titleArray[1],\n        textStyle:{\n          fontSize:15,\n          align:'center'\n        },\n        top:10\n      },\n      // tooltip: {\n      //     trigger: 'item',\n      //     formatter: \"{a} <br/>{b}: {c} ({d}%)\"\n      // },\n      color:this.colorStyle,\n      legend: {\n        show:false,\n        orient: 'vertical',\n        x:'left',\n        y: 'bottom',\n        data:this.sellTitleData\n      },\n      series: [\n        {\n          name:null,\n          type:'pie',\n          radius: ['30%', '70%'],\n          avoidLabelOverlap: false,\n          label: {\n            normal: {\n              show: false,\n              position: 'top',\n            },\n            emphasis: {\n              show: true,\n              textStyle: {\n                fontSize: '14',\n              }\n            }\n          },\n          labelLine: {\n            normal: {\n              show: false\n            }\n          },\n          data:[\n            {value:this.sellValData[0], name:this.sellTitleData[0]},\n            {value:this.sellValData[1], name:this.sellTitleData[1]},\n            {value:this.sellValData[2], name:this.sellTitleData[2]},\n          ]\n        }\n      ]\n    };\n    const optionCus = {\n      title:{\n        text:this.titleArray[2],\n        textStyle:{\n          fontSize:15,\n          align:'center'\n        },\n        top:10\n      },\n      // tooltip: {\n      //     trigger: 'item',\n      //     formatter: \"{a} <br/>{b}: {c} ({d}%)\"\n      // },\n      color:this.colorStyle,\n      legend: {\n        show:false,\n        orient: 'vertical',\n        x:'left',\n        y: 'bottom',\n        data:this.cusTitleData\n      },\n      series: [\n        {\n          name:null,\n          type:'pie',\n          radius: ['30%', '70%'],\n          avoidLabelOverlap: false,\n          label: {\n            normal: {\n              show: false,\n              position: 'top',\n            },\n            emphasis: {\n              show: true,\n              textStyle: {\n                fontSize: '14',\n              }\n            }\n          },\n          labelLine: {\n            normal: {\n              show: false\n            }\n          },\n          data:[\n            {value:this.cusValData[0], name:this.cusTitleData[0]},\n            {value:this.cusValData[1], name:this.cusTitleData[1]},\n          ]\n        }\n      ]\n    };\n    const optionFund = {\n      title:{\n        text:this.titleArray[3],\n        textStyle:{\n          fontSize:15,\n          align:'center'\n        },\n        top:10\n      },\n      // tooltip: {\n      //     trigger: 'item',\n      //     formatter: \"{a} <br/>{b}: {c} ({d}%)\"\n      // },\n      color:this.colorStyle,\n      legend: {\n        show:false,\n        orient: 'vertical',\n        x:'left',\n        y: 'bottom',\n        data:this.fundTitleData\n      },\n      series: [\n        {\n          name:null,\n          type:'pie',\n          radius: ['30%', '70%'],\n          avoidLabelOverlap: false,\n          label: {\n            normal: {\n              show: false,\n              position: 'top',\n            },\n            emphasis: {\n              show: true,\n              textStyle: {\n                fontSize: '14',\n              }\n            }\n          },\n          labelLine: {\n            normal: {\n              show: false\n            }\n          },\n          data:[\n            {value:this.fundValData[0], name:this.fundTitleData[0]},\n            {value:this.fundValData[1], name:this.fundTitleData[1]},\n          ]\n        }\n      ]\n    };\n    const optionMember = {\n      title:{\n        text:this.titleArray[4],\n        textStyle:{\n          fontSize:15,\n          align:'center'\n        },\n        top:10\n      },\n      // tooltip: {\n      //     trigger: 'item',\n      //     formatter: \"{a} <br/>{b}: {c} ({d}%)\"\n      // },\n      color:this.colorStyle,\n      legend: {\n        show:false,\n        orient: 'vertical',\n        x:'left',\n        y: 'bottom',\n        data:this.memberTitleData\n      },\n      series: [\n        {\n          name:null,\n          type:'pie',\n          radius: ['30%', '70%'],\n          avoidLabelOverlap: false,\n          label: {\n            normal: {\n              show: false,\n              position: 'top',\n            },\n            emphasis: {\n              show: true,\n              textStyle: {\n                fontSize: '14',\n              }\n            }\n          },\n          labelLine: {\n            normal: {\n              show: false\n            }\n          },\n          data:[\n            {value:this.memberValData[0], name:this.memberTitleData[0]},\n            {value:this.memberValData[1], name:this.memberTitleData[1]},\n          ]\n        }\n      ]\n    };\n    const optionGive = {\n      title:{\n        text:this.titleArray[5],\n        textStyle:{\n          fontSize:12,\n          align:'center'\n        },\n        top:10\n      },\n      // tooltip: {\n      //     trigger: 'item',\n      //     formatter: \"{a} <br/>{b}: {c} ({d}%)\"\n      // },\n      color:this.colorStyle,\n      legend: {\n        show:false,\n        orient: 'vertical',\n        x:'left',\n        y: 'bottom',\n        data:this.giveTitleData\n      },\n      series: [\n        {\n          name:null,\n          type:'pie',\n          radius: ['30%', '70%'],\n          avoidLabelOverlap: false,\n          label: {\n            normal: {\n              show: false,\n              position: 'center',\n            },\n            emphasis: {\n              show: true,\n              textStyle: {\n                fontSize: '14',\n              }\n            }\n          },\n          labelLine: {\n            normal: {\n              show: false\n            }\n          },\n          data:[\n            {value:this.giveValData[0], name:this.giveTitleData[0]},\n            {value:this.giveValData[1], name:this.giveTitleData[1]},\n            {value:this.giveValData[2], name:this.giveTitleData[2]},\n            {value:this.giveValData[3], name:this.giveTitleData[3]},\n            {value:this.giveValData[4], name:this.giveTitleData[4]},\n            {value:this.giveValData[5], name:this.giveTitleData[5]}\n          ]\n        }\n      ]\n    };\n    const optionUse = {\n      title:{\n        text:this.titleArray[6],\n        textStyle:{\n          fontSize:15,\n          align:'center'\n        },\n        top:10\n      },\n      // tooltip: {\n      //     trigger: 'item',\n      //     formatter: \"{a} <br/>{b}: {c} ({d}%)\"\n      // },\n      color:this.colorStyle,\n      legend: {\n        show:false,\n        orient: 'vertical',\n        x:'left',\n        y: 'bottom',\n        data:this.useTitleData\n      },\n      series: [\n        {\n          name:null,\n          type:'pie',\n          radius: ['30%', '70%'],\n          avoidLabelOverlap: false,\n          label: {\n            normal: {\n              show: false,\n              position: 'center',\n            },\n            emphasis: {\n              show: true,\n              textStyle: {\n                fontSize: '14',\n              }\n            }\n          },\n          labelLine: {\n            normal: {\n              show: false\n            }\n          },\n          data:[\n            {value:this.useValData[0], name:this.useTitleData[0]},\n            {value:this.useValData[1], name:this.useTitleData[1]},\n            {value:this.useValData[2], name:this.useTitleData[2]},\n            {value:this.useValData[3], name:this.useTitleData[3]},\n            {value:this.useValData[4], name:this.useTitleData[4]}\n          ]\n        }\n      ]\n    };\n    let echPay = echarts.init(this.$refs.echPay);\n    echPay.setOption(optionPay);\n    let echSell = echarts.init(this.$refs.echSell);\n    echSell.setOption(optionSell);\n    let echCus = echarts.init(this.$refs.echCus);\n    echCus.setOption(optionCus);\n    let echFund = echarts.init(this.$refs.echFund);\n    echFund.setOption(optionFund);\n    let echMember = echarts.init(this.$refs.echMember);\n    echMember.setOption(optionMember);\n    let echGive = echarts.init(this.$refs.echGiveIntegral);\n    echGive.setOption(optionGive);\n    let echUse = echarts.init(this.$refs.echUseIntegral);\n    echUse.setOption(optionUse);\n  },\n  methods: {\n     getSum (arrObj) {\n       // console.log(arrObj)\n       this.activeName = '1'\n      return arrObj.reduce((num = 0, item = 0) => {\n            return num + item\n       })\n     }\n  },\n  watch: {\n    activeName: function (newValue, oldValue) {\n      console.log(newValue)\n    }\n  }\n}\n</script>\n\n<style scoped>\n  .count{\n    position: absolute;\n    right: 20px;\n  }\n  .el-collapse-item /deep/ .el-collapse-item__header{ /**/\n    background-color: #eee;\n    border-bottom: 1px solid #ccc;\n    padding-left: 15px;\n  }\n  i{\n    font-style: normal;\n  }\n  .sr-all{\n    margin-right: 5px;\n  }\n  .circle{\n    display: inline-block;\n    width: 10px;\n    height: 10px;\n    border-radius: 100%;\n  }\n  .payStyle,.sellStyle,.cusStyle,.giveIntegralStyle,.useIntegralStyle{\n    padding-bottom: 2%;\n    border-bottom: 1px solid #aaa;\n  }\n  .allWidth /deep/ >div:first-of-type{\n    width: 100%!important;\n  }\n  .el-row{\n    padding-left: 15px;\n  }\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/children/makePic.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',[_c('el-collapse',{staticStyle:{\"margin-bottom\":\"50px\"},attrs:{\"accordion\":\"\"},model:{value:(_vm.activeName),callback:function ($$v) {_vm.activeName=$$v},expression:\"activeName\"}},[_c('el-collapse-item',{attrs:{\"name\":\"1\"}},[_c('template',{slot:\"title\"},[_vm._v(\"\\n        \"),_c('span',{staticClass:\"sr-all count\"},[_vm._v(\"\"),_c('i',{attrs:{\"id\":\"allCash\"}},[_vm._v(_vm._s(_vm.getSum(_vm.payValData)))]),_vm._v(\" / \"),_c('i',{attrs:{\"id\":\"allTime\"}},[_vm._v(_vm._s(_vm.getSum(_vm.payNumData)))]),_vm._v(\"\")])]),_vm._v(\" \"),_c('div',{staticStyle:{\"width\":\"100%\",\"height\":\"100%\"}},[_c('div',{ref:\"echPay\",staticStyle:{\"height\":\"250px\"}}),_vm._v(\" \"),_c('div',{staticClass:\"payStyle\"},_vm._l((_vm.payTitleData),function(val,ind){return _c('el-row',{key:val},[_c('el-col',{attrs:{\"span\":12}},[_c('span',{staticClass:\"circle\",style:({'background-color':_vm.colorStyle[ind]})}),_vm._v(\" \"),_c('span',[_vm._v(_vm._s(val))])]),_vm._v(\" \"),_c('el-col',{attrs:{\"span\":8}},[_vm._v(\"\\n              \"+_vm._s(_vm.payValData[ind])+\"\\n            \")]),_vm._v(\" \"),_c('el-col',{attrs:{\"span\":4}},[_vm._v(\"\\n              \"+_vm._s(_vm.payNumData[ind])+\"\\n            \")])],1)}),1),_vm._v(\" \"),_c('div',{ref:\"echSell\",staticStyle:{\"height\":\"250px\"}}),_vm._v(\" \"),_c('div',{staticClass:\"sellStyle\"},_vm._l((_vm.sellTitleData),function(val,ind){return _c('el-row',{key:val},[_c('el-col',{attrs:{\"span\":12}},[_c('span',{staticClass:\"circle\",style:({'background-color':_vm.colorStyle[ind]})}),_vm._v(\" \"),_c('span',[_vm._v(_vm._s(val))])]),_vm._v(\" \"),_c('el-col',{attrs:{\"span\":8}},[_vm._v(\"\\n              \"+_vm._s(_vm.sellValData[ind])+\"\\n            \")]),_vm._v(\" \"),_c('el-col',{attrs:{\"span\":4}},[_vm._v(\"\\n              \"+_vm._s(_vm.sellNumData[ind])+\"\\n            \")])],1)}),1),_vm._v(\" \"),_c('div',{ref:\"echCus\",staticStyle:{\"height\":\"250px\"}}),_vm._v(\" \"),_c('div',{staticClass:\"cusStyle\"},_vm._l((_vm.cusTitleData),function(val,ind){return _c('el-row',{key:val,staticClass:\"mui-row\"},[_c('el-col',{attrs:{\"span\":12}},[_c('span',{staticClass:\"circle\",style:({'background-color':_vm.colorStyle[ind]})}),_vm._v(\" \"),_c('span',[_vm._v(_vm._s(val))])]),_vm._v(\" \"),_c('el-col',{attrs:{\"span\":8}},[_vm._v(\"\\n              \"+_vm._s(_vm.sellValData[ind])+\"\\n            \")]),_vm._v(\" \"),_c('el-col',{attrs:{\"span\":4}},[_vm._v(\"\\n              \"+_vm._s(_vm.sellNumData[ind])+\"\\n            \")])],1)}),1),_vm._v(\" \"),_c('div',{ref:\"echFund\",staticStyle:{\"height\":\"250px\"}}),_vm._v(\" \"),_c('div',{staticClass:\"fundStyle\"},_vm._l((_vm.fundTitleData),function(val,ind){return _c('el-row',{key:val,staticClass:\"mui-row\"},[_c('el-col',{attrs:{\"span\":12}},[_c('span',{staticClass:\"circle\",style:({'background-color':_vm.colorStyle[ind]})}),_vm._v(\" \"),_c('span',[_vm._v(_vm._s(val))])]),_vm._v(\" \"),_c('el-col',{attrs:{\"span\":8}},[_vm._v(\"\\n              \"+_vm._s(_vm.fundValData[ind])+\"\\n            \")]),_vm._v(\" \"),_c('el-col',{attrs:{\"span\":4}},[_vm._v(\"\\n              \"+_vm._s(_vm.fundNumData[ind])+\"\\n            \")])],1)}),1)])],2),_vm._v(\" \"),_c('el-collapse-item',{attrs:{\"name\":\"2\"}},[_c('template',{slot:\"title\"},[_vm._v(\"\\n        \"),_c('span',{staticClass:\"sr-all count\"},[_vm._v(\" \"),_c('i',{attrs:{\"id\":\"addMember\"}},[_vm._v(_vm._s(_vm.getSum(_vm.memberValData)))]),_vm._v(\" \")])]),_vm._v(\" \"),_c('div',[_c('div',{ref:\"echMember\",staticStyle:{\"height\":\"300px\"}}),_vm._v(\" \"),_c('div',{staticClass:\"memberStyle\"},_vm._l((_vm.memberTitleData),function(val,ind){return _c('el-row',{key:val,staticClass:\"mui-row\"},[_c('el-col',{attrs:{\"span\":12}},[_c('span',{staticClass:\"circle\",style:({'background-color':_vm.colorStyle[ind]})}),_vm._v(\" \"),_c('span',[_vm._v(_vm._s(val))])]),_vm._v(\" \"),_c('el-col',{attrs:{\"span\":12}},[_vm._v(\"\\n              \"+_vm._s(_vm.memberValData[ind])+\"\\n            \")])],1)}),1)])],2),_vm._v(\" \"),_c('el-collapse-item',{attrs:{\"name\":\"3\"}},[_c('template',{slot:\"title\"},[_vm._v(\"\\n        \"),_c('span',{staticClass:\"sr-all count\"},[_vm._v(\"\"),_c('i',{attrs:{\"id\":\"giveInt\"}},[_vm._v(_vm._s(_vm.getSum(_vm.giveValData)))]),_vm._v(\" / \"),_c('i',{attrs:{\"id\":\"useInt\"}},[_vm._v(_vm._s(_vm.getSum(_vm.useValData)))])])]),_vm._v(\" \"),_c('div',[_c('div',{ref:\"echGiveIntegral\",staticStyle:{\"height\":\"300px\"}}),_vm._v(\" \"),_c('div',{staticClass:\"giveIntegralStyle\"},_vm._l((_vm.giveTitleData),function(val,ind){return _c('el-row',{key:val,staticClass:\"mui-row\"},[_c('el-col',{attrs:{\"span\":12}},[_c('span',{staticClass:\"circle\",style:({'background-color':_vm.colorStyle[ind]})}),_vm._v(\" \"),_c('span',[_vm._v(_vm._s(val))])]),_vm._v(\" \"),_c('el-col',{attrs:{\"span\":12}},[_vm._v(\"\\n              \"+_vm._s(_vm.giveValData[ind])+\"\\n            \")])],1)}),1),_vm._v(\" \"),_c('div',{ref:\"echUseIntegral\",staticStyle:{\"height\":\"300px\"}}),_vm._v(\" \"),_c('div',{staticClass:\"useIntegralStyle\"},_vm._l((_vm.useTitleData),function(val,ind){return _c('el-row',{key:val,staticClass:\"mui-row\"},[_c('el-col',{attrs:{\"span\":12}},[_c('span',{staticClass:\"circle\",style:({'background-color':_vm.colorStyle[ind]})}),_vm._v(\" \"),_c('span',[_vm._v(_vm._s(val))])]),_vm._v(\" \"),_c('el-col',{attrs:{\"span\":12}},[_vm._v(\"\\n              \"+_vm._s(_vm.useValData[ind])+\"\\n            \")])],1)}),1)])],2)],1)],1)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-5edb57d6\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/children/makePic.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-5edb57d6\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./makePic.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./makePic.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./makePic.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-5edb57d6\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./makePic.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-5edb57d6\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/children/makePic.vue\n// module id = null\n// module chunks = ","<template>\n  <section class=\"echartBox\">\n      <div ref=\"echartContent\" class=\"echartContent\"></div>\n      <v-swiper v-bind:swPic=\"swHeight\" v-bind:minVal=\"minWidth\" v-bind:diyType=\"'card'\"></v-swiper>\n  </section>\n</template>\n\n<script>\nimport swiper from '@/components/common/swiper.vue'\nimport echarts from '../../../static/echarts.js'\n//  require  import require  node_modules  import \nexport default {\n    name: 'echarts',\n    data () {\n      return {\n        minWidth: 2,\n        swHeight: this.$store.getters.showType\n      }\n    },\n    created () {\n    },\n    mounted () {\n     const option = {\n        title: {\n          text: ''\n        },\n        legend: {\n          top: 0,\n          data: ['', '', '']\n        },\n        tooltip: {},\n        radar: {\n          axisLine: {\n            show: true\n          },\n          splitArea: {\n            areaStyle: {\n              color: '#fff',\n              shadowBlur: 0\n            }\n          },\n          radius:'70%',\n          splitNumber: 8,\n          nameGap:5,\n          // shape: 'circle',\n          indicator: [{\n            name: '\\n(cm)',\n            max: 6500,\n            color:'#000',\n          },\n            {\n              name: 'BMI',\n              max: 30000,\n              color:'#000',\n            },\n            {\n              name: '\\n(cm)',\n              max: 38000,\n              color:'#000',\n            },\n            {\n              name: '\\n(s)',\n              max: 52000,\n              color:'#000',\n            },\n            {\n              name: '\\n(m)',\n              max: 25000,\n              color:'#000',\n            },\n            {\n              name: '\\n(m)',\n              max: 25000,\n              color:'#000',\n            },\n            {\n              name: '\\n(/min)',\n              max: 25000,\n              color:'#000',\n            },\n            {\n              name: '\\n(/)',\n              max: 25000,\n              color:'#000',\n            },\n            {\n              name: '505\\n()',\n              max: 25000,\n              color:'#000',\n            },\n            {\n              name: '\\n(kg)',\n              max: 26000,\n              color:'#000',\n            }\n          ]\n        },\n        series: [\n          {\n            name: '',\n            type: 'radar',\n            symbol: \"circle\",\n            symbolSize:\"10\",\n            data: [\n              {\n                value: [3200, 18900, 19000, 26000, 9500, 12500, 9500, 15500, 12500, 13000],\n                name: '',\n                itemStyle: {\n                  normal: {\n                    color : \"rgba(0,161,233,.6)\", // \n                    lineStyle: {\n                      color:\"#00A1E9\", // \n                      borderColor: \"#00A1E9\"\n                    }\n                  }\n                },\n                areaStyle: {\n                  normal: {\n                    opacity: 0.3,\n                  }\n                },\n              },\n              {\n                value: [2450, 18800, 23600, 32200, 12500, 12500, 6100, 15500, 12500, 16000],\n                name: '',\n                symbol: \"circle\",\n                symbolSize:\"10\",\n                itemStyle: {\n                  normal: {\n                    color : \"rgba(248,129,37,.6)\", // \n                    lineStyle: {\n                      color:\"#F88125\", // \n                      borderColor: \"#F88125\"\n                    }\n                  }\n                },\n                areaStyle: {\n                  normal: {\n                    opacity: 0.3,\n                  }\n                }\n              },\n              {\n                value: [4900, 22600, 28600, 34000, 17000, 9000, 20000, 16500, 19000, 13000],\n                name: '',\n                symbol: \"circle\",\n                symbolSize:\"10\",\n                itemStyle: {\n                  normal: {\n                    color : \"rgba(141,206,16,.6)\", // \n                    lineStyle: {\n                      color:\"#8CCC2F\", // \n                      borderColor: \"#8CCC2F\"\n                    }\n                  }\n                },\n                areaStyle: {\n                  normal: {\n                    opacity: 0.3,\n                  }\n                }\n              }\n            ]\n          }]\n      }\n      let myChart = echarts.init(this.$refs.echartContent)\n      myChart.setOption(option)\n      this.showName()\n    },\n    components: {\n      'v-swiper': swiper\n    },\n    methods: {\n      showName () {\n        // this.$store.commit('changeType', {id: 2})\n        // this.minWidth = this.$store.getters.showType\n      }\n    }\n  }\n</script>\n\n<style lang=\"scss\" scoped>\n .echartContent{\n    min-height: 420px;\n    width: 100%;\n   padding-top: 5%;\n  }\n  .echartBox{\n    height: 100%;\n    /deep/ .el-carousel{\n      position: fixed;\n      bottom: 50px;\n    }\n    /deep/ .el-carousel__indicators--outside{\n      display: none;\n    }\n  }\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/children/echarts.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',{staticClass:\"echartBox\"},[_c('div',{ref:\"echartContent\",staticClass:\"echartContent\"}),_vm._v(\" \"),_c('v-swiper',{attrs:{\"swPic\":_vm.swHeight,\"minVal\":_vm.minWidth,\"diyType\":'card'}})],1)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-528208d4\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/children/echarts.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-528208d4\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!sass-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./echarts.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./echarts.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./echarts.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-528208d4\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./echarts.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-528208d4\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/children/echarts.vue\n// module id = null\n// module chunks = ","<template>\n    <div>\n       <h4></h4>\n      <div id=\"qrcodeBox\"></div>\n      <h4></h4>\n      <div id=\"qrcodeBy\"></div>\n      <h4></h4>\n      <div id=\"qrcodePay\"></div>\n    </div>\n</template>\n\n<script>\nimport QRCode from 'qrcodejs2'\nexport default {\n    name: \"richScan\",\n    data () {\n      return {\n      }\n    },\n  mounted () {\n      this.qrcodeFn();\n  },\n  methods : {\n    qrcodeFn () {\n      let myQrcode = new QRCode(\"qrcodeBox\", {\n        width: 150,\n        height: 150,\n        text: \"http://www.baidu.com\",//\n        colorDark : \"#000000\",\n        colorLight : \"#ffffff\"\n      })\n      let myQrcodeTwo = new QRCode(\"qrcodeBy\", {\n        width: 150,\n        height: 150,\n        text: \"http://www.baidu.com\",//\n        colorDark : \"#000000\",\n        colorLight : \"#ffffff\"\n      })\n      let myQrcodeThr = new QRCode(\"qrcodePay\", {\n        width: 150,\n        height: 150,\n        text: \"http://www.baidu.com\",//\n        colorDark : \"#000000\",\n        colorLight : \"#ffffff\"\n      })\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n  h4{\n    margin: 0;\n    padding: 30px 0 15px 0;\n  }\n    div{\n      width: 100%;\n      text-align: center;\n      #qrcodeBox,#qrcodeBy,#qrcodePay{\n        display: flex;\n        justify-content: center;\n      }\n    }\n  #qrcodePay{\n    margin-bottom: 70px;\n  }\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/children/richScan.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('h4',[_vm._v(\"\")]),_vm._v(\" \"),_c('div',{attrs:{\"id\":\"qrcodeBox\"}}),_vm._v(\" \"),_c('h4',[_vm._v(\"\")]),_vm._v(\" \"),_c('div',{attrs:{\"id\":\"qrcodeBy\"}}),_vm._v(\" \"),_c('h4',[_vm._v(\"\")]),_vm._v(\" \"),_c('div',{attrs:{\"id\":\"qrcodePay\"}})])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-0521a039\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/children/richScan.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-0521a039\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!sass-loader?{\\\"sourceMap\\\":true}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./richScan.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./richScan.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./richScan.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-0521a039\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./richScan.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-0521a039\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/children/richScan.vue\n// module id = null\n// module chunks = ","<template>\n    <div class=\"errPageBox\">\n      <div class=\"errPage\">\n        <h1>404</h1>\n        <div>...</div>\n        <h3>{{ timeCount }}</h3>\n      </div>\n    </div>\n</template>\n\n<script>\nexport default {\n  name: 'errPage',\n  data () {\n    return {\n      timeCount: 3,\n      timer: null\n    }\n  },\n  mounted () {\n    if (this.timer == null) {\n      this.timer = setInterval(() => {\n        this.setTime()\n      }, 1000)\n    }\n  },\n  methods: {\n    setTime () {\n      if (this.timeCount > 0) {\n        this.timeCount --\n      } else {\n        this.$router.push('/')\n        clearInterval(this.timer)\n        this.timer = null\n      }\n    }\n  },\n  destroyed: function () {\n    // \n    clearInterval(this.timer)\n    this.timer = null\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n  .errPageBox{\n    width: 100%;\n    height: 100%;\n    position: fixed;\n    z-index: 99;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    color: #ff6a1b;\n    .errPage{\n      width: 60%;\n      text-align: center;\n    }\n  }\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/errPage.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"errPageBox\"},[_c('div',{staticClass:\"errPage\"},[_c('h1',[_vm._v(\"404\")]),_vm._v(\" \"),_c('div',[_vm._v(\"...\")]),_vm._v(\" \"),_c('h3',[_vm._v(_vm._s(_vm.timeCount))])])])}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-626bcd0e\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/errPage.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-626bcd0e\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!sass-loader?{\\\"sourceMap\\\":true}!../../node_modules/vue-loader/lib/selector?type=styles&index=0!./errPage.vue\")\n}\nvar normalizeComponent = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./errPage.vue\"\nimport __vue_script__ from \"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./errPage.vue\"\n/* template */\nimport __vue_template__ from \"!!../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-626bcd0e\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../node_modules/vue-loader/lib/selector?type=template&index=0!./errPage.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-626bcd0e\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/errPage.vue\n// module id = null\n// module chunks = ","import Vue from 'vue'\nimport Router from 'vue-router'\nimport login from '@/components/login.vue'\nimport index from '@/components/index.vue'\n\nimport log from '@/components/loginChild/log.vue'\nimport reg from '@/components/loginChild/reg.vue'\nimport home from '@/components/children/home.vue'\nimport makePic from '@/components/children/makePic.vue'\nimport echarts from '@/components/children/echarts.vue'\nimport richScan from '@/components/children/richScan.vue'\nimport errPage from '@/components/errPage.vue'\n\nVue.use(Router)\n\nexport default new Router({\n  mode: 'history', // url#/\n  routes: [\n    {path: '/', redirect: '/login'},\n    {\n      path: '/login',\n      component: login,\n      children: [\n        {path: 'log', component: log},\n        {path: 'reg', component: reg}\n      ],\n      redirect: '/login/log'// \n    },\n    {\n      path: '/index',\n      component: index,\n      children: [\n        // {path: '/home', components: { 'default': home, 'swiper': swiper }},\n        {path: '/home', component: home},\n        {path: '/makePic', component: makePic},\n        {path: '/echarts', component: echarts},\n        {path: '/richScan', component: richScan}\n      ],\n      redirect: '/home'// \n    },\n    {path: '*', component: errPage}\n  ],\n  linkActiveClass: 'homeActive' // \n})\n\n\n\n// WEBPACK FOOTER //\n// ./src/router/index.js","<template>\n    <transition style=\"width: 100%;height: 100%;max-width: 750px;\">\n      <router-view></router-view>\n    </transition>\n</template>\n\n<script>\nexport default {\n  name: 'App',\n  data () {\n    return {\n    }\n  },\n  watch: {\n    '$route.path': function (newVal, oldVal) {\n      let canBox = document.getElementById('canBox')\n      console.log('' + newVal)\n      if (newVal === '/login/log' || newVal === '/login/reg') {\n        canBox.style.display = 'block'\n      } else {\n        canBox.style.display = 'none'\n      }\n    }\n  }\n}\n</script>\n\n<style scoped lang=\"scss\">\n  body{\n    overflow: hidden;\n  }\n  .v-enter{\n    opacity: 0;\n    transform:translateX(100%) scale(0.8);\n  }\n  .v-leave-to{\n    opacity: 0;\n    transform:translateX(-100%);\n    position:absolute;\n    top:60px;\n  }\n  .v-enter-active, .v-leave-active{\n    transition:all 0.6s ease;\n  }\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/App.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{staticStyle:{\"width\":\"100%\",\"height\":\"100%\",\"max-width\":\"750px\"}},[_c('router-view')],1)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-61c8bd16\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/App.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-61c8bd16\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!sass-loader?{\\\"sourceMap\\\":true}!../node_modules/vue-loader/lib/selector?type=styles&index=0!./App.vue\")\n}\nvar normalizeComponent = require(\"!../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./App.vue\"\nimport __vue_script__ from \"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./App.vue\"\n/* template */\nimport __vue_template__ from \"!!../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-61c8bd16\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../node_modules/vue-loader/lib/selector?type=template&index=0!./App.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-61c8bd16\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/App.vue\n// module id = null\n// module chunks = ","// The Vue build version to load with the `import` command\n// (runtime-only or standalone) has been set in webpack.base.conf with an alias.\nimport Vue from 'vue'\nimport router from './router'\nimport Vuex from 'vuex'\nimport axios from 'axios'\nimport echarts from 'echarts'\nimport MintUI from 'mint-ui'\nimport ElementUI from 'element-ui'\nimport 'element-ui/lib/theme-chalk/index.css'\nimport 'mint-ui/lib/style.css'\nimport { Search, PullRefresh, Row, Col } from 'vant'\n\nimport App from './App'\n\nVue.use(Vuex)\nVue.use(MintUI)\nVue.use(ElementUI)\nVue.use(Search)\nVue.use(PullRefresh)\nVue.use(Row).use(Col)\nVue.config.productionTip = false\nVue.prototype.axios = axios\nVue.prototype.echarts = echarts\naxios.defaults.baseURL = 'https://easy-mock.com/mock/5c73f7ad2960be059723832f'\n\n/* eslint-disable no-new */\nconst store = new Vuex.Store({\n  state: {\n    swHeight: 173,\n    swWidth: 376\n  },\n  mutations: {\n    changeType (state, parmsObj) {\n      state.swHeight = state.swHeight / parmsObj.id\n      state.swWidth = state.swWidth / parmsObj.id\n    }\n  },\n  getters: {\n    showType: function (state) {\n      return state\n    }\n  }\n})\n\nconst vm = new Vue({\n  el: '#app',\n  router,\n  store,\n  components: { App },\n  template: '<App/>'\n})\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js","const Detector = {\n\tcanvas : !! window.CanvasRenderingContext2D,\n\twebgl : ( function () { try { return !! document.createElement( 'canvas' ).getContext( 'experimental-webgl' ); } catch( e ) { return false; } } )(),\n\tworkers : !! window.Worker,\n\tfileapi : window.File && window.FileReader && window.FileList && window.Blob,\n\n\tgetWebGLErrorMessage : function () {\n\t\tlet domElement = document.createElement( 'div' );\n\t\tdomElement.style.fontFamily = 'monospace';\n\t\tdomElement.style.fontSize = '13px';\n\t\tdomElement.style.textAlign = 'center';\n\t\tdomElement.style.background = '#eee';\n\t\tdomElement.style.color = '#000';\n\t\tdomElement.style.padding = '1em';\n\t\tdomElement.style.width = '475px';\n\t\tdomElement.style.margin = '5em auto 0';\n\t\tif ( ! this.webgl ) {\n\t\t\tdomElement.innerHTML = ''\n\t\t}\n\t\treturn domElement;\n\t},\n\taddGetWebGLMessage : function ( parameters ) {\n\t\tvar parent, id, domElement;\n\t\tparameters = parameters || {};\n\t\tparent = parameters.parent !== undefined ? parameters.parent : document.body;\n\t\tid = parameters.id !== undefined ? parameters.id : 'oldie';\n\t\tdomElement = Detector.getWebGLErrorMessage();\n\t\tdomElement.id = id;\n\t\tparent.appendChild( domElement );\n\t}\n\n};\nconst s = document.createElement('script');\ns.type = 'x-shader/x-vertex';\ns.setAttribute('id','vs');\ns.innerText='varying vec2 vUv;\\n' +\n  '\\t\\t\\tvoid main() {\\n' +\n  '\\t\\t\\t\\tvUv = uv;\\n' +\n  '\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n' +\n  '\\t\\t\\t}';\ndocument.body.appendChild(s);\n\nconst ss = document.createElement('script');\nss.type = 'x-shader/x-fragment';\nss.setAttribute('id','fs');\nss.innerText='uniform sampler2D map;\\n' +\n  '\\t\\t\\tuniform vec3 fogColor;\\n' +\n  '\\t\\t\\tuniform float fogNear;\\n' +\n  '\\t\\t\\tuniform float fogFar;\\n' +\n  '\\t\\t\\tvarying vec2 vUv;\\n' +\n  '\\t\\t\\tvoid main() {\\n' +\n  '\\t\\t\\t\\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n' +\n  '\\t\\t\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n' +\n  '\\t\\t\\t\\tgl_FragColor = texture2D( map, vUv );\\n' +\n  '\\t\\t\\t\\tgl_FragColor.w *= pow( gl_FragCoord.z, 20.0 );\\n' +\n  '\\t\\t\\t\\tgl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\n' +\n  '\\t\\t\\t}';\ndocument.body.appendChild(ss);\n\nif ( ! Detector.webgl ) Detector.addGetWebGLMessage();\n\nvar container;\nvar camera, scene, renderer;\nvar mesh, geometry, material;\n\nvar mouseX = 0, mouseY = 0;\nvar start_time = Date.now();\n\nvar windowHalfX = window.innerWidth / 2;\nvar windowHalfY = window.innerHeight / 2;\n\ninit();\n\nfunction init() {\n\n  container = document.createElement( 'div' );\n  container.style.width = '100%';\n  container.style.height = '100%';\n  container.setAttribute('id','canBox')\n  container.style.overflow = 'hidden';\n  container.style.backgroundImage='-webkit-gradient(linear, left top, left bottom, from(#3A7CEC), to(#79c4ff))'\n  container.style.backgroundImage='-webkit-linear-gradient(top, #3A7CEC, #79c4ff)'\n  container.style.backgroundImage='linear-gradient(to bottom, #3A7CEC, #79c4ff)'\n  document.body.appendChild( container );\n\n\n  camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 3000 );\n  camera.position.z = 6000;\n\n  scene = new THREE.Scene();\n\n  geometry = new THREE.Geometry();\n\n  var texture = THREE.ImageUtils.loadTexture( 'static/cloud.png', null, animate );\n  texture.magFilter = THREE.LinearMipMapLinearFilter;\n  texture.minFilter = THREE.LinearMipMapLinearFilter;\n\n  var fog = new THREE.Fog( 0x4584b4, - 100, 3000 );\n\n  material = new THREE.ShaderMaterial( {\n\n    uniforms: {\n\n      \"map\": { type: \"t\", value: texture },\n      \"fogColor\" : { type: \"c\", value: fog.color },\n      \"fogNear\" : { type: \"f\", value: fog.near },\n      \"fogFar\" : { type: \"f\", value: fog.far },\n\n    },\n    vertexShader: document.getElementById( 'vs' ).textContent,\n    fragmentShader: document.getElementById( 'fs' ).textContent,\n    depthWrite: false,\n    depthTest: false,\n    transparent: true\n\n  } );\n\n  var plane = new THREE.Mesh( new THREE.PlaneGeometry( 64, 64 ) );\n\n  for ( var i = 0; i < 8000; i++ ) {\n\n    plane.position.x = Math.random() * 1000 - 500;\n    plane.position.y = - Math.random() * Math.random() * 200 - 15;\n    plane.position.z = i;\n    plane.rotation.z = Math.random() * Math.PI;\n    plane.scale.x = plane.scale.y = Math.random() * Math.random() * 1.5 + 0.5;\n\n    THREE.GeometryUtils.merge( geometry, plane );\n\n  }\n\n  mesh = new THREE.Mesh( geometry, material );\n  scene.add( mesh );\n\n  mesh = new THREE.Mesh( geometry, material );\n  mesh.position.z = - 8000;\n  scene.add( mesh );\n\n  renderer = new THREE.WebGLRenderer( { antialias: false } );\n  renderer.setSize( window.innerWidth , window.innerHeight );\n   container.appendChild( renderer.domElement );\n\n  // document.addEventListener( 'click', onDocumentMouseMove, false );\n   window.addEventListener( 'orientationchange', onWindowResize, false );\n}\n\n// function onDocumentMouseMove( event ) {\n// \tmouseX = ( event.clientX - windowHalfX ) * 0.25;\n// \tmouseY = ( event.clientY - windowHalfY ) * 0.25;\n// }\n//\nfunction onWindowResize( event ) {\n\tlocation.reload()\n}\n\nfunction animate() {\n  requestAnimationFrame( animate );\n  position = ( ( Date.now() - start_time ) * 0.03 ) % 8000;\n  camera.position.x += ( mouseX - camera.position.x ) * 0.01;\n  camera.position.y += ( - mouseY - camera.position.y ) * 0.01;\n  camera.position.z = - position + 8000;\n  renderer.render( scene, camera );\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./static/Detector.js\n// module id = Z0q7\n// module chunks = 1","module.exports = __webpack_public_path__ + \"static/img/bg_content.99f0bfe.png\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/assets/images/bg_content.png\n// module id = o2Ho\n// module chunks = 1"],"sourceRoot":""}